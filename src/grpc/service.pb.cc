// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

#include "service.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace protos {
template <typename>
PROTOBUF_CONSTEXPR Vector2D::Vector2D(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/ 0

  , /*decltype(_impl_.y_)*/ 0

  , /*decltype(_impl_.dist_)*/ 0

  , /*decltype(_impl_.angle_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Vector2DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Vector2DDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Vector2DDefaultTypeInternal() {}
  union {
    Vector2D _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Vector2DDefaultTypeInternal _Vector2D_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ball::Ball(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.relative_position_)*/nullptr
  , /*decltype(_impl_.seen_position_)*/nullptr
  , /*decltype(_impl_.heard_position_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.seen_velocity_)*/nullptr
  , /*decltype(_impl_.heard_velocity_)*/nullptr
  , /*decltype(_impl_.pos_count_)*/ 0

  , /*decltype(_impl_.seen_pos_count_)*/ 0

  , /*decltype(_impl_.heard_pos_count_)*/ 0

  , /*decltype(_impl_.vel_count_)*/ 0

  , /*decltype(_impl_.seen_vel_count_)*/ 0

  , /*decltype(_impl_.heard_vel_count_)*/ 0

  , /*decltype(_impl_.lost_count_)*/ 0

  , /*decltype(_impl_.ghost_count_)*/ 0

  , /*decltype(_impl_.dist_from_self_)*/ 0

  , /*decltype(_impl_.angle_from_self_)*/ 0
} {}
struct BallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BallDefaultTypeInternal() {}
  union {
    Ball _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BallDefaultTypeInternal _Ball_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Player::Player(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.seen_position_)*/nullptr
  , /*decltype(_impl_.heard_position_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.seen_velocity_)*/nullptr
  , /*decltype(_impl_.pos_count_)*/ 0

  , /*decltype(_impl_.seen_pos_count_)*/ 0

  , /*decltype(_impl_.heard_pos_count_)*/ 0

  , /*decltype(_impl_.vel_count_)*/ 0

  , /*decltype(_impl_.seen_vel_count_)*/ 0

  , /*decltype(_impl_.ghost_count_)*/ 0

  , /*decltype(_impl_.dist_from_self_)*/ 0

  , /*decltype(_impl_.angle_from_self_)*/ 0

  , /*decltype(_impl_.id_)*/ 0

  , /*decltype(_impl_.side_)*/ 0

  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.uniform_number_count_)*/ 0

  , /*decltype(_impl_.body_direction_)*/ 0

  , /*decltype(_impl_.body_direction_count_)*/ 0

  , /*decltype(_impl_.face_direction_)*/ 0

  , /*decltype(_impl_.face_direction_count_)*/ 0

  , /*decltype(_impl_.point_to_direction_)*/ 0

  , /*decltype(_impl_.point_to_direction_count_)*/ 0

  , /*decltype(_impl_.is_goalie_)*/ false

  , /*decltype(_impl_.is_kicking_)*/ false

  , /*decltype(_impl_.is_tackling_)*/ false

  , /*decltype(_impl_.dist_from_ball_)*/ 0

  , /*decltype(_impl_.angle_from_ball_)*/ 0

  , /*decltype(_impl_.ball_reach_steps_)*/ 0
} {}
struct PlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerDefaultTypeInternal() {}
  union {
    Player _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerDefaultTypeInternal _Player_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Self::Self(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.seen_position_)*/nullptr
  , /*decltype(_impl_.heard_position_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.seen_velocity_)*/nullptr
  , /*decltype(_impl_.pos_count_)*/ 0

  , /*decltype(_impl_.seen_pos_count_)*/ 0

  , /*decltype(_impl_.heard_pos_count_)*/ 0

  , /*decltype(_impl_.vel_count_)*/ 0

  , /*decltype(_impl_.seen_vel_count_)*/ 0

  , /*decltype(_impl_.ghost_count_)*/ 0

  , /*decltype(_impl_.id_)*/ 0

  , /*decltype(_impl_.side_)*/ 0

  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.uniform_number_count_)*/ 0

  , /*decltype(_impl_.body_direction_)*/ 0

  , /*decltype(_impl_.body_direction_count_)*/ 0

  , /*decltype(_impl_.face_direction_)*/ 0

  , /*decltype(_impl_.face_direction_count_)*/ 0

  , /*decltype(_impl_.point_to_direction_)*/ 0

  , /*decltype(_impl_.point_to_direction_count_)*/ 0

  , /*decltype(_impl_.dist_from_ball_)*/ 0

  , /*decltype(_impl_.is_goalie_)*/ false

  , /*decltype(_impl_.is_kicking_)*/ false

  , /*decltype(_impl_.is_tackling_)*/ false

  , /*decltype(_impl_.is_kickable_)*/ false

  , /*decltype(_impl_.angle_from_ball_)*/ 0

  , /*decltype(_impl_.ball_reach_steps_)*/ 0

  , /*decltype(_impl_.relative_neck_direction_)*/ 0

  , /*decltype(_impl_.stamina_)*/ 0

  , /*decltype(_impl_.catch_probability_)*/ 0

  , /*decltype(_impl_.tackle_probability_)*/ 0

  , /*decltype(_impl_.foul_probability_)*/ 0

  , /*decltype(_impl_.view_width_)*/ 0
} {}
struct SelfDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelfDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelfDefaultTypeInternal() {}
  union {
    Self _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelfDefaultTypeInternal _Self_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR InterceptInfo::InterceptInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.final_self_position_)*/nullptr
  , /*decltype(_impl_.action_type_)*/ 0

  , /*decltype(_impl_.turn_steps_)*/ 0

  , /*decltype(_impl_.turn_angle_)*/ 0

  , /*decltype(_impl_.dash_steps_)*/ 0

  , /*decltype(_impl_.dash_power_)*/ 0

  , /*decltype(_impl_.dash_dir_)*/ 0

  , /*decltype(_impl_.final_ball_dist_)*/ 0

  , /*decltype(_impl_.final_stamina_)*/ 0

  , /*decltype(_impl_.value_)*/ 0
} {}
struct InterceptInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InterceptInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InterceptInfoDefaultTypeInternal() {}
  union {
    InterceptInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InterceptInfoDefaultTypeInternal _InterceptInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR InterceptTable::InterceptTable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.self_intercept_info_)*/{}
  , /*decltype(_impl_.self_reach_steps_)*/ 0

  , /*decltype(_impl_.first_teammate_reach_steps_)*/ 0

  , /*decltype(_impl_.second_teammate_reach_steps_)*/ 0

  , /*decltype(_impl_.first_opponent_reach_steps_)*/ 0

  , /*decltype(_impl_.second_opponent_reach_steps_)*/ 0

  , /*decltype(_impl_.first_teammate_id_)*/ 0

  , /*decltype(_impl_.second_teammate_id_)*/ 0

  , /*decltype(_impl_.first_opponent_id_)*/ 0

  , /*decltype(_impl_.second_opponent_id_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InterceptTableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InterceptTableDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InterceptTableDefaultTypeInternal() {}
  union {
    InterceptTable _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InterceptTableDefaultTypeInternal _InterceptTable_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WorldModel_OurPlayersDictEntry_DoNotUse::WorldModel_OurPlayersDictEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal() {}
  union {
    WorldModel_OurPlayersDictEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal _WorldModel_OurPlayersDictEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WorldModel_TheirPlayersDictEntry_DoNotUse::WorldModel_TheirPlayersDictEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal() {}
  union {
    WorldModel_TheirPlayersDictEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal _WorldModel_TheirPlayersDictEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WorldModel::WorldModel(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.teammates_)*/{}
  , /*decltype(_impl_.opponents_)*/{}
  , /*decltype(_impl_.unknowns_)*/{}
  , /*decltype(_impl_.our_players_dict_)*/{}
  , /*decltype(_impl_.their_players_dict_)*/{}
  , /*decltype(_impl_.our_team_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.their_team_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.intercept_table_)*/nullptr
  , /*decltype(_impl_.self_)*/nullptr
  , /*decltype(_impl_.ball_)*/nullptr
  , /*decltype(_impl_.our_side_)*/ 0

  , /*decltype(_impl_.last_set_play_start_time_)*/ 0

  , /*decltype(_impl_.our_goalie_uniform_number_)*/ 0

  , /*decltype(_impl_.their_goalie_uniform_number_)*/ 0

  , /*decltype(_impl_.offside_line_x_)*/ 0

  , /*decltype(_impl_.ofside_line_x_count_)*/ 0

  , /*decltype(_impl_.kickable_teammate_id_)*/ 0

  , /*decltype(_impl_.kickable_opponent_id_)*/ 0

  , /*decltype(_impl_.last_kick_side_)*/ 0

  , /*decltype(_impl_.last_kicker_uniform_number_)*/ 0

  , /*decltype(_impl_.cycle_)*/ 0

  , /*decltype(_impl_.game_mode_type_)*/ 0

  , /*decltype(_impl_.left_team_score_)*/ 0

  , /*decltype(_impl_.right_team_score_)*/ 0

  , /*decltype(_impl_.is_our_set_play_)*/ false

  , /*decltype(_impl_.is_their_set_play_)*/ false

  , /*decltype(_impl_.stoped_cycle_)*/ 0

  , /*decltype(_impl_.our_team_score_)*/ 0

  , /*decltype(_impl_.their_team_score_)*/ 0
} {}
struct WorldModelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WorldModelDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WorldModelDefaultTypeInternal() {}
  union {
    WorldModel _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WorldModelDefaultTypeInternal _WorldModel_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR State::State(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.world_model_)*/nullptr
  , /*decltype(_impl_.full_world_model_)*/nullptr} {}
struct StateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StateDefaultTypeInternal() {}
  union {
    State _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StateDefaultTypeInternal _State_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Dash::Dash(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.power_)*/ 0

  , /*decltype(_impl_.relative_direction_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DashDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DashDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DashDefaultTypeInternal() {}
  union {
    Dash _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DashDefaultTypeInternal _Dash_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Turn::Turn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.relative_direction_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TurnDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TurnDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TurnDefaultTypeInternal() {}
  union {
    Turn _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TurnDefaultTypeInternal _Turn_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Kick::Kick(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.power_)*/ 0

  , /*decltype(_impl_.relative_direction_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KickDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KickDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KickDefaultTypeInternal() {}
  union {
    Kick _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KickDefaultTypeInternal _Kick_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Tackle::Tackle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.power_or_dir_)*/ 0

  , /*decltype(_impl_.foul_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TackleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TackleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TackleDefaultTypeInternal() {}
  union {
    Tackle _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TackleDefaultTypeInternal _Tackle_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Catch::Catch(
    ::_pbi::ConstantInitialized) {}
struct CatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CatchDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CatchDefaultTypeInternal() {}
  union {
    Catch _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CatchDefaultTypeInternal _Catch_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Move::Move(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/ 0

  , /*decltype(_impl_.y_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveDefaultTypeInternal() {}
  union {
    Move _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveDefaultTypeInternal _Move_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TurnNeck::TurnNeck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.moment_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TurnNeckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TurnNeckDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TurnNeckDefaultTypeInternal() {}
  union {
    TurnNeck _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TurnNeckDefaultTypeInternal _TurnNeck_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ChangeView::ChangeView(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.view_width_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ChangeViewDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangeViewDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangeViewDefaultTypeInternal() {}
  union {
    ChangeView _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangeViewDefaultTypeInternal _ChangeView_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Say::Say(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SayDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SayDefaultTypeInternal() {}
  union {
    Say _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SayDefaultTypeInternal _Say_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PointTo::PointTo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/ 0

  , /*decltype(_impl_.y_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PointToDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointToDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointToDefaultTypeInternal() {}
  union {
    PointTo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointToDefaultTypeInternal _PointTo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PointToOf::PointToOf(
    ::_pbi::ConstantInitialized) {}
struct PointToOfDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointToOfDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointToOfDefaultTypeInternal() {}
  union {
    PointToOf _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointToOfDefaultTypeInternal _PointToOf_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AttentionTo::AttentionTo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.unum_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AttentionToDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttentionToDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttentionToDefaultTypeInternal() {}
  union {
    AttentionTo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttentionToDefaultTypeInternal _AttentionTo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AttentionToOf::AttentionToOf(
    ::_pbi::ConstantInitialized) {}
struct AttentionToOfDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttentionToOfDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttentionToOfDefaultTypeInternal() {}
  union {
    AttentionToOf _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttentionToOfDefaultTypeInternal _AttentionToOf_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Log::Log(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogDefaultTypeInternal() {}
  union {
    Log _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogDefaultTypeInternal _Log_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DebugClient::DebugClient(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DebugClientDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DebugClientDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DebugClientDefaultTypeInternal() {}
  union {
    DebugClient _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DebugClientDefaultTypeInternal _DebugClient_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Action::Action(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.action_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActionDefaultTypeInternal() {}
  union {
    Action _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionDefaultTypeInternal _Action_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Actions::Actions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.actions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ActionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActionsDefaultTypeInternal() {}
  union {
    Actions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionsDefaultTypeInternal _Actions_default_instance_;
}  // namespace protos
static ::_pb::Metadata file_level_metadata_service_2eproto[27];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_service_2eproto[4];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_service_2eproto = nullptr;
const ::uint32_t TableStruct_service_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Vector2D, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Vector2D, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::protos::Vector2D, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::protos::Vector2D, _impl_.dist_),
    PROTOBUF_FIELD_OFFSET(::protos::Vector2D, _impl_.angle_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.relative_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.seen_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.heard_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.seen_velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.heard_velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.seen_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.heard_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.seen_vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.heard_vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.lost_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.ghost_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.dist_from_self_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.angle_from_self_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.seen_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.heard_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.seen_velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.seen_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.heard_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.seen_vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.ghost_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.dist_from_self_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.angle_from_self_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.side_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.uniform_number_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.is_goalie_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.body_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.body_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.face_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.face_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.point_to_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.point_to_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.is_kicking_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.dist_from_ball_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.angle_from_ball_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.ball_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.is_tackling_),
    0,
    1,
    2,
    3,
    4,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.seen_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.heard_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.seen_velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.seen_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.heard_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.seen_vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.ghost_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.side_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.uniform_number_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.is_goalie_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.body_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.body_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.face_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.face_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.point_to_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.point_to_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.is_kicking_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.dist_from_ball_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.angle_from_ball_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.ball_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.is_tackling_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.relative_neck_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.stamina_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.is_kickable_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.catch_probability_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.tackle_probability_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.foul_probability_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.view_width_),
    0,
    1,
    2,
    3,
    4,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.action_type_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.turn_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.turn_angle_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.dash_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.dash_power_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.dash_dir_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.final_self_position_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.final_ball_dist_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.final_stamina_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.value_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.self_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.first_teammate_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.second_teammate_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.first_opponent_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.second_opponent_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.first_teammate_id_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.second_teammate_id_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.first_opponent_id_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.second_opponent_id_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.self_intercept_info_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_OurPlayersDictEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_OurPlayersDictEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_OurPlayersDictEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_OurPlayersDictEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_TheirPlayersDictEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_TheirPlayersDictEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_TheirPlayersDictEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_TheirPlayersDictEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.intercept_table_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.our_team_name_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.their_team_name_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.our_side_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.last_set_play_start_time_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.self_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.ball_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.teammates_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.opponents_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.unknowns_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.our_players_dict_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.their_players_dict_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.our_goalie_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.their_goalie_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.offside_line_x_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.ofside_line_x_count_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.kickable_teammate_id_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.kickable_opponent_id_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.last_kick_side_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.last_kicker_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.cycle_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.game_mode_type_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.left_team_score_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.right_team_score_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.is_our_set_play_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.is_their_set_play_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.stoped_cycle_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.our_team_score_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.their_team_score_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    1,
    2,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::State, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::State, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::State, _impl_.world_model_),
    PROTOBUF_FIELD_OFFSET(::protos::State, _impl_.full_world_model_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Dash, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Dash, _impl_.power_),
    PROTOBUF_FIELD_OFFSET(::protos::Dash, _impl_.relative_direction_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Turn, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Turn, _impl_.relative_direction_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Kick, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Kick, _impl_.power_),
    PROTOBUF_FIELD_OFFSET(::protos::Kick, _impl_.relative_direction_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Tackle, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Tackle, _impl_.power_or_dir_),
    PROTOBUF_FIELD_OFFSET(::protos::Tackle, _impl_.foul_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Catch, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Move, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Move, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::protos::Move, _impl_.y_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::TurnNeck, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::TurnNeck, _impl_.moment_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::ChangeView, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::ChangeView, _impl_.view_width_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Say, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Say, _impl_.message_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::PointTo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::PointTo, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::protos::PointTo, _impl_.y_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::PointToOf, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::AttentionTo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AttentionTo, _impl_.unum_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::AttentionToOf, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Log, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Log, _impl_.message_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::DebugClient, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::DebugClient, _impl_.message_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Action, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::protos::Action, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::protos::Action, _impl_.action_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Actions, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Actions, _impl_.actions_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::protos::Vector2D)},
        { 12, 37, -1, sizeof(::protos::Ball)},
        { 54, 91, -1, sizeof(::protos::Player)},
        { 120, 162, -1, sizeof(::protos::Self)},
        { 196, 214, -1, sizeof(::protos::InterceptInfo)},
        { 224, -1, -1, sizeof(::protos::InterceptTable)},
        { 242, 252, -1, sizeof(::protos::WorldModel_OurPlayersDictEntry_DoNotUse)},
        { 254, 264, -1, sizeof(::protos::WorldModel_TheirPlayersDictEntry_DoNotUse)},
        { 266, 303, -1, sizeof(::protos::WorldModel)},
        { 332, 342, -1, sizeof(::protos::State)},
        { 344, -1, -1, sizeof(::protos::Dash)},
        { 354, -1, -1, sizeof(::protos::Turn)},
        { 363, -1, -1, sizeof(::protos::Kick)},
        { 373, -1, -1, sizeof(::protos::Tackle)},
        { 383, -1, -1, sizeof(::protos::Catch)},
        { 391, -1, -1, sizeof(::protos::Move)},
        { 401, -1, -1, sizeof(::protos::TurnNeck)},
        { 410, -1, -1, sizeof(::protos::ChangeView)},
        { 419, -1, -1, sizeof(::protos::Say)},
        { 428, -1, -1, sizeof(::protos::PointTo)},
        { 438, -1, -1, sizeof(::protos::PointToOf)},
        { 446, -1, -1, sizeof(::protos::AttentionTo)},
        { 455, -1, -1, sizeof(::protos::AttentionToOf)},
        { 463, -1, -1, sizeof(::protos::Log)},
        { 472, -1, -1, sizeof(::protos::DebugClient)},
        { 481, -1, -1, sizeof(::protos::Action)},
        { 505, -1, -1, sizeof(::protos::Actions)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::protos::_Vector2D_default_instance_._instance,
    &::protos::_Ball_default_instance_._instance,
    &::protos::_Player_default_instance_._instance,
    &::protos::_Self_default_instance_._instance,
    &::protos::_InterceptInfo_default_instance_._instance,
    &::protos::_InterceptTable_default_instance_._instance,
    &::protos::_WorldModel_OurPlayersDictEntry_DoNotUse_default_instance_._instance,
    &::protos::_WorldModel_TheirPlayersDictEntry_DoNotUse_default_instance_._instance,
    &::protos::_WorldModel_default_instance_._instance,
    &::protos::_State_default_instance_._instance,
    &::protos::_Dash_default_instance_._instance,
    &::protos::_Turn_default_instance_._instance,
    &::protos::_Kick_default_instance_._instance,
    &::protos::_Tackle_default_instance_._instance,
    &::protos::_Catch_default_instance_._instance,
    &::protos::_Move_default_instance_._instance,
    &::protos::_TurnNeck_default_instance_._instance,
    &::protos::_ChangeView_default_instance_._instance,
    &::protos::_Say_default_instance_._instance,
    &::protos::_PointTo_default_instance_._instance,
    &::protos::_PointToOf_default_instance_._instance,
    &::protos::_AttentionTo_default_instance_._instance,
    &::protos::_AttentionToOf_default_instance_._instance,
    &::protos::_Log_default_instance_._instance,
    &::protos::_DebugClient_default_instance_._instance,
    &::protos::_Action_default_instance_._instance,
    &::protos::_Actions_default_instance_._instance,
};
const char descriptor_table_protodef_service_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\rservice.proto\022\006protos\"=\n\010Vector2D\022\t\n\001x"
    "\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\014\n\004dist\030\003 \001(\002\022\r\n\005angle"
    "\030\004 \001(\002\"\203\004\n\004Ball\022\"\n\010position\030\001 \001(\0132\020.prot"
    "os.Vector2D\022+\n\021relative_position\030\002 \001(\0132\020"
    ".protos.Vector2D\022\'\n\rseen_position\030\003 \001(\0132"
    "\020.protos.Vector2D\022(\n\016heard_position\030\004 \001("
    "\0132\020.protos.Vector2D\022\"\n\010velocity\030\005 \001(\0132\020."
    "protos.Vector2D\022\'\n\rseen_velocity\030\006 \001(\0132\020"
    ".protos.Vector2D\022(\n\016heard_velocity\030\007 \001(\013"
    "2\020.protos.Vector2D\022\021\n\tpos_count\030\010 \001(\005\022\026\n"
    "\016seen_pos_count\030\t \001(\005\022\027\n\017heard_pos_count"
    "\030\n \001(\005\022\021\n\tvel_count\030\013 \001(\005\022\026\n\016seen_vel_co"
    "unt\030\014 \001(\005\022\027\n\017heard_vel_count\030\r \001(\005\022\022\n\nlo"
    "st_count\030\016 \001(\005\022\023\n\013ghost_count\030\017 \001(\005\022\026\n\016d"
    "ist_from_self\030\020 \001(\002\022\027\n\017angle_from_self\030\021"
    " \001(\002\"\220\006\n\006Player\022\"\n\010position\030\001 \001(\0132\020.prot"
    "os.Vector2D\022\'\n\rseen_position\030\002 \001(\0132\020.pro"
    "tos.Vector2D\022(\n\016heard_position\030\003 \001(\0132\020.p"
    "rotos.Vector2D\022\"\n\010velocity\030\004 \001(\0132\020.proto"
    "s.Vector2D\022\'\n\rseen_velocity\030\005 \001(\0132\020.prot"
    "os.Vector2D\022\021\n\tpos_count\030\006 \001(\005\022\026\n\016seen_p"
    "os_count\030\007 \001(\005\022\027\n\017heard_pos_count\030\010 \001(\005\022"
    "\021\n\tvel_count\030\t \001(\005\022\026\n\016seen_vel_count\030\n \001"
    "(\005\022\023\n\013ghost_count\030\013 \001(\005\022\026\n\016dist_from_sel"
    "f\030\014 \001(\002\022\027\n\017angle_from_self\030\r \001(\002\022\n\n\002id\030\016"
    " \001(\005\022\032\n\004side\030\017 \001(\0162\014.protos.Side\022\026\n\016unif"
    "orm_number\030\020 \001(\005\022\034\n\024uniform_number_count"
    "\030\021 \001(\005\022\021\n\tis_goalie\030\022 \001(\010\022\026\n\016body_direct"
    "ion\030\023 \001(\002\022\034\n\024body_direction_count\030\024 \001(\005\022"
    "\026\n\016face_direction\030\025 \001(\002\022\034\n\024face_directio"
    "n_count\030\026 \001(\005\022\032\n\022point_to_direction\030\027 \001("
    "\002\022 \n\030point_to_direction_count\030\030 \001(\005\022\022\n\ni"
    "s_kicking\030\031 \001(\010\022\026\n\016dist_from_ball\030\032 \001(\002\022"
    "\027\n\017angle_from_ball\030\033 \001(\002\022\030\n\020ball_reach_s"
    "teps\030\034 \001(\005\022\023\n\013is_tackling\030\035 \001(\010\"\234\007\n\004Self"
    "\022\"\n\010position\030\001 \001(\0132\020.protos.Vector2D\022\'\n\r"
    "seen_position\030\002 \001(\0132\020.protos.Vector2D\022(\n"
    "\016heard_position\030\003 \001(\0132\020.protos.Vector2D\022"
    "\"\n\010velocity\030\004 \001(\0132\020.protos.Vector2D\022\'\n\rs"
    "een_velocity\030\005 \001(\0132\020.protos.Vector2D\022\021\n\t"
    "pos_count\030\006 \001(\005\022\026\n\016seen_pos_count\030\007 \001(\005\022"
    "\027\n\017heard_pos_count\030\010 \001(\005\022\021\n\tvel_count\030\t "
    "\001(\005\022\026\n\016seen_vel_count\030\n \001(\005\022\023\n\013ghost_cou"
    "nt\030\013 \001(\005\022\n\n\002id\030\014 \001(\005\022\032\n\004side\030\r \001(\0162\014.pro"
    "tos.Side\022\026\n\016uniform_number\030\016 \001(\005\022\034\n\024unif"
    "orm_number_count\030\017 \001(\005\022\021\n\tis_goalie\030\020 \001("
    "\010\022\026\n\016body_direction\030\021 \001(\002\022\034\n\024body_direct"
    "ion_count\030\022 \001(\005\022\026\n\016face_direction\030\023 \001(\002\022"
    "\034\n\024face_direction_count\030\024 \001(\005\022\032\n\022point_t"
    "o_direction\030\025 \001(\002\022 \n\030point_to_direction_"
    "count\030\026 \001(\005\022\022\n\nis_kicking\030\027 \001(\010\022\026\n\016dist_"
    "from_ball\030\030 \001(\002\022\027\n\017angle_from_ball\030\031 \001(\002"
    "\022\030\n\020ball_reach_steps\030\032 \001(\005\022\023\n\013is_tacklin"
    "g\030\033 \001(\010\022\037\n\027relative_neck_direction\030\034 \001(\002"
    "\022\017\n\007stamina\030\035 \001(\002\022\023\n\013is_kickable\030\036 \001(\010\022\031"
    "\n\021catch_probability\030\037 \001(\002\022\032\n\022tackle_prob"
    "ability\030  \001(\002\022\030\n\020foul_probability\030! \001(\002\022"
    "%\n\nview_width\030\" \001(\0162\021.protos.ViewWidth\"\221"
    "\002\n\rInterceptInfo\0220\n\013action_type\030\001 \001(\0162\033."
    "protos.InterceptActionType\022\022\n\nturn_steps"
    "\030\002 \001(\005\022\022\n\nturn_angle\030\003 \001(\002\022\022\n\ndash_steps"
    "\030\004 \001(\005\022\022\n\ndash_power\030\005 \001(\002\022\020\n\010dash_dir\030\006"
    " \001(\002\022-\n\023final_self_position\030\007 \001(\0132\020.prot"
    "os.Vector2D\022\027\n\017final_ball_dist\030\010 \001(\002\022\025\n\r"
    "final_stamina\030\t \001(\002\022\r\n\005value\030\n \001(\002\"\336\002\n\016I"
    "nterceptTable\022\030\n\020self_reach_steps\030\001 \001(\005\022"
    "\"\n\032first_teammate_reach_steps\030\002 \001(\005\022#\n\033s"
    "econd_teammate_reach_steps\030\003 \001(\005\022\"\n\032firs"
    "t_opponent_reach_steps\030\004 \001(\005\022#\n\033second_o"
    "pponent_reach_steps\030\005 \001(\005\022\031\n\021first_teamm"
    "ate_id\030\006 \001(\005\022\032\n\022second_teammate_id\030\007 \001(\005"
    "\022\031\n\021first_opponent_id\030\010 \001(\005\022\032\n\022second_op"
    "ponent_id\030\t \001(\005\0222\n\023self_intercept_info\030\n"
    " \003(\0132\025.protos.InterceptInfo\"\326\010\n\nWorldMod"
    "el\022/\n\017intercept_table\030\001 \001(\0132\026.protos.Int"
    "erceptTable\022\025\n\rour_team_name\030\002 \001(\t\022\027\n\017th"
    "eir_team_name\030\003 \001(\t\022\036\n\010our_side\030\004 \001(\0162\014."
    "protos.Side\022 \n\030last_set_play_start_time\030"
    "\005 \001(\005\022\032\n\004self\030\006 \001(\0132\014.protos.Self\022\032\n\004bal"
    "l\030\007 \001(\0132\014.protos.Ball\022!\n\tteammates\030\010 \003(\013"
    "2\016.protos.Player\022!\n\topponents\030\t \003(\0132\016.pr"
    "otos.Player\022 \n\010unknowns\030\n \003(\0132\016.protos.P"
    "layer\022@\n\020our_players_dict\030\013 \003(\0132&.protos"
    ".WorldModel.OurPlayersDictEntry\022D\n\022their"
    "_players_dict\030\014 \003(\0132(.protos.WorldModel."
    "TheirPlayersDictEntry\022!\n\031our_goalie_unif"
    "orm_number\030\r \001(\005\022#\n\033their_goalie_uniform"
    "_number\030\016 \001(\005\022\026\n\016offside_line_x\030\017 \001(\002\022\033\n"
    "\023ofside_line_x_count\030\020 \001(\005\022\034\n\024kickable_t"
    "eammate_id\030\021 \001(\005\022\034\n\024kickable_opponent_id"
    "\030\022 \001(\005\022$\n\016last_kick_side\030\023 \001(\0162\014.protos."
    "Side\022\"\n\032last_kicker_uniform_number\030\024 \001(\005"
    "\022\r\n\005cycle\030\025 \001(\005\022,\n\016game_mode_type\030\026 \001(\0162"
    "\024.protos.GameModeType\022\027\n\017left_team_score"
    "\030\027 \001(\005\022\030\n\020right_team_score\030\030 \001(\005\022\027\n\017is_o"
    "ur_set_play\030\031 \001(\010\022\031\n\021is_their_set_play\030\032"
    " \001(\010\022\024\n\014stoped_cycle\030\033 \001(\005\022\026\n\016our_team_s"
    "core\030\034 \001(\005\022\030\n\020their_team_score\030\035 \001(\005\032E\n\023"
    "OurPlayersDictEntry\022\013\n\003key\030\001 \001(\005\022\035\n\005valu"
    "e\030\002 \001(\0132\016.protos.Player:\0028\001\032G\n\025TheirPlay"
    "ersDictEntry\022\013\n\003key\030\001 \001(\005\022\035\n\005value\030\002 \001(\013"
    "2\016.protos.Player:\0028\001\"^\n\005State\022\'\n\013world_m"
    "odel\030\001 \001(\0132\022.protos.WorldModel\022,\n\020full_w"
    "orld_model\030\002 \001(\0132\022.protos.WorldModel\"1\n\004"
    "Dash\022\r\n\005power\030\001 \001(\002\022\032\n\022relative_directio"
    "n\030\002 \001(\002\"\"\n\004Turn\022\032\n\022relative_direction\030\001 "
    "\001(\002\"1\n\004Kick\022\r\n\005power\030\001 \001(\002\022\032\n\022relative_d"
    "irection\030\002 \001(\002\",\n\006Tackle\022\024\n\014power_or_dir"
    "\030\001 \001(\002\022\014\n\004foul\030\002 \001(\010\"\007\n\005Catch\"\034\n\004Move\022\t\n"
    "\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\"\032\n\010TurnNeck\022\016\n\006momen"
    "t\030\001 \001(\002\"3\n\nChangeView\022%\n\nview_width\030\001 \001("
    "\0162\021.protos.ViewWidth\"\026\n\003Say\022\017\n\007message\030\001"
    " \001(\t\"\037\n\007PointTo\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\"\013\n"
    "\tPointToOf\"\033\n\013AttentionTo\022\014\n\004unum\030\001 \001(\005\""
    "\017\n\rAttentionToOf\"\026\n\003Log\022\017\n\007message\030\001 \001(\t"
    "\"\036\n\013DebugClient\022\017\n\007message\030\001 \001(\t\"\261\004\n\006Act"
    "ion\022\034\n\004dash\030\001 \001(\0132\014.protos.DashH\000\022\034\n\004tur"
    "n\030\002 \001(\0132\014.protos.TurnH\000\022\034\n\004kick\030\003 \001(\0132\014."
    "protos.KickH\000\022 \n\006tackle\030\004 \001(\0132\016.protos.T"
    "ackleH\000\022\036\n\005catch\030\005 \001(\0132\r.protos.CatchH\000\022"
    "\034\n\004move\030\006 \001(\0132\014.protos.MoveH\000\022%\n\tturn_ne"
    "ck\030\007 \001(\0132\020.protos.TurnNeckH\000\022)\n\013change_v"
    "iew\030\010 \001(\0132\022.protos.ChangeViewH\000\022\032\n\003say\030\t"
    " \001(\0132\013.protos.SayH\000\022#\n\010point_to\030\n \001(\0132\017."
    "protos.PointToH\000\022(\n\013point_to_of\030\013 \001(\0132\021."
    "protos.PointToOfH\000\022+\n\014attention_to\030\014 \001(\013"
    "2\023.protos.AttentionToH\000\0220\n\017attention_to_"
    "of\030\r \001(\0132\025.protos.AttentionToOfH\000\022\032\n\003log"
    "\030\016 \001(\0132\013.protos.LogH\000\022+\n\014debug_client\030\017 "
    "\001(\0132\023.protos.DebugClientH\000B\010\n\006action\"*\n\007"
    "Actions\022\037\n\007actions\030\001 \003(\0132\016.protos.Action"
    "*-\n\tViewWidth\022\n\n\006NARROW\020\000\022\n\n\006NORMAL\020\001\022\010\n"
    "\004WIDE\020\002*(\n\004Side\022\013\n\007UNKNOWN\020\000\022\010\n\004LEFT\020\001\022\t"
    "\n\005RIGHT\020\002*v\n\023InterceptActionType\022!\n\035UNKN"
    "OWN_Intercept_Action_Type\020\000\022\r\n\tOMNI_DASH"
    "\020\001\022\025\n\021TURN_FORWARD_DASH\020\002\022\026\n\022TURN_BACKWA"
    "RD_DASH\020\003*\232\t\n\014GameModeType\022\021\n\rBeforeKick"
    "Off\020\000\022\014\n\010TimeOver\020\001\022\n\n\006PlayOn\020\002\022\020\n\014KickO"
    "ff_Left\020\003\022\021\n\rKickOff_Right\020\004\022\017\n\013KickIn_L"
    "eft\020\005\022\020\n\014KickIn_Right\020\006\022\021\n\rFreeKick_Left"
    "\020\007\022\022\n\016FreeKick_Right\020\010\022\023\n\017CornerKick_Lef"
    "t\020\t\022\024\n\020CornerKick_Right\020\n\022\021\n\rGoalKick_Le"
    "ft\020\013\022\022\n\016GoalKick_Right\020\014\022\022\n\016AfterGoal_Le"
    "ft\020\r\022\023\n\017AfterGoal_Right\020\016\022\020\n\014OffSide_Lef"
    "t\020\017\022\021\n\rOffSide_Right\020\020\022\024\n\020PenaltyKick_Le"
    "ft\020\021\022\025\n\021PenaltyKick_Right\020\022\022\021\n\rFirstHalf"
    "Over\020\023\022\t\n\005Pause\020\024\022\t\n\005Human\020\025\022\023\n\017FoulChar"
    "ge_Left\020\026\022\024\n\020FoulCharge_Right\020\027\022\021\n\rFoulP"
    "ush_Left\020\030\022\022\n\016FoulPush_Right\020\031\022\035\n\031FoulMu"
    "ltipleAttacker_Left\020\032\022\036\n\032FoulMultipleAtt"
    "acker_Right\020\033\022\024\n\020FoulBallOut_Left\020\034\022\025\n\021F"
    "oulBallOut_Right\020\035\022\021\n\rBackPass_Left\020\036\022\022\n"
    "\016BackPass_Right\020\037\022\026\n\022FreeKickFault_Left\020"
    " \022\027\n\023FreeKickFault_Right\020!\022\023\n\017CatchFault"
    "_Left\020\"\022\024\n\020CatchFault_Right\020#\022\024\n\020IndFree"
    "Kick_Left\020$\022\025\n\021IndFreeKick_Right\020%\022\025\n\021Pe"
    "naltySetup_Left\020&\022\026\n\022PenaltySetup_Right\020"
    "\'\022\025\n\021PenaltyReady_Left\020(\022\026\n\022PenaltyReady"
    "_Right\020)\022\025\n\021PenaltyTaken_Left\020*\022\026\n\022Penal"
    "tyTaken_Right\020+\022\024\n\020PenaltyMiss_Left\020,\022\025\n"
    "\021PenaltyMiss_Right\020-\022\025\n\021PenaltyScore_Lef"
    "t\020.\022\026\n\022PenaltyScore_Right\020/\022\027\n\023IllegalDe"
    "fense_Left\0200\022\030\n\024IllegalDefense_Right\0201\022\022"
    "\n\016PenaltyOnfield\0202\022\017\n\013PenaltyFoul\0203\022\024\n\020G"
    "oalieCatch_Left\0204\022\025\n\021GoalieCatch_Right\0205"
    "\022\016\n\nExtendHalf\0206\022\014\n\010MODE_MAX\020726\n\004Game\022."
    "\n\nGetActions\022\r.protos.State\032\017.protos.Act"
    "ions\"\000b\006proto3"
};
static ::absl::once_flag descriptor_table_service_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_service_2eproto = {
    false,
    false,
    6694,
    descriptor_table_protodef_service_2eproto,
    "service.proto",
    &descriptor_table_service_2eproto_once,
    nullptr,
    0,
    27,
    schemas,
    file_default_instances,
    TableStruct_service_2eproto::offsets,
    file_level_metadata_service_2eproto,
    file_level_enum_descriptors_service_2eproto,
    file_level_service_descriptors_service_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_service_2eproto_getter() {
  return &descriptor_table_service_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_service_2eproto(&descriptor_table_service_2eproto);
namespace protos {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ViewWidth_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_service_2eproto);
  return file_level_enum_descriptors_service_2eproto[0];
}
bool ViewWidth_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Side_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_service_2eproto);
  return file_level_enum_descriptors_service_2eproto[1];
}
bool Side_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InterceptActionType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_service_2eproto);
  return file_level_enum_descriptors_service_2eproto[2];
}
bool InterceptActionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameModeType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_service_2eproto);
  return file_level_enum_descriptors_service_2eproto[3];
}
bool GameModeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class Vector2D::_Internal {
 public:
};

Vector2D::Vector2D(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Vector2D)
}
Vector2D::Vector2D(const Vector2D& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Vector2D)
}

inline void Vector2D::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.x_) { 0 }

    , decltype(_impl_.y_) { 0 }

    , decltype(_impl_.dist_) { 0 }

    , decltype(_impl_.angle_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Vector2D::~Vector2D() {
  // @@protoc_insertion_point(destructor:protos.Vector2D)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vector2D::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Vector2D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vector2D::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Vector2D)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.angle_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.angle_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vector2D::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Vector2D::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Vector2D)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y(), target);
  }

  // float dist = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist = this->_internal_dist();
  ::uint32_t raw_dist;
  memcpy(&raw_dist, &tmp_dist, sizeof(tmp_dist));
  if (raw_dist != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_dist(), target);
  }

  // float angle = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = this->_internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Vector2D)
  return target;
}

::size_t Vector2D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Vector2D)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  // float dist = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist = this->_internal_dist();
  ::uint32_t raw_dist;
  memcpy(&raw_dist, &tmp_dist, sizeof(tmp_dist));
  if (raw_dist != 0) {
    total_size += 5;
  }

  // float angle = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = this->_internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vector2D::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Vector2D::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vector2D::GetClassData() const { return &_class_data_; }


void Vector2D::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Vector2D*>(&to_msg);
  auto& from = static_cast<const Vector2D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Vector2D)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist = from._internal_dist();
  ::uint32_t raw_dist;
  memcpy(&raw_dist, &tmp_dist, sizeof(tmp_dist));
  if (raw_dist != 0) {
    _this->_internal_set_dist(from._internal_dist());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = from._internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    _this->_internal_set_angle(from._internal_angle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vector2D::CopyFrom(const Vector2D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Vector2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector2D::IsInitialized() const {
  return true;
}

void Vector2D::InternalSwap(Vector2D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vector2D, _impl_.angle_)
      + sizeof(Vector2D::_impl_.angle_)
      - PROTOBUF_FIELD_OFFSET(Vector2D, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vector2D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[0]);
}
// ===================================================================

class Ball::_Internal {
 public:
  using HasBits = decltype(std::declval<Ball>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ball, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const Ball* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& relative_position(const Ball* msg);
  static void set_has_relative_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& seen_position(const Ball* msg);
  static void set_has_seen_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::protos::Vector2D& heard_position(const Ball* msg);
  static void set_has_heard_position(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::protos::Vector2D& velocity(const Ball* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::protos::Vector2D& seen_velocity(const Ball* msg);
  static void set_has_seen_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::protos::Vector2D& heard_velocity(const Ball* msg);
  static void set_has_heard_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::protos::Vector2D&
Ball::_Internal::position(const Ball* msg) {
  return *msg->_impl_.position_;
}
const ::protos::Vector2D&
Ball::_Internal::relative_position(const Ball* msg) {
  return *msg->_impl_.relative_position_;
}
const ::protos::Vector2D&
Ball::_Internal::seen_position(const Ball* msg) {
  return *msg->_impl_.seen_position_;
}
const ::protos::Vector2D&
Ball::_Internal::heard_position(const Ball* msg) {
  return *msg->_impl_.heard_position_;
}
const ::protos::Vector2D&
Ball::_Internal::velocity(const Ball* msg) {
  return *msg->_impl_.velocity_;
}
const ::protos::Vector2D&
Ball::_Internal::seen_velocity(const Ball* msg) {
  return *msg->_impl_.seen_velocity_;
}
const ::protos::Vector2D&
Ball::_Internal::heard_velocity(const Ball* msg) {
  return *msg->_impl_.heard_velocity_;
}
Ball::Ball(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Ball)
}
Ball::Ball(const Ball& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Ball* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.relative_position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.heard_velocity_){nullptr}
    , decltype(_impl_.pos_count_) {}

    , decltype(_impl_.seen_pos_count_) {}

    , decltype(_impl_.heard_pos_count_) {}

    , decltype(_impl_.vel_count_) {}

    , decltype(_impl_.seen_vel_count_) {}

    , decltype(_impl_.heard_vel_count_) {}

    , decltype(_impl_.lost_count_) {}

    , decltype(_impl_.ghost_count_) {}

    , decltype(_impl_.dist_from_self_) {}

    , decltype(_impl_.angle_from_self_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.relative_position_ = new ::protos::Vector2D(*from._impl_.relative_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.seen_position_ = new ::protos::Vector2D(*from._impl_.seen_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.heard_position_ = new ::protos::Vector2D(*from._impl_.heard_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.velocity_ = new ::protos::Vector2D(*from._impl_.velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000020u) != 0) {
    _this->_impl_.seen_velocity_ = new ::protos::Vector2D(*from._impl_.seen_velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000040u) != 0) {
    _this->_impl_.heard_velocity_ = new ::protos::Vector2D(*from._impl_.heard_velocity_);
  }
  ::memcpy(&_impl_.pos_count_, &from._impl_.pos_count_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.angle_from_self_) -
    reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.angle_from_self_));
  // @@protoc_insertion_point(copy_constructor:protos.Ball)
}

inline void Ball::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.relative_position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.heard_velocity_){nullptr}
    , decltype(_impl_.pos_count_) { 0 }

    , decltype(_impl_.seen_pos_count_) { 0 }

    , decltype(_impl_.heard_pos_count_) { 0 }

    , decltype(_impl_.vel_count_) { 0 }

    , decltype(_impl_.seen_vel_count_) { 0 }

    , decltype(_impl_.heard_vel_count_) { 0 }

    , decltype(_impl_.lost_count_) { 0 }

    , decltype(_impl_.ghost_count_) { 0 }

    , decltype(_impl_.dist_from_self_) { 0 }

    , decltype(_impl_.angle_from_self_) { 0 }

  };
}

Ball::~Ball() {
  // @@protoc_insertion_point(destructor:protos.Ball)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ball::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.relative_position_;
  if (this != internal_default_instance()) delete _impl_.seen_position_;
  if (this != internal_default_instance()) delete _impl_.heard_position_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
  if (this != internal_default_instance()) delete _impl_.seen_velocity_;
  if (this != internal_default_instance()) delete _impl_.heard_velocity_;
}

void Ball::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ball::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Ball)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.relative_position_ != nullptr);
      _impl_.relative_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.seen_position_ != nullptr);
      _impl_.seen_position_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.heard_position_ != nullptr);
      _impl_.heard_position_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.velocity_ != nullptr);
      _impl_.velocity_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.seen_velocity_ != nullptr);
      _impl_.seen_velocity_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(_impl_.heard_velocity_ != nullptr);
      _impl_.heard_velocity_->Clear();
    }
  }
  ::memset(&_impl_.pos_count_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.angle_from_self_) -
      reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.angle_from_self_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ball::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D relative_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_relative_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D heard_position = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_heard_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D velocity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_velocity = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D heard_velocity = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_heard_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 pos_count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_pos_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.seen_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 heard_pos_count = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.heard_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 vel_count = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_vel_count = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _impl_.seen_vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 heard_vel_count = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _impl_.heard_vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 lost_count = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.lost_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ghost_count = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _impl_.ghost_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist_from_self = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 133)) {
          _impl_.dist_from_self_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle_from_self = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 141)) {
          _impl_.angle_from_self_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ball::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Ball)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D relative_position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::relative_position(this),
        _Internal::relative_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_position = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::seen_position(this),
        _Internal::seen_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D heard_position = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::heard_position(this),
        _Internal::heard_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D velocity = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_velocity = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::seen_velocity(this),
        _Internal::seen_velocity(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D heard_velocity = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::heard_velocity(this),
        _Internal::heard_velocity(this).GetCachedSize(), target, stream);
  }

  // int32 pos_count = 8;
  if (this->_internal_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_pos_count(), target);
  }

  // int32 seen_pos_count = 9;
  if (this->_internal_seen_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        9, this->_internal_seen_pos_count(), target);
  }

  // int32 heard_pos_count = 10;
  if (this->_internal_heard_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_heard_pos_count(), target);
  }

  // int32 vel_count = 11;
  if (this->_internal_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        11, this->_internal_vel_count(), target);
  }

  // int32 seen_vel_count = 12;
  if (this->_internal_seen_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        12, this->_internal_seen_vel_count(), target);
  }

  // int32 heard_vel_count = 13;
  if (this->_internal_heard_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        13, this->_internal_heard_vel_count(), target);
  }

  // int32 lost_count = 14;
  if (this->_internal_lost_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        14, this->_internal_lost_count(), target);
  }

  // int32 ghost_count = 15;
  if (this->_internal_ghost_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        15, this->_internal_ghost_count(), target);
  }

  // float dist_from_self = 16;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = this->_internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        16, this->_internal_dist_from_self(), target);
  }

  // float angle_from_self = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = this->_internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        17, this->_internal_angle_from_self(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Ball)
  return target;
}

::size_t Ball::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Ball)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // .protos.Vector2D position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // .protos.Vector2D relative_position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.relative_position_);
    }

    // .protos.Vector2D seen_position = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_position_);
    }

    // .protos.Vector2D heard_position = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.heard_position_);
    }

    // .protos.Vector2D velocity = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.velocity_);
    }

    // .protos.Vector2D seen_velocity = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_velocity_);
    }

    // .protos.Vector2D heard_velocity = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.heard_velocity_);
    }

  }
  // int32 pos_count = 8;
  if (this->_internal_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_pos_count());
  }

  // int32 seen_pos_count = 9;
  if (this->_internal_seen_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_pos_count());
  }

  // int32 heard_pos_count = 10;
  if (this->_internal_heard_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_heard_pos_count());
  }

  // int32 vel_count = 11;
  if (this->_internal_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_vel_count());
  }

  // int32 seen_vel_count = 12;
  if (this->_internal_seen_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_vel_count());
  }

  // int32 heard_vel_count = 13;
  if (this->_internal_heard_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_heard_vel_count());
  }

  // int32 lost_count = 14;
  if (this->_internal_lost_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_lost_count());
  }

  // int32 ghost_count = 15;
  if (this->_internal_ghost_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_ghost_count());
  }

  // float dist_from_self = 16;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = this->_internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    total_size += 6;
  }

  // float angle_from_self = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = this->_internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    total_size += 6;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ball::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ball::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ball::GetClassData() const { return &_class_data_; }


void Ball::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ball*>(&to_msg);
  auto& from = static_cast<const Ball&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Ball)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_relative_position()->::protos::Vector2D::MergeFrom(
          from._internal_relative_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_seen_position()->::protos::Vector2D::MergeFrom(
          from._internal_seen_position());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_heard_position()->::protos::Vector2D::MergeFrom(
          from._internal_heard_position());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_velocity());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_seen_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_seen_velocity());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_heard_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_heard_velocity());
    }
  }
  if (from._internal_pos_count() != 0) {
    _this->_internal_set_pos_count(from._internal_pos_count());
  }
  if (from._internal_seen_pos_count() != 0) {
    _this->_internal_set_seen_pos_count(from._internal_seen_pos_count());
  }
  if (from._internal_heard_pos_count() != 0) {
    _this->_internal_set_heard_pos_count(from._internal_heard_pos_count());
  }
  if (from._internal_vel_count() != 0) {
    _this->_internal_set_vel_count(from._internal_vel_count());
  }
  if (from._internal_seen_vel_count() != 0) {
    _this->_internal_set_seen_vel_count(from._internal_seen_vel_count());
  }
  if (from._internal_heard_vel_count() != 0) {
    _this->_internal_set_heard_vel_count(from._internal_heard_vel_count());
  }
  if (from._internal_lost_count() != 0) {
    _this->_internal_set_lost_count(from._internal_lost_count());
  }
  if (from._internal_ghost_count() != 0) {
    _this->_internal_set_ghost_count(from._internal_ghost_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = from._internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    _this->_internal_set_dist_from_self(from._internal_dist_from_self());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = from._internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    _this->_internal_set_angle_from_self(from._internal_angle_from_self());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ball::CopyFrom(const Ball& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Ball)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ball::IsInitialized() const {
  return true;
}

void Ball::InternalSwap(Ball* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ball, _impl_.angle_from_self_)
      + sizeof(Ball::_impl_.angle_from_self_)
      - PROTOBUF_FIELD_OFFSET(Ball, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ball::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[1]);
}
// ===================================================================

class Player::_Internal {
 public:
  using HasBits = decltype(std::declval<Player>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Player, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const Player* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& seen_position(const Player* msg);
  static void set_has_seen_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& heard_position(const Player* msg);
  static void set_has_heard_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::protos::Vector2D& velocity(const Player* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::protos::Vector2D& seen_velocity(const Player* msg);
  static void set_has_seen_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::protos::Vector2D&
Player::_Internal::position(const Player* msg) {
  return *msg->_impl_.position_;
}
const ::protos::Vector2D&
Player::_Internal::seen_position(const Player* msg) {
  return *msg->_impl_.seen_position_;
}
const ::protos::Vector2D&
Player::_Internal::heard_position(const Player* msg) {
  return *msg->_impl_.heard_position_;
}
const ::protos::Vector2D&
Player::_Internal::velocity(const Player* msg) {
  return *msg->_impl_.velocity_;
}
const ::protos::Vector2D&
Player::_Internal::seen_velocity(const Player* msg) {
  return *msg->_impl_.seen_velocity_;
}
Player::Player(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Player)
}
Player::Player(const Player& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Player* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.pos_count_) {}

    , decltype(_impl_.seen_pos_count_) {}

    , decltype(_impl_.heard_pos_count_) {}

    , decltype(_impl_.vel_count_) {}

    , decltype(_impl_.seen_vel_count_) {}

    , decltype(_impl_.ghost_count_) {}

    , decltype(_impl_.dist_from_self_) {}

    , decltype(_impl_.angle_from_self_) {}

    , decltype(_impl_.id_) {}

    , decltype(_impl_.side_) {}

    , decltype(_impl_.uniform_number_) {}

    , decltype(_impl_.uniform_number_count_) {}

    , decltype(_impl_.body_direction_) {}

    , decltype(_impl_.body_direction_count_) {}

    , decltype(_impl_.face_direction_) {}

    , decltype(_impl_.face_direction_count_) {}

    , decltype(_impl_.point_to_direction_) {}

    , decltype(_impl_.point_to_direction_count_) {}

    , decltype(_impl_.is_goalie_) {}

    , decltype(_impl_.is_kicking_) {}

    , decltype(_impl_.is_tackling_) {}

    , decltype(_impl_.dist_from_ball_) {}

    , decltype(_impl_.angle_from_ball_) {}

    , decltype(_impl_.ball_reach_steps_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.seen_position_ = new ::protos::Vector2D(*from._impl_.seen_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.heard_position_ = new ::protos::Vector2D(*from._impl_.heard_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.velocity_ = new ::protos::Vector2D(*from._impl_.velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.seen_velocity_ = new ::protos::Vector2D(*from._impl_.seen_velocity_);
  }
  ::memcpy(&_impl_.pos_count_, &from._impl_.pos_count_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.ball_reach_steps_) -
    reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.ball_reach_steps_));
  // @@protoc_insertion_point(copy_constructor:protos.Player)
}

inline void Player::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.pos_count_) { 0 }

    , decltype(_impl_.seen_pos_count_) { 0 }

    , decltype(_impl_.heard_pos_count_) { 0 }

    , decltype(_impl_.vel_count_) { 0 }

    , decltype(_impl_.seen_vel_count_) { 0 }

    , decltype(_impl_.ghost_count_) { 0 }

    , decltype(_impl_.dist_from_self_) { 0 }

    , decltype(_impl_.angle_from_self_) { 0 }

    , decltype(_impl_.id_) { 0 }

    , decltype(_impl_.side_) { 0 }

    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.uniform_number_count_) { 0 }

    , decltype(_impl_.body_direction_) { 0 }

    , decltype(_impl_.body_direction_count_) { 0 }

    , decltype(_impl_.face_direction_) { 0 }

    , decltype(_impl_.face_direction_count_) { 0 }

    , decltype(_impl_.point_to_direction_) { 0 }

    , decltype(_impl_.point_to_direction_count_) { 0 }

    , decltype(_impl_.is_goalie_) { false }

    , decltype(_impl_.is_kicking_) { false }

    , decltype(_impl_.is_tackling_) { false }

    , decltype(_impl_.dist_from_ball_) { 0 }

    , decltype(_impl_.angle_from_ball_) { 0 }

    , decltype(_impl_.ball_reach_steps_) { 0 }

  };
}

Player::~Player() {
  // @@protoc_insertion_point(destructor:protos.Player)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Player::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.seen_position_;
  if (this != internal_default_instance()) delete _impl_.heard_position_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
  if (this != internal_default_instance()) delete _impl_.seen_velocity_;
}

void Player::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Player::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Player)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.seen_position_ != nullptr);
      _impl_.seen_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.heard_position_ != nullptr);
      _impl_.heard_position_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.velocity_ != nullptr);
      _impl_.velocity_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.seen_velocity_ != nullptr);
      _impl_.seen_velocity_->Clear();
    }
  }
  ::memset(&_impl_.pos_count_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.ball_reach_steps_) -
      reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.ball_reach_steps_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Player::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D heard_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_heard_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D velocity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_velocity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 pos_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_pos_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.seen_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 heard_pos_count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.heard_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 vel_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_vel_count = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.seen_vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ghost_count = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.ghost_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist_from_self = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 101)) {
          _impl_.dist_from_self_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle_from_self = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 109)) {
          _impl_.angle_from_self_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 id = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Side side = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number_count = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 136)) {
          _impl_.uniform_number_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_goalie = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
          _impl_.is_goalie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float body_direction = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 157)) {
          _impl_.body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 body_direction_count = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _impl_.body_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float face_direction = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 173)) {
          _impl_.face_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 face_direction_count = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 176)) {
          _impl_.face_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float point_to_direction = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 189)) {
          _impl_.point_to_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 point_to_direction_count = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 192)) {
          _impl_.point_to_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_kicking = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 200)) {
          _impl_.is_kicking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist_from_ball = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 213)) {
          _impl_.dist_from_ball_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle_from_ball = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 221)) {
          _impl_.angle_from_ball_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ball_reach_steps = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 224)) {
          _impl_.ball_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_tackling = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 232)) {
          _impl_.is_tackling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Player::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Player)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::seen_position(this),
        _Internal::seen_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D heard_position = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::heard_position(this),
        _Internal::heard_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D velocity = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_velocity = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::seen_velocity(this),
        _Internal::seen_velocity(this).GetCachedSize(), target, stream);
  }

  // int32 pos_count = 6;
  if (this->_internal_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_pos_count(), target);
  }

  // int32 seen_pos_count = 7;
  if (this->_internal_seen_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_seen_pos_count(), target);
  }

  // int32 heard_pos_count = 8;
  if (this->_internal_heard_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_heard_pos_count(), target);
  }

  // int32 vel_count = 9;
  if (this->_internal_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        9, this->_internal_vel_count(), target);
  }

  // int32 seen_vel_count = 10;
  if (this->_internal_seen_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_seen_vel_count(), target);
  }

  // int32 ghost_count = 11;
  if (this->_internal_ghost_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        11, this->_internal_ghost_count(), target);
  }

  // float dist_from_self = 12;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = this->_internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        12, this->_internal_dist_from_self(), target);
  }

  // float angle_from_self = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = this->_internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        13, this->_internal_angle_from_self(), target);
  }

  // int32 id = 14;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        14, this->_internal_id(), target);
  }

  // .protos.Side side = 15;
  if (this->_internal_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        15, this->_internal_side(), target);
  }

  // int32 uniform_number = 16;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        16, this->_internal_uniform_number(), target);
  }

  // int32 uniform_number_count = 17;
  if (this->_internal_uniform_number_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        17, this->_internal_uniform_number_count(), target);
  }

  // bool is_goalie = 18;
  if (this->_internal_is_goalie() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        18, this->_internal_is_goalie(), target);
  }

  // float body_direction = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        19, this->_internal_body_direction(), target);
  }

  // int32 body_direction_count = 20;
  if (this->_internal_body_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        20, this->_internal_body_direction_count(), target);
  }

  // float face_direction = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = this->_internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        21, this->_internal_face_direction(), target);
  }

  // int32 face_direction_count = 22;
  if (this->_internal_face_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        22, this->_internal_face_direction_count(), target);
  }

  // float point_to_direction = 23;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = this->_internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        23, this->_internal_point_to_direction(), target);
  }

  // int32 point_to_direction_count = 24;
  if (this->_internal_point_to_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        24, this->_internal_point_to_direction_count(), target);
  }

  // bool is_kicking = 25;
  if (this->_internal_is_kicking() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        25, this->_internal_is_kicking(), target);
  }

  // float dist_from_ball = 26;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = this->_internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        26, this->_internal_dist_from_ball(), target);
  }

  // float angle_from_ball = 27;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = this->_internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        27, this->_internal_angle_from_ball(), target);
  }

  // int32 ball_reach_steps = 28;
  if (this->_internal_ball_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        28, this->_internal_ball_reach_steps(), target);
  }

  // bool is_tackling = 29;
  if (this->_internal_is_tackling() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        29, this->_internal_is_tackling(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Player)
  return target;
}

::size_t Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Player)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // .protos.Vector2D position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // .protos.Vector2D seen_position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_position_);
    }

    // .protos.Vector2D heard_position = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.heard_position_);
    }

    // .protos.Vector2D velocity = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.velocity_);
    }

    // .protos.Vector2D seen_velocity = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_velocity_);
    }

  }
  // int32 pos_count = 6;
  if (this->_internal_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_pos_count());
  }

  // int32 seen_pos_count = 7;
  if (this->_internal_seen_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_pos_count());
  }

  // int32 heard_pos_count = 8;
  if (this->_internal_heard_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_heard_pos_count());
  }

  // int32 vel_count = 9;
  if (this->_internal_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_vel_count());
  }

  // int32 seen_vel_count = 10;
  if (this->_internal_seen_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_vel_count());
  }

  // int32 ghost_count = 11;
  if (this->_internal_ghost_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_ghost_count());
  }

  // float dist_from_self = 12;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = this->_internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    total_size += 5;
  }

  // float angle_from_self = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = this->_internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    total_size += 5;
  }

  // int32 id = 14;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_id());
  }

  // .protos.Side side = 15;
  if (this->_internal_side() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  // int32 uniform_number = 16;
  if (this->_internal_uniform_number() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_uniform_number());
  }

  // int32 uniform_number_count = 17;
  if (this->_internal_uniform_number_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_uniform_number_count());
  }

  // float body_direction = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    total_size += 6;
  }

  // int32 body_direction_count = 20;
  if (this->_internal_body_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_body_direction_count());
  }

  // float face_direction = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = this->_internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    total_size += 6;
  }

  // int32 face_direction_count = 22;
  if (this->_internal_face_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_face_direction_count());
  }

  // float point_to_direction = 23;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = this->_internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    total_size += 6;
  }

  // int32 point_to_direction_count = 24;
  if (this->_internal_point_to_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_point_to_direction_count());
  }

  // bool is_goalie = 18;
  if (this->_internal_is_goalie() != 0) {
    total_size += 3;
  }

  // bool is_kicking = 25;
  if (this->_internal_is_kicking() != 0) {
    total_size += 3;
  }

  // bool is_tackling = 29;
  if (this->_internal_is_tackling() != 0) {
    total_size += 3;
  }

  // float dist_from_ball = 26;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = this->_internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    total_size += 6;
  }

  // float angle_from_ball = 27;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = this->_internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    total_size += 6;
  }

  // int32 ball_reach_steps = 28;
  if (this->_internal_ball_reach_steps() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_ball_reach_steps());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Player::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Player::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Player::GetClassData() const { return &_class_data_; }


void Player::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Player*>(&to_msg);
  auto& from = static_cast<const Player&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Player)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_seen_position()->::protos::Vector2D::MergeFrom(
          from._internal_seen_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_heard_position()->::protos::Vector2D::MergeFrom(
          from._internal_heard_position());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_velocity());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_seen_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_seen_velocity());
    }
  }
  if (from._internal_pos_count() != 0) {
    _this->_internal_set_pos_count(from._internal_pos_count());
  }
  if (from._internal_seen_pos_count() != 0) {
    _this->_internal_set_seen_pos_count(from._internal_seen_pos_count());
  }
  if (from._internal_heard_pos_count() != 0) {
    _this->_internal_set_heard_pos_count(from._internal_heard_pos_count());
  }
  if (from._internal_vel_count() != 0) {
    _this->_internal_set_vel_count(from._internal_vel_count());
  }
  if (from._internal_seen_vel_count() != 0) {
    _this->_internal_set_seen_vel_count(from._internal_seen_vel_count());
  }
  if (from._internal_ghost_count() != 0) {
    _this->_internal_set_ghost_count(from._internal_ghost_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = from._internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    _this->_internal_set_dist_from_self(from._internal_dist_from_self());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = from._internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    _this->_internal_set_angle_from_self(from._internal_angle_from_self());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_side() != 0) {
    _this->_internal_set_side(from._internal_side());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  if (from._internal_uniform_number_count() != 0) {
    _this->_internal_set_uniform_number_count(from._internal_uniform_number_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = from._internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    _this->_internal_set_body_direction(from._internal_body_direction());
  }
  if (from._internal_body_direction_count() != 0) {
    _this->_internal_set_body_direction_count(from._internal_body_direction_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = from._internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    _this->_internal_set_face_direction(from._internal_face_direction());
  }
  if (from._internal_face_direction_count() != 0) {
    _this->_internal_set_face_direction_count(from._internal_face_direction_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = from._internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    _this->_internal_set_point_to_direction(from._internal_point_to_direction());
  }
  if (from._internal_point_to_direction_count() != 0) {
    _this->_internal_set_point_to_direction_count(from._internal_point_to_direction_count());
  }
  if (from._internal_is_goalie() != 0) {
    _this->_internal_set_is_goalie(from._internal_is_goalie());
  }
  if (from._internal_is_kicking() != 0) {
    _this->_internal_set_is_kicking(from._internal_is_kicking());
  }
  if (from._internal_is_tackling() != 0) {
    _this->_internal_set_is_tackling(from._internal_is_tackling());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = from._internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    _this->_internal_set_dist_from_ball(from._internal_dist_from_ball());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = from._internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    _this->_internal_set_angle_from_ball(from._internal_angle_from_ball());
  }
  if (from._internal_ball_reach_steps() != 0) {
    _this->_internal_set_ball_reach_steps(from._internal_ball_reach_steps());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Player::CopyFrom(const Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Player::IsInitialized() const {
  return true;
}

void Player::InternalSwap(Player* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Player, _impl_.ball_reach_steps_)
      + sizeof(Player::_impl_.ball_reach_steps_)
      - PROTOBUF_FIELD_OFFSET(Player, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Player::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[2]);
}
// ===================================================================

class Self::_Internal {
 public:
  using HasBits = decltype(std::declval<Self>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Self, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const Self* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& seen_position(const Self* msg);
  static void set_has_seen_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& heard_position(const Self* msg);
  static void set_has_heard_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::protos::Vector2D& velocity(const Self* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::protos::Vector2D& seen_velocity(const Self* msg);
  static void set_has_seen_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::protos::Vector2D&
Self::_Internal::position(const Self* msg) {
  return *msg->_impl_.position_;
}
const ::protos::Vector2D&
Self::_Internal::seen_position(const Self* msg) {
  return *msg->_impl_.seen_position_;
}
const ::protos::Vector2D&
Self::_Internal::heard_position(const Self* msg) {
  return *msg->_impl_.heard_position_;
}
const ::protos::Vector2D&
Self::_Internal::velocity(const Self* msg) {
  return *msg->_impl_.velocity_;
}
const ::protos::Vector2D&
Self::_Internal::seen_velocity(const Self* msg) {
  return *msg->_impl_.seen_velocity_;
}
Self::Self(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Self)
}
Self::Self(const Self& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Self* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.pos_count_) {}

    , decltype(_impl_.seen_pos_count_) {}

    , decltype(_impl_.heard_pos_count_) {}

    , decltype(_impl_.vel_count_) {}

    , decltype(_impl_.seen_vel_count_) {}

    , decltype(_impl_.ghost_count_) {}

    , decltype(_impl_.id_) {}

    , decltype(_impl_.side_) {}

    , decltype(_impl_.uniform_number_) {}

    , decltype(_impl_.uniform_number_count_) {}

    , decltype(_impl_.body_direction_) {}

    , decltype(_impl_.body_direction_count_) {}

    , decltype(_impl_.face_direction_) {}

    , decltype(_impl_.face_direction_count_) {}

    , decltype(_impl_.point_to_direction_) {}

    , decltype(_impl_.point_to_direction_count_) {}

    , decltype(_impl_.dist_from_ball_) {}

    , decltype(_impl_.is_goalie_) {}

    , decltype(_impl_.is_kicking_) {}

    , decltype(_impl_.is_tackling_) {}

    , decltype(_impl_.is_kickable_) {}

    , decltype(_impl_.angle_from_ball_) {}

    , decltype(_impl_.ball_reach_steps_) {}

    , decltype(_impl_.relative_neck_direction_) {}

    , decltype(_impl_.stamina_) {}

    , decltype(_impl_.catch_probability_) {}

    , decltype(_impl_.tackle_probability_) {}

    , decltype(_impl_.foul_probability_) {}

    , decltype(_impl_.view_width_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.seen_position_ = new ::protos::Vector2D(*from._impl_.seen_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.heard_position_ = new ::protos::Vector2D(*from._impl_.heard_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.velocity_ = new ::protos::Vector2D(*from._impl_.velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.seen_velocity_ = new ::protos::Vector2D(*from._impl_.seen_velocity_);
  }
  ::memcpy(&_impl_.pos_count_, &from._impl_.pos_count_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.view_width_) -
    reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.view_width_));
  // @@protoc_insertion_point(copy_constructor:protos.Self)
}

inline void Self::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.pos_count_) { 0 }

    , decltype(_impl_.seen_pos_count_) { 0 }

    , decltype(_impl_.heard_pos_count_) { 0 }

    , decltype(_impl_.vel_count_) { 0 }

    , decltype(_impl_.seen_vel_count_) { 0 }

    , decltype(_impl_.ghost_count_) { 0 }

    , decltype(_impl_.id_) { 0 }

    , decltype(_impl_.side_) { 0 }

    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.uniform_number_count_) { 0 }

    , decltype(_impl_.body_direction_) { 0 }

    , decltype(_impl_.body_direction_count_) { 0 }

    , decltype(_impl_.face_direction_) { 0 }

    , decltype(_impl_.face_direction_count_) { 0 }

    , decltype(_impl_.point_to_direction_) { 0 }

    , decltype(_impl_.point_to_direction_count_) { 0 }

    , decltype(_impl_.dist_from_ball_) { 0 }

    , decltype(_impl_.is_goalie_) { false }

    , decltype(_impl_.is_kicking_) { false }

    , decltype(_impl_.is_tackling_) { false }

    , decltype(_impl_.is_kickable_) { false }

    , decltype(_impl_.angle_from_ball_) { 0 }

    , decltype(_impl_.ball_reach_steps_) { 0 }

    , decltype(_impl_.relative_neck_direction_) { 0 }

    , decltype(_impl_.stamina_) { 0 }

    , decltype(_impl_.catch_probability_) { 0 }

    , decltype(_impl_.tackle_probability_) { 0 }

    , decltype(_impl_.foul_probability_) { 0 }

    , decltype(_impl_.view_width_) { 0 }

  };
}

Self::~Self() {
  // @@protoc_insertion_point(destructor:protos.Self)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Self::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.seen_position_;
  if (this != internal_default_instance()) delete _impl_.heard_position_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
  if (this != internal_default_instance()) delete _impl_.seen_velocity_;
}

void Self::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Self::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Self)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.seen_position_ != nullptr);
      _impl_.seen_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.heard_position_ != nullptr);
      _impl_.heard_position_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.velocity_ != nullptr);
      _impl_.velocity_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.seen_velocity_ != nullptr);
      _impl_.seen_velocity_->Clear();
    }
  }
  ::memset(&_impl_.pos_count_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.view_width_) -
      reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.view_width_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Self::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D heard_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_heard_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D velocity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_velocity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 pos_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_pos_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.seen_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 heard_pos_count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.heard_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 vel_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_vel_count = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.seen_vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ghost_count = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.ghost_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 id = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Side side = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number_count = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _impl_.uniform_number_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_goalie = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _impl_.is_goalie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float body_direction = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 141)) {
          _impl_.body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 body_direction_count = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
          _impl_.body_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float face_direction = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 157)) {
          _impl_.face_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 face_direction_count = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _impl_.face_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float point_to_direction = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 173)) {
          _impl_.point_to_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 point_to_direction_count = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 176)) {
          _impl_.point_to_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_kicking = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 184)) {
          _impl_.is_kicking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist_from_ball = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 197)) {
          _impl_.dist_from_ball_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle_from_ball = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 205)) {
          _impl_.angle_from_ball_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ball_reach_steps = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 208)) {
          _impl_.ball_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_tackling = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 216)) {
          _impl_.is_tackling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float relative_neck_direction = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 229)) {
          _impl_.relative_neck_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float stamina = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 237)) {
          _impl_.stamina_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_kickable = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 240)) {
          _impl_.is_kickable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float catch_probability = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 253)) {
          _impl_.catch_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float tackle_probability = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 5)) {
          _impl_.tackle_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float foul_probability = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.foul_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.ViewWidth view_width = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_view_width(static_cast<::protos::ViewWidth>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Self::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Self)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::seen_position(this),
        _Internal::seen_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D heard_position = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::heard_position(this),
        _Internal::heard_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D velocity = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_velocity = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::seen_velocity(this),
        _Internal::seen_velocity(this).GetCachedSize(), target, stream);
  }

  // int32 pos_count = 6;
  if (this->_internal_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_pos_count(), target);
  }

  // int32 seen_pos_count = 7;
  if (this->_internal_seen_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_seen_pos_count(), target);
  }

  // int32 heard_pos_count = 8;
  if (this->_internal_heard_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_heard_pos_count(), target);
  }

  // int32 vel_count = 9;
  if (this->_internal_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        9, this->_internal_vel_count(), target);
  }

  // int32 seen_vel_count = 10;
  if (this->_internal_seen_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_seen_vel_count(), target);
  }

  // int32 ghost_count = 11;
  if (this->_internal_ghost_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        11, this->_internal_ghost_count(), target);
  }

  // int32 id = 12;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        12, this->_internal_id(), target);
  }

  // .protos.Side side = 13;
  if (this->_internal_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        13, this->_internal_side(), target);
  }

  // int32 uniform_number = 14;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        14, this->_internal_uniform_number(), target);
  }

  // int32 uniform_number_count = 15;
  if (this->_internal_uniform_number_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        15, this->_internal_uniform_number_count(), target);
  }

  // bool is_goalie = 16;
  if (this->_internal_is_goalie() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        16, this->_internal_is_goalie(), target);
  }

  // float body_direction = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        17, this->_internal_body_direction(), target);
  }

  // int32 body_direction_count = 18;
  if (this->_internal_body_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        18, this->_internal_body_direction_count(), target);
  }

  // float face_direction = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = this->_internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        19, this->_internal_face_direction(), target);
  }

  // int32 face_direction_count = 20;
  if (this->_internal_face_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        20, this->_internal_face_direction_count(), target);
  }

  // float point_to_direction = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = this->_internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        21, this->_internal_point_to_direction(), target);
  }

  // int32 point_to_direction_count = 22;
  if (this->_internal_point_to_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        22, this->_internal_point_to_direction_count(), target);
  }

  // bool is_kicking = 23;
  if (this->_internal_is_kicking() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        23, this->_internal_is_kicking(), target);
  }

  // float dist_from_ball = 24;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = this->_internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        24, this->_internal_dist_from_ball(), target);
  }

  // float angle_from_ball = 25;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = this->_internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        25, this->_internal_angle_from_ball(), target);
  }

  // int32 ball_reach_steps = 26;
  if (this->_internal_ball_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        26, this->_internal_ball_reach_steps(), target);
  }

  // bool is_tackling = 27;
  if (this->_internal_is_tackling() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        27, this->_internal_is_tackling(), target);
  }

  // float relative_neck_direction = 28;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_neck_direction = this->_internal_relative_neck_direction();
  ::uint32_t raw_relative_neck_direction;
  memcpy(&raw_relative_neck_direction, &tmp_relative_neck_direction, sizeof(tmp_relative_neck_direction));
  if (raw_relative_neck_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        28, this->_internal_relative_neck_direction(), target);
  }

  // float stamina = 29;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina = this->_internal_stamina();
  ::uint32_t raw_stamina;
  memcpy(&raw_stamina, &tmp_stamina, sizeof(tmp_stamina));
  if (raw_stamina != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        29, this->_internal_stamina(), target);
  }

  // bool is_kickable = 30;
  if (this->_internal_is_kickable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        30, this->_internal_is_kickable(), target);
  }

  // float catch_probability = 31;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_probability = this->_internal_catch_probability();
  ::uint32_t raw_catch_probability;
  memcpy(&raw_catch_probability, &tmp_catch_probability, sizeof(tmp_catch_probability));
  if (raw_catch_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        31, this->_internal_catch_probability(), target);
  }

  // float tackle_probability = 32;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_probability = this->_internal_tackle_probability();
  ::uint32_t raw_tackle_probability;
  memcpy(&raw_tackle_probability, &tmp_tackle_probability, sizeof(tmp_tackle_probability));
  if (raw_tackle_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        32, this->_internal_tackle_probability(), target);
  }

  // float foul_probability = 33;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_probability = this->_internal_foul_probability();
  ::uint32_t raw_foul_probability;
  memcpy(&raw_foul_probability, &tmp_foul_probability, sizeof(tmp_foul_probability));
  if (raw_foul_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        33, this->_internal_foul_probability(), target);
  }

  // .protos.ViewWidth view_width = 34;
  if (this->_internal_view_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        34, this->_internal_view_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Self)
  return target;
}

::size_t Self::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Self)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // .protos.Vector2D position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // .protos.Vector2D seen_position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_position_);
    }

    // .protos.Vector2D heard_position = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.heard_position_);
    }

    // .protos.Vector2D velocity = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.velocity_);
    }

    // .protos.Vector2D seen_velocity = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_velocity_);
    }

  }
  // int32 pos_count = 6;
  if (this->_internal_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_pos_count());
  }

  // int32 seen_pos_count = 7;
  if (this->_internal_seen_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_pos_count());
  }

  // int32 heard_pos_count = 8;
  if (this->_internal_heard_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_heard_pos_count());
  }

  // int32 vel_count = 9;
  if (this->_internal_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_vel_count());
  }

  // int32 seen_vel_count = 10;
  if (this->_internal_seen_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_vel_count());
  }

  // int32 ghost_count = 11;
  if (this->_internal_ghost_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_ghost_count());
  }

  // int32 id = 12;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_id());
  }

  // .protos.Side side = 13;
  if (this->_internal_side() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  // int32 uniform_number = 14;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  // int32 uniform_number_count = 15;
  if (this->_internal_uniform_number_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number_count());
  }

  // float body_direction = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    total_size += 6;
  }

  // int32 body_direction_count = 18;
  if (this->_internal_body_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_body_direction_count());
  }

  // float face_direction = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = this->_internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    total_size += 6;
  }

  // int32 face_direction_count = 20;
  if (this->_internal_face_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_face_direction_count());
  }

  // float point_to_direction = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = this->_internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    total_size += 6;
  }

  // int32 point_to_direction_count = 22;
  if (this->_internal_point_to_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_point_to_direction_count());
  }

  // float dist_from_ball = 24;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = this->_internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    total_size += 6;
  }

  // bool is_goalie = 16;
  if (this->_internal_is_goalie() != 0) {
    total_size += 3;
  }

  // bool is_kicking = 23;
  if (this->_internal_is_kicking() != 0) {
    total_size += 3;
  }

  // bool is_tackling = 27;
  if (this->_internal_is_tackling() != 0) {
    total_size += 3;
  }

  // bool is_kickable = 30;
  if (this->_internal_is_kickable() != 0) {
    total_size += 3;
  }

  // float angle_from_ball = 25;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = this->_internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    total_size += 6;
  }

  // int32 ball_reach_steps = 26;
  if (this->_internal_ball_reach_steps() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_ball_reach_steps());
  }

  // float relative_neck_direction = 28;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_neck_direction = this->_internal_relative_neck_direction();
  ::uint32_t raw_relative_neck_direction;
  memcpy(&raw_relative_neck_direction, &tmp_relative_neck_direction, sizeof(tmp_relative_neck_direction));
  if (raw_relative_neck_direction != 0) {
    total_size += 6;
  }

  // float stamina = 29;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina = this->_internal_stamina();
  ::uint32_t raw_stamina;
  memcpy(&raw_stamina, &tmp_stamina, sizeof(tmp_stamina));
  if (raw_stamina != 0) {
    total_size += 6;
  }

  // float catch_probability = 31;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_probability = this->_internal_catch_probability();
  ::uint32_t raw_catch_probability;
  memcpy(&raw_catch_probability, &tmp_catch_probability, sizeof(tmp_catch_probability));
  if (raw_catch_probability != 0) {
    total_size += 6;
  }

  // float tackle_probability = 32;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_probability = this->_internal_tackle_probability();
  ::uint32_t raw_tackle_probability;
  memcpy(&raw_tackle_probability, &tmp_tackle_probability, sizeof(tmp_tackle_probability));
  if (raw_tackle_probability != 0) {
    total_size += 6;
  }

  // float foul_probability = 33;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_probability = this->_internal_foul_probability();
  ::uint32_t raw_foul_probability;
  memcpy(&raw_foul_probability, &tmp_foul_probability, sizeof(tmp_foul_probability));
  if (raw_foul_probability != 0) {
    total_size += 6;
  }

  // .protos.ViewWidth view_width = 34;
  if (this->_internal_view_width() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_view_width());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Self::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Self::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Self::GetClassData() const { return &_class_data_; }


void Self::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Self*>(&to_msg);
  auto& from = static_cast<const Self&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Self)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_seen_position()->::protos::Vector2D::MergeFrom(
          from._internal_seen_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_heard_position()->::protos::Vector2D::MergeFrom(
          from._internal_heard_position());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_velocity());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_seen_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_seen_velocity());
    }
  }
  if (from._internal_pos_count() != 0) {
    _this->_internal_set_pos_count(from._internal_pos_count());
  }
  if (from._internal_seen_pos_count() != 0) {
    _this->_internal_set_seen_pos_count(from._internal_seen_pos_count());
  }
  if (from._internal_heard_pos_count() != 0) {
    _this->_internal_set_heard_pos_count(from._internal_heard_pos_count());
  }
  if (from._internal_vel_count() != 0) {
    _this->_internal_set_vel_count(from._internal_vel_count());
  }
  if (from._internal_seen_vel_count() != 0) {
    _this->_internal_set_seen_vel_count(from._internal_seen_vel_count());
  }
  if (from._internal_ghost_count() != 0) {
    _this->_internal_set_ghost_count(from._internal_ghost_count());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_side() != 0) {
    _this->_internal_set_side(from._internal_side());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  if (from._internal_uniform_number_count() != 0) {
    _this->_internal_set_uniform_number_count(from._internal_uniform_number_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = from._internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    _this->_internal_set_body_direction(from._internal_body_direction());
  }
  if (from._internal_body_direction_count() != 0) {
    _this->_internal_set_body_direction_count(from._internal_body_direction_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = from._internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    _this->_internal_set_face_direction(from._internal_face_direction());
  }
  if (from._internal_face_direction_count() != 0) {
    _this->_internal_set_face_direction_count(from._internal_face_direction_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = from._internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    _this->_internal_set_point_to_direction(from._internal_point_to_direction());
  }
  if (from._internal_point_to_direction_count() != 0) {
    _this->_internal_set_point_to_direction_count(from._internal_point_to_direction_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = from._internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    _this->_internal_set_dist_from_ball(from._internal_dist_from_ball());
  }
  if (from._internal_is_goalie() != 0) {
    _this->_internal_set_is_goalie(from._internal_is_goalie());
  }
  if (from._internal_is_kicking() != 0) {
    _this->_internal_set_is_kicking(from._internal_is_kicking());
  }
  if (from._internal_is_tackling() != 0) {
    _this->_internal_set_is_tackling(from._internal_is_tackling());
  }
  if (from._internal_is_kickable() != 0) {
    _this->_internal_set_is_kickable(from._internal_is_kickable());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = from._internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    _this->_internal_set_angle_from_ball(from._internal_angle_from_ball());
  }
  if (from._internal_ball_reach_steps() != 0) {
    _this->_internal_set_ball_reach_steps(from._internal_ball_reach_steps());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_neck_direction = from._internal_relative_neck_direction();
  ::uint32_t raw_relative_neck_direction;
  memcpy(&raw_relative_neck_direction, &tmp_relative_neck_direction, sizeof(tmp_relative_neck_direction));
  if (raw_relative_neck_direction != 0) {
    _this->_internal_set_relative_neck_direction(from._internal_relative_neck_direction());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina = from._internal_stamina();
  ::uint32_t raw_stamina;
  memcpy(&raw_stamina, &tmp_stamina, sizeof(tmp_stamina));
  if (raw_stamina != 0) {
    _this->_internal_set_stamina(from._internal_stamina());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_probability = from._internal_catch_probability();
  ::uint32_t raw_catch_probability;
  memcpy(&raw_catch_probability, &tmp_catch_probability, sizeof(tmp_catch_probability));
  if (raw_catch_probability != 0) {
    _this->_internal_set_catch_probability(from._internal_catch_probability());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_probability = from._internal_tackle_probability();
  ::uint32_t raw_tackle_probability;
  memcpy(&raw_tackle_probability, &tmp_tackle_probability, sizeof(tmp_tackle_probability));
  if (raw_tackle_probability != 0) {
    _this->_internal_set_tackle_probability(from._internal_tackle_probability());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_probability = from._internal_foul_probability();
  ::uint32_t raw_foul_probability;
  memcpy(&raw_foul_probability, &tmp_foul_probability, sizeof(tmp_foul_probability));
  if (raw_foul_probability != 0) {
    _this->_internal_set_foul_probability(from._internal_foul_probability());
  }
  if (from._internal_view_width() != 0) {
    _this->_internal_set_view_width(from._internal_view_width());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Self::CopyFrom(const Self& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Self)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Self::IsInitialized() const {
  return true;
}

void Self::InternalSwap(Self* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Self, _impl_.view_width_)
      + sizeof(Self::_impl_.view_width_)
      - PROTOBUF_FIELD_OFFSET(Self, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Self::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[3]);
}
// ===================================================================

class InterceptInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<InterceptInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(InterceptInfo, _impl_._has_bits_);
  static const ::protos::Vector2D& final_self_position(const InterceptInfo* msg);
  static void set_has_final_self_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
InterceptInfo::_Internal::final_self_position(const InterceptInfo* msg) {
  return *msg->_impl_.final_self_position_;
}
InterceptInfo::InterceptInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.InterceptInfo)
}
InterceptInfo::InterceptInfo(const InterceptInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InterceptInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.final_self_position_){nullptr}
    , decltype(_impl_.action_type_) {}

    , decltype(_impl_.turn_steps_) {}

    , decltype(_impl_.turn_angle_) {}

    , decltype(_impl_.dash_steps_) {}

    , decltype(_impl_.dash_power_) {}

    , decltype(_impl_.dash_dir_) {}

    , decltype(_impl_.final_ball_dist_) {}

    , decltype(_impl_.final_stamina_) {}

    , decltype(_impl_.value_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.final_self_position_ = new ::protos::Vector2D(*from._impl_.final_self_position_);
  }
  ::memcpy(&_impl_.action_type_, &from._impl_.action_type_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.value_) -
    reinterpret_cast<char*>(&_impl_.action_type_)) + sizeof(_impl_.value_));
  // @@protoc_insertion_point(copy_constructor:protos.InterceptInfo)
}

inline void InterceptInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.final_self_position_){nullptr}
    , decltype(_impl_.action_type_) { 0 }

    , decltype(_impl_.turn_steps_) { 0 }

    , decltype(_impl_.turn_angle_) { 0 }

    , decltype(_impl_.dash_steps_) { 0 }

    , decltype(_impl_.dash_power_) { 0 }

    , decltype(_impl_.dash_dir_) { 0 }

    , decltype(_impl_.final_ball_dist_) { 0 }

    , decltype(_impl_.final_stamina_) { 0 }

    , decltype(_impl_.value_) { 0 }

  };
}

InterceptInfo::~InterceptInfo() {
  // @@protoc_insertion_point(destructor:protos.InterceptInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InterceptInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.final_self_position_;
}

void InterceptInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InterceptInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.InterceptInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.final_self_position_ != nullptr);
    _impl_.final_self_position_->Clear();
  }
  ::memset(&_impl_.action_type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.value_) -
      reinterpret_cast<char*>(&_impl_.action_type_)) + sizeof(_impl_.value_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InterceptInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.InterceptActionType action_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_action_type(static_cast<::protos::InterceptActionType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 turn_steps = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.turn_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float turn_angle = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.turn_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 dash_steps = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.dash_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dash_power = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.dash_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dash_dir = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 53)) {
          _impl_.dash_dir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D final_self_position = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_final_self_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float final_ball_dist = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 69)) {
          _impl_.final_ball_dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float final_stamina = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 77)) {
          _impl_.final_stamina_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float value = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 85)) {
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* InterceptInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.InterceptInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.InterceptActionType action_type = 1;
  if (this->_internal_action_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_action_type(), target);
  }

  // int32 turn_steps = 2;
  if (this->_internal_turn_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_turn_steps(), target);
  }

  // float turn_angle = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_turn_angle = this->_internal_turn_angle();
  ::uint32_t raw_turn_angle;
  memcpy(&raw_turn_angle, &tmp_turn_angle, sizeof(tmp_turn_angle));
  if (raw_turn_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_turn_angle(), target);
  }

  // int32 dash_steps = 4;
  if (this->_internal_dash_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_dash_steps(), target);
  }

  // float dash_power = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power = this->_internal_dash_power();
  ::uint32_t raw_dash_power;
  memcpy(&raw_dash_power, &tmp_dash_power, sizeof(tmp_dash_power));
  if (raw_dash_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_dash_power(), target);
  }

  // float dash_dir = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_dir = this->_internal_dash_dir();
  ::uint32_t raw_dash_dir;
  memcpy(&raw_dash_dir, &tmp_dash_dir, sizeof(tmp_dash_dir));
  if (raw_dash_dir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_dash_dir(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D final_self_position = 7;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::final_self_position(this),
        _Internal::final_self_position(this).GetCachedSize(), target, stream);
  }

  // float final_ball_dist = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_ball_dist = this->_internal_final_ball_dist();
  ::uint32_t raw_final_ball_dist;
  memcpy(&raw_final_ball_dist, &tmp_final_ball_dist, sizeof(tmp_final_ball_dist));
  if (raw_final_ball_dist != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_final_ball_dist(), target);
  }

  // float final_stamina = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_stamina = this->_internal_final_stamina();
  ::uint32_t raw_final_stamina;
  memcpy(&raw_final_stamina, &tmp_final_stamina, sizeof(tmp_final_stamina));
  if (raw_final_stamina != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_final_stamina(), target);
  }

  // float value = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  ::uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.InterceptInfo)
  return target;
}

::size_t InterceptInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.InterceptInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D final_self_position = 7;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.final_self_position_);
  }

  // .protos.InterceptActionType action_type = 1;
  if (this->_internal_action_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_action_type());
  }

  // int32 turn_steps = 2;
  if (this->_internal_turn_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_turn_steps());
  }

  // float turn_angle = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_turn_angle = this->_internal_turn_angle();
  ::uint32_t raw_turn_angle;
  memcpy(&raw_turn_angle, &tmp_turn_angle, sizeof(tmp_turn_angle));
  if (raw_turn_angle != 0) {
    total_size += 5;
  }

  // int32 dash_steps = 4;
  if (this->_internal_dash_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_dash_steps());
  }

  // float dash_power = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power = this->_internal_dash_power();
  ::uint32_t raw_dash_power;
  memcpy(&raw_dash_power, &tmp_dash_power, sizeof(tmp_dash_power));
  if (raw_dash_power != 0) {
    total_size += 5;
  }

  // float dash_dir = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_dir = this->_internal_dash_dir();
  ::uint32_t raw_dash_dir;
  memcpy(&raw_dash_dir, &tmp_dash_dir, sizeof(tmp_dash_dir));
  if (raw_dash_dir != 0) {
    total_size += 5;
  }

  // float final_ball_dist = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_ball_dist = this->_internal_final_ball_dist();
  ::uint32_t raw_final_ball_dist;
  memcpy(&raw_final_ball_dist, &tmp_final_ball_dist, sizeof(tmp_final_ball_dist));
  if (raw_final_ball_dist != 0) {
    total_size += 5;
  }

  // float final_stamina = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_stamina = this->_internal_final_stamina();
  ::uint32_t raw_final_stamina;
  memcpy(&raw_final_stamina, &tmp_final_stamina, sizeof(tmp_final_stamina));
  if (raw_final_stamina != 0) {
    total_size += 5;
  }

  // float value = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  ::uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InterceptInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InterceptInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InterceptInfo::GetClassData() const { return &_class_data_; }


void InterceptInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InterceptInfo*>(&to_msg);
  auto& from = static_cast<const InterceptInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.InterceptInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_final_self_position()->::protos::Vector2D::MergeFrom(
        from._internal_final_self_position());
  }
  if (from._internal_action_type() != 0) {
    _this->_internal_set_action_type(from._internal_action_type());
  }
  if (from._internal_turn_steps() != 0) {
    _this->_internal_set_turn_steps(from._internal_turn_steps());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_turn_angle = from._internal_turn_angle();
  ::uint32_t raw_turn_angle;
  memcpy(&raw_turn_angle, &tmp_turn_angle, sizeof(tmp_turn_angle));
  if (raw_turn_angle != 0) {
    _this->_internal_set_turn_angle(from._internal_turn_angle());
  }
  if (from._internal_dash_steps() != 0) {
    _this->_internal_set_dash_steps(from._internal_dash_steps());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power = from._internal_dash_power();
  ::uint32_t raw_dash_power;
  memcpy(&raw_dash_power, &tmp_dash_power, sizeof(tmp_dash_power));
  if (raw_dash_power != 0) {
    _this->_internal_set_dash_power(from._internal_dash_power());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_dir = from._internal_dash_dir();
  ::uint32_t raw_dash_dir;
  memcpy(&raw_dash_dir, &tmp_dash_dir, sizeof(tmp_dash_dir));
  if (raw_dash_dir != 0) {
    _this->_internal_set_dash_dir(from._internal_dash_dir());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_ball_dist = from._internal_final_ball_dist();
  ::uint32_t raw_final_ball_dist;
  memcpy(&raw_final_ball_dist, &tmp_final_ball_dist, sizeof(tmp_final_ball_dist));
  if (raw_final_ball_dist != 0) {
    _this->_internal_set_final_ball_dist(from._internal_final_ball_dist());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_stamina = from._internal_final_stamina();
  ::uint32_t raw_final_stamina;
  memcpy(&raw_final_stamina, &tmp_final_stamina, sizeof(tmp_final_stamina));
  if (raw_final_stamina != 0) {
    _this->_internal_set_final_stamina(from._internal_final_stamina());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_value = from._internal_value();
  ::uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InterceptInfo::CopyFrom(const InterceptInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.InterceptInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InterceptInfo::IsInitialized() const {
  return true;
}

void InterceptInfo::InternalSwap(InterceptInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InterceptInfo, _impl_.value_)
      + sizeof(InterceptInfo::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(InterceptInfo, _impl_.final_self_position_)>(
          reinterpret_cast<char*>(&_impl_.final_self_position_),
          reinterpret_cast<char*>(&other->_impl_.final_self_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InterceptInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[4]);
}
// ===================================================================

class InterceptTable::_Internal {
 public:
};

InterceptTable::InterceptTable(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.InterceptTable)
}
InterceptTable::InterceptTable(const InterceptTable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InterceptTable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.self_intercept_info_){from._impl_.self_intercept_info_}
    , decltype(_impl_.self_reach_steps_) {}

    , decltype(_impl_.first_teammate_reach_steps_) {}

    , decltype(_impl_.second_teammate_reach_steps_) {}

    , decltype(_impl_.first_opponent_reach_steps_) {}

    , decltype(_impl_.second_opponent_reach_steps_) {}

    , decltype(_impl_.first_teammate_id_) {}

    , decltype(_impl_.second_teammate_id_) {}

    , decltype(_impl_.first_opponent_id_) {}

    , decltype(_impl_.second_opponent_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.self_reach_steps_, &from._impl_.self_reach_steps_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.second_opponent_id_) -
    reinterpret_cast<char*>(&_impl_.self_reach_steps_)) + sizeof(_impl_.second_opponent_id_));
  // @@protoc_insertion_point(copy_constructor:protos.InterceptTable)
}

inline void InterceptTable::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.self_intercept_info_){arena}
    , decltype(_impl_.self_reach_steps_) { 0 }

    , decltype(_impl_.first_teammate_reach_steps_) { 0 }

    , decltype(_impl_.second_teammate_reach_steps_) { 0 }

    , decltype(_impl_.first_opponent_reach_steps_) { 0 }

    , decltype(_impl_.second_opponent_reach_steps_) { 0 }

    , decltype(_impl_.first_teammate_id_) { 0 }

    , decltype(_impl_.second_teammate_id_) { 0 }

    , decltype(_impl_.first_opponent_id_) { 0 }

    , decltype(_impl_.second_opponent_id_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

InterceptTable::~InterceptTable() {
  // @@protoc_insertion_point(destructor:protos.InterceptTable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InterceptTable::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_self_intercept_info()->~RepeatedPtrField();
}

void InterceptTable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InterceptTable::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.InterceptTable)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_self_intercept_info()->Clear();
  ::memset(&_impl_.self_reach_steps_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.second_opponent_id_) -
      reinterpret_cast<char*>(&_impl_.self_reach_steps_)) + sizeof(_impl_.second_opponent_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InterceptTable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 self_reach_steps = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.self_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 first_teammate_reach_steps = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.first_teammate_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 second_teammate_reach_steps = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.second_teammate_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 first_opponent_reach_steps = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.first_opponent_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 second_opponent_reach_steps = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.second_opponent_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 first_teammate_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.first_teammate_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 second_teammate_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.second_teammate_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 first_opponent_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.first_opponent_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 second_opponent_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.second_opponent_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .protos.InterceptInfo self_intercept_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_self_intercept_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* InterceptTable::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.InterceptTable)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 self_reach_steps = 1;
  if (this->_internal_self_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_self_reach_steps(), target);
  }

  // int32 first_teammate_reach_steps = 2;
  if (this->_internal_first_teammate_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_first_teammate_reach_steps(), target);
  }

  // int32 second_teammate_reach_steps = 3;
  if (this->_internal_second_teammate_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_second_teammate_reach_steps(), target);
  }

  // int32 first_opponent_reach_steps = 4;
  if (this->_internal_first_opponent_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_first_opponent_reach_steps(), target);
  }

  // int32 second_opponent_reach_steps = 5;
  if (this->_internal_second_opponent_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_second_opponent_reach_steps(), target);
  }

  // int32 first_teammate_id = 6;
  if (this->_internal_first_teammate_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_first_teammate_id(), target);
  }

  // int32 second_teammate_id = 7;
  if (this->_internal_second_teammate_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_second_teammate_id(), target);
  }

  // int32 first_opponent_id = 8;
  if (this->_internal_first_opponent_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_first_opponent_id(), target);
  }

  // int32 second_opponent_id = 9;
  if (this->_internal_second_opponent_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        9, this->_internal_second_opponent_id(), target);
  }

  // repeated .protos.InterceptInfo self_intercept_info = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_self_intercept_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_self_intercept_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.InterceptTable)
  return target;
}

::size_t InterceptTable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.InterceptTable)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protos.InterceptInfo self_intercept_info = 10;
  total_size += 1UL * this->_internal_self_intercept_info_size();
  for (const auto& msg : this->_internal_self_intercept_info()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int32 self_reach_steps = 1;
  if (this->_internal_self_reach_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_self_reach_steps());
  }

  // int32 first_teammate_reach_steps = 2;
  if (this->_internal_first_teammate_reach_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_first_teammate_reach_steps());
  }

  // int32 second_teammate_reach_steps = 3;
  if (this->_internal_second_teammate_reach_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_second_teammate_reach_steps());
  }

  // int32 first_opponent_reach_steps = 4;
  if (this->_internal_first_opponent_reach_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_first_opponent_reach_steps());
  }

  // int32 second_opponent_reach_steps = 5;
  if (this->_internal_second_opponent_reach_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_second_opponent_reach_steps());
  }

  // int32 first_teammate_id = 6;
  if (this->_internal_first_teammate_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_first_teammate_id());
  }

  // int32 second_teammate_id = 7;
  if (this->_internal_second_teammate_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_second_teammate_id());
  }

  // int32 first_opponent_id = 8;
  if (this->_internal_first_opponent_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_first_opponent_id());
  }

  // int32 second_opponent_id = 9;
  if (this->_internal_second_opponent_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_second_opponent_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InterceptTable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InterceptTable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InterceptTable::GetClassData() const { return &_class_data_; }


void InterceptTable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InterceptTable*>(&to_msg);
  auto& from = static_cast<const InterceptTable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.InterceptTable)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_self_intercept_info()->MergeFrom(from._internal_self_intercept_info());
  if (from._internal_self_reach_steps() != 0) {
    _this->_internal_set_self_reach_steps(from._internal_self_reach_steps());
  }
  if (from._internal_first_teammate_reach_steps() != 0) {
    _this->_internal_set_first_teammate_reach_steps(from._internal_first_teammate_reach_steps());
  }
  if (from._internal_second_teammate_reach_steps() != 0) {
    _this->_internal_set_second_teammate_reach_steps(from._internal_second_teammate_reach_steps());
  }
  if (from._internal_first_opponent_reach_steps() != 0) {
    _this->_internal_set_first_opponent_reach_steps(from._internal_first_opponent_reach_steps());
  }
  if (from._internal_second_opponent_reach_steps() != 0) {
    _this->_internal_set_second_opponent_reach_steps(from._internal_second_opponent_reach_steps());
  }
  if (from._internal_first_teammate_id() != 0) {
    _this->_internal_set_first_teammate_id(from._internal_first_teammate_id());
  }
  if (from._internal_second_teammate_id() != 0) {
    _this->_internal_set_second_teammate_id(from._internal_second_teammate_id());
  }
  if (from._internal_first_opponent_id() != 0) {
    _this->_internal_set_first_opponent_id(from._internal_first_opponent_id());
  }
  if (from._internal_second_opponent_id() != 0) {
    _this->_internal_set_second_opponent_id(from._internal_second_opponent_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InterceptTable::CopyFrom(const InterceptTable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.InterceptTable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InterceptTable::IsInitialized() const {
  return true;
}

void InterceptTable::InternalSwap(InterceptTable* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_self_intercept_info()->InternalSwap(other->_internal_mutable_self_intercept_info());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InterceptTable, _impl_.second_opponent_id_)
      + sizeof(InterceptTable::_impl_.second_opponent_id_)
      - PROTOBUF_FIELD_OFFSET(InterceptTable, _impl_.self_reach_steps_)>(
          reinterpret_cast<char*>(&_impl_.self_reach_steps_),
          reinterpret_cast<char*>(&other->_impl_.self_reach_steps_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InterceptTable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[5]);
}
// ===================================================================

WorldModel_OurPlayersDictEntry_DoNotUse::WorldModel_OurPlayersDictEntry_DoNotUse() {}
WorldModel_OurPlayersDictEntry_DoNotUse::WorldModel_OurPlayersDictEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void WorldModel_OurPlayersDictEntry_DoNotUse::MergeFrom(const WorldModel_OurPlayersDictEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata WorldModel_OurPlayersDictEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[6]);
}
// ===================================================================

WorldModel_TheirPlayersDictEntry_DoNotUse::WorldModel_TheirPlayersDictEntry_DoNotUse() {}
WorldModel_TheirPlayersDictEntry_DoNotUse::WorldModel_TheirPlayersDictEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void WorldModel_TheirPlayersDictEntry_DoNotUse::MergeFrom(const WorldModel_TheirPlayersDictEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata WorldModel_TheirPlayersDictEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[7]);
}
// ===================================================================

class WorldModel::_Internal {
 public:
  using HasBits = decltype(std::declval<WorldModel>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(WorldModel, _impl_._has_bits_);
  static const ::protos::InterceptTable& intercept_table(const WorldModel* msg);
  static void set_has_intercept_table(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Self& self(const WorldModel* msg);
  static void set_has_self(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Ball& ball(const WorldModel* msg);
  static void set_has_ball(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::protos::InterceptTable&
WorldModel::_Internal::intercept_table(const WorldModel* msg) {
  return *msg->_impl_.intercept_table_;
}
const ::protos::Self&
WorldModel::_Internal::self(const WorldModel* msg) {
  return *msg->_impl_.self_;
}
const ::protos::Ball&
WorldModel::_Internal::ball(const WorldModel* msg) {
  return *msg->_impl_.ball_;
}
WorldModel::WorldModel(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.WorldModel)
}
WorldModel::WorldModel(const WorldModel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WorldModel* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.teammates_){from._impl_.teammates_}
    , decltype(_impl_.opponents_){from._impl_.opponents_}
    , decltype(_impl_.unknowns_){from._impl_.unknowns_}
    , /*decltype(_impl_.our_players_dict_)*/{}
    , /*decltype(_impl_.their_players_dict_)*/{}
    , decltype(_impl_.our_team_name_) {}

    , decltype(_impl_.their_team_name_) {}

    , decltype(_impl_.intercept_table_){nullptr}
    , decltype(_impl_.self_){nullptr}
    , decltype(_impl_.ball_){nullptr}
    , decltype(_impl_.our_side_) {}

    , decltype(_impl_.last_set_play_start_time_) {}

    , decltype(_impl_.our_goalie_uniform_number_) {}

    , decltype(_impl_.their_goalie_uniform_number_) {}

    , decltype(_impl_.offside_line_x_) {}

    , decltype(_impl_.ofside_line_x_count_) {}

    , decltype(_impl_.kickable_teammate_id_) {}

    , decltype(_impl_.kickable_opponent_id_) {}

    , decltype(_impl_.last_kick_side_) {}

    , decltype(_impl_.last_kicker_uniform_number_) {}

    , decltype(_impl_.cycle_) {}

    , decltype(_impl_.game_mode_type_) {}

    , decltype(_impl_.left_team_score_) {}

    , decltype(_impl_.right_team_score_) {}

    , decltype(_impl_.is_our_set_play_) {}

    , decltype(_impl_.is_their_set_play_) {}

    , decltype(_impl_.stoped_cycle_) {}

    , decltype(_impl_.our_team_score_) {}

    , decltype(_impl_.their_team_score_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.our_players_dict_.MergeFrom(from._impl_.our_players_dict_);
  _this->_impl_.their_players_dict_.MergeFrom(from._impl_.their_players_dict_);
  _impl_.our_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.our_team_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_our_team_name().empty()) {
    _this->_impl_.our_team_name_.Set(from._internal_our_team_name(), _this->GetArenaForAllocation());
  }
  _impl_.their_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.their_team_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_their_team_name().empty()) {
    _this->_impl_.their_team_name_.Set(from._internal_their_team_name(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.intercept_table_ = new ::protos::InterceptTable(*from._impl_.intercept_table_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.self_ = new ::protos::Self(*from._impl_.self_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.ball_ = new ::protos::Ball(*from._impl_.ball_);
  }
  ::memcpy(&_impl_.our_side_, &from._impl_.our_side_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.their_team_score_) -
    reinterpret_cast<char*>(&_impl_.our_side_)) + sizeof(_impl_.their_team_score_));
  // @@protoc_insertion_point(copy_constructor:protos.WorldModel)
}

inline void WorldModel::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.teammates_){arena}
    , decltype(_impl_.opponents_){arena}
    , decltype(_impl_.unknowns_){arena}
    , /*decltype(_impl_.our_players_dict_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.their_players_dict_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.our_team_name_) {}

    , decltype(_impl_.their_team_name_) {}

    , decltype(_impl_.intercept_table_){nullptr}
    , decltype(_impl_.self_){nullptr}
    , decltype(_impl_.ball_){nullptr}
    , decltype(_impl_.our_side_) { 0 }

    , decltype(_impl_.last_set_play_start_time_) { 0 }

    , decltype(_impl_.our_goalie_uniform_number_) { 0 }

    , decltype(_impl_.their_goalie_uniform_number_) { 0 }

    , decltype(_impl_.offside_line_x_) { 0 }

    , decltype(_impl_.ofside_line_x_count_) { 0 }

    , decltype(_impl_.kickable_teammate_id_) { 0 }

    , decltype(_impl_.kickable_opponent_id_) { 0 }

    , decltype(_impl_.last_kick_side_) { 0 }

    , decltype(_impl_.last_kicker_uniform_number_) { 0 }

    , decltype(_impl_.cycle_) { 0 }

    , decltype(_impl_.game_mode_type_) { 0 }

    , decltype(_impl_.left_team_score_) { 0 }

    , decltype(_impl_.right_team_score_) { 0 }

    , decltype(_impl_.is_our_set_play_) { false }

    , decltype(_impl_.is_their_set_play_) { false }

    , decltype(_impl_.stoped_cycle_) { 0 }

    , decltype(_impl_.our_team_score_) { 0 }

    , decltype(_impl_.their_team_score_) { 0 }

  };
  _impl_.our_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.our_team_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.their_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.their_team_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WorldModel::~WorldModel() {
  // @@protoc_insertion_point(destructor:protos.WorldModel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WorldModel::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_teammates()->~RepeatedPtrField();
  _internal_mutable_opponents()->~RepeatedPtrField();
  _internal_mutable_unknowns()->~RepeatedPtrField();
  _impl_.our_players_dict_.~MapField();
  _impl_.their_players_dict_.~MapField();
  _impl_.our_team_name_.Destroy();
  _impl_.their_team_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.intercept_table_;
  if (this != internal_default_instance()) delete _impl_.self_;
  if (this != internal_default_instance()) delete _impl_.ball_;
}

void WorldModel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WorldModel::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.WorldModel)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_teammates()->Clear();
  _internal_mutable_opponents()->Clear();
  _internal_mutable_unknowns()->Clear();
  _impl_.our_players_dict_.Clear();
  _impl_.their_players_dict_.Clear();
  _impl_.our_team_name_.ClearToEmpty();
  _impl_.their_team_name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.intercept_table_ != nullptr);
      _impl_.intercept_table_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.self_ != nullptr);
      _impl_.self_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.ball_ != nullptr);
      _impl_.ball_->Clear();
    }
  }
  ::memset(&_impl_.our_side_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.their_team_score_) -
      reinterpret_cast<char*>(&_impl_.our_side_)) + sizeof(_impl_.their_team_score_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WorldModel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.InterceptTable intercept_table = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_intercept_table(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string our_team_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_our_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.WorldModel.our_team_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string their_team_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_their_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.WorldModel.their_team_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Side our_side = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_our_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 last_set_play_start_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.last_set_play_start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Self self = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_self(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Ball ball = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .protos.Player teammates = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_teammates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .protos.Player opponents = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_opponents(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .protos.Player unknowns = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_unknowns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // map<int32, .protos.Player> our_players_dict = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.our_players_dict_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // map<int32, .protos.Player> their_players_dict = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.their_players_dict_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 our_goalie_uniform_number = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _impl_.our_goalie_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 their_goalie_uniform_number = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.their_goalie_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float offside_line_x = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 125)) {
          _impl_.offside_line_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ofside_line_x_count = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _impl_.ofside_line_x_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 kickable_teammate_id = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 136)) {
          _impl_.kickable_teammate_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 kickable_opponent_id = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
          _impl_.kickable_opponent_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Side last_kick_side = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 152)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_last_kick_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 last_kicker_uniform_number = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _impl_.last_kicker_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 cycle = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 168)) {
          _impl_.cycle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.GameModeType game_mode_type = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 176)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_game_mode_type(static_cast<::protos::GameModeType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 left_team_score = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 184)) {
          _impl_.left_team_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 right_team_score = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 192)) {
          _impl_.right_team_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_our_set_play = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 200)) {
          _impl_.is_our_set_play_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_their_set_play = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 208)) {
          _impl_.is_their_set_play_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 stoped_cycle = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 216)) {
          _impl_.stoped_cycle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 our_team_score = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 224)) {
          _impl_.our_team_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 their_team_score = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 232)) {
          _impl_.their_team_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* WorldModel::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.WorldModel)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.InterceptTable intercept_table = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::intercept_table(this),
        _Internal::intercept_table(this).GetCachedSize(), target, stream);
  }

  // string our_team_name = 2;
  if (!this->_internal_our_team_name().empty()) {
    const std::string& _s = this->_internal_our_team_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.WorldModel.our_team_name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string their_team_name = 3;
  if (!this->_internal_their_team_name().empty()) {
    const std::string& _s = this->_internal_their_team_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.WorldModel.their_team_name");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // .protos.Side our_side = 4;
  if (this->_internal_our_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_our_side(), target);
  }

  // int32 last_set_play_start_time = 5;
  if (this->_internal_last_set_play_start_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_last_set_play_start_time(), target);
  }

  // .protos.Self self = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::self(this),
        _Internal::self(this).GetCachedSize(), target, stream);
  }

  // .protos.Ball ball = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::ball(this),
        _Internal::ball(this).GetCachedSize(), target, stream);
  }

  // repeated .protos.Player teammates = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_teammates_size()); i < n; i++) {
    const auto& repfield = this->_internal_teammates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .protos.Player opponents = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_opponents_size()); i < n; i++) {
    const auto& repfield = this->_internal_opponents(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .protos.Player unknowns = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_unknowns_size()); i < n; i++) {
    const auto& repfield = this->_internal_unknowns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // map<int32, .protos.Player> our_players_dict = 11;
  if (!this->_internal_our_players_dict().empty()) {
    using MapType = ::_pb::Map<::int32_t, ::protos::Player>;
    using WireHelper = WorldModel_OurPlayersDictEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_our_players_dict();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(11, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(11, entry.first, entry.second, target, stream);
      }
    }
  }

  // map<int32, .protos.Player> their_players_dict = 12;
  if (!this->_internal_their_players_dict().empty()) {
    using MapType = ::_pb::Map<::int32_t, ::protos::Player>;
    using WireHelper = WorldModel_TheirPlayersDictEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_their_players_dict();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(12, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(12, entry.first, entry.second, target, stream);
      }
    }
  }

  // int32 our_goalie_uniform_number = 13;
  if (this->_internal_our_goalie_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        13, this->_internal_our_goalie_uniform_number(), target);
  }

  // int32 their_goalie_uniform_number = 14;
  if (this->_internal_their_goalie_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        14, this->_internal_their_goalie_uniform_number(), target);
  }

  // float offside_line_x = 15;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_line_x = this->_internal_offside_line_x();
  ::uint32_t raw_offside_line_x;
  memcpy(&raw_offside_line_x, &tmp_offside_line_x, sizeof(tmp_offside_line_x));
  if (raw_offside_line_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        15, this->_internal_offside_line_x(), target);
  }

  // int32 ofside_line_x_count = 16;
  if (this->_internal_ofside_line_x_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        16, this->_internal_ofside_line_x_count(), target);
  }

  // int32 kickable_teammate_id = 17;
  if (this->_internal_kickable_teammate_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        17, this->_internal_kickable_teammate_id(), target);
  }

  // int32 kickable_opponent_id = 18;
  if (this->_internal_kickable_opponent_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        18, this->_internal_kickable_opponent_id(), target);
  }

  // .protos.Side last_kick_side = 19;
  if (this->_internal_last_kick_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        19, this->_internal_last_kick_side(), target);
  }

  // int32 last_kicker_uniform_number = 20;
  if (this->_internal_last_kicker_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        20, this->_internal_last_kicker_uniform_number(), target);
  }

  // int32 cycle = 21;
  if (this->_internal_cycle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        21, this->_internal_cycle(), target);
  }

  // .protos.GameModeType game_mode_type = 22;
  if (this->_internal_game_mode_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        22, this->_internal_game_mode_type(), target);
  }

  // int32 left_team_score = 23;
  if (this->_internal_left_team_score() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        23, this->_internal_left_team_score(), target);
  }

  // int32 right_team_score = 24;
  if (this->_internal_right_team_score() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        24, this->_internal_right_team_score(), target);
  }

  // bool is_our_set_play = 25;
  if (this->_internal_is_our_set_play() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        25, this->_internal_is_our_set_play(), target);
  }

  // bool is_their_set_play = 26;
  if (this->_internal_is_their_set_play() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        26, this->_internal_is_their_set_play(), target);
  }

  // int32 stoped_cycle = 27;
  if (this->_internal_stoped_cycle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        27, this->_internal_stoped_cycle(), target);
  }

  // int32 our_team_score = 28;
  if (this->_internal_our_team_score() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        28, this->_internal_our_team_score(), target);
  }

  // int32 their_team_score = 29;
  if (this->_internal_their_team_score() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        29, this->_internal_their_team_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.WorldModel)
  return target;
}

::size_t WorldModel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.WorldModel)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protos.Player teammates = 8;
  total_size += 1UL * this->_internal_teammates_size();
  for (const auto& msg : this->_internal_teammates()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .protos.Player opponents = 9;
  total_size += 1UL * this->_internal_opponents_size();
  for (const auto& msg : this->_internal_opponents()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .protos.Player unknowns = 10;
  total_size += 1UL * this->_internal_unknowns_size();
  for (const auto& msg : this->_internal_unknowns()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<int32, .protos.Player> our_players_dict = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_our_players_dict_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >::const_iterator
      it = this->_internal_our_players_dict().begin();
      it != this->_internal_our_players_dict().end(); ++it) {
    total_size += WorldModel_OurPlayersDictEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<int32, .protos.Player> their_players_dict = 12;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_their_players_dict_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >::const_iterator
      it = this->_internal_their_players_dict().begin();
      it != this->_internal_their_players_dict().end(); ++it) {
    total_size += WorldModel_TheirPlayersDictEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string our_team_name = 2;
  if (!this->_internal_our_team_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_our_team_name());
  }

  // string their_team_name = 3;
  if (!this->_internal_their_team_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_their_team_name());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .protos.InterceptTable intercept_table = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.intercept_table_);
    }

    // .protos.Self self = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.self_);
    }

    // .protos.Ball ball = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_);
    }

  }
  // .protos.Side our_side = 4;
  if (this->_internal_our_side() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_our_side());
  }

  // int32 last_set_play_start_time = 5;
  if (this->_internal_last_set_play_start_time() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_last_set_play_start_time());
  }

  // int32 our_goalie_uniform_number = 13;
  if (this->_internal_our_goalie_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_our_goalie_uniform_number());
  }

  // int32 their_goalie_uniform_number = 14;
  if (this->_internal_their_goalie_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_their_goalie_uniform_number());
  }

  // float offside_line_x = 15;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_line_x = this->_internal_offside_line_x();
  ::uint32_t raw_offside_line_x;
  memcpy(&raw_offside_line_x, &tmp_offside_line_x, sizeof(tmp_offside_line_x));
  if (raw_offside_line_x != 0) {
    total_size += 5;
  }

  // int32 ofside_line_x_count = 16;
  if (this->_internal_ofside_line_x_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_ofside_line_x_count());
  }

  // int32 kickable_teammate_id = 17;
  if (this->_internal_kickable_teammate_id() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_kickable_teammate_id());
  }

  // int32 kickable_opponent_id = 18;
  if (this->_internal_kickable_opponent_id() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_kickable_opponent_id());
  }

  // .protos.Side last_kick_side = 19;
  if (this->_internal_last_kick_side() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_last_kick_side());
  }

  // int32 last_kicker_uniform_number = 20;
  if (this->_internal_last_kicker_uniform_number() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_last_kicker_uniform_number());
  }

  // int32 cycle = 21;
  if (this->_internal_cycle() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_cycle());
  }

  // .protos.GameModeType game_mode_type = 22;
  if (this->_internal_game_mode_type() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_game_mode_type());
  }

  // int32 left_team_score = 23;
  if (this->_internal_left_team_score() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_left_team_score());
  }

  // int32 right_team_score = 24;
  if (this->_internal_right_team_score() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_right_team_score());
  }

  // bool is_our_set_play = 25;
  if (this->_internal_is_our_set_play() != 0) {
    total_size += 3;
  }

  // bool is_their_set_play = 26;
  if (this->_internal_is_their_set_play() != 0) {
    total_size += 3;
  }

  // int32 stoped_cycle = 27;
  if (this->_internal_stoped_cycle() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_stoped_cycle());
  }

  // int32 our_team_score = 28;
  if (this->_internal_our_team_score() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_our_team_score());
  }

  // int32 their_team_score = 29;
  if (this->_internal_their_team_score() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_their_team_score());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WorldModel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WorldModel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WorldModel::GetClassData() const { return &_class_data_; }


void WorldModel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WorldModel*>(&to_msg);
  auto& from = static_cast<const WorldModel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.WorldModel)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_teammates()->MergeFrom(from._internal_teammates());
  _this->_internal_mutable_opponents()->MergeFrom(from._internal_opponents());
  _this->_internal_mutable_unknowns()->MergeFrom(from._internal_unknowns());
  _this->_impl_.our_players_dict_.MergeFrom(from._impl_.our_players_dict_);
  _this->_impl_.their_players_dict_.MergeFrom(from._impl_.their_players_dict_);
  if (!from._internal_our_team_name().empty()) {
    _this->_internal_set_our_team_name(from._internal_our_team_name());
  }
  if (!from._internal_their_team_name().empty()) {
    _this->_internal_set_their_team_name(from._internal_their_team_name());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_intercept_table()->::protos::InterceptTable::MergeFrom(
          from._internal_intercept_table());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_self()->::protos::Self::MergeFrom(
          from._internal_self());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_ball()->::protos::Ball::MergeFrom(
          from._internal_ball());
    }
  }
  if (from._internal_our_side() != 0) {
    _this->_internal_set_our_side(from._internal_our_side());
  }
  if (from._internal_last_set_play_start_time() != 0) {
    _this->_internal_set_last_set_play_start_time(from._internal_last_set_play_start_time());
  }
  if (from._internal_our_goalie_uniform_number() != 0) {
    _this->_internal_set_our_goalie_uniform_number(from._internal_our_goalie_uniform_number());
  }
  if (from._internal_their_goalie_uniform_number() != 0) {
    _this->_internal_set_their_goalie_uniform_number(from._internal_their_goalie_uniform_number());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_line_x = from._internal_offside_line_x();
  ::uint32_t raw_offside_line_x;
  memcpy(&raw_offside_line_x, &tmp_offside_line_x, sizeof(tmp_offside_line_x));
  if (raw_offside_line_x != 0) {
    _this->_internal_set_offside_line_x(from._internal_offside_line_x());
  }
  if (from._internal_ofside_line_x_count() != 0) {
    _this->_internal_set_ofside_line_x_count(from._internal_ofside_line_x_count());
  }
  if (from._internal_kickable_teammate_id() != 0) {
    _this->_internal_set_kickable_teammate_id(from._internal_kickable_teammate_id());
  }
  if (from._internal_kickable_opponent_id() != 0) {
    _this->_internal_set_kickable_opponent_id(from._internal_kickable_opponent_id());
  }
  if (from._internal_last_kick_side() != 0) {
    _this->_internal_set_last_kick_side(from._internal_last_kick_side());
  }
  if (from._internal_last_kicker_uniform_number() != 0) {
    _this->_internal_set_last_kicker_uniform_number(from._internal_last_kicker_uniform_number());
  }
  if (from._internal_cycle() != 0) {
    _this->_internal_set_cycle(from._internal_cycle());
  }
  if (from._internal_game_mode_type() != 0) {
    _this->_internal_set_game_mode_type(from._internal_game_mode_type());
  }
  if (from._internal_left_team_score() != 0) {
    _this->_internal_set_left_team_score(from._internal_left_team_score());
  }
  if (from._internal_right_team_score() != 0) {
    _this->_internal_set_right_team_score(from._internal_right_team_score());
  }
  if (from._internal_is_our_set_play() != 0) {
    _this->_internal_set_is_our_set_play(from._internal_is_our_set_play());
  }
  if (from._internal_is_their_set_play() != 0) {
    _this->_internal_set_is_their_set_play(from._internal_is_their_set_play());
  }
  if (from._internal_stoped_cycle() != 0) {
    _this->_internal_set_stoped_cycle(from._internal_stoped_cycle());
  }
  if (from._internal_our_team_score() != 0) {
    _this->_internal_set_our_team_score(from._internal_our_team_score());
  }
  if (from._internal_their_team_score() != 0) {
    _this->_internal_set_their_team_score(from._internal_their_team_score());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WorldModel::CopyFrom(const WorldModel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.WorldModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WorldModel::IsInitialized() const {
  return true;
}

void WorldModel::InternalSwap(WorldModel* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_teammates()->InternalSwap(other->_internal_mutable_teammates());
  _internal_mutable_opponents()->InternalSwap(other->_internal_mutable_opponents());
  _internal_mutable_unknowns()->InternalSwap(other->_internal_mutable_unknowns());
  _impl_.our_players_dict_.InternalSwap(&other->_impl_.our_players_dict_);
  _impl_.their_players_dict_.InternalSwap(&other->_impl_.their_players_dict_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.our_team_name_, lhs_arena,
                                       &other->_impl_.our_team_name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.their_team_name_, lhs_arena,
                                       &other->_impl_.their_team_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WorldModel, _impl_.their_team_score_)
      + sizeof(WorldModel::_impl_.their_team_score_)
      - PROTOBUF_FIELD_OFFSET(WorldModel, _impl_.intercept_table_)>(
          reinterpret_cast<char*>(&_impl_.intercept_table_),
          reinterpret_cast<char*>(&other->_impl_.intercept_table_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WorldModel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[8]);
}
// ===================================================================

class State::_Internal {
 public:
  using HasBits = decltype(std::declval<State>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(State, _impl_._has_bits_);
  static const ::protos::WorldModel& world_model(const State* msg);
  static void set_has_world_model(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::WorldModel& full_world_model(const State* msg);
  static void set_has_full_world_model(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::protos::WorldModel&
State::_Internal::world_model(const State* msg) {
  return *msg->_impl_.world_model_;
}
const ::protos::WorldModel&
State::_Internal::full_world_model(const State* msg) {
  return *msg->_impl_.full_world_model_;
}
State::State(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.State)
}
State::State(const State& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  State* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.world_model_){nullptr}
    , decltype(_impl_.full_world_model_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.world_model_ = new ::protos::WorldModel(*from._impl_.world_model_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.full_world_model_ = new ::protos::WorldModel(*from._impl_.full_world_model_);
  }
  // @@protoc_insertion_point(copy_constructor:protos.State)
}

inline void State::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.world_model_){nullptr}
    , decltype(_impl_.full_world_model_){nullptr}
  };
}

State::~State() {
  // @@protoc_insertion_point(destructor:protos.State)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void State::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.world_model_;
  if (this != internal_default_instance()) delete _impl_.full_world_model_;
}

void State::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void State::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.State)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.world_model_ != nullptr);
      _impl_.world_model_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.full_world_model_ != nullptr);
      _impl_.full_world_model_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* State::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.WorldModel world_model = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_world_model(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.WorldModel full_world_model = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_full_world_model(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* State::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.State)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.WorldModel world_model = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::world_model(this),
        _Internal::world_model(this).GetCachedSize(), target, stream);
  }

  // .protos.WorldModel full_world_model = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::full_world_model(this),
        _Internal::full_world_model(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.State)
  return target;
}

::size_t State::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.State)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .protos.WorldModel world_model = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.world_model_);
    }

    // .protos.WorldModel full_world_model = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.full_world_model_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData State::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    State::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*State::GetClassData() const { return &_class_data_; }


void State::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<State*>(&to_msg);
  auto& from = static_cast<const State&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.State)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_world_model()->::protos::WorldModel::MergeFrom(
          from._internal_world_model());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_full_world_model()->::protos::WorldModel::MergeFrom(
          from._internal_full_world_model());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void State::CopyFrom(const State& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.State)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool State::IsInitialized() const {
  return true;
}

void State::InternalSwap(State* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(State, _impl_.full_world_model_)
      + sizeof(State::_impl_.full_world_model_)
      - PROTOBUF_FIELD_OFFSET(State, _impl_.world_model_)>(
          reinterpret_cast<char*>(&_impl_.world_model_),
          reinterpret_cast<char*>(&other->_impl_.world_model_));
}

::PROTOBUF_NAMESPACE_ID::Metadata State::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[9]);
}
// ===================================================================

class Dash::_Internal {
 public:
};

Dash::Dash(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Dash)
}
Dash::Dash(const Dash& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Dash)
}

inline void Dash::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.power_) { 0 }

    , decltype(_impl_.relative_direction_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Dash::~Dash() {
  // @@protoc_insertion_point(destructor:protos.Dash)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Dash::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Dash::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Dash::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Dash)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.power_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.relative_direction_) -
      reinterpret_cast<char*>(&_impl_.power_)) + sizeof(_impl_.relative_direction_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Dash::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float power = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float relative_direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.relative_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Dash::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Dash)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float power = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = this->_internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_power(), target);
  }

  // float relative_direction = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_relative_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Dash)
  return target;
}

::size_t Dash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Dash)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float power = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = this->_internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    total_size += 5;
  }

  // float relative_direction = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Dash::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Dash::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Dash::GetClassData() const { return &_class_data_; }


void Dash::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Dash*>(&to_msg);
  auto& from = static_cast<const Dash&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Dash)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = from._internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    _this->_internal_set_power(from._internal_power());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = from._internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    _this->_internal_set_relative_direction(from._internal_relative_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Dash::CopyFrom(const Dash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Dash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Dash::IsInitialized() const {
  return true;
}

void Dash::InternalSwap(Dash* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Dash, _impl_.relative_direction_)
      + sizeof(Dash::_impl_.relative_direction_)
      - PROTOBUF_FIELD_OFFSET(Dash, _impl_.power_)>(
          reinterpret_cast<char*>(&_impl_.power_),
          reinterpret_cast<char*>(&other->_impl_.power_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Dash::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[10]);
}
// ===================================================================

class Turn::_Internal {
 public:
};

Turn::Turn(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Turn)
}
Turn::Turn(const Turn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Turn)
}

inline void Turn::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.relative_direction_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Turn::~Turn() {
  // @@protoc_insertion_point(destructor:protos.Turn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Turn::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Turn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Turn::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Turn)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.relative_direction_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Turn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float relative_direction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.relative_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Turn::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Turn)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float relative_direction = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_relative_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Turn)
  return target;
}

::size_t Turn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Turn)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float relative_direction = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Turn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Turn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Turn::GetClassData() const { return &_class_data_; }


void Turn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Turn*>(&to_msg);
  auto& from = static_cast<const Turn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Turn)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = from._internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    _this->_internal_set_relative_direction(from._internal_relative_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Turn::CopyFrom(const Turn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Turn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Turn::IsInitialized() const {
  return true;
}

void Turn::InternalSwap(Turn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.relative_direction_, other->_impl_.relative_direction_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Turn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[11]);
}
// ===================================================================

class Kick::_Internal {
 public:
};

Kick::Kick(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Kick)
}
Kick::Kick(const Kick& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Kick)
}

inline void Kick::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.power_) { 0 }

    , decltype(_impl_.relative_direction_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Kick::~Kick() {
  // @@protoc_insertion_point(destructor:protos.Kick)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Kick::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Kick::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Kick::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Kick)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.power_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.relative_direction_) -
      reinterpret_cast<char*>(&_impl_.power_)) + sizeof(_impl_.relative_direction_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Kick::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float power = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float relative_direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.relative_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Kick::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Kick)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float power = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = this->_internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_power(), target);
  }

  // float relative_direction = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_relative_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Kick)
  return target;
}

::size_t Kick::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Kick)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float power = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = this->_internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    total_size += 5;
  }

  // float relative_direction = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Kick::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Kick::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Kick::GetClassData() const { return &_class_data_; }


void Kick::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Kick*>(&to_msg);
  auto& from = static_cast<const Kick&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Kick)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = from._internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    _this->_internal_set_power(from._internal_power());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = from._internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    _this->_internal_set_relative_direction(from._internal_relative_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Kick::CopyFrom(const Kick& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Kick)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Kick::IsInitialized() const {
  return true;
}

void Kick::InternalSwap(Kick* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Kick, _impl_.relative_direction_)
      + sizeof(Kick::_impl_.relative_direction_)
      - PROTOBUF_FIELD_OFFSET(Kick, _impl_.power_)>(
          reinterpret_cast<char*>(&_impl_.power_),
          reinterpret_cast<char*>(&other->_impl_.power_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Kick::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[12]);
}
// ===================================================================

class Tackle::_Internal {
 public:
};

Tackle::Tackle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Tackle)
}
Tackle::Tackle(const Tackle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Tackle)
}

inline void Tackle::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.power_or_dir_) { 0 }

    , decltype(_impl_.foul_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Tackle::~Tackle() {
  // @@protoc_insertion_point(destructor:protos.Tackle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Tackle::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Tackle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Tackle::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Tackle)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.power_or_dir_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.foul_) -
      reinterpret_cast<char*>(&_impl_.power_or_dir_)) + sizeof(_impl_.foul_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Tackle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float power_or_dir = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.power_or_dir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool foul = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.foul_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Tackle::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Tackle)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float power_or_dir = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power_or_dir = this->_internal_power_or_dir();
  ::uint32_t raw_power_or_dir;
  memcpy(&raw_power_or_dir, &tmp_power_or_dir, sizeof(tmp_power_or_dir));
  if (raw_power_or_dir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_power_or_dir(), target);
  }

  // bool foul = 2;
  if (this->_internal_foul() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_foul(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Tackle)
  return target;
}

::size_t Tackle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Tackle)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float power_or_dir = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power_or_dir = this->_internal_power_or_dir();
  ::uint32_t raw_power_or_dir;
  memcpy(&raw_power_or_dir, &tmp_power_or_dir, sizeof(tmp_power_or_dir));
  if (raw_power_or_dir != 0) {
    total_size += 5;
  }

  // bool foul = 2;
  if (this->_internal_foul() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Tackle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Tackle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Tackle::GetClassData() const { return &_class_data_; }


void Tackle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Tackle*>(&to_msg);
  auto& from = static_cast<const Tackle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Tackle)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power_or_dir = from._internal_power_or_dir();
  ::uint32_t raw_power_or_dir;
  memcpy(&raw_power_or_dir, &tmp_power_or_dir, sizeof(tmp_power_or_dir));
  if (raw_power_or_dir != 0) {
    _this->_internal_set_power_or_dir(from._internal_power_or_dir());
  }
  if (from._internal_foul() != 0) {
    _this->_internal_set_foul(from._internal_foul());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Tackle::CopyFrom(const Tackle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Tackle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tackle::IsInitialized() const {
  return true;
}

void Tackle::InternalSwap(Tackle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Tackle, _impl_.foul_)
      + sizeof(Tackle::_impl_.foul_)
      - PROTOBUF_FIELD_OFFSET(Tackle, _impl_.power_or_dir_)>(
          reinterpret_cast<char*>(&_impl_.power_or_dir_),
          reinterpret_cast<char*>(&other->_impl_.power_or_dir_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Tackle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[13]);
}
// ===================================================================

class Catch::_Internal {
 public:
};

Catch::Catch(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.Catch)
}
Catch::Catch(const Catch& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Catch* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Catch)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Catch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Catch::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Catch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[14]);
}
// ===================================================================

class Move::_Internal {
 public:
};

Move::Move(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Move)
}
Move::Move(const Move& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Move)
}

inline void Move::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.x_) { 0 }

    , decltype(_impl_.y_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Move::~Move() {
  // @@protoc_insertion_point(destructor:protos.Move)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Move::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Move::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Move::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Move)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Move::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Move::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Move)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Move)
  return target;
}

::size_t Move::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Move)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Move::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Move::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Move::GetClassData() const { return &_class_data_; }


void Move::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Move*>(&to_msg);
  auto& from = static_cast<const Move&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Move)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Move::CopyFrom(const Move& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Move)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Move::IsInitialized() const {
  return true;
}

void Move::InternalSwap(Move* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Move, _impl_.y_)
      + sizeof(Move::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(Move, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Move::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[15]);
}
// ===================================================================

class TurnNeck::_Internal {
 public:
};

TurnNeck::TurnNeck(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.TurnNeck)
}
TurnNeck::TurnNeck(const TurnNeck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.TurnNeck)
}

inline void TurnNeck::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.moment_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TurnNeck::~TurnNeck() {
  // @@protoc_insertion_point(destructor:protos.TurnNeck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TurnNeck::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void TurnNeck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TurnNeck::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.TurnNeck)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.moment_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TurnNeck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float moment = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.moment_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TurnNeck::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.TurnNeck)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float moment = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_moment = this->_internal_moment();
  ::uint32_t raw_moment;
  memcpy(&raw_moment, &tmp_moment, sizeof(tmp_moment));
  if (raw_moment != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_moment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.TurnNeck)
  return target;
}

::size_t TurnNeck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.TurnNeck)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float moment = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_moment = this->_internal_moment();
  ::uint32_t raw_moment;
  memcpy(&raw_moment, &tmp_moment, sizeof(tmp_moment));
  if (raw_moment != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TurnNeck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TurnNeck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TurnNeck::GetClassData() const { return &_class_data_; }


void TurnNeck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TurnNeck*>(&to_msg);
  auto& from = static_cast<const TurnNeck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.TurnNeck)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_moment = from._internal_moment();
  ::uint32_t raw_moment;
  memcpy(&raw_moment, &tmp_moment, sizeof(tmp_moment));
  if (raw_moment != 0) {
    _this->_internal_set_moment(from._internal_moment());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TurnNeck::CopyFrom(const TurnNeck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.TurnNeck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TurnNeck::IsInitialized() const {
  return true;
}

void TurnNeck::InternalSwap(TurnNeck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.moment_, other->_impl_.moment_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TurnNeck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[16]);
}
// ===================================================================

class ChangeView::_Internal {
 public:
};

ChangeView::ChangeView(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.ChangeView)
}
ChangeView::ChangeView(const ChangeView& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.ChangeView)
}

inline void ChangeView::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.view_width_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ChangeView::~ChangeView() {
  // @@protoc_insertion_point(destructor:protos.ChangeView)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangeView::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ChangeView::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangeView::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.ChangeView)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.view_width_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangeView::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.ViewWidth view_width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_view_width(static_cast<::protos::ViewWidth>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ChangeView::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.ChangeView)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.ViewWidth view_width = 1;
  if (this->_internal_view_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_view_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.ChangeView)
  return target;
}

::size_t ChangeView::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.ChangeView)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.ViewWidth view_width = 1;
  if (this->_internal_view_width() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_view_width());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangeView::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChangeView::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangeView::GetClassData() const { return &_class_data_; }


void ChangeView::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChangeView*>(&to_msg);
  auto& from = static_cast<const ChangeView&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.ChangeView)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_view_width() != 0) {
    _this->_internal_set_view_width(from._internal_view_width());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangeView::CopyFrom(const ChangeView& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.ChangeView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeView::IsInitialized() const {
  return true;
}

void ChangeView::InternalSwap(ChangeView* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.view_width_, other->_impl_.view_width_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangeView::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[17]);
}
// ===================================================================

class Say::_Internal {
 public:
};

Say::Say(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Say)
}
Say::Say(const Say& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Say* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:protos.Say)
}

inline void Say::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.message_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Say::~Say() {
  // @@protoc_insertion_point(destructor:protos.Say)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Say::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void Say::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Say::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Say)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Say::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.Say.message"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Say::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Say)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    const std::string& _s = this->_internal_message();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.Say.message");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Say)
  return target;
}

::size_t Say::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Say)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Say::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Say::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Say::GetClassData() const { return &_class_data_; }


void Say::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Say*>(&to_msg);
  auto& from = static_cast<const Say&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Say)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Say::CopyFrom(const Say& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Say)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Say::IsInitialized() const {
  return true;
}

void Say::InternalSwap(Say* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, lhs_arena,
                                       &other->_impl_.message_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata Say::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[18]);
}
// ===================================================================

class PointTo::_Internal {
 public:
};

PointTo::PointTo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.PointTo)
}
PointTo::PointTo(const PointTo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.PointTo)
}

inline void PointTo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.x_) { 0 }

    , decltype(_impl_.y_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PointTo::~PointTo() {
  // @@protoc_insertion_point(destructor:protos.PointTo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PointTo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PointTo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PointTo::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.PointTo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PointTo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PointTo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.PointTo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.PointTo)
  return target;
}

::size_t PointTo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.PointTo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointTo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PointTo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointTo::GetClassData() const { return &_class_data_; }


void PointTo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PointTo*>(&to_msg);
  auto& from = static_cast<const PointTo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.PointTo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PointTo::CopyFrom(const PointTo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.PointTo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointTo::IsInitialized() const {
  return true;
}

void PointTo::InternalSwap(PointTo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PointTo, _impl_.y_)
      + sizeof(PointTo::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(PointTo, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PointTo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[19]);
}
// ===================================================================

class PointToOf::_Internal {
 public:
};

PointToOf::PointToOf(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.PointToOf)
}
PointToOf::PointToOf(const PointToOf& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  PointToOf* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.PointToOf)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointToOf::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointToOf::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata PointToOf::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[20]);
}
// ===================================================================

class AttentionTo::_Internal {
 public:
};

AttentionTo::AttentionTo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AttentionTo)
}
AttentionTo::AttentionTo(const AttentionTo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.AttentionTo)
}

inline void AttentionTo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.unum_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AttentionTo::~AttentionTo() {
  // @@protoc_insertion_point(destructor:protos.AttentionTo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AttentionTo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AttentionTo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AttentionTo::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AttentionTo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.unum_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AttentionTo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 unum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.unum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AttentionTo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AttentionTo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 unum = 1;
  if (this->_internal_unum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_unum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AttentionTo)
  return target;
}

::size_t AttentionTo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AttentionTo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 unum = 1;
  if (this->_internal_unum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_unum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AttentionTo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AttentionTo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AttentionTo::GetClassData() const { return &_class_data_; }


void AttentionTo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AttentionTo*>(&to_msg);
  auto& from = static_cast<const AttentionTo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AttentionTo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_unum() != 0) {
    _this->_internal_set_unum(from._internal_unum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AttentionTo::CopyFrom(const AttentionTo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AttentionTo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AttentionTo::IsInitialized() const {
  return true;
}

void AttentionTo::InternalSwap(AttentionTo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.unum_, other->_impl_.unum_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AttentionTo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[21]);
}
// ===================================================================

class AttentionToOf::_Internal {
 public:
};

AttentionToOf::AttentionToOf(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.AttentionToOf)
}
AttentionToOf::AttentionToOf(const AttentionToOf& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  AttentionToOf* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.AttentionToOf)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AttentionToOf::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AttentionToOf::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata AttentionToOf::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[22]);
}
// ===================================================================

class Log::_Internal {
 public:
};

Log::Log(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Log)
}
Log::Log(const Log& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Log* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:protos.Log)
}

inline void Log::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.message_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Log::~Log() {
  // @@protoc_insertion_point(destructor:protos.Log)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Log::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void Log::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Log::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Log)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Log::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.Log.message"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Log::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Log)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    const std::string& _s = this->_internal_message();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.Log.message");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Log)
  return target;
}

::size_t Log::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Log)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Log::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Log::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Log::GetClassData() const { return &_class_data_; }


void Log::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Log*>(&to_msg);
  auto& from = static_cast<const Log&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Log)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Log::CopyFrom(const Log& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Log)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Log::IsInitialized() const {
  return true;
}

void Log::InternalSwap(Log* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, lhs_arena,
                                       &other->_impl_.message_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata Log::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[23]);
}
// ===================================================================

class DebugClient::_Internal {
 public:
};

DebugClient::DebugClient(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.DebugClient)
}
DebugClient::DebugClient(const DebugClient& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DebugClient* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:protos.DebugClient)
}

inline void DebugClient::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.message_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DebugClient::~DebugClient() {
  // @@protoc_insertion_point(destructor:protos.DebugClient)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DebugClient::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void DebugClient::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DebugClient::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.DebugClient)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DebugClient::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.DebugClient.message"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DebugClient::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.DebugClient)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    const std::string& _s = this->_internal_message();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.DebugClient.message");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.DebugClient)
  return target;
}

::size_t DebugClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.DebugClient)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DebugClient::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DebugClient::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DebugClient::GetClassData() const { return &_class_data_; }


void DebugClient::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DebugClient*>(&to_msg);
  auto& from = static_cast<const DebugClient&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.DebugClient)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DebugClient::CopyFrom(const DebugClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.DebugClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugClient::IsInitialized() const {
  return true;
}

void DebugClient::InternalSwap(DebugClient* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, lhs_arena,
                                       &other->_impl_.message_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata DebugClient::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[24]);
}
// ===================================================================

class Action::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::protos::Action, _impl_._oneof_case_);
  static const ::protos::Dash& dash(const Action* msg);
  static const ::protos::Turn& turn(const Action* msg);
  static const ::protos::Kick& kick(const Action* msg);
  static const ::protos::Tackle& tackle(const Action* msg);
  static const ::protos::Catch& catch_(const Action* msg);
  static const ::protos::Move& move(const Action* msg);
  static const ::protos::TurnNeck& turn_neck(const Action* msg);
  static const ::protos::ChangeView& change_view(const Action* msg);
  static const ::protos::Say& say(const Action* msg);
  static const ::protos::PointTo& point_to(const Action* msg);
  static const ::protos::PointToOf& point_to_of(const Action* msg);
  static const ::protos::AttentionTo& attention_to(const Action* msg);
  static const ::protos::AttentionToOf& attention_to_of(const Action* msg);
  static const ::protos::Log& log(const Action* msg);
  static const ::protos::DebugClient& debug_client(const Action* msg);
};

const ::protos::Dash&
Action::_Internal::dash(const Action* msg) {
  return *msg->_impl_.action_.dash_;
}
const ::protos::Turn&
Action::_Internal::turn(const Action* msg) {
  return *msg->_impl_.action_.turn_;
}
const ::protos::Kick&
Action::_Internal::kick(const Action* msg) {
  return *msg->_impl_.action_.kick_;
}
const ::protos::Tackle&
Action::_Internal::tackle(const Action* msg) {
  return *msg->_impl_.action_.tackle_;
}
const ::protos::Catch&
Action::_Internal::catch_(const Action* msg) {
  return *msg->_impl_.action_.catch__;
}
const ::protos::Move&
Action::_Internal::move(const Action* msg) {
  return *msg->_impl_.action_.move_;
}
const ::protos::TurnNeck&
Action::_Internal::turn_neck(const Action* msg) {
  return *msg->_impl_.action_.turn_neck_;
}
const ::protos::ChangeView&
Action::_Internal::change_view(const Action* msg) {
  return *msg->_impl_.action_.change_view_;
}
const ::protos::Say&
Action::_Internal::say(const Action* msg) {
  return *msg->_impl_.action_.say_;
}
const ::protos::PointTo&
Action::_Internal::point_to(const Action* msg) {
  return *msg->_impl_.action_.point_to_;
}
const ::protos::PointToOf&
Action::_Internal::point_to_of(const Action* msg) {
  return *msg->_impl_.action_.point_to_of_;
}
const ::protos::AttentionTo&
Action::_Internal::attention_to(const Action* msg) {
  return *msg->_impl_.action_.attention_to_;
}
const ::protos::AttentionToOf&
Action::_Internal::attention_to_of(const Action* msg) {
  return *msg->_impl_.action_.attention_to_of_;
}
const ::protos::Log&
Action::_Internal::log(const Action* msg) {
  return *msg->_impl_.action_.log_;
}
const ::protos::DebugClient&
Action::_Internal::debug_client(const Action* msg) {
  return *msg->_impl_.action_.debug_client_;
}
void Action::set_allocated_dash(::protos::Dash* dash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (dash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dash);
    if (message_arena != submessage_arena) {
      dash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dash, submessage_arena);
    }
    set_has_dash();
    _impl_.action_.dash_ = dash;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.dash)
}
void Action::set_allocated_turn(::protos::Turn* turn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (turn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(turn);
    if (message_arena != submessage_arena) {
      turn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, turn, submessage_arena);
    }
    set_has_turn();
    _impl_.action_.turn_ = turn;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.turn)
}
void Action::set_allocated_kick(::protos::Kick* kick) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (kick) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(kick);
    if (message_arena != submessage_arena) {
      kick = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kick, submessage_arena);
    }
    set_has_kick();
    _impl_.action_.kick_ = kick;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.kick)
}
void Action::set_allocated_tackle(::protos::Tackle* tackle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (tackle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tackle);
    if (message_arena != submessage_arena) {
      tackle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tackle, submessage_arena);
    }
    set_has_tackle();
    _impl_.action_.tackle_ = tackle;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.tackle)
}
void Action::set_allocated_catch_(::protos::Catch* catch_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (catch_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(catch_);
    if (message_arena != submessage_arena) {
      catch_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, catch_, submessage_arena);
    }
    set_has_catch_();
    _impl_.action_.catch__ = catch_;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.catch)
}
void Action::set_allocated_move(::protos::Move* move) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (move) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(move);
    if (message_arena != submessage_arena) {
      move = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, move, submessage_arena);
    }
    set_has_move();
    _impl_.action_.move_ = move;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.move)
}
void Action::set_allocated_turn_neck(::protos::TurnNeck* turn_neck) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (turn_neck) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(turn_neck);
    if (message_arena != submessage_arena) {
      turn_neck = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, turn_neck, submessage_arena);
    }
    set_has_turn_neck();
    _impl_.action_.turn_neck_ = turn_neck;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.turn_neck)
}
void Action::set_allocated_change_view(::protos::ChangeView* change_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (change_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(change_view);
    if (message_arena != submessage_arena) {
      change_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, change_view, submessage_arena);
    }
    set_has_change_view();
    _impl_.action_.change_view_ = change_view;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.change_view)
}
void Action::set_allocated_say(::protos::Say* say) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (say) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(say);
    if (message_arena != submessage_arena) {
      say = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, say, submessage_arena);
    }
    set_has_say();
    _impl_.action_.say_ = say;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.say)
}
void Action::set_allocated_point_to(::protos::PointTo* point_to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (point_to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point_to);
    if (message_arena != submessage_arena) {
      point_to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_to, submessage_arena);
    }
    set_has_point_to();
    _impl_.action_.point_to_ = point_to;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.point_to)
}
void Action::set_allocated_point_to_of(::protos::PointToOf* point_to_of) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (point_to_of) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point_to_of);
    if (message_arena != submessage_arena) {
      point_to_of = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_to_of, submessage_arena);
    }
    set_has_point_to_of();
    _impl_.action_.point_to_of_ = point_to_of;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.point_to_of)
}
void Action::set_allocated_attention_to(::protos::AttentionTo* attention_to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (attention_to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attention_to);
    if (message_arena != submessage_arena) {
      attention_to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attention_to, submessage_arena);
    }
    set_has_attention_to();
    _impl_.action_.attention_to_ = attention_to;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.attention_to)
}
void Action::set_allocated_attention_to_of(::protos::AttentionToOf* attention_to_of) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (attention_to_of) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attention_to_of);
    if (message_arena != submessage_arena) {
      attention_to_of = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attention_to_of, submessage_arena);
    }
    set_has_attention_to_of();
    _impl_.action_.attention_to_of_ = attention_to_of;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.attention_to_of)
}
void Action::set_allocated_log(::protos::Log* log) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (log) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(log);
    if (message_arena != submessage_arena) {
      log = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log, submessage_arena);
    }
    set_has_log();
    _impl_.action_.log_ = log;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.log)
}
void Action::set_allocated_debug_client(::protos::DebugClient* debug_client) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (debug_client) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(debug_client);
    if (message_arena != submessage_arena) {
      debug_client = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, debug_client, submessage_arena);
    }
    set_has_debug_client();
    _impl_.action_.debug_client_ = debug_client;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.debug_client)
}
Action::Action(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Action)
}
Action::Action(const Action& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Action* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.action_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_action();
  switch (from.action_case()) {
    case kDash: {
      _this->_internal_mutable_dash()->::protos::Dash::MergeFrom(
          from._internal_dash());
      break;
    }
    case kTurn: {
      _this->_internal_mutable_turn()->::protos::Turn::MergeFrom(
          from._internal_turn());
      break;
    }
    case kKick: {
      _this->_internal_mutable_kick()->::protos::Kick::MergeFrom(
          from._internal_kick());
      break;
    }
    case kTackle: {
      _this->_internal_mutable_tackle()->::protos::Tackle::MergeFrom(
          from._internal_tackle());
      break;
    }
    case kCatch: {
      _this->_internal_mutable_catch_()->::protos::Catch::MergeFrom(
          from._internal_catch_());
      break;
    }
    case kMove: {
      _this->_internal_mutable_move()->::protos::Move::MergeFrom(
          from._internal_move());
      break;
    }
    case kTurnNeck: {
      _this->_internal_mutable_turn_neck()->::protos::TurnNeck::MergeFrom(
          from._internal_turn_neck());
      break;
    }
    case kChangeView: {
      _this->_internal_mutable_change_view()->::protos::ChangeView::MergeFrom(
          from._internal_change_view());
      break;
    }
    case kSay: {
      _this->_internal_mutable_say()->::protos::Say::MergeFrom(
          from._internal_say());
      break;
    }
    case kPointTo: {
      _this->_internal_mutable_point_to()->::protos::PointTo::MergeFrom(
          from._internal_point_to());
      break;
    }
    case kPointToOf: {
      _this->_internal_mutable_point_to_of()->::protos::PointToOf::MergeFrom(
          from._internal_point_to_of());
      break;
    }
    case kAttentionTo: {
      _this->_internal_mutable_attention_to()->::protos::AttentionTo::MergeFrom(
          from._internal_attention_to());
      break;
    }
    case kAttentionToOf: {
      _this->_internal_mutable_attention_to_of()->::protos::AttentionToOf::MergeFrom(
          from._internal_attention_to_of());
      break;
    }
    case kLog: {
      _this->_internal_mutable_log()->::protos::Log::MergeFrom(
          from._internal_log());
      break;
    }
    case kDebugClient: {
      _this->_internal_mutable_debug_client()->::protos::DebugClient::MergeFrom(
          from._internal_debug_client());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:protos.Action)
}

inline void Action::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.action_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_action();
}

Action::~Action() {
  // @@protoc_insertion_point(destructor:protos.Action)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Action::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_action()) {
    clear_action();
  }
}

void Action::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Action::clear_action() {
// @@protoc_insertion_point(one_of_clear_start:protos.Action)
  switch (action_case()) {
    case kDash: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.dash_;
      }
      break;
    }
    case kTurn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.turn_;
      }
      break;
    }
    case kKick: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.kick_;
      }
      break;
    }
    case kTackle: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.tackle_;
      }
      break;
    }
    case kCatch: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.catch__;
      }
      break;
    }
    case kMove: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.move_;
      }
      break;
    }
    case kTurnNeck: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.turn_neck_;
      }
      break;
    }
    case kChangeView: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.change_view_;
      }
      break;
    }
    case kSay: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.say_;
      }
      break;
    }
    case kPointTo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.point_to_;
      }
      break;
    }
    case kPointToOf: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.point_to_of_;
      }
      break;
    }
    case kAttentionTo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.attention_to_;
      }
      break;
    }
    case kAttentionToOf: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.attention_to_of_;
      }
      break;
    }
    case kLog: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.log_;
      }
      break;
    }
    case kDebugClient: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.debug_client_;
      }
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}


void Action::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Action)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_action();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Action::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Dash dash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dash(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Turn turn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_turn(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Kick kick = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_kick(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Tackle tackle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_tackle(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Catch catch = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_catch_(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Move move = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_move(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.TurnNeck turn_neck = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_turn_neck(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.ChangeView change_view = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_change_view(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Say say = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_say(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.PointTo point_to = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_point_to(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.PointToOf point_to_of = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_point_to_of(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AttentionTo attention_to = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_attention_to(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AttentionToOf attention_to_of = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_attention_to_of(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Log log = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_log(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.DebugClient debug_client = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_debug_client(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Action::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Action)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (action_case()) {
    case kDash: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::dash(this),
          _Internal::dash(this).GetCachedSize(), target, stream);
      break;
    }
    case kTurn: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::turn(this),
          _Internal::turn(this).GetCachedSize(), target, stream);
      break;
    }
    case kKick: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::kick(this),
          _Internal::kick(this).GetCachedSize(), target, stream);
      break;
    }
    case kTackle: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::tackle(this),
          _Internal::tackle(this).GetCachedSize(), target, stream);
      break;
    }
    case kCatch: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::catch_(this),
          _Internal::catch_(this).GetCachedSize(), target, stream);
      break;
    }
    case kMove: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::move(this),
          _Internal::move(this).GetCachedSize(), target, stream);
      break;
    }
    case kTurnNeck: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::turn_neck(this),
          _Internal::turn_neck(this).GetCachedSize(), target, stream);
      break;
    }
    case kChangeView: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::change_view(this),
          _Internal::change_view(this).GetCachedSize(), target, stream);
      break;
    }
    case kSay: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::say(this),
          _Internal::say(this).GetCachedSize(), target, stream);
      break;
    }
    case kPointTo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::point_to(this),
          _Internal::point_to(this).GetCachedSize(), target, stream);
      break;
    }
    case kPointToOf: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::point_to_of(this),
          _Internal::point_to_of(this).GetCachedSize(), target, stream);
      break;
    }
    case kAttentionTo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::attention_to(this),
          _Internal::attention_to(this).GetCachedSize(), target, stream);
      break;
    }
    case kAttentionToOf: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, _Internal::attention_to_of(this),
          _Internal::attention_to_of(this).GetCachedSize(), target, stream);
      break;
    }
    case kLog: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, _Internal::log(this),
          _Internal::log(this).GetCachedSize(), target, stream);
      break;
    }
    case kDebugClient: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, _Internal::debug_client(this),
          _Internal::debug_client(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Action)
  return target;
}

::size_t Action::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Action)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (action_case()) {
    // .protos.Dash dash = 1;
    case kDash: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.dash_);
      break;
    }
    // .protos.Turn turn = 2;
    case kTurn: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.turn_);
      break;
    }
    // .protos.Kick kick = 3;
    case kKick: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.kick_);
      break;
    }
    // .protos.Tackle tackle = 4;
    case kTackle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.tackle_);
      break;
    }
    // .protos.Catch catch = 5;
    case kCatch: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.catch__);
      break;
    }
    // .protos.Move move = 6;
    case kMove: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.move_);
      break;
    }
    // .protos.TurnNeck turn_neck = 7;
    case kTurnNeck: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.turn_neck_);
      break;
    }
    // .protos.ChangeView change_view = 8;
    case kChangeView: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.change_view_);
      break;
    }
    // .protos.Say say = 9;
    case kSay: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.say_);
      break;
    }
    // .protos.PointTo point_to = 10;
    case kPointTo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.point_to_);
      break;
    }
    // .protos.PointToOf point_to_of = 11;
    case kPointToOf: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.point_to_of_);
      break;
    }
    // .protos.AttentionTo attention_to = 12;
    case kAttentionTo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.attention_to_);
      break;
    }
    // .protos.AttentionToOf attention_to_of = 13;
    case kAttentionToOf: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.attention_to_of_);
      break;
    }
    // .protos.Log log = 14;
    case kLog: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.log_);
      break;
    }
    // .protos.DebugClient debug_client = 15;
    case kDebugClient: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.debug_client_);
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Action::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Action::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Action::GetClassData() const { return &_class_data_; }


void Action::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Action*>(&to_msg);
  auto& from = static_cast<const Action&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Action)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.action_case()) {
    case kDash: {
      _this->_internal_mutable_dash()->::protos::Dash::MergeFrom(
          from._internal_dash());
      break;
    }
    case kTurn: {
      _this->_internal_mutable_turn()->::protos::Turn::MergeFrom(
          from._internal_turn());
      break;
    }
    case kKick: {
      _this->_internal_mutable_kick()->::protos::Kick::MergeFrom(
          from._internal_kick());
      break;
    }
    case kTackle: {
      _this->_internal_mutable_tackle()->::protos::Tackle::MergeFrom(
          from._internal_tackle());
      break;
    }
    case kCatch: {
      _this->_internal_mutable_catch_()->::protos::Catch::MergeFrom(
          from._internal_catch_());
      break;
    }
    case kMove: {
      _this->_internal_mutable_move()->::protos::Move::MergeFrom(
          from._internal_move());
      break;
    }
    case kTurnNeck: {
      _this->_internal_mutable_turn_neck()->::protos::TurnNeck::MergeFrom(
          from._internal_turn_neck());
      break;
    }
    case kChangeView: {
      _this->_internal_mutable_change_view()->::protos::ChangeView::MergeFrom(
          from._internal_change_view());
      break;
    }
    case kSay: {
      _this->_internal_mutable_say()->::protos::Say::MergeFrom(
          from._internal_say());
      break;
    }
    case kPointTo: {
      _this->_internal_mutable_point_to()->::protos::PointTo::MergeFrom(
          from._internal_point_to());
      break;
    }
    case kPointToOf: {
      _this->_internal_mutable_point_to_of()->::protos::PointToOf::MergeFrom(
          from._internal_point_to_of());
      break;
    }
    case kAttentionTo: {
      _this->_internal_mutable_attention_to()->::protos::AttentionTo::MergeFrom(
          from._internal_attention_to());
      break;
    }
    case kAttentionToOf: {
      _this->_internal_mutable_attention_to_of()->::protos::AttentionToOf::MergeFrom(
          from._internal_attention_to_of());
      break;
    }
    case kLog: {
      _this->_internal_mutable_log()->::protos::Log::MergeFrom(
          from._internal_log());
      break;
    }
    case kDebugClient: {
      _this->_internal_mutable_debug_client()->::protos::DebugClient::MergeFrom(
          from._internal_debug_client());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Action::CopyFrom(const Action& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Action)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Action::IsInitialized() const {
  return true;
}

void Action::InternalSwap(Action* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.action_, other->_impl_.action_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Action::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[25]);
}
// ===================================================================

class Actions::_Internal {
 public:
};

Actions::Actions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Actions)
}
Actions::Actions(const Actions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Actions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.actions_){from._impl_.actions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Actions)
}

inline void Actions::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.actions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Actions::~Actions() {
  // @@protoc_insertion_point(destructor:protos.Actions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Actions::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_actions()->~RepeatedPtrField();
}

void Actions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Actions::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Actions)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_actions()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Actions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .protos.Action actions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_actions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Actions::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Actions)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protos.Action actions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_actions_size()); i < n; i++) {
    const auto& repfield = this->_internal_actions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Actions)
  return target;
}

::size_t Actions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Actions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protos.Action actions = 1;
  total_size += 1UL * this->_internal_actions_size();
  for (const auto& msg : this->_internal_actions()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Actions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Actions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Actions::GetClassData() const { return &_class_data_; }


void Actions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Actions*>(&to_msg);
  auto& from = static_cast<const Actions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Actions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_actions()->MergeFrom(from._internal_actions());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Actions::CopyFrom(const Actions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Actions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Actions::IsInitialized() const {
  return true;
}

void Actions::InternalSwap(Actions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_actions()->InternalSwap(other->_internal_mutable_actions());
}

::PROTOBUF_NAMESPACE_ID::Metadata Actions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[26]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::protos::Vector2D*
Arena::CreateMaybeMessage< ::protos::Vector2D >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Vector2D >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Ball*
Arena::CreateMaybeMessage< ::protos::Ball >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Ball >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Player*
Arena::CreateMaybeMessage< ::protos::Player >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Player >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Self*
Arena::CreateMaybeMessage< ::protos::Self >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Self >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::InterceptInfo*
Arena::CreateMaybeMessage< ::protos::InterceptInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::InterceptInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::InterceptTable*
Arena::CreateMaybeMessage< ::protos::InterceptTable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::InterceptTable >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::WorldModel_OurPlayersDictEntry_DoNotUse*
Arena::CreateMaybeMessage< ::protos::WorldModel_OurPlayersDictEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::WorldModel_OurPlayersDictEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::WorldModel_TheirPlayersDictEntry_DoNotUse*
Arena::CreateMaybeMessage< ::protos::WorldModel_TheirPlayersDictEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::WorldModel_TheirPlayersDictEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::WorldModel*
Arena::CreateMaybeMessage< ::protos::WorldModel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::WorldModel >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::State*
Arena::CreateMaybeMessage< ::protos::State >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::State >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Dash*
Arena::CreateMaybeMessage< ::protos::Dash >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Dash >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Turn*
Arena::CreateMaybeMessage< ::protos::Turn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Turn >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Kick*
Arena::CreateMaybeMessage< ::protos::Kick >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Kick >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Tackle*
Arena::CreateMaybeMessage< ::protos::Tackle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Tackle >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Catch*
Arena::CreateMaybeMessage< ::protos::Catch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Catch >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Move*
Arena::CreateMaybeMessage< ::protos::Move >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Move >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::TurnNeck*
Arena::CreateMaybeMessage< ::protos::TurnNeck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::TurnNeck >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::ChangeView*
Arena::CreateMaybeMessage< ::protos::ChangeView >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::ChangeView >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Say*
Arena::CreateMaybeMessage< ::protos::Say >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Say >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::PointTo*
Arena::CreateMaybeMessage< ::protos::PointTo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::PointTo >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::PointToOf*
Arena::CreateMaybeMessage< ::protos::PointToOf >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::PointToOf >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AttentionTo*
Arena::CreateMaybeMessage< ::protos::AttentionTo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AttentionTo >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AttentionToOf*
Arena::CreateMaybeMessage< ::protos::AttentionToOf >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AttentionToOf >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Log*
Arena::CreateMaybeMessage< ::protos::Log >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Log >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::DebugClient*
Arena::CreateMaybeMessage< ::protos::DebugClient >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::DebugClient >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Action*
Arena::CreateMaybeMessage< ::protos::Action >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Action >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Actions*
Arena::CreateMaybeMessage< ::protos::Actions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Actions >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
