// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

#include "service.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace protos {
template <typename>
PROTOBUF_CONSTEXPR Vector2D::Vector2D(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/ 0

  , /*decltype(_impl_.y_)*/ 0

  , /*decltype(_impl_.dist_)*/ 0

  , /*decltype(_impl_.angle_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Vector2DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Vector2DDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Vector2DDefaultTypeInternal() {}
  union {
    Vector2D _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Vector2DDefaultTypeInternal _Vector2D_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ball::Ball(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.relative_position_)*/nullptr
  , /*decltype(_impl_.seen_position_)*/nullptr
  , /*decltype(_impl_.heard_position_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.seen_velocity_)*/nullptr
  , /*decltype(_impl_.heard_velocity_)*/nullptr
  , /*decltype(_impl_.pos_count_)*/ 0

  , /*decltype(_impl_.seen_pos_count_)*/ 0

  , /*decltype(_impl_.heard_pos_count_)*/ 0

  , /*decltype(_impl_.vel_count_)*/ 0

  , /*decltype(_impl_.seen_vel_count_)*/ 0

  , /*decltype(_impl_.heard_vel_count_)*/ 0

  , /*decltype(_impl_.lost_count_)*/ 0

  , /*decltype(_impl_.ghost_count_)*/ 0

  , /*decltype(_impl_.dist_from_self_)*/ 0

  , /*decltype(_impl_.angle_from_self_)*/ 0
} {}
struct BallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BallDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BallDefaultTypeInternal() {}
  union {
    Ball _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BallDefaultTypeInternal _Ball_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Player::Player(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.seen_position_)*/nullptr
  , /*decltype(_impl_.heard_position_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.seen_velocity_)*/nullptr
  , /*decltype(_impl_.pos_count_)*/ 0

  , /*decltype(_impl_.seen_pos_count_)*/ 0

  , /*decltype(_impl_.heard_pos_count_)*/ 0

  , /*decltype(_impl_.vel_count_)*/ 0

  , /*decltype(_impl_.seen_vel_count_)*/ 0

  , /*decltype(_impl_.ghost_count_)*/ 0

  , /*decltype(_impl_.dist_from_self_)*/ 0

  , /*decltype(_impl_.angle_from_self_)*/ 0

  , /*decltype(_impl_.id_)*/ 0

  , /*decltype(_impl_.side_)*/ 0

  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.uniform_number_count_)*/ 0

  , /*decltype(_impl_.body_direction_)*/ 0

  , /*decltype(_impl_.body_direction_count_)*/ 0

  , /*decltype(_impl_.face_direction_)*/ 0

  , /*decltype(_impl_.face_direction_count_)*/ 0

  , /*decltype(_impl_.point_to_direction_)*/ 0

  , /*decltype(_impl_.point_to_direction_count_)*/ 0

  , /*decltype(_impl_.is_goalie_)*/ false

  , /*decltype(_impl_.is_kicking_)*/ false

  , /*decltype(_impl_.is_tackling_)*/ false

  , /*decltype(_impl_.dist_from_ball_)*/ 0

  , /*decltype(_impl_.angle_from_ball_)*/ 0

  , /*decltype(_impl_.ball_reach_steps_)*/ 0
} {}
struct PlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerDefaultTypeInternal() {}
  union {
    Player _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerDefaultTypeInternal _Player_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Self::Self(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.seen_position_)*/nullptr
  , /*decltype(_impl_.heard_position_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.seen_velocity_)*/nullptr
  , /*decltype(_impl_.pos_count_)*/ 0

  , /*decltype(_impl_.seen_pos_count_)*/ 0

  , /*decltype(_impl_.heard_pos_count_)*/ 0

  , /*decltype(_impl_.vel_count_)*/ 0

  , /*decltype(_impl_.seen_vel_count_)*/ 0

  , /*decltype(_impl_.ghost_count_)*/ 0

  , /*decltype(_impl_.id_)*/ 0

  , /*decltype(_impl_.side_)*/ 0

  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.uniform_number_count_)*/ 0

  , /*decltype(_impl_.body_direction_)*/ 0

  , /*decltype(_impl_.body_direction_count_)*/ 0

  , /*decltype(_impl_.face_direction_)*/ 0

  , /*decltype(_impl_.face_direction_count_)*/ 0

  , /*decltype(_impl_.point_to_direction_)*/ 0

  , /*decltype(_impl_.point_to_direction_count_)*/ 0

  , /*decltype(_impl_.dist_from_ball_)*/ 0

  , /*decltype(_impl_.is_goalie_)*/ false

  , /*decltype(_impl_.is_kicking_)*/ false

  , /*decltype(_impl_.is_tackling_)*/ false

  , /*decltype(_impl_.is_kickable_)*/ false

  , /*decltype(_impl_.angle_from_ball_)*/ 0

  , /*decltype(_impl_.ball_reach_steps_)*/ 0

  , /*decltype(_impl_.relative_neck_direction_)*/ 0

  , /*decltype(_impl_.stamina_)*/ 0

  , /*decltype(_impl_.catch_probability_)*/ 0

  , /*decltype(_impl_.tackle_probability_)*/ 0

  , /*decltype(_impl_.foul_probability_)*/ 0

  , /*decltype(_impl_.view_width_)*/ 0
} {}
struct SelfDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelfDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelfDefaultTypeInternal() {}
  union {
    Self _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelfDefaultTypeInternal _Self_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR InterceptInfo::InterceptInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.final_self_position_)*/nullptr
  , /*decltype(_impl_.action_type_)*/ 0

  , /*decltype(_impl_.turn_steps_)*/ 0

  , /*decltype(_impl_.turn_angle_)*/ 0

  , /*decltype(_impl_.dash_steps_)*/ 0

  , /*decltype(_impl_.dash_power_)*/ 0

  , /*decltype(_impl_.dash_dir_)*/ 0

  , /*decltype(_impl_.final_ball_dist_)*/ 0

  , /*decltype(_impl_.final_stamina_)*/ 0

  , /*decltype(_impl_.value_)*/ 0
} {}
struct InterceptInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InterceptInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InterceptInfoDefaultTypeInternal() {}
  union {
    InterceptInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InterceptInfoDefaultTypeInternal _InterceptInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR InterceptTable::InterceptTable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.self_intercept_info_)*/{}
  , /*decltype(_impl_.self_reach_steps_)*/ 0

  , /*decltype(_impl_.first_teammate_reach_steps_)*/ 0

  , /*decltype(_impl_.second_teammate_reach_steps_)*/ 0

  , /*decltype(_impl_.first_opponent_reach_steps_)*/ 0

  , /*decltype(_impl_.second_opponent_reach_steps_)*/ 0

  , /*decltype(_impl_.first_teammate_id_)*/ 0

  , /*decltype(_impl_.second_teammate_id_)*/ 0

  , /*decltype(_impl_.first_opponent_id_)*/ 0

  , /*decltype(_impl_.second_opponent_id_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InterceptTableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InterceptTableDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InterceptTableDefaultTypeInternal() {}
  union {
    InterceptTable _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InterceptTableDefaultTypeInternal _InterceptTable_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WorldModel_OurPlayersDictEntry_DoNotUse::WorldModel_OurPlayersDictEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal() {}
  union {
    WorldModel_OurPlayersDictEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal _WorldModel_OurPlayersDictEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WorldModel_TheirPlayersDictEntry_DoNotUse::WorldModel_TheirPlayersDictEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal() {}
  union {
    WorldModel_TheirPlayersDictEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal _WorldModel_TheirPlayersDictEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WorldModel::WorldModel(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.teammates_)*/{}
  , /*decltype(_impl_.opponents_)*/{}
  , /*decltype(_impl_.unknowns_)*/{}
  , /*decltype(_impl_.our_players_dict_)*/{}
  , /*decltype(_impl_.their_players_dict_)*/{}
  , /*decltype(_impl_.our_team_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.their_team_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.intercept_table_)*/nullptr
  , /*decltype(_impl_.self_)*/nullptr
  , /*decltype(_impl_.ball_)*/nullptr
  , /*decltype(_impl_.our_side_)*/ 0

  , /*decltype(_impl_.last_set_play_start_time_)*/ 0

  , /*decltype(_impl_.our_goalie_uniform_number_)*/ 0

  , /*decltype(_impl_.their_goalie_uniform_number_)*/ 0

  , /*decltype(_impl_.offside_line_x_)*/ 0

  , /*decltype(_impl_.ofside_line_x_count_)*/ 0

  , /*decltype(_impl_.kickable_teammate_id_)*/ 0

  , /*decltype(_impl_.kickable_opponent_id_)*/ 0

  , /*decltype(_impl_.last_kick_side_)*/ 0

  , /*decltype(_impl_.last_kicker_uniform_number_)*/ 0

  , /*decltype(_impl_.cycle_)*/ 0

  , /*decltype(_impl_.game_mode_type_)*/ 0

  , /*decltype(_impl_.left_team_score_)*/ 0

  , /*decltype(_impl_.right_team_score_)*/ 0

  , /*decltype(_impl_.is_our_set_play_)*/ false

  , /*decltype(_impl_.is_their_set_play_)*/ false

  , /*decltype(_impl_.stoped_cycle_)*/ 0

  , /*decltype(_impl_.our_team_score_)*/ 0

  , /*decltype(_impl_.their_team_score_)*/ 0
} {}
struct WorldModelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WorldModelDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WorldModelDefaultTypeInternal() {}
  union {
    WorldModel _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WorldModelDefaultTypeInternal _WorldModel_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR State::State(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.world_model_)*/nullptr
  , /*decltype(_impl_.full_world_model_)*/nullptr} {}
struct StateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StateDefaultTypeInternal() {}
  union {
    State _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StateDefaultTypeInternal _State_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Dash::Dash(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.power_)*/ 0

  , /*decltype(_impl_.relative_direction_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DashDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DashDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DashDefaultTypeInternal() {}
  union {
    Dash _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DashDefaultTypeInternal _Dash_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Turn::Turn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.relative_direction_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TurnDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TurnDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TurnDefaultTypeInternal() {}
  union {
    Turn _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TurnDefaultTypeInternal _Turn_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Kick::Kick(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.power_)*/ 0

  , /*decltype(_impl_.relative_direction_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KickDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KickDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KickDefaultTypeInternal() {}
  union {
    Kick _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KickDefaultTypeInternal _Kick_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Tackle::Tackle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.power_or_dir_)*/ 0

  , /*decltype(_impl_.foul_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TackleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TackleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TackleDefaultTypeInternal() {}
  union {
    Tackle _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TackleDefaultTypeInternal _Tackle_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Catch::Catch(
    ::_pbi::ConstantInitialized) {}
struct CatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CatchDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CatchDefaultTypeInternal() {}
  union {
    Catch _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CatchDefaultTypeInternal _Catch_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Move::Move(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/ 0

  , /*decltype(_impl_.y_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveDefaultTypeInternal() {}
  union {
    Move _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveDefaultTypeInternal _Move_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TurnNeck::TurnNeck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.moment_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TurnNeckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TurnNeckDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TurnNeckDefaultTypeInternal() {}
  union {
    TurnNeck _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TurnNeckDefaultTypeInternal _TurnNeck_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ChangeView::ChangeView(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.view_width_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ChangeViewDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangeViewDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangeViewDefaultTypeInternal() {}
  union {
    ChangeView _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangeViewDefaultTypeInternal _ChangeView_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BallMessage::BallMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ball_position_)*/nullptr
  , /*decltype(_impl_.ball_velocity_)*/nullptr} {}
struct BallMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BallMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BallMessageDefaultTypeInternal() {}
  union {
    BallMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BallMessageDefaultTypeInternal _BallMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PassMessage::PassMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.receiver_point_)*/nullptr
  , /*decltype(_impl_.ball_position_)*/nullptr
  , /*decltype(_impl_.ball_velocity_)*/nullptr
  , /*decltype(_impl_.receiver_uniform_number_)*/ 0
} {}
struct PassMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PassMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PassMessageDefaultTypeInternal() {}
  union {
    PassMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PassMessageDefaultTypeInternal _PassMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR InterceptMessage::InterceptMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.our_)*/ false

  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.cycle_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InterceptMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InterceptMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InterceptMessageDefaultTypeInternal() {}
  union {
    InterceptMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InterceptMessageDefaultTypeInternal _InterceptMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR GoalieMessage::GoalieMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.goalie_position_)*/nullptr
  , /*decltype(_impl_.goalie_uniform_number_)*/ 0

  , /*decltype(_impl_.goalie_body_direction_)*/ 0
} {}
struct GoalieMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GoalieMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GoalieMessageDefaultTypeInternal() {}
  union {
    GoalieMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GoalieMessageDefaultTypeInternal _GoalieMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR GoalieAndPlayerMessage::GoalieAndPlayerMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.goalie_position_)*/nullptr
  , /*decltype(_impl_.player_position_)*/nullptr
  , /*decltype(_impl_.goalie_uniform_number_)*/ 0

  , /*decltype(_impl_.goalie_body_direction_)*/ 0

  , /*decltype(_impl_.player_uniform_number_)*/ 0
} {}
struct GoalieAndPlayerMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GoalieAndPlayerMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GoalieAndPlayerMessageDefaultTypeInternal() {}
  union {
    GoalieAndPlayerMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GoalieAndPlayerMessageDefaultTypeInternal _GoalieAndPlayerMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OffsideLineMessage::OffsideLineMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.offside_line_x_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OffsideLineMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OffsideLineMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OffsideLineMessageDefaultTypeInternal() {}
  union {
    OffsideLineMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OffsideLineMessageDefaultTypeInternal _OffsideLineMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DefenseLineMessage::DefenseLineMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.defense_line_x_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DefenseLineMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DefenseLineMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DefenseLineMessageDefaultTypeInternal() {}
  union {
    DefenseLineMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DefenseLineMessageDefaultTypeInternal _DefenseLineMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WaitRequestMessage::WaitRequestMessage(
    ::_pbi::ConstantInitialized) {}
struct WaitRequestMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WaitRequestMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WaitRequestMessageDefaultTypeInternal() {}
  union {
    WaitRequestMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WaitRequestMessageDefaultTypeInternal _WaitRequestMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SetplayMessage::SetplayMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.wait_step_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetplayMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetplayMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetplayMessageDefaultTypeInternal() {}
  union {
    SetplayMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetplayMessageDefaultTypeInternal _SetplayMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PassRequestMessage::PassRequestMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_point_)*/nullptr} {}
struct PassRequestMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PassRequestMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PassRequestMessageDefaultTypeInternal() {}
  union {
    PassRequestMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PassRequestMessageDefaultTypeInternal _PassRequestMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StaminaMessage::StaminaMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stamina_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StaminaMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaminaMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaminaMessageDefaultTypeInternal() {}
  union {
    StaminaMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaminaMessageDefaultTypeInternal _StaminaMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RecoveryMessage::RecoveryMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.recovery_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RecoveryMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecoveryMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecoveryMessageDefaultTypeInternal() {}
  union {
    RecoveryMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecoveryMessageDefaultTypeInternal _RecoveryMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StaminaCapacityMessage::StaminaCapacityMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stamina_capacity_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StaminaCapacityMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaminaCapacityMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaminaCapacityMessageDefaultTypeInternal() {}
  union {
    StaminaCapacityMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaminaCapacityMessageDefaultTypeInternal _StaminaCapacityMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DribbleMessage::DribbleMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_point_)*/nullptr
  , /*decltype(_impl_.queue_count_)*/ 0
} {}
struct DribbleMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DribbleMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DribbleMessageDefaultTypeInternal() {}
  union {
    DribbleMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DribbleMessageDefaultTypeInternal _DribbleMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BallGoalieMessage::BallGoalieMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ball_position_)*/nullptr
  , /*decltype(_impl_.ball_velocity_)*/nullptr
  , /*decltype(_impl_.goalie_position_)*/nullptr
  , /*decltype(_impl_.goalie_body_direction_)*/ 0
} {}
struct BallGoalieMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BallGoalieMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BallGoalieMessageDefaultTypeInternal() {}
  union {
    BallGoalieMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BallGoalieMessageDefaultTypeInternal _BallGoalieMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OnePlayerMessage::OnePlayerMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.uniform_number_)*/ 0
} {}
struct OnePlayerMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OnePlayerMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OnePlayerMessageDefaultTypeInternal() {}
  union {
    OnePlayerMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OnePlayerMessageDefaultTypeInternal _OnePlayerMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TwoPlayerMessage::TwoPlayerMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.first_position_)*/nullptr
  , /*decltype(_impl_.second_position_)*/nullptr
  , /*decltype(_impl_.first_uniform_number_)*/ 0

  , /*decltype(_impl_.second_uniform_number_)*/ 0
} {}
struct TwoPlayerMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TwoPlayerMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TwoPlayerMessageDefaultTypeInternal() {}
  union {
    TwoPlayerMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TwoPlayerMessageDefaultTypeInternal _TwoPlayerMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ThreePlayerMessage::ThreePlayerMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.first_position_)*/nullptr
  , /*decltype(_impl_.second_position_)*/nullptr
  , /*decltype(_impl_.third_position_)*/nullptr
  , /*decltype(_impl_.first_uniform_number_)*/ 0

  , /*decltype(_impl_.second_uniform_number_)*/ 0

  , /*decltype(_impl_.third_uniform_number_)*/ 0
} {}
struct ThreePlayerMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreePlayerMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreePlayerMessageDefaultTypeInternal() {}
  union {
    ThreePlayerMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreePlayerMessageDefaultTypeInternal _ThreePlayerMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SelfMessage::SelfMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.self_position_)*/nullptr
  , /*decltype(_impl_.self_body_direction_)*/ 0

  , /*decltype(_impl_.self_stamina_)*/ 0
} {}
struct SelfMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelfMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelfMessageDefaultTypeInternal() {}
  union {
    SelfMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelfMessageDefaultTypeInternal _SelfMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TeammateMessage::TeammateMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.body_direction_)*/ 0
} {}
struct TeammateMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TeammateMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TeammateMessageDefaultTypeInternal() {}
  union {
    TeammateMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TeammateMessageDefaultTypeInternal _TeammateMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OpponentMessage::OpponentMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.body_direction_)*/ 0
} {}
struct OpponentMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OpponentMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OpponentMessageDefaultTypeInternal() {}
  union {
    OpponentMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OpponentMessageDefaultTypeInternal _OpponentMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BallPlayerMessage::BallPlayerMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ball_position_)*/nullptr
  , /*decltype(_impl_.ball_velocity_)*/nullptr
  , /*decltype(_impl_.player_position_)*/nullptr
  , /*decltype(_impl_.uniform_number_)*/ 0

  , /*decltype(_impl_.body_direction_)*/ 0
} {}
struct BallPlayerMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BallPlayerMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BallPlayerMessageDefaultTypeInternal() {}
  union {
    BallPlayerMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BallPlayerMessageDefaultTypeInternal _BallPlayerMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Say::Say(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SayDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SayDefaultTypeInternal() {}
  union {
    Say _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SayDefaultTypeInternal _Say_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PointTo::PointTo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/ 0

  , /*decltype(_impl_.y_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PointToDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointToDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointToDefaultTypeInternal() {}
  union {
    PointTo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointToDefaultTypeInternal _PointTo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PointToOf::PointToOf(
    ::_pbi::ConstantInitialized) {}
struct PointToOfDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointToOfDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointToOfDefaultTypeInternal() {}
  union {
    PointToOf _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointToOfDefaultTypeInternal _PointToOf_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AttentionTo::AttentionTo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.side_)*/ 0

  , /*decltype(_impl_.unum_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AttentionToDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttentionToDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttentionToDefaultTypeInternal() {}
  union {
    AttentionTo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttentionToDefaultTypeInternal _AttentionTo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AttentionToOf::AttentionToOf(
    ::_pbi::ConstantInitialized) {}
struct AttentionToOfDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttentionToOfDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttentionToOfDefaultTypeInternal() {}
  union {
    AttentionToOf _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttentionToOfDefaultTypeInternal _AttentionToOf_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddText::AddText(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.level_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AddTextDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddTextDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddTextDefaultTypeInternal() {}
  union {
    AddText _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddTextDefaultTypeInternal _AddText_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddPoint::AddPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.point_)*/nullptr
  , /*decltype(_impl_.level_)*/ 0
} {}
struct AddPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddPointDefaultTypeInternal() {}
  union {
    AddPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddPointDefaultTypeInternal _AddPoint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddLine::AddLine(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.start_)*/nullptr
  , /*decltype(_impl_.end_)*/nullptr
  , /*decltype(_impl_.level_)*/ 0
} {}
struct AddLineDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddLineDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddLineDefaultTypeInternal() {}
  union {
    AddLine _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddLineDefaultTypeInternal _AddLine_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddArc::AddArc(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.center_)*/nullptr
  , /*decltype(_impl_.level_)*/ 0

  , /*decltype(_impl_.radius_)*/ 0

  , /*decltype(_impl_.start_angle_)*/ 0

  , /*decltype(_impl_.span_angel_)*/ 0
} {}
struct AddArcDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddArcDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddArcDefaultTypeInternal() {}
  union {
    AddArc _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddArcDefaultTypeInternal _AddArc_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddCircle::AddCircle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.center_)*/nullptr
  , /*decltype(_impl_.level_)*/ 0

  , /*decltype(_impl_.radius_)*/ 0

  , /*decltype(_impl_.fill_)*/ false
} {}
struct AddCircleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddCircleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddCircleDefaultTypeInternal() {}
  union {
    AddCircle _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddCircleDefaultTypeInternal _AddCircle_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddTriangle::AddTriangle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.point1_)*/nullptr
  , /*decltype(_impl_.point2_)*/nullptr
  , /*decltype(_impl_.point3_)*/nullptr
  , /*decltype(_impl_.level_)*/ 0

  , /*decltype(_impl_.fill_)*/ false
} {}
struct AddTriangleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddTriangleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddTriangleDefaultTypeInternal() {}
  union {
    AddTriangle _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddTriangleDefaultTypeInternal _AddTriangle_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddRectangle::AddRectangle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.color_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.level_)*/ 0

  , /*decltype(_impl_.left_)*/ 0

  , /*decltype(_impl_.top_)*/ 0

  , /*decltype(_impl_.length_)*/ 0

  , /*decltype(_impl_.width_)*/ 0

  , /*decltype(_impl_.fill_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AddRectangleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddRectangleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddRectangleDefaultTypeInternal() {}
  union {
    AddRectangle _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddRectangleDefaultTypeInternal _AddRectangle_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddSector::AddSector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.center_)*/nullptr
  , /*decltype(_impl_.level_)*/ 0

  , /*decltype(_impl_.min_radius_)*/ 0

  , /*decltype(_impl_.max_radius_)*/ 0

  , /*decltype(_impl_.start_angle_)*/ 0

  , /*decltype(_impl_.span_angel_)*/ 0

  , /*decltype(_impl_.fill_)*/ false
} {}
struct AddSectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddSectorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddSectorDefaultTypeInternal() {}
  union {
    AddSector _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddSectorDefaultTypeInternal _AddSector_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddMessage::AddMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.color_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.level_)*/ 0
} {}
struct AddMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddMessageDefaultTypeInternal() {}
  union {
    AddMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddMessageDefaultTypeInternal _AddMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Log::Log(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.log_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct LogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogDefaultTypeInternal() {}
  union {
    Log _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogDefaultTypeInternal _Log_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DebugClient::DebugClient(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DebugClientDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DebugClientDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DebugClientDefaultTypeInternal() {}
  union {
    DebugClient _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DebugClientDefaultTypeInternal _DebugClient_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Action::Action(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.action_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActionDefaultTypeInternal() {}
  union {
    Action _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionDefaultTypeInternal _Action_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Actions::Actions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.actions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ActionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActionsDefaultTypeInternal() {}
  union {
    Actions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionsDefaultTypeInternal _Actions_default_instance_;
}  // namespace protos
static ::_pb::Metadata file_level_metadata_service_2eproto[58];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_service_2eproto[5];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_service_2eproto = nullptr;
const ::uint32_t TableStruct_service_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Vector2D, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Vector2D, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::protos::Vector2D, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::protos::Vector2D, _impl_.dist_),
    PROTOBUF_FIELD_OFFSET(::protos::Vector2D, _impl_.angle_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.relative_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.seen_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.heard_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.seen_velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.heard_velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.seen_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.heard_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.seen_vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.heard_vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.lost_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.ghost_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.dist_from_self_),
    PROTOBUF_FIELD_OFFSET(::protos::Ball, _impl_.angle_from_self_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.seen_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.heard_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.seen_velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.seen_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.heard_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.seen_vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.ghost_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.dist_from_self_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.angle_from_self_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.side_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.uniform_number_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.is_goalie_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.body_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.body_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.face_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.face_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.point_to_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.point_to_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.is_kicking_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.dist_from_ball_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.angle_from_ball_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.ball_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::Player, _impl_.is_tackling_),
    0,
    1,
    2,
    3,
    4,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.seen_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.heard_position_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.seen_velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.seen_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.heard_pos_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.seen_vel_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.ghost_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.side_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.uniform_number_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.is_goalie_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.body_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.body_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.face_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.face_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.point_to_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.point_to_direction_count_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.is_kicking_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.dist_from_ball_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.angle_from_ball_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.ball_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.is_tackling_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.relative_neck_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.stamina_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.is_kickable_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.catch_probability_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.tackle_probability_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.foul_probability_),
    PROTOBUF_FIELD_OFFSET(::protos::Self, _impl_.view_width_),
    0,
    1,
    2,
    3,
    4,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.action_type_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.turn_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.turn_angle_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.dash_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.dash_power_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.dash_dir_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.final_self_position_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.final_ball_dist_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.final_stamina_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptInfo, _impl_.value_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.self_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.first_teammate_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.second_teammate_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.first_opponent_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.second_opponent_reach_steps_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.first_teammate_id_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.second_teammate_id_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.first_opponent_id_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.second_opponent_id_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptTable, _impl_.self_intercept_info_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_OurPlayersDictEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_OurPlayersDictEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_OurPlayersDictEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_OurPlayersDictEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_TheirPlayersDictEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_TheirPlayersDictEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_TheirPlayersDictEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel_TheirPlayersDictEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.intercept_table_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.our_team_name_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.their_team_name_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.our_side_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.last_set_play_start_time_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.self_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.ball_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.teammates_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.opponents_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.unknowns_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.our_players_dict_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.their_players_dict_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.our_goalie_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.their_goalie_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.offside_line_x_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.ofside_line_x_count_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.kickable_teammate_id_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.kickable_opponent_id_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.last_kick_side_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.last_kicker_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.cycle_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.game_mode_type_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.left_team_score_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.right_team_score_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.is_our_set_play_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.is_their_set_play_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.stoped_cycle_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.our_team_score_),
    PROTOBUF_FIELD_OFFSET(::protos::WorldModel, _impl_.their_team_score_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    1,
    2,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::State, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::State, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::State, _impl_.world_model_),
    PROTOBUF_FIELD_OFFSET(::protos::State, _impl_.full_world_model_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Dash, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Dash, _impl_.power_),
    PROTOBUF_FIELD_OFFSET(::protos::Dash, _impl_.relative_direction_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Turn, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Turn, _impl_.relative_direction_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Kick, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Kick, _impl_.power_),
    PROTOBUF_FIELD_OFFSET(::protos::Kick, _impl_.relative_direction_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Tackle, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Tackle, _impl_.power_or_dir_),
    PROTOBUF_FIELD_OFFSET(::protos::Tackle, _impl_.foul_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Catch, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Move, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Move, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::protos::Move, _impl_.y_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::TurnNeck, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::TurnNeck, _impl_.moment_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::ChangeView, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::ChangeView, _impl_.view_width_),
    PROTOBUF_FIELD_OFFSET(::protos::BallMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::BallMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::BallMessage, _impl_.ball_position_),
    PROTOBUF_FIELD_OFFSET(::protos::BallMessage, _impl_.ball_velocity_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::protos::PassMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::PassMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::PassMessage, _impl_.receiver_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::PassMessage, _impl_.receiver_point_),
    PROTOBUF_FIELD_OFFSET(::protos::PassMessage, _impl_.ball_position_),
    PROTOBUF_FIELD_OFFSET(::protos::PassMessage, _impl_.ball_velocity_),
    ~0u,
    0,
    1,
    2,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::InterceptMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::InterceptMessage, _impl_.our_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptMessage, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::InterceptMessage, _impl_.cycle_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::GoalieMessage, _impl_.goalie_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieMessage, _impl_.goalie_position_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieMessage, _impl_.goalie_body_direction_),
    ~0u,
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::GoalieAndPlayerMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieAndPlayerMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::GoalieAndPlayerMessage, _impl_.goalie_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieAndPlayerMessage, _impl_.goalie_position_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieAndPlayerMessage, _impl_.goalie_body_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieAndPlayerMessage, _impl_.player_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::GoalieAndPlayerMessage, _impl_.player_position_),
    ~0u,
    0,
    ~0u,
    ~0u,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::OffsideLineMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::OffsideLineMessage, _impl_.offside_line_x_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::DefenseLineMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::DefenseLineMessage, _impl_.defense_line_x_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::WaitRequestMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::SetplayMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::SetplayMessage, _impl_.wait_step_),
    PROTOBUF_FIELD_OFFSET(::protos::PassRequestMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::PassRequestMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::PassRequestMessage, _impl_.target_point_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::StaminaMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::StaminaMessage, _impl_.stamina_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::RecoveryMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::RecoveryMessage, _impl_.recovery_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::StaminaCapacityMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::StaminaCapacityMessage, _impl_.stamina_capacity_),
    PROTOBUF_FIELD_OFFSET(::protos::DribbleMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::DribbleMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::DribbleMessage, _impl_.target_point_),
    PROTOBUF_FIELD_OFFSET(::protos::DribbleMessage, _impl_.queue_count_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::BallGoalieMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::BallGoalieMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::BallGoalieMessage, _impl_.ball_position_),
    PROTOBUF_FIELD_OFFSET(::protos::BallGoalieMessage, _impl_.ball_velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::BallGoalieMessage, _impl_.goalie_position_),
    PROTOBUF_FIELD_OFFSET(::protos::BallGoalieMessage, _impl_.goalie_body_direction_),
    0,
    1,
    2,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::OnePlayerMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::OnePlayerMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::OnePlayerMessage, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::OnePlayerMessage, _impl_.position_),
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::protos::TwoPlayerMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::TwoPlayerMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::TwoPlayerMessage, _impl_.first_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::TwoPlayerMessage, _impl_.first_position_),
    PROTOBUF_FIELD_OFFSET(::protos::TwoPlayerMessage, _impl_.second_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::TwoPlayerMessage, _impl_.second_position_),
    ~0u,
    0,
    ~0u,
    1,
    PROTOBUF_FIELD_OFFSET(::protos::ThreePlayerMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::ThreePlayerMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::ThreePlayerMessage, _impl_.first_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::ThreePlayerMessage, _impl_.first_position_),
    PROTOBUF_FIELD_OFFSET(::protos::ThreePlayerMessage, _impl_.second_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::ThreePlayerMessage, _impl_.second_position_),
    PROTOBUF_FIELD_OFFSET(::protos::ThreePlayerMessage, _impl_.third_uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::ThreePlayerMessage, _impl_.third_position_),
    ~0u,
    0,
    ~0u,
    1,
    ~0u,
    2,
    PROTOBUF_FIELD_OFFSET(::protos::SelfMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::SelfMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::SelfMessage, _impl_.self_position_),
    PROTOBUF_FIELD_OFFSET(::protos::SelfMessage, _impl_.self_body_direction_),
    PROTOBUF_FIELD_OFFSET(::protos::SelfMessage, _impl_.self_stamina_),
    0,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::TeammateMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::TeammateMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::TeammateMessage, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::TeammateMessage, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::TeammateMessage, _impl_.body_direction_),
    ~0u,
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::OpponentMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::OpponentMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::OpponentMessage, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::OpponentMessage, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::OpponentMessage, _impl_.body_direction_),
    ~0u,
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::BallPlayerMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::BallPlayerMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::BallPlayerMessage, _impl_.ball_position_),
    PROTOBUF_FIELD_OFFSET(::protos::BallPlayerMessage, _impl_.ball_velocity_),
    PROTOBUF_FIELD_OFFSET(::protos::BallPlayerMessage, _impl_.uniform_number_),
    PROTOBUF_FIELD_OFFSET(::protos::BallPlayerMessage, _impl_.player_position_),
    PROTOBUF_FIELD_OFFSET(::protos::BallPlayerMessage, _impl_.body_direction_),
    0,
    1,
    ~0u,
    2,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Say, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::protos::Say, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::protos::Say, _impl_.message_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::PointTo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::PointTo, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::protos::PointTo, _impl_.y_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::PointToOf, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::AttentionTo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AttentionTo, _impl_.side_),
    PROTOBUF_FIELD_OFFSET(::protos::AttentionTo, _impl_.unum_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::AttentionToOf, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::AddText, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddText, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddText, _impl_.message_),
    PROTOBUF_FIELD_OFFSET(::protos::AddPoint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::AddPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddPoint, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddPoint, _impl_.point_),
    PROTOBUF_FIELD_OFFSET(::protos::AddPoint, _impl_.color_),
    ~0u,
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::AddLine, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::AddLine, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddLine, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddLine, _impl_.start_),
    PROTOBUF_FIELD_OFFSET(::protos::AddLine, _impl_.end_),
    PROTOBUF_FIELD_OFFSET(::protos::AddLine, _impl_.color_),
    ~0u,
    0,
    1,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::AddArc, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::AddArc, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddArc, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddArc, _impl_.center_),
    PROTOBUF_FIELD_OFFSET(::protos::AddArc, _impl_.radius_),
    PROTOBUF_FIELD_OFFSET(::protos::AddArc, _impl_.start_angle_),
    PROTOBUF_FIELD_OFFSET(::protos::AddArc, _impl_.span_angel_),
    PROTOBUF_FIELD_OFFSET(::protos::AddArc, _impl_.color_),
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::AddCircle, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::AddCircle, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddCircle, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddCircle, _impl_.center_),
    PROTOBUF_FIELD_OFFSET(::protos::AddCircle, _impl_.radius_),
    PROTOBUF_FIELD_OFFSET(::protos::AddCircle, _impl_.color_),
    PROTOBUF_FIELD_OFFSET(::protos::AddCircle, _impl_.fill_),
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::AddTriangle, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::AddTriangle, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddTriangle, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddTriangle, _impl_.point1_),
    PROTOBUF_FIELD_OFFSET(::protos::AddTriangle, _impl_.point2_),
    PROTOBUF_FIELD_OFFSET(::protos::AddTriangle, _impl_.point3_),
    PROTOBUF_FIELD_OFFSET(::protos::AddTriangle, _impl_.color_),
    PROTOBUF_FIELD_OFFSET(::protos::AddTriangle, _impl_.fill_),
    ~0u,
    0,
    1,
    2,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::AddRectangle, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddRectangle, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddRectangle, _impl_.left_),
    PROTOBUF_FIELD_OFFSET(::protos::AddRectangle, _impl_.top_),
    PROTOBUF_FIELD_OFFSET(::protos::AddRectangle, _impl_.length_),
    PROTOBUF_FIELD_OFFSET(::protos::AddRectangle, _impl_.width_),
    PROTOBUF_FIELD_OFFSET(::protos::AddRectangle, _impl_.color_),
    PROTOBUF_FIELD_OFFSET(::protos::AddRectangle, _impl_.fill_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_.center_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_.min_radius_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_.max_radius_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_.start_angle_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_.span_angel_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_.color_),
    PROTOBUF_FIELD_OFFSET(::protos::AddSector, _impl_.fill_),
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::protos::AddMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::protos::AddMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::AddMessage, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::protos::AddMessage, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::protos::AddMessage, _impl_.message_),
    PROTOBUF_FIELD_OFFSET(::protos::AddMessage, _impl_.color_),
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Log, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::protos::Log, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::protos::Log, _impl_.log_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::DebugClient, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::DebugClient, _impl_.message_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Action, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::protos::Action, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::protos::Action, _impl_.action_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::protos::Actions, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::protos::Actions, _impl_.actions_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::protos::Vector2D)},
        { 12, 37, -1, sizeof(::protos::Ball)},
        { 54, 91, -1, sizeof(::protos::Player)},
        { 120, 162, -1, sizeof(::protos::Self)},
        { 196, 214, -1, sizeof(::protos::InterceptInfo)},
        { 224, -1, -1, sizeof(::protos::InterceptTable)},
        { 242, 252, -1, sizeof(::protos::WorldModel_OurPlayersDictEntry_DoNotUse)},
        { 254, 264, -1, sizeof(::protos::WorldModel_TheirPlayersDictEntry_DoNotUse)},
        { 266, 303, -1, sizeof(::protos::WorldModel)},
        { 332, 342, -1, sizeof(::protos::State)},
        { 344, -1, -1, sizeof(::protos::Dash)},
        { 354, -1, -1, sizeof(::protos::Turn)},
        { 363, -1, -1, sizeof(::protos::Kick)},
        { 373, -1, -1, sizeof(::protos::Tackle)},
        { 383, -1, -1, sizeof(::protos::Catch)},
        { 391, -1, -1, sizeof(::protos::Move)},
        { 401, -1, -1, sizeof(::protos::TurnNeck)},
        { 410, -1, -1, sizeof(::protos::ChangeView)},
        { 419, 429, -1, sizeof(::protos::BallMessage)},
        { 431, 443, -1, sizeof(::protos::PassMessage)},
        { 447, -1, -1, sizeof(::protos::InterceptMessage)},
        { 458, 469, -1, sizeof(::protos::GoalieMessage)},
        { 472, 485, -1, sizeof(::protos::GoalieAndPlayerMessage)},
        { 490, -1, -1, sizeof(::protos::OffsideLineMessage)},
        { 499, -1, -1, sizeof(::protos::DefenseLineMessage)},
        { 508, -1, -1, sizeof(::protos::WaitRequestMessage)},
        { 516, -1, -1, sizeof(::protos::SetplayMessage)},
        { 525, 534, -1, sizeof(::protos::PassRequestMessage)},
        { 535, -1, -1, sizeof(::protos::StaminaMessage)},
        { 544, -1, -1, sizeof(::protos::RecoveryMessage)},
        { 553, -1, -1, sizeof(::protos::StaminaCapacityMessage)},
        { 562, 572, -1, sizeof(::protos::DribbleMessage)},
        { 574, 586, -1, sizeof(::protos::BallGoalieMessage)},
        { 590, 600, -1, sizeof(::protos::OnePlayerMessage)},
        { 602, 614, -1, sizeof(::protos::TwoPlayerMessage)},
        { 618, 632, -1, sizeof(::protos::ThreePlayerMessage)},
        { 638, 649, -1, sizeof(::protos::SelfMessage)},
        { 652, 663, -1, sizeof(::protos::TeammateMessage)},
        { 666, 677, -1, sizeof(::protos::OpponentMessage)},
        { 680, 693, -1, sizeof(::protos::BallPlayerMessage)},
        { 698, -1, -1, sizeof(::protos::Say)},
        { 729, -1, -1, sizeof(::protos::PointTo)},
        { 739, -1, -1, sizeof(::protos::PointToOf)},
        { 747, -1, -1, sizeof(::protos::AttentionTo)},
        { 757, -1, -1, sizeof(::protos::AttentionToOf)},
        { 765, -1, -1, sizeof(::protos::AddText)},
        { 775, 786, -1, sizeof(::protos::AddPoint)},
        { 789, 801, -1, sizeof(::protos::AddLine)},
        { 805, 819, -1, sizeof(::protos::AddArc)},
        { 825, 838, -1, sizeof(::protos::AddCircle)},
        { 843, 857, -1, sizeof(::protos::AddTriangle)},
        { 863, -1, -1, sizeof(::protos::AddRectangle)},
        { 878, 894, -1, sizeof(::protos::AddSector)},
        { 902, 914, -1, sizeof(::protos::AddMessage)},
        { 918, -1, -1, sizeof(::protos::Log)},
        { 936, -1, -1, sizeof(::protos::DebugClient)},
        { 945, -1, -1, sizeof(::protos::Action)},
        { 969, -1, -1, sizeof(::protos::Actions)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::protos::_Vector2D_default_instance_._instance,
    &::protos::_Ball_default_instance_._instance,
    &::protos::_Player_default_instance_._instance,
    &::protos::_Self_default_instance_._instance,
    &::protos::_InterceptInfo_default_instance_._instance,
    &::protos::_InterceptTable_default_instance_._instance,
    &::protos::_WorldModel_OurPlayersDictEntry_DoNotUse_default_instance_._instance,
    &::protos::_WorldModel_TheirPlayersDictEntry_DoNotUse_default_instance_._instance,
    &::protos::_WorldModel_default_instance_._instance,
    &::protos::_State_default_instance_._instance,
    &::protos::_Dash_default_instance_._instance,
    &::protos::_Turn_default_instance_._instance,
    &::protos::_Kick_default_instance_._instance,
    &::protos::_Tackle_default_instance_._instance,
    &::protos::_Catch_default_instance_._instance,
    &::protos::_Move_default_instance_._instance,
    &::protos::_TurnNeck_default_instance_._instance,
    &::protos::_ChangeView_default_instance_._instance,
    &::protos::_BallMessage_default_instance_._instance,
    &::protos::_PassMessage_default_instance_._instance,
    &::protos::_InterceptMessage_default_instance_._instance,
    &::protos::_GoalieMessage_default_instance_._instance,
    &::protos::_GoalieAndPlayerMessage_default_instance_._instance,
    &::protos::_OffsideLineMessage_default_instance_._instance,
    &::protos::_DefenseLineMessage_default_instance_._instance,
    &::protos::_WaitRequestMessage_default_instance_._instance,
    &::protos::_SetplayMessage_default_instance_._instance,
    &::protos::_PassRequestMessage_default_instance_._instance,
    &::protos::_StaminaMessage_default_instance_._instance,
    &::protos::_RecoveryMessage_default_instance_._instance,
    &::protos::_StaminaCapacityMessage_default_instance_._instance,
    &::protos::_DribbleMessage_default_instance_._instance,
    &::protos::_BallGoalieMessage_default_instance_._instance,
    &::protos::_OnePlayerMessage_default_instance_._instance,
    &::protos::_TwoPlayerMessage_default_instance_._instance,
    &::protos::_ThreePlayerMessage_default_instance_._instance,
    &::protos::_SelfMessage_default_instance_._instance,
    &::protos::_TeammateMessage_default_instance_._instance,
    &::protos::_OpponentMessage_default_instance_._instance,
    &::protos::_BallPlayerMessage_default_instance_._instance,
    &::protos::_Say_default_instance_._instance,
    &::protos::_PointTo_default_instance_._instance,
    &::protos::_PointToOf_default_instance_._instance,
    &::protos::_AttentionTo_default_instance_._instance,
    &::protos::_AttentionToOf_default_instance_._instance,
    &::protos::_AddText_default_instance_._instance,
    &::protos::_AddPoint_default_instance_._instance,
    &::protos::_AddLine_default_instance_._instance,
    &::protos::_AddArc_default_instance_._instance,
    &::protos::_AddCircle_default_instance_._instance,
    &::protos::_AddTriangle_default_instance_._instance,
    &::protos::_AddRectangle_default_instance_._instance,
    &::protos::_AddSector_default_instance_._instance,
    &::protos::_AddMessage_default_instance_._instance,
    &::protos::_Log_default_instance_._instance,
    &::protos::_DebugClient_default_instance_._instance,
    &::protos::_Action_default_instance_._instance,
    &::protos::_Actions_default_instance_._instance,
};
const char descriptor_table_protodef_service_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\rservice.proto\022\006protos\"=\n\010Vector2D\022\t\n\001x"
    "\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\014\n\004dist\030\003 \001(\002\022\r\n\005angle"
    "\030\004 \001(\002\"\203\004\n\004Ball\022\"\n\010position\030\001 \001(\0132\020.prot"
    "os.Vector2D\022+\n\021relative_position\030\002 \001(\0132\020"
    ".protos.Vector2D\022\'\n\rseen_position\030\003 \001(\0132"
    "\020.protos.Vector2D\022(\n\016heard_position\030\004 \001("
    "\0132\020.protos.Vector2D\022\"\n\010velocity\030\005 \001(\0132\020."
    "protos.Vector2D\022\'\n\rseen_velocity\030\006 \001(\0132\020"
    ".protos.Vector2D\022(\n\016heard_velocity\030\007 \001(\013"
    "2\020.protos.Vector2D\022\021\n\tpos_count\030\010 \001(\005\022\026\n"
    "\016seen_pos_count\030\t \001(\005\022\027\n\017heard_pos_count"
    "\030\n \001(\005\022\021\n\tvel_count\030\013 \001(\005\022\026\n\016seen_vel_co"
    "unt\030\014 \001(\005\022\027\n\017heard_vel_count\030\r \001(\005\022\022\n\nlo"
    "st_count\030\016 \001(\005\022\023\n\013ghost_count\030\017 \001(\005\022\026\n\016d"
    "ist_from_self\030\020 \001(\002\022\027\n\017angle_from_self\030\021"
    " \001(\002\"\220\006\n\006Player\022\"\n\010position\030\001 \001(\0132\020.prot"
    "os.Vector2D\022\'\n\rseen_position\030\002 \001(\0132\020.pro"
    "tos.Vector2D\022(\n\016heard_position\030\003 \001(\0132\020.p"
    "rotos.Vector2D\022\"\n\010velocity\030\004 \001(\0132\020.proto"
    "s.Vector2D\022\'\n\rseen_velocity\030\005 \001(\0132\020.prot"
    "os.Vector2D\022\021\n\tpos_count\030\006 \001(\005\022\026\n\016seen_p"
    "os_count\030\007 \001(\005\022\027\n\017heard_pos_count\030\010 \001(\005\022"
    "\021\n\tvel_count\030\t \001(\005\022\026\n\016seen_vel_count\030\n \001"
    "(\005\022\023\n\013ghost_count\030\013 \001(\005\022\026\n\016dist_from_sel"
    "f\030\014 \001(\002\022\027\n\017angle_from_self\030\r \001(\002\022\n\n\002id\030\016"
    " \001(\005\022\032\n\004side\030\017 \001(\0162\014.protos.Side\022\026\n\016unif"
    "orm_number\030\020 \001(\005\022\034\n\024uniform_number_count"
    "\030\021 \001(\005\022\021\n\tis_goalie\030\022 \001(\010\022\026\n\016body_direct"
    "ion\030\023 \001(\002\022\034\n\024body_direction_count\030\024 \001(\005\022"
    "\026\n\016face_direction\030\025 \001(\002\022\034\n\024face_directio"
    "n_count\030\026 \001(\005\022\032\n\022point_to_direction\030\027 \001("
    "\002\022 \n\030point_to_direction_count\030\030 \001(\005\022\022\n\ni"
    "s_kicking\030\031 \001(\010\022\026\n\016dist_from_ball\030\032 \001(\002\022"
    "\027\n\017angle_from_ball\030\033 \001(\002\022\030\n\020ball_reach_s"
    "teps\030\034 \001(\005\022\023\n\013is_tackling\030\035 \001(\010\"\234\007\n\004Self"
    "\022\"\n\010position\030\001 \001(\0132\020.protos.Vector2D\022\'\n\r"
    "seen_position\030\002 \001(\0132\020.protos.Vector2D\022(\n"
    "\016heard_position\030\003 \001(\0132\020.protos.Vector2D\022"
    "\"\n\010velocity\030\004 \001(\0132\020.protos.Vector2D\022\'\n\rs"
    "een_velocity\030\005 \001(\0132\020.protos.Vector2D\022\021\n\t"
    "pos_count\030\006 \001(\005\022\026\n\016seen_pos_count\030\007 \001(\005\022"
    "\027\n\017heard_pos_count\030\010 \001(\005\022\021\n\tvel_count\030\t "
    "\001(\005\022\026\n\016seen_vel_count\030\n \001(\005\022\023\n\013ghost_cou"
    "nt\030\013 \001(\005\022\n\n\002id\030\014 \001(\005\022\032\n\004side\030\r \001(\0162\014.pro"
    "tos.Side\022\026\n\016uniform_number\030\016 \001(\005\022\034\n\024unif"
    "orm_number_count\030\017 \001(\005\022\021\n\tis_goalie\030\020 \001("
    "\010\022\026\n\016body_direction\030\021 \001(\002\022\034\n\024body_direct"
    "ion_count\030\022 \001(\005\022\026\n\016face_direction\030\023 \001(\002\022"
    "\034\n\024face_direction_count\030\024 \001(\005\022\032\n\022point_t"
    "o_direction\030\025 \001(\002\022 \n\030point_to_direction_"
    "count\030\026 \001(\005\022\022\n\nis_kicking\030\027 \001(\010\022\026\n\016dist_"
    "from_ball\030\030 \001(\002\022\027\n\017angle_from_ball\030\031 \001(\002"
    "\022\030\n\020ball_reach_steps\030\032 \001(\005\022\023\n\013is_tacklin"
    "g\030\033 \001(\010\022\037\n\027relative_neck_direction\030\034 \001(\002"
    "\022\017\n\007stamina\030\035 \001(\002\022\023\n\013is_kickable\030\036 \001(\010\022\031"
    "\n\021catch_probability\030\037 \001(\002\022\032\n\022tackle_prob"
    "ability\030  \001(\002\022\030\n\020foul_probability\030! \001(\002\022"
    "%\n\nview_width\030\" \001(\0162\021.protos.ViewWidth\"\221"
    "\002\n\rInterceptInfo\0220\n\013action_type\030\001 \001(\0162\033."
    "protos.InterceptActionType\022\022\n\nturn_steps"
    "\030\002 \001(\005\022\022\n\nturn_angle\030\003 \001(\002\022\022\n\ndash_steps"
    "\030\004 \001(\005\022\022\n\ndash_power\030\005 \001(\002\022\020\n\010dash_dir\030\006"
    " \001(\002\022-\n\023final_self_position\030\007 \001(\0132\020.prot"
    "os.Vector2D\022\027\n\017final_ball_dist\030\010 \001(\002\022\025\n\r"
    "final_stamina\030\t \001(\002\022\r\n\005value\030\n \001(\002\"\336\002\n\016I"
    "nterceptTable\022\030\n\020self_reach_steps\030\001 \001(\005\022"
    "\"\n\032first_teammate_reach_steps\030\002 \001(\005\022#\n\033s"
    "econd_teammate_reach_steps\030\003 \001(\005\022\"\n\032firs"
    "t_opponent_reach_steps\030\004 \001(\005\022#\n\033second_o"
    "pponent_reach_steps\030\005 \001(\005\022\031\n\021first_teamm"
    "ate_id\030\006 \001(\005\022\032\n\022second_teammate_id\030\007 \001(\005"
    "\022\031\n\021first_opponent_id\030\010 \001(\005\022\032\n\022second_op"
    "ponent_id\030\t \001(\005\0222\n\023self_intercept_info\030\n"
    " \003(\0132\025.protos.InterceptInfo\"\326\010\n\nWorldMod"
    "el\022/\n\017intercept_table\030\001 \001(\0132\026.protos.Int"
    "erceptTable\022\025\n\rour_team_name\030\002 \001(\t\022\027\n\017th"
    "eir_team_name\030\003 \001(\t\022\036\n\010our_side\030\004 \001(\0162\014."
    "protos.Side\022 \n\030last_set_play_start_time\030"
    "\005 \001(\005\022\032\n\004self\030\006 \001(\0132\014.protos.Self\022\032\n\004bal"
    "l\030\007 \001(\0132\014.protos.Ball\022!\n\tteammates\030\010 \003(\013"
    "2\016.protos.Player\022!\n\topponents\030\t \003(\0132\016.pr"
    "otos.Player\022 \n\010unknowns\030\n \003(\0132\016.protos.P"
    "layer\022@\n\020our_players_dict\030\013 \003(\0132&.protos"
    ".WorldModel.OurPlayersDictEntry\022D\n\022their"
    "_players_dict\030\014 \003(\0132(.protos.WorldModel."
    "TheirPlayersDictEntry\022!\n\031our_goalie_unif"
    "orm_number\030\r \001(\005\022#\n\033their_goalie_uniform"
    "_number\030\016 \001(\005\022\026\n\016offside_line_x\030\017 \001(\002\022\033\n"
    "\023ofside_line_x_count\030\020 \001(\005\022\034\n\024kickable_t"
    "eammate_id\030\021 \001(\005\022\034\n\024kickable_opponent_id"
    "\030\022 \001(\005\022$\n\016last_kick_side\030\023 \001(\0162\014.protos."
    "Side\022\"\n\032last_kicker_uniform_number\030\024 \001(\005"
    "\022\r\n\005cycle\030\025 \001(\005\022,\n\016game_mode_type\030\026 \001(\0162"
    "\024.protos.GameModeType\022\027\n\017left_team_score"
    "\030\027 \001(\005\022\030\n\020right_team_score\030\030 \001(\005\022\027\n\017is_o"
    "ur_set_play\030\031 \001(\010\022\031\n\021is_their_set_play\030\032"
    " \001(\010\022\024\n\014stoped_cycle\030\033 \001(\005\022\026\n\016our_team_s"
    "core\030\034 \001(\005\022\030\n\020their_team_score\030\035 \001(\005\032E\n\023"
    "OurPlayersDictEntry\022\013\n\003key\030\001 \001(\005\022\035\n\005valu"
    "e\030\002 \001(\0132\016.protos.Player:\0028\001\032G\n\025TheirPlay"
    "ersDictEntry\022\013\n\003key\030\001 \001(\005\022\035\n\005value\030\002 \001(\013"
    "2\016.protos.Player:\0028\001\"^\n\005State\022\'\n\013world_m"
    "odel\030\001 \001(\0132\022.protos.WorldModel\022,\n\020full_w"
    "orld_model\030\002 \001(\0132\022.protos.WorldModel\"1\n\004"
    "Dash\022\r\n\005power\030\001 \001(\002\022\032\n\022relative_directio"
    "n\030\002 \001(\002\"\"\n\004Turn\022\032\n\022relative_direction\030\001 "
    "\001(\002\"1\n\004Kick\022\r\n\005power\030\001 \001(\002\022\032\n\022relative_d"
    "irection\030\002 \001(\002\",\n\006Tackle\022\024\n\014power_or_dir"
    "\030\001 \001(\002\022\014\n\004foul\030\002 \001(\010\"\007\n\005Catch\"\034\n\004Move\022\t\n"
    "\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\"\032\n\010TurnNeck\022\016\n\006momen"
    "t\030\001 \001(\002\"3\n\nChangeView\022%\n\nview_width\030\001 \001("
    "\0162\021.protos.ViewWidth\"_\n\013BallMessage\022\'\n\rb"
    "all_position\030\001 \001(\0132\020.protos.Vector2D\022\'\n\r"
    "ball_velocity\030\002 \001(\0132\020.protos.Vector2D\"\252\001"
    "\n\013PassMessage\022\037\n\027receiver_uniform_number"
    "\030\001 \001(\005\022(\n\016receiver_point\030\002 \001(\0132\020.protos."
    "Vector2D\022\'\n\rball_position\030\003 \001(\0132\020.protos"
    ".Vector2D\022\'\n\rball_velocity\030\004 \001(\0132\020.proto"
    "s.Vector2D\"F\n\020InterceptMessage\022\013\n\003our\030\001 "
    "\001(\010\022\026\n\016uniform_number\030\002 \001(\005\022\r\n\005cycle\030\003 \001"
    "(\005\"x\n\rGoalieMessage\022\035\n\025goalie_uniform_nu"
    "mber\030\001 \001(\005\022)\n\017goalie_position\030\002 \001(\0132\020.pr"
    "otos.Vector2D\022\035\n\025goalie_body_direction\030\003"
    " \001(\002\"\313\001\n\026GoalieAndPlayerMessage\022\035\n\025goali"
    "e_uniform_number\030\001 \001(\005\022)\n\017goalie_positio"
    "n\030\002 \001(\0132\020.protos.Vector2D\022\035\n\025goalie_body"
    "_direction\030\003 \001(\002\022\035\n\025player_uniform_numbe"
    "r\030\004 \001(\005\022)\n\017player_position\030\005 \001(\0132\020.proto"
    "s.Vector2D\",\n\022OffsideLineMessage\022\026\n\016offs"
    "ide_line_x\030\001 \001(\002\",\n\022DefenseLineMessage\022\026"
    "\n\016defense_line_x\030\001 \001(\002\"\024\n\022WaitRequestMes"
    "sage\"#\n\016SetplayMessage\022\021\n\twait_step\030\001 \001("
    "\005\"<\n\022PassRequestMessage\022&\n\014target_point\030"
    "\001 \001(\0132\020.protos.Vector2D\"!\n\016StaminaMessag"
    "e\022\017\n\007stamina\030\001 \001(\002\"#\n\017RecoveryMessage\022\020\n"
    "\010recovery\030\001 \001(\002\"2\n\026StaminaCapacityMessag"
    "e\022\030\n\020stamina_capacity\030\001 \001(\002\"M\n\016DribbleMe"
    "ssage\022&\n\014target_point\030\001 \001(\0132\020.protos.Vec"
    "tor2D\022\023\n\013queue_count\030\002 \001(\005\"\257\001\n\021BallGoali"
    "eMessage\022\'\n\rball_position\030\001 \001(\0132\020.protos"
    ".Vector2D\022\'\n\rball_velocity\030\002 \001(\0132\020.proto"
    "s.Vector2D\022)\n\017goalie_position\030\003 \001(\0132\020.pr"
    "otos.Vector2D\022\035\n\025goalie_body_direction\030\004"
    " \001(\002\"N\n\020OnePlayerMessage\022\026\n\016uniform_numb"
    "er\030\001 \001(\005\022\"\n\010position\030\002 \001(\0132\020.protos.Vect"
    "or2D\"\244\001\n\020TwoPlayerMessage\022\034\n\024first_unifo"
    "rm_number\030\001 \001(\005\022(\n\016first_position\030\002 \001(\0132"
    "\020.protos.Vector2D\022\035\n\025second_uniform_numb"
    "er\030\003 \001(\005\022)\n\017second_position\030\004 \001(\0132\020.prot"
    "os.Vector2D\"\356\001\n\022ThreePlayerMessage\022\034\n\024fi"
    "rst_uniform_number\030\001 \001(\005\022(\n\016first_positi"
    "on\030\002 \001(\0132\020.protos.Vector2D\022\035\n\025second_uni"
    "form_number\030\003 \001(\005\022)\n\017second_position\030\004 \001"
    "(\0132\020.protos.Vector2D\022\034\n\024third_uniform_nu"
    "mber\030\005 \001(\005\022(\n\016third_position\030\006 \001(\0132\020.pro"
    "tos.Vector2D\"i\n\013SelfMessage\022\'\n\rself_posi"
    "tion\030\001 \001(\0132\020.protos.Vector2D\022\033\n\023self_bod"
    "y_direction\030\002 \001(\002\022\024\n\014self_stamina\030\003 \001(\002\""
    "e\n\017TeammateMessage\022\026\n\016uniform_number\030\001 \001"
    "(\005\022\"\n\010position\030\002 \001(\0132\020.protos.Vector2D\022\026"
    "\n\016body_direction\030\003 \001(\002\"e\n\017OpponentMessag"
    "e\022\026\n\016uniform_number\030\001 \001(\005\022\"\n\010position\030\002 "
    "\001(\0132\020.protos.Vector2D\022\026\n\016body_direction\030"
    "\003 \001(\002\"\300\001\n\021BallPlayerMessage\022\'\n\rball_posi"
    "tion\030\001 \001(\0132\020.protos.Vector2D\022\'\n\rball_vel"
    "ocity\030\002 \001(\0132\020.protos.Vector2D\022\026\n\016uniform"
    "_number\030\003 \001(\005\022)\n\017player_position\030\004 \001(\0132\020"
    ".protos.Vector2D\022\026\n\016body_direction\030\005 \001(\002"
    "\"\320\t\n\003Say\022+\n\014ball_message\030\001 \001(\0132\023.protos."
    "BallMessageH\000\022+\n\014pass_message\030\002 \001(\0132\023.pr"
    "otos.PassMessageH\000\0225\n\021intercept_message\030"
    "\003 \001(\0132\030.protos.InterceptMessageH\000\022/\n\016goa"
    "lie_message\030\004 \001(\0132\025.protos.GoalieMessage"
    "H\000\022C\n\031goalie_and_player_message\030\005 \001(\0132\036."
    "protos.GoalieAndPlayerMessageH\000\022:\n\024offsi"
    "de_line_message\030\006 \001(\0132\032.protos.OffsideLi"
    "neMessageH\000\022:\n\024defense_line_message\030\007 \001("
    "\0132\032.protos.DefenseLineMessageH\000\022:\n\024wait_"
    "request_message\030\010 \001(\0132\032.protos.WaitReque"
    "stMessageH\000\0221\n\017setplay_message\030\t \001(\0132\026.p"
    "rotos.SetplayMessageH\000\022:\n\024pass_request_m"
    "essage\030\n \001(\0132\032.protos.PassRequestMessage"
    "H\000\0221\n\017stamina_message\030\013 \001(\0132\026.protos.Sta"
    "minaMessageH\000\0223\n\020recovery_message\030\014 \001(\0132"
    "\027.protos.RecoveryMessageH\000\022B\n\030stamina_ca"
    "pacity_message\030\r \001(\0132\036.protos.StaminaCap"
    "acityMessageH\000\0221\n\017dribble_message\030\016 \001(\0132"
    "\026.protos.DribbleMessageH\000\0228\n\023ball_goalie"
    "_message\030\017 \001(\0132\031.protos.BallGoalieMessag"
    "eH\000\0226\n\022one_player_message\030\020 \001(\0132\030.protos"
    ".OnePlayerMessageH\000\0226\n\022two_player_messag"
    "e\030\021 \001(\0132\030.protos.TwoPlayerMessageH\000\022:\n\024t"
    "hree_player_message\030\022 \001(\0132\032.protos.Three"
    "PlayerMessageH\000\022+\n\014self_message\030\023 \001(\0132\023."
    "protos.SelfMessageH\000\0223\n\020teammate_message"
    "\030\024 \001(\0132\027.protos.TeammateMessageH\000\0223\n\020opp"
    "onent_message\030\025 \001(\0132\027.protos.OpponentMes"
    "sageH\000\0228\n\023ball_player_message\030\026 \001(\0132\031.pr"
    "otos.BallPlayerMessageH\000B\t\n\007message\"\037\n\007P"
    "ointTo\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\"\013\n\tPointToO"
    "f\"7\n\013AttentionTo\022\032\n\004side\030\001 \001(\0162\014.protos."
    "Side\022\014\n\004unum\030\002 \001(\005\"\017\n\rAttentionToOf\">\n\007A"
    "ddText\022\"\n\005level\030\001 \001(\0162\023.protos.LoggerLev"
    "el\022\017\n\007message\030\002 \001(\t\"^\n\010AddPoint\022\"\n\005level"
    "\030\001 \001(\0162\023.protos.LoggerLevel\022\037\n\005point\030\002 \001"
    "(\0132\020.protos.Vector2D\022\r\n\005color\030\003 \001(\t\"|\n\007A"
    "ddLine\022\"\n\005level\030\001 \001(\0162\023.protos.LoggerLev"
    "el\022\037\n\005start\030\002 \001(\0132\020.protos.Vector2D\022\035\n\003e"
    "nd\030\003 \001(\0132\020.protos.Vector2D\022\r\n\005color\030\004 \001("
    "\t\"\226\001\n\006AddArc\022\"\n\005level\030\001 \001(\0162\023.protos.Log"
    "gerLevel\022 \n\006center\030\002 \001(\0132\020.protos.Vector"
    "2D\022\016\n\006radius\030\003 \001(\002\022\023\n\013start_angle\030\004 \001(\002\022"
    "\022\n\nspan_angel\030\005 \001(\002\022\r\n\005color\030\006 \001(\t\"~\n\tAd"
    "dCircle\022\"\n\005level\030\001 \001(\0162\023.protos.LoggerLe"
    "vel\022 \n\006center\030\002 \001(\0132\020.protos.Vector2D\022\016\n"
    "\006radius\030\003 \001(\002\022\r\n\005color\030\004 \001(\t\022\014\n\004fill\030\005 \001"
    "(\010\"\264\001\n\013AddTriangle\022\"\n\005level\030\001 \001(\0162\023.prot"
    "os.LoggerLevel\022 \n\006point1\030\002 \001(\0132\020.protos."
    "Vector2D\022 \n\006point2\030\003 \001(\0132\020.protos.Vector"
    "2D\022 \n\006point3\030\004 \001(\0132\020.protos.Vector2D\022\r\n\005"
    "color\030\005 \001(\t\022\014\n\004fill\030\006 \001(\010\"\211\001\n\014AddRectang"
    "le\022\"\n\005level\030\001 \001(\0162\023.protos.LoggerLevel\022\014"
    "\n\004left\030\002 \001(\002\022\013\n\003top\030\003 \001(\002\022\016\n\006length\030\004 \001("
    "\002\022\r\n\005width\030\005 \001(\002\022\r\n\005color\030\006 \001(\t\022\014\n\004fill\030"
    "\007 \001(\010\"\277\001\n\tAddSector\022\"\n\005level\030\001 \001(\0162\023.pro"
    "tos.LoggerLevel\022 \n\006center\030\002 \001(\0132\020.protos"
    ".Vector2D\022\022\n\nmin_radius\030\003 \001(\002\022\022\n\nmax_rad"
    "ius\030\004 \001(\002\022\023\n\013start_angle\030\005 \001(\002\022\022\n\nspan_a"
    "ngel\030\006 \001(\002\022\r\n\005color\030\007 \001(\t\022\014\n\004fill\030\010 \001(\010\""
    "t\n\nAddMessage\022\"\n\005level\030\001 \001(\0162\023.protos.Lo"
    "ggerLevel\022\"\n\010position\030\002 \001(\0132\020.protos.Vec"
    "tor2D\022\017\n\007message\030\003 \001(\t\022\r\n\005color\030\004 \001(\t\"\371\002"
    "\n\003Log\022#\n\010add_text\030\001 \001(\0132\017.protos.AddText"
    "H\000\022%\n\tadd_point\030\002 \001(\0132\020.protos.AddPointH"
    "\000\022#\n\010add_line\030\003 \001(\0132\017.protos.AddLineH\000\022!"
    "\n\007add_arc\030\004 \001(\0132\016.protos.AddArcH\000\022\'\n\nadd"
    "_circle\030\005 \001(\0132\021.protos.AddCircleH\000\022+\n\014ad"
    "d_triangle\030\006 \001(\0132\023.protos.AddTriangleH\000\022"
    "-\n\radd_rectangle\030\007 \001(\0132\024.protos.AddRecta"
    "ngleH\000\022\'\n\nadd_sector\030\010 \001(\0132\021.protos.AddS"
    "ectorH\000\022)\n\013add_message\030\t \001(\0132\022.protos.Ad"
    "dMessageH\000B\005\n\003log\"\036\n\013DebugClient\022\017\n\007mess"
    "age\030\001 \001(\t\"\261\004\n\006Action\022\034\n\004dash\030\001 \001(\0132\014.pro"
    "tos.DashH\000\022\034\n\004turn\030\002 \001(\0132\014.protos.TurnH\000"
    "\022\034\n\004kick\030\003 \001(\0132\014.protos.KickH\000\022 \n\006tackle"
    "\030\004 \001(\0132\016.protos.TackleH\000\022\036\n\005catch\030\005 \001(\0132"
    "\r.protos.CatchH\000\022\034\n\004move\030\006 \001(\0132\014.protos."
    "MoveH\000\022%\n\tturn_neck\030\007 \001(\0132\020.protos.TurnN"
    "eckH\000\022)\n\013change_view\030\010 \001(\0132\022.protos.Chan"
    "geViewH\000\022\032\n\003say\030\t \001(\0132\013.protos.SayH\000\022#\n\010"
    "point_to\030\n \001(\0132\017.protos.PointToH\000\022(\n\013poi"
    "nt_to_of\030\013 \001(\0132\021.protos.PointToOfH\000\022+\n\014a"
    "ttention_to\030\014 \001(\0132\023.protos.AttentionToH\000"
    "\0220\n\017attention_to_of\030\r \001(\0132\025.protos.Atten"
    "tionToOfH\000\022\032\n\003log\030\016 \001(\0132\013.protos.LogH\000\022+"
    "\n\014debug_client\030\017 \001(\0132\023.protos.DebugClien"
    "tH\000B\010\n\006action\"*\n\007Actions\022\037\n\007actions\030\001 \003("
    "\0132\016.protos.Action*-\n\tViewWidth\022\n\n\006NARROW"
    "\020\000\022\n\n\006NORMAL\020\001\022\010\n\004WIDE\020\002*(\n\004Side\022\013\n\007UNKN"
    "OWN\020\000\022\010\n\004LEFT\020\001\022\t\n\005RIGHT\020\002*\255\002\n\013LoggerLev"
    "el\022\010\n\004None\020\000\022\n\n\006SYSTEM\020\001\022\n\n\006SENSOR\020\002\022\t\n\005"
    "WORLD\020\004\022\n\n\006ACTION\020\010\022\r\n\tINTERCEPT\020\020\022\010\n\004KI"
    "CK\020 \022\010\n\004HOLD\020@\022\014\n\007DRIBBLE\020\200\001\022\t\n\004PASS\020\200\002\022"
    "\n\n\005CROSS\020\200\004\022\n\n\005SHOOT\020\200\010\022\n\n\005CLEAR\020\200\020\022\n\n\005B"
    "LOCK\020\200 \022\t\n\004MARK\020\200@\022\021\n\013POSITIONING\020\200\200\001\022\n\n"
    "\004ROLE\020\200\200\002\022\n\n\004TEAM\020\200\200\004\022\023\n\rCOMMUNICATION\020\200"
    "\200\010\022\016\n\010ANALYZER\020\200\200\020\022\022\n\014ACTION_CHAIN\020\200\200 \022\n"
    "\n\004PLAN\020\200\200@*v\n\023InterceptActionType\022!\n\035UNK"
    "NOWN_Intercept_Action_Type\020\000\022\r\n\tOMNI_DAS"
    "H\020\001\022\025\n\021TURN_FORWARD_DASH\020\002\022\026\n\022TURN_BACKW"
    "ARD_DASH\020\003*\232\t\n\014GameModeType\022\021\n\rBeforeKic"
    "kOff\020\000\022\014\n\010TimeOver\020\001\022\n\n\006PlayOn\020\002\022\020\n\014Kick"
    "Off_Left\020\003\022\021\n\rKickOff_Right\020\004\022\017\n\013KickIn_"
    "Left\020\005\022\020\n\014KickIn_Right\020\006\022\021\n\rFreeKick_Lef"
    "t\020\007\022\022\n\016FreeKick_Right\020\010\022\023\n\017CornerKick_Le"
    "ft\020\t\022\024\n\020CornerKick_Right\020\n\022\021\n\rGoalKick_L"
    "eft\020\013\022\022\n\016GoalKick_Right\020\014\022\022\n\016AfterGoal_L"
    "eft\020\r\022\023\n\017AfterGoal_Right\020\016\022\020\n\014OffSide_Le"
    "ft\020\017\022\021\n\rOffSide_Right\020\020\022\024\n\020PenaltyKick_L"
    "eft\020\021\022\025\n\021PenaltyKick_Right\020\022\022\021\n\rFirstHal"
    "fOver\020\023\022\t\n\005Pause\020\024\022\t\n\005Human\020\025\022\023\n\017FoulCha"
    "rge_Left\020\026\022\024\n\020FoulCharge_Right\020\027\022\021\n\rFoul"
    "Push_Left\020\030\022\022\n\016FoulPush_Right\020\031\022\035\n\031FoulM"
    "ultipleAttacker_Left\020\032\022\036\n\032FoulMultipleAt"
    "tacker_Right\020\033\022\024\n\020FoulBallOut_Left\020\034\022\025\n\021"
    "FoulBallOut_Right\020\035\022\021\n\rBackPass_Left\020\036\022\022"
    "\n\016BackPass_Right\020\037\022\026\n\022FreeKickFault_Left"
    "\020 \022\027\n\023FreeKickFault_Right\020!\022\023\n\017CatchFaul"
    "t_Left\020\"\022\024\n\020CatchFault_Right\020#\022\024\n\020IndFre"
    "eKick_Left\020$\022\025\n\021IndFreeKick_Right\020%\022\025\n\021P"
    "enaltySetup_Left\020&\022\026\n\022PenaltySetup_Right"
    "\020\'\022\025\n\021PenaltyReady_Left\020(\022\026\n\022PenaltyRead"
    "y_Right\020)\022\025\n\021PenaltyTaken_Left\020*\022\026\n\022Pena"
    "ltyTaken_Right\020+\022\024\n\020PenaltyMiss_Left\020,\022\025"
    "\n\021PenaltyMiss_Right\020-\022\025\n\021PenaltyScore_Le"
    "ft\020.\022\026\n\022PenaltyScore_Right\020/\022\027\n\023IllegalD"
    "efense_Left\0200\022\030\n\024IllegalDefense_Right\0201\022"
    "\022\n\016PenaltyOnfield\0202\022\017\n\013PenaltyFoul\0203\022\024\n\020"
    "GoalieCatch_Left\0204\022\025\n\021GoalieCatch_Right\020"
    "5\022\016\n\nExtendHalf\0206\022\014\n\010MODE_MAX\020726\n\004Game\022"
    ".\n\nGetActions\022\r.protos.State\032\017.protos.Ac"
    "tions\"\000b\006proto3"
};
static ::absl::once_flag descriptor_table_service_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_service_2eproto = {
    false,
    false,
    12055,
    descriptor_table_protodef_service_2eproto,
    "service.proto",
    &descriptor_table_service_2eproto_once,
    nullptr,
    0,
    58,
    schemas,
    file_default_instances,
    TableStruct_service_2eproto::offsets,
    file_level_metadata_service_2eproto,
    file_level_enum_descriptors_service_2eproto,
    file_level_service_descriptors_service_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_service_2eproto_getter() {
  return &descriptor_table_service_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_service_2eproto(&descriptor_table_service_2eproto);
namespace protos {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ViewWidth_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_service_2eproto);
  return file_level_enum_descriptors_service_2eproto[0];
}
bool ViewWidth_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Side_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_service_2eproto);
  return file_level_enum_descriptors_service_2eproto[1];
}
bool Side_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoggerLevel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_service_2eproto);
  return file_level_enum_descriptors_service_2eproto[2];
}
bool LoggerLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InterceptActionType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_service_2eproto);
  return file_level_enum_descriptors_service_2eproto[3];
}
bool InterceptActionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameModeType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_service_2eproto);
  return file_level_enum_descriptors_service_2eproto[4];
}
bool GameModeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class Vector2D::_Internal {
 public:
};

Vector2D::Vector2D(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Vector2D)
}
Vector2D::Vector2D(const Vector2D& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Vector2D)
}

inline void Vector2D::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.x_) { 0 }

    , decltype(_impl_.y_) { 0 }

    , decltype(_impl_.dist_) { 0 }

    , decltype(_impl_.angle_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Vector2D::~Vector2D() {
  // @@protoc_insertion_point(destructor:protos.Vector2D)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vector2D::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Vector2D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vector2D::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Vector2D)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.angle_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.angle_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vector2D::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Vector2D::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Vector2D)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y(), target);
  }

  // float dist = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist = this->_internal_dist();
  ::uint32_t raw_dist;
  memcpy(&raw_dist, &tmp_dist, sizeof(tmp_dist));
  if (raw_dist != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_dist(), target);
  }

  // float angle = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = this->_internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Vector2D)
  return target;
}

::size_t Vector2D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Vector2D)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  // float dist = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist = this->_internal_dist();
  ::uint32_t raw_dist;
  memcpy(&raw_dist, &tmp_dist, sizeof(tmp_dist));
  if (raw_dist != 0) {
    total_size += 5;
  }

  // float angle = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = this->_internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vector2D::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Vector2D::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vector2D::GetClassData() const { return &_class_data_; }


void Vector2D::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Vector2D*>(&to_msg);
  auto& from = static_cast<const Vector2D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Vector2D)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist = from._internal_dist();
  ::uint32_t raw_dist;
  memcpy(&raw_dist, &tmp_dist, sizeof(tmp_dist));
  if (raw_dist != 0) {
    _this->_internal_set_dist(from._internal_dist());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = from._internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    _this->_internal_set_angle(from._internal_angle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vector2D::CopyFrom(const Vector2D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Vector2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector2D::IsInitialized() const {
  return true;
}

void Vector2D::InternalSwap(Vector2D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vector2D, _impl_.angle_)
      + sizeof(Vector2D::_impl_.angle_)
      - PROTOBUF_FIELD_OFFSET(Vector2D, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vector2D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[0]);
}
// ===================================================================

class Ball::_Internal {
 public:
  using HasBits = decltype(std::declval<Ball>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ball, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const Ball* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& relative_position(const Ball* msg);
  static void set_has_relative_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& seen_position(const Ball* msg);
  static void set_has_seen_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::protos::Vector2D& heard_position(const Ball* msg);
  static void set_has_heard_position(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::protos::Vector2D& velocity(const Ball* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::protos::Vector2D& seen_velocity(const Ball* msg);
  static void set_has_seen_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::protos::Vector2D& heard_velocity(const Ball* msg);
  static void set_has_heard_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::protos::Vector2D&
Ball::_Internal::position(const Ball* msg) {
  return *msg->_impl_.position_;
}
const ::protos::Vector2D&
Ball::_Internal::relative_position(const Ball* msg) {
  return *msg->_impl_.relative_position_;
}
const ::protos::Vector2D&
Ball::_Internal::seen_position(const Ball* msg) {
  return *msg->_impl_.seen_position_;
}
const ::protos::Vector2D&
Ball::_Internal::heard_position(const Ball* msg) {
  return *msg->_impl_.heard_position_;
}
const ::protos::Vector2D&
Ball::_Internal::velocity(const Ball* msg) {
  return *msg->_impl_.velocity_;
}
const ::protos::Vector2D&
Ball::_Internal::seen_velocity(const Ball* msg) {
  return *msg->_impl_.seen_velocity_;
}
const ::protos::Vector2D&
Ball::_Internal::heard_velocity(const Ball* msg) {
  return *msg->_impl_.heard_velocity_;
}
Ball::Ball(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Ball)
}
Ball::Ball(const Ball& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Ball* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.relative_position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.heard_velocity_){nullptr}
    , decltype(_impl_.pos_count_) {}

    , decltype(_impl_.seen_pos_count_) {}

    , decltype(_impl_.heard_pos_count_) {}

    , decltype(_impl_.vel_count_) {}

    , decltype(_impl_.seen_vel_count_) {}

    , decltype(_impl_.heard_vel_count_) {}

    , decltype(_impl_.lost_count_) {}

    , decltype(_impl_.ghost_count_) {}

    , decltype(_impl_.dist_from_self_) {}

    , decltype(_impl_.angle_from_self_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.relative_position_ = new ::protos::Vector2D(*from._impl_.relative_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.seen_position_ = new ::protos::Vector2D(*from._impl_.seen_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.heard_position_ = new ::protos::Vector2D(*from._impl_.heard_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.velocity_ = new ::protos::Vector2D(*from._impl_.velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000020u) != 0) {
    _this->_impl_.seen_velocity_ = new ::protos::Vector2D(*from._impl_.seen_velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000040u) != 0) {
    _this->_impl_.heard_velocity_ = new ::protos::Vector2D(*from._impl_.heard_velocity_);
  }
  ::memcpy(&_impl_.pos_count_, &from._impl_.pos_count_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.angle_from_self_) -
    reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.angle_from_self_));
  // @@protoc_insertion_point(copy_constructor:protos.Ball)
}

inline void Ball::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.relative_position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.heard_velocity_){nullptr}
    , decltype(_impl_.pos_count_) { 0 }

    , decltype(_impl_.seen_pos_count_) { 0 }

    , decltype(_impl_.heard_pos_count_) { 0 }

    , decltype(_impl_.vel_count_) { 0 }

    , decltype(_impl_.seen_vel_count_) { 0 }

    , decltype(_impl_.heard_vel_count_) { 0 }

    , decltype(_impl_.lost_count_) { 0 }

    , decltype(_impl_.ghost_count_) { 0 }

    , decltype(_impl_.dist_from_self_) { 0 }

    , decltype(_impl_.angle_from_self_) { 0 }

  };
}

Ball::~Ball() {
  // @@protoc_insertion_point(destructor:protos.Ball)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ball::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.relative_position_;
  if (this != internal_default_instance()) delete _impl_.seen_position_;
  if (this != internal_default_instance()) delete _impl_.heard_position_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
  if (this != internal_default_instance()) delete _impl_.seen_velocity_;
  if (this != internal_default_instance()) delete _impl_.heard_velocity_;
}

void Ball::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ball::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Ball)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.relative_position_ != nullptr);
      _impl_.relative_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.seen_position_ != nullptr);
      _impl_.seen_position_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.heard_position_ != nullptr);
      _impl_.heard_position_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.velocity_ != nullptr);
      _impl_.velocity_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.seen_velocity_ != nullptr);
      _impl_.seen_velocity_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(_impl_.heard_velocity_ != nullptr);
      _impl_.heard_velocity_->Clear();
    }
  }
  ::memset(&_impl_.pos_count_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.angle_from_self_) -
      reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.angle_from_self_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ball::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D relative_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_relative_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D heard_position = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_heard_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D velocity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_velocity = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D heard_velocity = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_heard_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 pos_count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_pos_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.seen_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 heard_pos_count = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.heard_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 vel_count = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_vel_count = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _impl_.seen_vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 heard_vel_count = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _impl_.heard_vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 lost_count = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.lost_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ghost_count = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _impl_.ghost_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist_from_self = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 133)) {
          _impl_.dist_from_self_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle_from_self = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 141)) {
          _impl_.angle_from_self_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ball::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Ball)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D relative_position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::relative_position(this),
        _Internal::relative_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_position = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::seen_position(this),
        _Internal::seen_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D heard_position = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::heard_position(this),
        _Internal::heard_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D velocity = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_velocity = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::seen_velocity(this),
        _Internal::seen_velocity(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D heard_velocity = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::heard_velocity(this),
        _Internal::heard_velocity(this).GetCachedSize(), target, stream);
  }

  // int32 pos_count = 8;
  if (this->_internal_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_pos_count(), target);
  }

  // int32 seen_pos_count = 9;
  if (this->_internal_seen_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        9, this->_internal_seen_pos_count(), target);
  }

  // int32 heard_pos_count = 10;
  if (this->_internal_heard_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_heard_pos_count(), target);
  }

  // int32 vel_count = 11;
  if (this->_internal_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        11, this->_internal_vel_count(), target);
  }

  // int32 seen_vel_count = 12;
  if (this->_internal_seen_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        12, this->_internal_seen_vel_count(), target);
  }

  // int32 heard_vel_count = 13;
  if (this->_internal_heard_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        13, this->_internal_heard_vel_count(), target);
  }

  // int32 lost_count = 14;
  if (this->_internal_lost_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        14, this->_internal_lost_count(), target);
  }

  // int32 ghost_count = 15;
  if (this->_internal_ghost_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        15, this->_internal_ghost_count(), target);
  }

  // float dist_from_self = 16;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = this->_internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        16, this->_internal_dist_from_self(), target);
  }

  // float angle_from_self = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = this->_internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        17, this->_internal_angle_from_self(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Ball)
  return target;
}

::size_t Ball::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Ball)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // .protos.Vector2D position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // .protos.Vector2D relative_position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.relative_position_);
    }

    // .protos.Vector2D seen_position = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_position_);
    }

    // .protos.Vector2D heard_position = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.heard_position_);
    }

    // .protos.Vector2D velocity = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.velocity_);
    }

    // .protos.Vector2D seen_velocity = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_velocity_);
    }

    // .protos.Vector2D heard_velocity = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.heard_velocity_);
    }

  }
  // int32 pos_count = 8;
  if (this->_internal_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_pos_count());
  }

  // int32 seen_pos_count = 9;
  if (this->_internal_seen_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_pos_count());
  }

  // int32 heard_pos_count = 10;
  if (this->_internal_heard_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_heard_pos_count());
  }

  // int32 vel_count = 11;
  if (this->_internal_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_vel_count());
  }

  // int32 seen_vel_count = 12;
  if (this->_internal_seen_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_vel_count());
  }

  // int32 heard_vel_count = 13;
  if (this->_internal_heard_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_heard_vel_count());
  }

  // int32 lost_count = 14;
  if (this->_internal_lost_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_lost_count());
  }

  // int32 ghost_count = 15;
  if (this->_internal_ghost_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_ghost_count());
  }

  // float dist_from_self = 16;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = this->_internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    total_size += 6;
  }

  // float angle_from_self = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = this->_internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    total_size += 6;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ball::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ball::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ball::GetClassData() const { return &_class_data_; }


void Ball::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ball*>(&to_msg);
  auto& from = static_cast<const Ball&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Ball)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_relative_position()->::protos::Vector2D::MergeFrom(
          from._internal_relative_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_seen_position()->::protos::Vector2D::MergeFrom(
          from._internal_seen_position());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_heard_position()->::protos::Vector2D::MergeFrom(
          from._internal_heard_position());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_velocity());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_seen_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_seen_velocity());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_heard_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_heard_velocity());
    }
  }
  if (from._internal_pos_count() != 0) {
    _this->_internal_set_pos_count(from._internal_pos_count());
  }
  if (from._internal_seen_pos_count() != 0) {
    _this->_internal_set_seen_pos_count(from._internal_seen_pos_count());
  }
  if (from._internal_heard_pos_count() != 0) {
    _this->_internal_set_heard_pos_count(from._internal_heard_pos_count());
  }
  if (from._internal_vel_count() != 0) {
    _this->_internal_set_vel_count(from._internal_vel_count());
  }
  if (from._internal_seen_vel_count() != 0) {
    _this->_internal_set_seen_vel_count(from._internal_seen_vel_count());
  }
  if (from._internal_heard_vel_count() != 0) {
    _this->_internal_set_heard_vel_count(from._internal_heard_vel_count());
  }
  if (from._internal_lost_count() != 0) {
    _this->_internal_set_lost_count(from._internal_lost_count());
  }
  if (from._internal_ghost_count() != 0) {
    _this->_internal_set_ghost_count(from._internal_ghost_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = from._internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    _this->_internal_set_dist_from_self(from._internal_dist_from_self());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = from._internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    _this->_internal_set_angle_from_self(from._internal_angle_from_self());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ball::CopyFrom(const Ball& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Ball)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ball::IsInitialized() const {
  return true;
}

void Ball::InternalSwap(Ball* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ball, _impl_.angle_from_self_)
      + sizeof(Ball::_impl_.angle_from_self_)
      - PROTOBUF_FIELD_OFFSET(Ball, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ball::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[1]);
}
// ===================================================================

class Player::_Internal {
 public:
  using HasBits = decltype(std::declval<Player>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Player, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const Player* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& seen_position(const Player* msg);
  static void set_has_seen_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& heard_position(const Player* msg);
  static void set_has_heard_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::protos::Vector2D& velocity(const Player* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::protos::Vector2D& seen_velocity(const Player* msg);
  static void set_has_seen_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::protos::Vector2D&
Player::_Internal::position(const Player* msg) {
  return *msg->_impl_.position_;
}
const ::protos::Vector2D&
Player::_Internal::seen_position(const Player* msg) {
  return *msg->_impl_.seen_position_;
}
const ::protos::Vector2D&
Player::_Internal::heard_position(const Player* msg) {
  return *msg->_impl_.heard_position_;
}
const ::protos::Vector2D&
Player::_Internal::velocity(const Player* msg) {
  return *msg->_impl_.velocity_;
}
const ::protos::Vector2D&
Player::_Internal::seen_velocity(const Player* msg) {
  return *msg->_impl_.seen_velocity_;
}
Player::Player(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Player)
}
Player::Player(const Player& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Player* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.pos_count_) {}

    , decltype(_impl_.seen_pos_count_) {}

    , decltype(_impl_.heard_pos_count_) {}

    , decltype(_impl_.vel_count_) {}

    , decltype(_impl_.seen_vel_count_) {}

    , decltype(_impl_.ghost_count_) {}

    , decltype(_impl_.dist_from_self_) {}

    , decltype(_impl_.angle_from_self_) {}

    , decltype(_impl_.id_) {}

    , decltype(_impl_.side_) {}

    , decltype(_impl_.uniform_number_) {}

    , decltype(_impl_.uniform_number_count_) {}

    , decltype(_impl_.body_direction_) {}

    , decltype(_impl_.body_direction_count_) {}

    , decltype(_impl_.face_direction_) {}

    , decltype(_impl_.face_direction_count_) {}

    , decltype(_impl_.point_to_direction_) {}

    , decltype(_impl_.point_to_direction_count_) {}

    , decltype(_impl_.is_goalie_) {}

    , decltype(_impl_.is_kicking_) {}

    , decltype(_impl_.is_tackling_) {}

    , decltype(_impl_.dist_from_ball_) {}

    , decltype(_impl_.angle_from_ball_) {}

    , decltype(_impl_.ball_reach_steps_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.seen_position_ = new ::protos::Vector2D(*from._impl_.seen_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.heard_position_ = new ::protos::Vector2D(*from._impl_.heard_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.velocity_ = new ::protos::Vector2D(*from._impl_.velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.seen_velocity_ = new ::protos::Vector2D(*from._impl_.seen_velocity_);
  }
  ::memcpy(&_impl_.pos_count_, &from._impl_.pos_count_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.ball_reach_steps_) -
    reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.ball_reach_steps_));
  // @@protoc_insertion_point(copy_constructor:protos.Player)
}

inline void Player::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.pos_count_) { 0 }

    , decltype(_impl_.seen_pos_count_) { 0 }

    , decltype(_impl_.heard_pos_count_) { 0 }

    , decltype(_impl_.vel_count_) { 0 }

    , decltype(_impl_.seen_vel_count_) { 0 }

    , decltype(_impl_.ghost_count_) { 0 }

    , decltype(_impl_.dist_from_self_) { 0 }

    , decltype(_impl_.angle_from_self_) { 0 }

    , decltype(_impl_.id_) { 0 }

    , decltype(_impl_.side_) { 0 }

    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.uniform_number_count_) { 0 }

    , decltype(_impl_.body_direction_) { 0 }

    , decltype(_impl_.body_direction_count_) { 0 }

    , decltype(_impl_.face_direction_) { 0 }

    , decltype(_impl_.face_direction_count_) { 0 }

    , decltype(_impl_.point_to_direction_) { 0 }

    , decltype(_impl_.point_to_direction_count_) { 0 }

    , decltype(_impl_.is_goalie_) { false }

    , decltype(_impl_.is_kicking_) { false }

    , decltype(_impl_.is_tackling_) { false }

    , decltype(_impl_.dist_from_ball_) { 0 }

    , decltype(_impl_.angle_from_ball_) { 0 }

    , decltype(_impl_.ball_reach_steps_) { 0 }

  };
}

Player::~Player() {
  // @@protoc_insertion_point(destructor:protos.Player)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Player::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.seen_position_;
  if (this != internal_default_instance()) delete _impl_.heard_position_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
  if (this != internal_default_instance()) delete _impl_.seen_velocity_;
}

void Player::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Player::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Player)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.seen_position_ != nullptr);
      _impl_.seen_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.heard_position_ != nullptr);
      _impl_.heard_position_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.velocity_ != nullptr);
      _impl_.velocity_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.seen_velocity_ != nullptr);
      _impl_.seen_velocity_->Clear();
    }
  }
  ::memset(&_impl_.pos_count_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.ball_reach_steps_) -
      reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.ball_reach_steps_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Player::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D heard_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_heard_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D velocity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_velocity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 pos_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_pos_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.seen_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 heard_pos_count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.heard_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 vel_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_vel_count = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.seen_vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ghost_count = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.ghost_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist_from_self = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 101)) {
          _impl_.dist_from_self_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle_from_self = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 109)) {
          _impl_.angle_from_self_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 id = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Side side = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number_count = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 136)) {
          _impl_.uniform_number_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_goalie = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
          _impl_.is_goalie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float body_direction = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 157)) {
          _impl_.body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 body_direction_count = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _impl_.body_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float face_direction = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 173)) {
          _impl_.face_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 face_direction_count = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 176)) {
          _impl_.face_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float point_to_direction = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 189)) {
          _impl_.point_to_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 point_to_direction_count = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 192)) {
          _impl_.point_to_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_kicking = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 200)) {
          _impl_.is_kicking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist_from_ball = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 213)) {
          _impl_.dist_from_ball_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle_from_ball = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 221)) {
          _impl_.angle_from_ball_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ball_reach_steps = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 224)) {
          _impl_.ball_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_tackling = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 232)) {
          _impl_.is_tackling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Player::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Player)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::seen_position(this),
        _Internal::seen_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D heard_position = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::heard_position(this),
        _Internal::heard_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D velocity = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_velocity = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::seen_velocity(this),
        _Internal::seen_velocity(this).GetCachedSize(), target, stream);
  }

  // int32 pos_count = 6;
  if (this->_internal_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_pos_count(), target);
  }

  // int32 seen_pos_count = 7;
  if (this->_internal_seen_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_seen_pos_count(), target);
  }

  // int32 heard_pos_count = 8;
  if (this->_internal_heard_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_heard_pos_count(), target);
  }

  // int32 vel_count = 9;
  if (this->_internal_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        9, this->_internal_vel_count(), target);
  }

  // int32 seen_vel_count = 10;
  if (this->_internal_seen_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_seen_vel_count(), target);
  }

  // int32 ghost_count = 11;
  if (this->_internal_ghost_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        11, this->_internal_ghost_count(), target);
  }

  // float dist_from_self = 12;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = this->_internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        12, this->_internal_dist_from_self(), target);
  }

  // float angle_from_self = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = this->_internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        13, this->_internal_angle_from_self(), target);
  }

  // int32 id = 14;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        14, this->_internal_id(), target);
  }

  // .protos.Side side = 15;
  if (this->_internal_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        15, this->_internal_side(), target);
  }

  // int32 uniform_number = 16;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        16, this->_internal_uniform_number(), target);
  }

  // int32 uniform_number_count = 17;
  if (this->_internal_uniform_number_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        17, this->_internal_uniform_number_count(), target);
  }

  // bool is_goalie = 18;
  if (this->_internal_is_goalie() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        18, this->_internal_is_goalie(), target);
  }

  // float body_direction = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        19, this->_internal_body_direction(), target);
  }

  // int32 body_direction_count = 20;
  if (this->_internal_body_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        20, this->_internal_body_direction_count(), target);
  }

  // float face_direction = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = this->_internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        21, this->_internal_face_direction(), target);
  }

  // int32 face_direction_count = 22;
  if (this->_internal_face_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        22, this->_internal_face_direction_count(), target);
  }

  // float point_to_direction = 23;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = this->_internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        23, this->_internal_point_to_direction(), target);
  }

  // int32 point_to_direction_count = 24;
  if (this->_internal_point_to_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        24, this->_internal_point_to_direction_count(), target);
  }

  // bool is_kicking = 25;
  if (this->_internal_is_kicking() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        25, this->_internal_is_kicking(), target);
  }

  // float dist_from_ball = 26;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = this->_internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        26, this->_internal_dist_from_ball(), target);
  }

  // float angle_from_ball = 27;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = this->_internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        27, this->_internal_angle_from_ball(), target);
  }

  // int32 ball_reach_steps = 28;
  if (this->_internal_ball_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        28, this->_internal_ball_reach_steps(), target);
  }

  // bool is_tackling = 29;
  if (this->_internal_is_tackling() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        29, this->_internal_is_tackling(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Player)
  return target;
}

::size_t Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Player)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // .protos.Vector2D position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // .protos.Vector2D seen_position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_position_);
    }

    // .protos.Vector2D heard_position = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.heard_position_);
    }

    // .protos.Vector2D velocity = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.velocity_);
    }

    // .protos.Vector2D seen_velocity = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_velocity_);
    }

  }
  // int32 pos_count = 6;
  if (this->_internal_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_pos_count());
  }

  // int32 seen_pos_count = 7;
  if (this->_internal_seen_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_pos_count());
  }

  // int32 heard_pos_count = 8;
  if (this->_internal_heard_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_heard_pos_count());
  }

  // int32 vel_count = 9;
  if (this->_internal_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_vel_count());
  }

  // int32 seen_vel_count = 10;
  if (this->_internal_seen_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_vel_count());
  }

  // int32 ghost_count = 11;
  if (this->_internal_ghost_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_ghost_count());
  }

  // float dist_from_self = 12;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = this->_internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    total_size += 5;
  }

  // float angle_from_self = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = this->_internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    total_size += 5;
  }

  // int32 id = 14;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_id());
  }

  // .protos.Side side = 15;
  if (this->_internal_side() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  // int32 uniform_number = 16;
  if (this->_internal_uniform_number() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_uniform_number());
  }

  // int32 uniform_number_count = 17;
  if (this->_internal_uniform_number_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_uniform_number_count());
  }

  // float body_direction = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    total_size += 6;
  }

  // int32 body_direction_count = 20;
  if (this->_internal_body_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_body_direction_count());
  }

  // float face_direction = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = this->_internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    total_size += 6;
  }

  // int32 face_direction_count = 22;
  if (this->_internal_face_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_face_direction_count());
  }

  // float point_to_direction = 23;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = this->_internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    total_size += 6;
  }

  // int32 point_to_direction_count = 24;
  if (this->_internal_point_to_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_point_to_direction_count());
  }

  // bool is_goalie = 18;
  if (this->_internal_is_goalie() != 0) {
    total_size += 3;
  }

  // bool is_kicking = 25;
  if (this->_internal_is_kicking() != 0) {
    total_size += 3;
  }

  // bool is_tackling = 29;
  if (this->_internal_is_tackling() != 0) {
    total_size += 3;
  }

  // float dist_from_ball = 26;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = this->_internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    total_size += 6;
  }

  // float angle_from_ball = 27;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = this->_internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    total_size += 6;
  }

  // int32 ball_reach_steps = 28;
  if (this->_internal_ball_reach_steps() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_ball_reach_steps());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Player::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Player::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Player::GetClassData() const { return &_class_data_; }


void Player::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Player*>(&to_msg);
  auto& from = static_cast<const Player&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Player)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_seen_position()->::protos::Vector2D::MergeFrom(
          from._internal_seen_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_heard_position()->::protos::Vector2D::MergeFrom(
          from._internal_heard_position());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_velocity());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_seen_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_seen_velocity());
    }
  }
  if (from._internal_pos_count() != 0) {
    _this->_internal_set_pos_count(from._internal_pos_count());
  }
  if (from._internal_seen_pos_count() != 0) {
    _this->_internal_set_seen_pos_count(from._internal_seen_pos_count());
  }
  if (from._internal_heard_pos_count() != 0) {
    _this->_internal_set_heard_pos_count(from._internal_heard_pos_count());
  }
  if (from._internal_vel_count() != 0) {
    _this->_internal_set_vel_count(from._internal_vel_count());
  }
  if (from._internal_seen_vel_count() != 0) {
    _this->_internal_set_seen_vel_count(from._internal_seen_vel_count());
  }
  if (from._internal_ghost_count() != 0) {
    _this->_internal_set_ghost_count(from._internal_ghost_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_self = from._internal_dist_from_self();
  ::uint32_t raw_dist_from_self;
  memcpy(&raw_dist_from_self, &tmp_dist_from_self, sizeof(tmp_dist_from_self));
  if (raw_dist_from_self != 0) {
    _this->_internal_set_dist_from_self(from._internal_dist_from_self());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_self = from._internal_angle_from_self();
  ::uint32_t raw_angle_from_self;
  memcpy(&raw_angle_from_self, &tmp_angle_from_self, sizeof(tmp_angle_from_self));
  if (raw_angle_from_self != 0) {
    _this->_internal_set_angle_from_self(from._internal_angle_from_self());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_side() != 0) {
    _this->_internal_set_side(from._internal_side());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  if (from._internal_uniform_number_count() != 0) {
    _this->_internal_set_uniform_number_count(from._internal_uniform_number_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = from._internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    _this->_internal_set_body_direction(from._internal_body_direction());
  }
  if (from._internal_body_direction_count() != 0) {
    _this->_internal_set_body_direction_count(from._internal_body_direction_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = from._internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    _this->_internal_set_face_direction(from._internal_face_direction());
  }
  if (from._internal_face_direction_count() != 0) {
    _this->_internal_set_face_direction_count(from._internal_face_direction_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = from._internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    _this->_internal_set_point_to_direction(from._internal_point_to_direction());
  }
  if (from._internal_point_to_direction_count() != 0) {
    _this->_internal_set_point_to_direction_count(from._internal_point_to_direction_count());
  }
  if (from._internal_is_goalie() != 0) {
    _this->_internal_set_is_goalie(from._internal_is_goalie());
  }
  if (from._internal_is_kicking() != 0) {
    _this->_internal_set_is_kicking(from._internal_is_kicking());
  }
  if (from._internal_is_tackling() != 0) {
    _this->_internal_set_is_tackling(from._internal_is_tackling());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = from._internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    _this->_internal_set_dist_from_ball(from._internal_dist_from_ball());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = from._internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    _this->_internal_set_angle_from_ball(from._internal_angle_from_ball());
  }
  if (from._internal_ball_reach_steps() != 0) {
    _this->_internal_set_ball_reach_steps(from._internal_ball_reach_steps());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Player::CopyFrom(const Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Player::IsInitialized() const {
  return true;
}

void Player::InternalSwap(Player* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Player, _impl_.ball_reach_steps_)
      + sizeof(Player::_impl_.ball_reach_steps_)
      - PROTOBUF_FIELD_OFFSET(Player, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Player::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[2]);
}
// ===================================================================

class Self::_Internal {
 public:
  using HasBits = decltype(std::declval<Self>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Self, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const Self* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& seen_position(const Self* msg);
  static void set_has_seen_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& heard_position(const Self* msg);
  static void set_has_heard_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::protos::Vector2D& velocity(const Self* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::protos::Vector2D& seen_velocity(const Self* msg);
  static void set_has_seen_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::protos::Vector2D&
Self::_Internal::position(const Self* msg) {
  return *msg->_impl_.position_;
}
const ::protos::Vector2D&
Self::_Internal::seen_position(const Self* msg) {
  return *msg->_impl_.seen_position_;
}
const ::protos::Vector2D&
Self::_Internal::heard_position(const Self* msg) {
  return *msg->_impl_.heard_position_;
}
const ::protos::Vector2D&
Self::_Internal::velocity(const Self* msg) {
  return *msg->_impl_.velocity_;
}
const ::protos::Vector2D&
Self::_Internal::seen_velocity(const Self* msg) {
  return *msg->_impl_.seen_velocity_;
}
Self::Self(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Self)
}
Self::Self(const Self& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Self* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.pos_count_) {}

    , decltype(_impl_.seen_pos_count_) {}

    , decltype(_impl_.heard_pos_count_) {}

    , decltype(_impl_.vel_count_) {}

    , decltype(_impl_.seen_vel_count_) {}

    , decltype(_impl_.ghost_count_) {}

    , decltype(_impl_.id_) {}

    , decltype(_impl_.side_) {}

    , decltype(_impl_.uniform_number_) {}

    , decltype(_impl_.uniform_number_count_) {}

    , decltype(_impl_.body_direction_) {}

    , decltype(_impl_.body_direction_count_) {}

    , decltype(_impl_.face_direction_) {}

    , decltype(_impl_.face_direction_count_) {}

    , decltype(_impl_.point_to_direction_) {}

    , decltype(_impl_.point_to_direction_count_) {}

    , decltype(_impl_.dist_from_ball_) {}

    , decltype(_impl_.is_goalie_) {}

    , decltype(_impl_.is_kicking_) {}

    , decltype(_impl_.is_tackling_) {}

    , decltype(_impl_.is_kickable_) {}

    , decltype(_impl_.angle_from_ball_) {}

    , decltype(_impl_.ball_reach_steps_) {}

    , decltype(_impl_.relative_neck_direction_) {}

    , decltype(_impl_.stamina_) {}

    , decltype(_impl_.catch_probability_) {}

    , decltype(_impl_.tackle_probability_) {}

    , decltype(_impl_.foul_probability_) {}

    , decltype(_impl_.view_width_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.seen_position_ = new ::protos::Vector2D(*from._impl_.seen_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.heard_position_ = new ::protos::Vector2D(*from._impl_.heard_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.velocity_ = new ::protos::Vector2D(*from._impl_.velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.seen_velocity_ = new ::protos::Vector2D(*from._impl_.seen_velocity_);
  }
  ::memcpy(&_impl_.pos_count_, &from._impl_.pos_count_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.view_width_) -
    reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.view_width_));
  // @@protoc_insertion_point(copy_constructor:protos.Self)
}

inline void Self::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.seen_position_){nullptr}
    , decltype(_impl_.heard_position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.seen_velocity_){nullptr}
    , decltype(_impl_.pos_count_) { 0 }

    , decltype(_impl_.seen_pos_count_) { 0 }

    , decltype(_impl_.heard_pos_count_) { 0 }

    , decltype(_impl_.vel_count_) { 0 }

    , decltype(_impl_.seen_vel_count_) { 0 }

    , decltype(_impl_.ghost_count_) { 0 }

    , decltype(_impl_.id_) { 0 }

    , decltype(_impl_.side_) { 0 }

    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.uniform_number_count_) { 0 }

    , decltype(_impl_.body_direction_) { 0 }

    , decltype(_impl_.body_direction_count_) { 0 }

    , decltype(_impl_.face_direction_) { 0 }

    , decltype(_impl_.face_direction_count_) { 0 }

    , decltype(_impl_.point_to_direction_) { 0 }

    , decltype(_impl_.point_to_direction_count_) { 0 }

    , decltype(_impl_.dist_from_ball_) { 0 }

    , decltype(_impl_.is_goalie_) { false }

    , decltype(_impl_.is_kicking_) { false }

    , decltype(_impl_.is_tackling_) { false }

    , decltype(_impl_.is_kickable_) { false }

    , decltype(_impl_.angle_from_ball_) { 0 }

    , decltype(_impl_.ball_reach_steps_) { 0 }

    , decltype(_impl_.relative_neck_direction_) { 0 }

    , decltype(_impl_.stamina_) { 0 }

    , decltype(_impl_.catch_probability_) { 0 }

    , decltype(_impl_.tackle_probability_) { 0 }

    , decltype(_impl_.foul_probability_) { 0 }

    , decltype(_impl_.view_width_) { 0 }

  };
}

Self::~Self() {
  // @@protoc_insertion_point(destructor:protos.Self)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Self::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.seen_position_;
  if (this != internal_default_instance()) delete _impl_.heard_position_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
  if (this != internal_default_instance()) delete _impl_.seen_velocity_;
}

void Self::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Self::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Self)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.seen_position_ != nullptr);
      _impl_.seen_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.heard_position_ != nullptr);
      _impl_.heard_position_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.velocity_ != nullptr);
      _impl_.velocity_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.seen_velocity_ != nullptr);
      _impl_.seen_velocity_->Clear();
    }
  }
  ::memset(&_impl_.pos_count_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.view_width_) -
      reinterpret_cast<char*>(&_impl_.pos_count_)) + sizeof(_impl_.view_width_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Self::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D heard_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_heard_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D velocity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D seen_velocity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_seen_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 pos_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_pos_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.seen_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 heard_pos_count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.heard_pos_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 vel_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 seen_vel_count = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.seen_vel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ghost_count = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.ghost_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 id = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Side side = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number_count = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _impl_.uniform_number_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_goalie = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _impl_.is_goalie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float body_direction = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 141)) {
          _impl_.body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 body_direction_count = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
          _impl_.body_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float face_direction = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 157)) {
          _impl_.face_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 face_direction_count = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _impl_.face_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float point_to_direction = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 173)) {
          _impl_.point_to_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 point_to_direction_count = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 176)) {
          _impl_.point_to_direction_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_kicking = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 184)) {
          _impl_.is_kicking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dist_from_ball = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 197)) {
          _impl_.dist_from_ball_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle_from_ball = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 205)) {
          _impl_.angle_from_ball_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ball_reach_steps = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 208)) {
          _impl_.ball_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_tackling = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 216)) {
          _impl_.is_tackling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float relative_neck_direction = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 229)) {
          _impl_.relative_neck_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float stamina = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 237)) {
          _impl_.stamina_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_kickable = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 240)) {
          _impl_.is_kickable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float catch_probability = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 253)) {
          _impl_.catch_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float tackle_probability = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 5)) {
          _impl_.tackle_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float foul_probability = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.foul_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.ViewWidth view_width = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_view_width(static_cast<::protos::ViewWidth>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Self::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Self)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::seen_position(this),
        _Internal::seen_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D heard_position = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::heard_position(this),
        _Internal::heard_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D velocity = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D seen_velocity = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::seen_velocity(this),
        _Internal::seen_velocity(this).GetCachedSize(), target, stream);
  }

  // int32 pos_count = 6;
  if (this->_internal_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_pos_count(), target);
  }

  // int32 seen_pos_count = 7;
  if (this->_internal_seen_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_seen_pos_count(), target);
  }

  // int32 heard_pos_count = 8;
  if (this->_internal_heard_pos_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_heard_pos_count(), target);
  }

  // int32 vel_count = 9;
  if (this->_internal_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        9, this->_internal_vel_count(), target);
  }

  // int32 seen_vel_count = 10;
  if (this->_internal_seen_vel_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_seen_vel_count(), target);
  }

  // int32 ghost_count = 11;
  if (this->_internal_ghost_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        11, this->_internal_ghost_count(), target);
  }

  // int32 id = 12;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        12, this->_internal_id(), target);
  }

  // .protos.Side side = 13;
  if (this->_internal_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        13, this->_internal_side(), target);
  }

  // int32 uniform_number = 14;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        14, this->_internal_uniform_number(), target);
  }

  // int32 uniform_number_count = 15;
  if (this->_internal_uniform_number_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        15, this->_internal_uniform_number_count(), target);
  }

  // bool is_goalie = 16;
  if (this->_internal_is_goalie() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        16, this->_internal_is_goalie(), target);
  }

  // float body_direction = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        17, this->_internal_body_direction(), target);
  }

  // int32 body_direction_count = 18;
  if (this->_internal_body_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        18, this->_internal_body_direction_count(), target);
  }

  // float face_direction = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = this->_internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        19, this->_internal_face_direction(), target);
  }

  // int32 face_direction_count = 20;
  if (this->_internal_face_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        20, this->_internal_face_direction_count(), target);
  }

  // float point_to_direction = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = this->_internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        21, this->_internal_point_to_direction(), target);
  }

  // int32 point_to_direction_count = 22;
  if (this->_internal_point_to_direction_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        22, this->_internal_point_to_direction_count(), target);
  }

  // bool is_kicking = 23;
  if (this->_internal_is_kicking() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        23, this->_internal_is_kicking(), target);
  }

  // float dist_from_ball = 24;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = this->_internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        24, this->_internal_dist_from_ball(), target);
  }

  // float angle_from_ball = 25;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = this->_internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        25, this->_internal_angle_from_ball(), target);
  }

  // int32 ball_reach_steps = 26;
  if (this->_internal_ball_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        26, this->_internal_ball_reach_steps(), target);
  }

  // bool is_tackling = 27;
  if (this->_internal_is_tackling() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        27, this->_internal_is_tackling(), target);
  }

  // float relative_neck_direction = 28;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_neck_direction = this->_internal_relative_neck_direction();
  ::uint32_t raw_relative_neck_direction;
  memcpy(&raw_relative_neck_direction, &tmp_relative_neck_direction, sizeof(tmp_relative_neck_direction));
  if (raw_relative_neck_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        28, this->_internal_relative_neck_direction(), target);
  }

  // float stamina = 29;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina = this->_internal_stamina();
  ::uint32_t raw_stamina;
  memcpy(&raw_stamina, &tmp_stamina, sizeof(tmp_stamina));
  if (raw_stamina != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        29, this->_internal_stamina(), target);
  }

  // bool is_kickable = 30;
  if (this->_internal_is_kickable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        30, this->_internal_is_kickable(), target);
  }

  // float catch_probability = 31;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_probability = this->_internal_catch_probability();
  ::uint32_t raw_catch_probability;
  memcpy(&raw_catch_probability, &tmp_catch_probability, sizeof(tmp_catch_probability));
  if (raw_catch_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        31, this->_internal_catch_probability(), target);
  }

  // float tackle_probability = 32;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_probability = this->_internal_tackle_probability();
  ::uint32_t raw_tackle_probability;
  memcpy(&raw_tackle_probability, &tmp_tackle_probability, sizeof(tmp_tackle_probability));
  if (raw_tackle_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        32, this->_internal_tackle_probability(), target);
  }

  // float foul_probability = 33;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_probability = this->_internal_foul_probability();
  ::uint32_t raw_foul_probability;
  memcpy(&raw_foul_probability, &tmp_foul_probability, sizeof(tmp_foul_probability));
  if (raw_foul_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        33, this->_internal_foul_probability(), target);
  }

  // .protos.ViewWidth view_width = 34;
  if (this->_internal_view_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        34, this->_internal_view_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Self)
  return target;
}

::size_t Self::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Self)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // .protos.Vector2D position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // .protos.Vector2D seen_position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_position_);
    }

    // .protos.Vector2D heard_position = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.heard_position_);
    }

    // .protos.Vector2D velocity = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.velocity_);
    }

    // .protos.Vector2D seen_velocity = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seen_velocity_);
    }

  }
  // int32 pos_count = 6;
  if (this->_internal_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_pos_count());
  }

  // int32 seen_pos_count = 7;
  if (this->_internal_seen_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_pos_count());
  }

  // int32 heard_pos_count = 8;
  if (this->_internal_heard_pos_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_heard_pos_count());
  }

  // int32 vel_count = 9;
  if (this->_internal_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_vel_count());
  }

  // int32 seen_vel_count = 10;
  if (this->_internal_seen_vel_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_seen_vel_count());
  }

  // int32 ghost_count = 11;
  if (this->_internal_ghost_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_ghost_count());
  }

  // int32 id = 12;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_id());
  }

  // .protos.Side side = 13;
  if (this->_internal_side() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  // int32 uniform_number = 14;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  // int32 uniform_number_count = 15;
  if (this->_internal_uniform_number_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number_count());
  }

  // float body_direction = 17;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    total_size += 6;
  }

  // int32 body_direction_count = 18;
  if (this->_internal_body_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_body_direction_count());
  }

  // float face_direction = 19;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = this->_internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    total_size += 6;
  }

  // int32 face_direction_count = 20;
  if (this->_internal_face_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_face_direction_count());
  }

  // float point_to_direction = 21;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = this->_internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    total_size += 6;
  }

  // int32 point_to_direction_count = 22;
  if (this->_internal_point_to_direction_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_point_to_direction_count());
  }

  // float dist_from_ball = 24;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = this->_internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    total_size += 6;
  }

  // bool is_goalie = 16;
  if (this->_internal_is_goalie() != 0) {
    total_size += 3;
  }

  // bool is_kicking = 23;
  if (this->_internal_is_kicking() != 0) {
    total_size += 3;
  }

  // bool is_tackling = 27;
  if (this->_internal_is_tackling() != 0) {
    total_size += 3;
  }

  // bool is_kickable = 30;
  if (this->_internal_is_kickable() != 0) {
    total_size += 3;
  }

  // float angle_from_ball = 25;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = this->_internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    total_size += 6;
  }

  // int32 ball_reach_steps = 26;
  if (this->_internal_ball_reach_steps() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_ball_reach_steps());
  }

  // float relative_neck_direction = 28;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_neck_direction = this->_internal_relative_neck_direction();
  ::uint32_t raw_relative_neck_direction;
  memcpy(&raw_relative_neck_direction, &tmp_relative_neck_direction, sizeof(tmp_relative_neck_direction));
  if (raw_relative_neck_direction != 0) {
    total_size += 6;
  }

  // float stamina = 29;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina = this->_internal_stamina();
  ::uint32_t raw_stamina;
  memcpy(&raw_stamina, &tmp_stamina, sizeof(tmp_stamina));
  if (raw_stamina != 0) {
    total_size += 6;
  }

  // float catch_probability = 31;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_probability = this->_internal_catch_probability();
  ::uint32_t raw_catch_probability;
  memcpy(&raw_catch_probability, &tmp_catch_probability, sizeof(tmp_catch_probability));
  if (raw_catch_probability != 0) {
    total_size += 6;
  }

  // float tackle_probability = 32;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_probability = this->_internal_tackle_probability();
  ::uint32_t raw_tackle_probability;
  memcpy(&raw_tackle_probability, &tmp_tackle_probability, sizeof(tmp_tackle_probability));
  if (raw_tackle_probability != 0) {
    total_size += 6;
  }

  // float foul_probability = 33;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_probability = this->_internal_foul_probability();
  ::uint32_t raw_foul_probability;
  memcpy(&raw_foul_probability, &tmp_foul_probability, sizeof(tmp_foul_probability));
  if (raw_foul_probability != 0) {
    total_size += 6;
  }

  // .protos.ViewWidth view_width = 34;
  if (this->_internal_view_width() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_view_width());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Self::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Self::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Self::GetClassData() const { return &_class_data_; }


void Self::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Self*>(&to_msg);
  auto& from = static_cast<const Self&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Self)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_seen_position()->::protos::Vector2D::MergeFrom(
          from._internal_seen_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_heard_position()->::protos::Vector2D::MergeFrom(
          from._internal_heard_position());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_velocity());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_seen_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_seen_velocity());
    }
  }
  if (from._internal_pos_count() != 0) {
    _this->_internal_set_pos_count(from._internal_pos_count());
  }
  if (from._internal_seen_pos_count() != 0) {
    _this->_internal_set_seen_pos_count(from._internal_seen_pos_count());
  }
  if (from._internal_heard_pos_count() != 0) {
    _this->_internal_set_heard_pos_count(from._internal_heard_pos_count());
  }
  if (from._internal_vel_count() != 0) {
    _this->_internal_set_vel_count(from._internal_vel_count());
  }
  if (from._internal_seen_vel_count() != 0) {
    _this->_internal_set_seen_vel_count(from._internal_seen_vel_count());
  }
  if (from._internal_ghost_count() != 0) {
    _this->_internal_set_ghost_count(from._internal_ghost_count());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_side() != 0) {
    _this->_internal_set_side(from._internal_side());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  if (from._internal_uniform_number_count() != 0) {
    _this->_internal_set_uniform_number_count(from._internal_uniform_number_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = from._internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    _this->_internal_set_body_direction(from._internal_body_direction());
  }
  if (from._internal_body_direction_count() != 0) {
    _this->_internal_set_body_direction_count(from._internal_body_direction_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_face_direction = from._internal_face_direction();
  ::uint32_t raw_face_direction;
  memcpy(&raw_face_direction, &tmp_face_direction, sizeof(tmp_face_direction));
  if (raw_face_direction != 0) {
    _this->_internal_set_face_direction(from._internal_face_direction());
  }
  if (from._internal_face_direction_count() != 0) {
    _this->_internal_set_face_direction_count(from._internal_face_direction_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_point_to_direction = from._internal_point_to_direction();
  ::uint32_t raw_point_to_direction;
  memcpy(&raw_point_to_direction, &tmp_point_to_direction, sizeof(tmp_point_to_direction));
  if (raw_point_to_direction != 0) {
    _this->_internal_set_point_to_direction(from._internal_point_to_direction());
  }
  if (from._internal_point_to_direction_count() != 0) {
    _this->_internal_set_point_to_direction_count(from._internal_point_to_direction_count());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dist_from_ball = from._internal_dist_from_ball();
  ::uint32_t raw_dist_from_ball;
  memcpy(&raw_dist_from_ball, &tmp_dist_from_ball, sizeof(tmp_dist_from_ball));
  if (raw_dist_from_ball != 0) {
    _this->_internal_set_dist_from_ball(from._internal_dist_from_ball());
  }
  if (from._internal_is_goalie() != 0) {
    _this->_internal_set_is_goalie(from._internal_is_goalie());
  }
  if (from._internal_is_kicking() != 0) {
    _this->_internal_set_is_kicking(from._internal_is_kicking());
  }
  if (from._internal_is_tackling() != 0) {
    _this->_internal_set_is_tackling(from._internal_is_tackling());
  }
  if (from._internal_is_kickable() != 0) {
    _this->_internal_set_is_kickable(from._internal_is_kickable());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle_from_ball = from._internal_angle_from_ball();
  ::uint32_t raw_angle_from_ball;
  memcpy(&raw_angle_from_ball, &tmp_angle_from_ball, sizeof(tmp_angle_from_ball));
  if (raw_angle_from_ball != 0) {
    _this->_internal_set_angle_from_ball(from._internal_angle_from_ball());
  }
  if (from._internal_ball_reach_steps() != 0) {
    _this->_internal_set_ball_reach_steps(from._internal_ball_reach_steps());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_neck_direction = from._internal_relative_neck_direction();
  ::uint32_t raw_relative_neck_direction;
  memcpy(&raw_relative_neck_direction, &tmp_relative_neck_direction, sizeof(tmp_relative_neck_direction));
  if (raw_relative_neck_direction != 0) {
    _this->_internal_set_relative_neck_direction(from._internal_relative_neck_direction());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina = from._internal_stamina();
  ::uint32_t raw_stamina;
  memcpy(&raw_stamina, &tmp_stamina, sizeof(tmp_stamina));
  if (raw_stamina != 0) {
    _this->_internal_set_stamina(from._internal_stamina());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_catch_probability = from._internal_catch_probability();
  ::uint32_t raw_catch_probability;
  memcpy(&raw_catch_probability, &tmp_catch_probability, sizeof(tmp_catch_probability));
  if (raw_catch_probability != 0) {
    _this->_internal_set_catch_probability(from._internal_catch_probability());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_tackle_probability = from._internal_tackle_probability();
  ::uint32_t raw_tackle_probability;
  memcpy(&raw_tackle_probability, &tmp_tackle_probability, sizeof(tmp_tackle_probability));
  if (raw_tackle_probability != 0) {
    _this->_internal_set_tackle_probability(from._internal_tackle_probability());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_foul_probability = from._internal_foul_probability();
  ::uint32_t raw_foul_probability;
  memcpy(&raw_foul_probability, &tmp_foul_probability, sizeof(tmp_foul_probability));
  if (raw_foul_probability != 0) {
    _this->_internal_set_foul_probability(from._internal_foul_probability());
  }
  if (from._internal_view_width() != 0) {
    _this->_internal_set_view_width(from._internal_view_width());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Self::CopyFrom(const Self& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Self)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Self::IsInitialized() const {
  return true;
}

void Self::InternalSwap(Self* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Self, _impl_.view_width_)
      + sizeof(Self::_impl_.view_width_)
      - PROTOBUF_FIELD_OFFSET(Self, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Self::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[3]);
}
// ===================================================================

class InterceptInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<InterceptInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(InterceptInfo, _impl_._has_bits_);
  static const ::protos::Vector2D& final_self_position(const InterceptInfo* msg);
  static void set_has_final_self_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
InterceptInfo::_Internal::final_self_position(const InterceptInfo* msg) {
  return *msg->_impl_.final_self_position_;
}
InterceptInfo::InterceptInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.InterceptInfo)
}
InterceptInfo::InterceptInfo(const InterceptInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InterceptInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.final_self_position_){nullptr}
    , decltype(_impl_.action_type_) {}

    , decltype(_impl_.turn_steps_) {}

    , decltype(_impl_.turn_angle_) {}

    , decltype(_impl_.dash_steps_) {}

    , decltype(_impl_.dash_power_) {}

    , decltype(_impl_.dash_dir_) {}

    , decltype(_impl_.final_ball_dist_) {}

    , decltype(_impl_.final_stamina_) {}

    , decltype(_impl_.value_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.final_self_position_ = new ::protos::Vector2D(*from._impl_.final_self_position_);
  }
  ::memcpy(&_impl_.action_type_, &from._impl_.action_type_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.value_) -
    reinterpret_cast<char*>(&_impl_.action_type_)) + sizeof(_impl_.value_));
  // @@protoc_insertion_point(copy_constructor:protos.InterceptInfo)
}

inline void InterceptInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.final_self_position_){nullptr}
    , decltype(_impl_.action_type_) { 0 }

    , decltype(_impl_.turn_steps_) { 0 }

    , decltype(_impl_.turn_angle_) { 0 }

    , decltype(_impl_.dash_steps_) { 0 }

    , decltype(_impl_.dash_power_) { 0 }

    , decltype(_impl_.dash_dir_) { 0 }

    , decltype(_impl_.final_ball_dist_) { 0 }

    , decltype(_impl_.final_stamina_) { 0 }

    , decltype(_impl_.value_) { 0 }

  };
}

InterceptInfo::~InterceptInfo() {
  // @@protoc_insertion_point(destructor:protos.InterceptInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InterceptInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.final_self_position_;
}

void InterceptInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InterceptInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.InterceptInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.final_self_position_ != nullptr);
    _impl_.final_self_position_->Clear();
  }
  ::memset(&_impl_.action_type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.value_) -
      reinterpret_cast<char*>(&_impl_.action_type_)) + sizeof(_impl_.value_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InterceptInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.InterceptActionType action_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_action_type(static_cast<::protos::InterceptActionType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 turn_steps = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.turn_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float turn_angle = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.turn_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 dash_steps = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.dash_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dash_power = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.dash_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float dash_dir = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 53)) {
          _impl_.dash_dir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D final_self_position = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_final_self_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float final_ball_dist = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 69)) {
          _impl_.final_ball_dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float final_stamina = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 77)) {
          _impl_.final_stamina_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float value = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 85)) {
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* InterceptInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.InterceptInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.InterceptActionType action_type = 1;
  if (this->_internal_action_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_action_type(), target);
  }

  // int32 turn_steps = 2;
  if (this->_internal_turn_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_turn_steps(), target);
  }

  // float turn_angle = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_turn_angle = this->_internal_turn_angle();
  ::uint32_t raw_turn_angle;
  memcpy(&raw_turn_angle, &tmp_turn_angle, sizeof(tmp_turn_angle));
  if (raw_turn_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_turn_angle(), target);
  }

  // int32 dash_steps = 4;
  if (this->_internal_dash_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_dash_steps(), target);
  }

  // float dash_power = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power = this->_internal_dash_power();
  ::uint32_t raw_dash_power;
  memcpy(&raw_dash_power, &tmp_dash_power, sizeof(tmp_dash_power));
  if (raw_dash_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_dash_power(), target);
  }

  // float dash_dir = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_dir = this->_internal_dash_dir();
  ::uint32_t raw_dash_dir;
  memcpy(&raw_dash_dir, &tmp_dash_dir, sizeof(tmp_dash_dir));
  if (raw_dash_dir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_dash_dir(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D final_self_position = 7;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::final_self_position(this),
        _Internal::final_self_position(this).GetCachedSize(), target, stream);
  }

  // float final_ball_dist = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_ball_dist = this->_internal_final_ball_dist();
  ::uint32_t raw_final_ball_dist;
  memcpy(&raw_final_ball_dist, &tmp_final_ball_dist, sizeof(tmp_final_ball_dist));
  if (raw_final_ball_dist != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_final_ball_dist(), target);
  }

  // float final_stamina = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_stamina = this->_internal_final_stamina();
  ::uint32_t raw_final_stamina;
  memcpy(&raw_final_stamina, &tmp_final_stamina, sizeof(tmp_final_stamina));
  if (raw_final_stamina != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_final_stamina(), target);
  }

  // float value = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  ::uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.InterceptInfo)
  return target;
}

::size_t InterceptInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.InterceptInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D final_self_position = 7;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.final_self_position_);
  }

  // .protos.InterceptActionType action_type = 1;
  if (this->_internal_action_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_action_type());
  }

  // int32 turn_steps = 2;
  if (this->_internal_turn_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_turn_steps());
  }

  // float turn_angle = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_turn_angle = this->_internal_turn_angle();
  ::uint32_t raw_turn_angle;
  memcpy(&raw_turn_angle, &tmp_turn_angle, sizeof(tmp_turn_angle));
  if (raw_turn_angle != 0) {
    total_size += 5;
  }

  // int32 dash_steps = 4;
  if (this->_internal_dash_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_dash_steps());
  }

  // float dash_power = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power = this->_internal_dash_power();
  ::uint32_t raw_dash_power;
  memcpy(&raw_dash_power, &tmp_dash_power, sizeof(tmp_dash_power));
  if (raw_dash_power != 0) {
    total_size += 5;
  }

  // float dash_dir = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_dir = this->_internal_dash_dir();
  ::uint32_t raw_dash_dir;
  memcpy(&raw_dash_dir, &tmp_dash_dir, sizeof(tmp_dash_dir));
  if (raw_dash_dir != 0) {
    total_size += 5;
  }

  // float final_ball_dist = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_ball_dist = this->_internal_final_ball_dist();
  ::uint32_t raw_final_ball_dist;
  memcpy(&raw_final_ball_dist, &tmp_final_ball_dist, sizeof(tmp_final_ball_dist));
  if (raw_final_ball_dist != 0) {
    total_size += 5;
  }

  // float final_stamina = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_stamina = this->_internal_final_stamina();
  ::uint32_t raw_final_stamina;
  memcpy(&raw_final_stamina, &tmp_final_stamina, sizeof(tmp_final_stamina));
  if (raw_final_stamina != 0) {
    total_size += 5;
  }

  // float value = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  ::uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InterceptInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InterceptInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InterceptInfo::GetClassData() const { return &_class_data_; }


void InterceptInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InterceptInfo*>(&to_msg);
  auto& from = static_cast<const InterceptInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.InterceptInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_final_self_position()->::protos::Vector2D::MergeFrom(
        from._internal_final_self_position());
  }
  if (from._internal_action_type() != 0) {
    _this->_internal_set_action_type(from._internal_action_type());
  }
  if (from._internal_turn_steps() != 0) {
    _this->_internal_set_turn_steps(from._internal_turn_steps());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_turn_angle = from._internal_turn_angle();
  ::uint32_t raw_turn_angle;
  memcpy(&raw_turn_angle, &tmp_turn_angle, sizeof(tmp_turn_angle));
  if (raw_turn_angle != 0) {
    _this->_internal_set_turn_angle(from._internal_turn_angle());
  }
  if (from._internal_dash_steps() != 0) {
    _this->_internal_set_dash_steps(from._internal_dash_steps());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_power = from._internal_dash_power();
  ::uint32_t raw_dash_power;
  memcpy(&raw_dash_power, &tmp_dash_power, sizeof(tmp_dash_power));
  if (raw_dash_power != 0) {
    _this->_internal_set_dash_power(from._internal_dash_power());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_dash_dir = from._internal_dash_dir();
  ::uint32_t raw_dash_dir;
  memcpy(&raw_dash_dir, &tmp_dash_dir, sizeof(tmp_dash_dir));
  if (raw_dash_dir != 0) {
    _this->_internal_set_dash_dir(from._internal_dash_dir());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_ball_dist = from._internal_final_ball_dist();
  ::uint32_t raw_final_ball_dist;
  memcpy(&raw_final_ball_dist, &tmp_final_ball_dist, sizeof(tmp_final_ball_dist));
  if (raw_final_ball_dist != 0) {
    _this->_internal_set_final_ball_dist(from._internal_final_ball_dist());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_final_stamina = from._internal_final_stamina();
  ::uint32_t raw_final_stamina;
  memcpy(&raw_final_stamina, &tmp_final_stamina, sizeof(tmp_final_stamina));
  if (raw_final_stamina != 0) {
    _this->_internal_set_final_stamina(from._internal_final_stamina());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_value = from._internal_value();
  ::uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InterceptInfo::CopyFrom(const InterceptInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.InterceptInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InterceptInfo::IsInitialized() const {
  return true;
}

void InterceptInfo::InternalSwap(InterceptInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InterceptInfo, _impl_.value_)
      + sizeof(InterceptInfo::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(InterceptInfo, _impl_.final_self_position_)>(
          reinterpret_cast<char*>(&_impl_.final_self_position_),
          reinterpret_cast<char*>(&other->_impl_.final_self_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InterceptInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[4]);
}
// ===================================================================

class InterceptTable::_Internal {
 public:
};

InterceptTable::InterceptTable(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.InterceptTable)
}
InterceptTable::InterceptTable(const InterceptTable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InterceptTable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.self_intercept_info_){from._impl_.self_intercept_info_}
    , decltype(_impl_.self_reach_steps_) {}

    , decltype(_impl_.first_teammate_reach_steps_) {}

    , decltype(_impl_.second_teammate_reach_steps_) {}

    , decltype(_impl_.first_opponent_reach_steps_) {}

    , decltype(_impl_.second_opponent_reach_steps_) {}

    , decltype(_impl_.first_teammate_id_) {}

    , decltype(_impl_.second_teammate_id_) {}

    , decltype(_impl_.first_opponent_id_) {}

    , decltype(_impl_.second_opponent_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.self_reach_steps_, &from._impl_.self_reach_steps_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.second_opponent_id_) -
    reinterpret_cast<char*>(&_impl_.self_reach_steps_)) + sizeof(_impl_.second_opponent_id_));
  // @@protoc_insertion_point(copy_constructor:protos.InterceptTable)
}

inline void InterceptTable::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.self_intercept_info_){arena}
    , decltype(_impl_.self_reach_steps_) { 0 }

    , decltype(_impl_.first_teammate_reach_steps_) { 0 }

    , decltype(_impl_.second_teammate_reach_steps_) { 0 }

    , decltype(_impl_.first_opponent_reach_steps_) { 0 }

    , decltype(_impl_.second_opponent_reach_steps_) { 0 }

    , decltype(_impl_.first_teammate_id_) { 0 }

    , decltype(_impl_.second_teammate_id_) { 0 }

    , decltype(_impl_.first_opponent_id_) { 0 }

    , decltype(_impl_.second_opponent_id_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

InterceptTable::~InterceptTable() {
  // @@protoc_insertion_point(destructor:protos.InterceptTable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InterceptTable::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_self_intercept_info()->~RepeatedPtrField();
}

void InterceptTable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InterceptTable::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.InterceptTable)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_self_intercept_info()->Clear();
  ::memset(&_impl_.self_reach_steps_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.second_opponent_id_) -
      reinterpret_cast<char*>(&_impl_.self_reach_steps_)) + sizeof(_impl_.second_opponent_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InterceptTable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 self_reach_steps = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.self_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 first_teammate_reach_steps = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.first_teammate_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 second_teammate_reach_steps = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.second_teammate_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 first_opponent_reach_steps = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.first_opponent_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 second_opponent_reach_steps = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.second_opponent_reach_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 first_teammate_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.first_teammate_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 second_teammate_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.second_teammate_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 first_opponent_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.first_opponent_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 second_opponent_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.second_opponent_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .protos.InterceptInfo self_intercept_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_self_intercept_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* InterceptTable::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.InterceptTable)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 self_reach_steps = 1;
  if (this->_internal_self_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_self_reach_steps(), target);
  }

  // int32 first_teammate_reach_steps = 2;
  if (this->_internal_first_teammate_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_first_teammate_reach_steps(), target);
  }

  // int32 second_teammate_reach_steps = 3;
  if (this->_internal_second_teammate_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_second_teammate_reach_steps(), target);
  }

  // int32 first_opponent_reach_steps = 4;
  if (this->_internal_first_opponent_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_first_opponent_reach_steps(), target);
  }

  // int32 second_opponent_reach_steps = 5;
  if (this->_internal_second_opponent_reach_steps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_second_opponent_reach_steps(), target);
  }

  // int32 first_teammate_id = 6;
  if (this->_internal_first_teammate_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_first_teammate_id(), target);
  }

  // int32 second_teammate_id = 7;
  if (this->_internal_second_teammate_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_second_teammate_id(), target);
  }

  // int32 first_opponent_id = 8;
  if (this->_internal_first_opponent_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_first_opponent_id(), target);
  }

  // int32 second_opponent_id = 9;
  if (this->_internal_second_opponent_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        9, this->_internal_second_opponent_id(), target);
  }

  // repeated .protos.InterceptInfo self_intercept_info = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_self_intercept_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_self_intercept_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.InterceptTable)
  return target;
}

::size_t InterceptTable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.InterceptTable)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protos.InterceptInfo self_intercept_info = 10;
  total_size += 1UL * this->_internal_self_intercept_info_size();
  for (const auto& msg : this->_internal_self_intercept_info()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int32 self_reach_steps = 1;
  if (this->_internal_self_reach_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_self_reach_steps());
  }

  // int32 first_teammate_reach_steps = 2;
  if (this->_internal_first_teammate_reach_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_first_teammate_reach_steps());
  }

  // int32 second_teammate_reach_steps = 3;
  if (this->_internal_second_teammate_reach_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_second_teammate_reach_steps());
  }

  // int32 first_opponent_reach_steps = 4;
  if (this->_internal_first_opponent_reach_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_first_opponent_reach_steps());
  }

  // int32 second_opponent_reach_steps = 5;
  if (this->_internal_second_opponent_reach_steps() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_second_opponent_reach_steps());
  }

  // int32 first_teammate_id = 6;
  if (this->_internal_first_teammate_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_first_teammate_id());
  }

  // int32 second_teammate_id = 7;
  if (this->_internal_second_teammate_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_second_teammate_id());
  }

  // int32 first_opponent_id = 8;
  if (this->_internal_first_opponent_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_first_opponent_id());
  }

  // int32 second_opponent_id = 9;
  if (this->_internal_second_opponent_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_second_opponent_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InterceptTable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InterceptTable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InterceptTable::GetClassData() const { return &_class_data_; }


void InterceptTable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InterceptTable*>(&to_msg);
  auto& from = static_cast<const InterceptTable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.InterceptTable)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_self_intercept_info()->MergeFrom(from._internal_self_intercept_info());
  if (from._internal_self_reach_steps() != 0) {
    _this->_internal_set_self_reach_steps(from._internal_self_reach_steps());
  }
  if (from._internal_first_teammate_reach_steps() != 0) {
    _this->_internal_set_first_teammate_reach_steps(from._internal_first_teammate_reach_steps());
  }
  if (from._internal_second_teammate_reach_steps() != 0) {
    _this->_internal_set_second_teammate_reach_steps(from._internal_second_teammate_reach_steps());
  }
  if (from._internal_first_opponent_reach_steps() != 0) {
    _this->_internal_set_first_opponent_reach_steps(from._internal_first_opponent_reach_steps());
  }
  if (from._internal_second_opponent_reach_steps() != 0) {
    _this->_internal_set_second_opponent_reach_steps(from._internal_second_opponent_reach_steps());
  }
  if (from._internal_first_teammate_id() != 0) {
    _this->_internal_set_first_teammate_id(from._internal_first_teammate_id());
  }
  if (from._internal_second_teammate_id() != 0) {
    _this->_internal_set_second_teammate_id(from._internal_second_teammate_id());
  }
  if (from._internal_first_opponent_id() != 0) {
    _this->_internal_set_first_opponent_id(from._internal_first_opponent_id());
  }
  if (from._internal_second_opponent_id() != 0) {
    _this->_internal_set_second_opponent_id(from._internal_second_opponent_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InterceptTable::CopyFrom(const InterceptTable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.InterceptTable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InterceptTable::IsInitialized() const {
  return true;
}

void InterceptTable::InternalSwap(InterceptTable* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_self_intercept_info()->InternalSwap(other->_internal_mutable_self_intercept_info());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InterceptTable, _impl_.second_opponent_id_)
      + sizeof(InterceptTable::_impl_.second_opponent_id_)
      - PROTOBUF_FIELD_OFFSET(InterceptTable, _impl_.self_reach_steps_)>(
          reinterpret_cast<char*>(&_impl_.self_reach_steps_),
          reinterpret_cast<char*>(&other->_impl_.self_reach_steps_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InterceptTable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[5]);
}
// ===================================================================

WorldModel_OurPlayersDictEntry_DoNotUse::WorldModel_OurPlayersDictEntry_DoNotUse() {}
WorldModel_OurPlayersDictEntry_DoNotUse::WorldModel_OurPlayersDictEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void WorldModel_OurPlayersDictEntry_DoNotUse::MergeFrom(const WorldModel_OurPlayersDictEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata WorldModel_OurPlayersDictEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[6]);
}
// ===================================================================

WorldModel_TheirPlayersDictEntry_DoNotUse::WorldModel_TheirPlayersDictEntry_DoNotUse() {}
WorldModel_TheirPlayersDictEntry_DoNotUse::WorldModel_TheirPlayersDictEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void WorldModel_TheirPlayersDictEntry_DoNotUse::MergeFrom(const WorldModel_TheirPlayersDictEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata WorldModel_TheirPlayersDictEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[7]);
}
// ===================================================================

class WorldModel::_Internal {
 public:
  using HasBits = decltype(std::declval<WorldModel>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(WorldModel, _impl_._has_bits_);
  static const ::protos::InterceptTable& intercept_table(const WorldModel* msg);
  static void set_has_intercept_table(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Self& self(const WorldModel* msg);
  static void set_has_self(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Ball& ball(const WorldModel* msg);
  static void set_has_ball(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::protos::InterceptTable&
WorldModel::_Internal::intercept_table(const WorldModel* msg) {
  return *msg->_impl_.intercept_table_;
}
const ::protos::Self&
WorldModel::_Internal::self(const WorldModel* msg) {
  return *msg->_impl_.self_;
}
const ::protos::Ball&
WorldModel::_Internal::ball(const WorldModel* msg) {
  return *msg->_impl_.ball_;
}
WorldModel::WorldModel(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.WorldModel)
}
WorldModel::WorldModel(const WorldModel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WorldModel* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.teammates_){from._impl_.teammates_}
    , decltype(_impl_.opponents_){from._impl_.opponents_}
    , decltype(_impl_.unknowns_){from._impl_.unknowns_}
    , /*decltype(_impl_.our_players_dict_)*/{}
    , /*decltype(_impl_.their_players_dict_)*/{}
    , decltype(_impl_.our_team_name_) {}

    , decltype(_impl_.their_team_name_) {}

    , decltype(_impl_.intercept_table_){nullptr}
    , decltype(_impl_.self_){nullptr}
    , decltype(_impl_.ball_){nullptr}
    , decltype(_impl_.our_side_) {}

    , decltype(_impl_.last_set_play_start_time_) {}

    , decltype(_impl_.our_goalie_uniform_number_) {}

    , decltype(_impl_.their_goalie_uniform_number_) {}

    , decltype(_impl_.offside_line_x_) {}

    , decltype(_impl_.ofside_line_x_count_) {}

    , decltype(_impl_.kickable_teammate_id_) {}

    , decltype(_impl_.kickable_opponent_id_) {}

    , decltype(_impl_.last_kick_side_) {}

    , decltype(_impl_.last_kicker_uniform_number_) {}

    , decltype(_impl_.cycle_) {}

    , decltype(_impl_.game_mode_type_) {}

    , decltype(_impl_.left_team_score_) {}

    , decltype(_impl_.right_team_score_) {}

    , decltype(_impl_.is_our_set_play_) {}

    , decltype(_impl_.is_their_set_play_) {}

    , decltype(_impl_.stoped_cycle_) {}

    , decltype(_impl_.our_team_score_) {}

    , decltype(_impl_.their_team_score_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.our_players_dict_.MergeFrom(from._impl_.our_players_dict_);
  _this->_impl_.their_players_dict_.MergeFrom(from._impl_.their_players_dict_);
  _impl_.our_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.our_team_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_our_team_name().empty()) {
    _this->_impl_.our_team_name_.Set(from._internal_our_team_name(), _this->GetArenaForAllocation());
  }
  _impl_.their_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.their_team_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_their_team_name().empty()) {
    _this->_impl_.their_team_name_.Set(from._internal_their_team_name(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.intercept_table_ = new ::protos::InterceptTable(*from._impl_.intercept_table_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.self_ = new ::protos::Self(*from._impl_.self_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.ball_ = new ::protos::Ball(*from._impl_.ball_);
  }
  ::memcpy(&_impl_.our_side_, &from._impl_.our_side_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.their_team_score_) -
    reinterpret_cast<char*>(&_impl_.our_side_)) + sizeof(_impl_.their_team_score_));
  // @@protoc_insertion_point(copy_constructor:protos.WorldModel)
}

inline void WorldModel::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.teammates_){arena}
    , decltype(_impl_.opponents_){arena}
    , decltype(_impl_.unknowns_){arena}
    , /*decltype(_impl_.our_players_dict_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.their_players_dict_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.our_team_name_) {}

    , decltype(_impl_.their_team_name_) {}

    , decltype(_impl_.intercept_table_){nullptr}
    , decltype(_impl_.self_){nullptr}
    , decltype(_impl_.ball_){nullptr}
    , decltype(_impl_.our_side_) { 0 }

    , decltype(_impl_.last_set_play_start_time_) { 0 }

    , decltype(_impl_.our_goalie_uniform_number_) { 0 }

    , decltype(_impl_.their_goalie_uniform_number_) { 0 }

    , decltype(_impl_.offside_line_x_) { 0 }

    , decltype(_impl_.ofside_line_x_count_) { 0 }

    , decltype(_impl_.kickable_teammate_id_) { 0 }

    , decltype(_impl_.kickable_opponent_id_) { 0 }

    , decltype(_impl_.last_kick_side_) { 0 }

    , decltype(_impl_.last_kicker_uniform_number_) { 0 }

    , decltype(_impl_.cycle_) { 0 }

    , decltype(_impl_.game_mode_type_) { 0 }

    , decltype(_impl_.left_team_score_) { 0 }

    , decltype(_impl_.right_team_score_) { 0 }

    , decltype(_impl_.is_our_set_play_) { false }

    , decltype(_impl_.is_their_set_play_) { false }

    , decltype(_impl_.stoped_cycle_) { 0 }

    , decltype(_impl_.our_team_score_) { 0 }

    , decltype(_impl_.their_team_score_) { 0 }

  };
  _impl_.our_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.our_team_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.their_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.their_team_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WorldModel::~WorldModel() {
  // @@protoc_insertion_point(destructor:protos.WorldModel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WorldModel::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_teammates()->~RepeatedPtrField();
  _internal_mutable_opponents()->~RepeatedPtrField();
  _internal_mutable_unknowns()->~RepeatedPtrField();
  _impl_.our_players_dict_.~MapField();
  _impl_.their_players_dict_.~MapField();
  _impl_.our_team_name_.Destroy();
  _impl_.their_team_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.intercept_table_;
  if (this != internal_default_instance()) delete _impl_.self_;
  if (this != internal_default_instance()) delete _impl_.ball_;
}

void WorldModel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WorldModel::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.WorldModel)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_teammates()->Clear();
  _internal_mutable_opponents()->Clear();
  _internal_mutable_unknowns()->Clear();
  _impl_.our_players_dict_.Clear();
  _impl_.their_players_dict_.Clear();
  _impl_.our_team_name_.ClearToEmpty();
  _impl_.their_team_name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.intercept_table_ != nullptr);
      _impl_.intercept_table_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.self_ != nullptr);
      _impl_.self_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.ball_ != nullptr);
      _impl_.ball_->Clear();
    }
  }
  ::memset(&_impl_.our_side_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.their_team_score_) -
      reinterpret_cast<char*>(&_impl_.our_side_)) + sizeof(_impl_.their_team_score_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WorldModel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.InterceptTable intercept_table = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_intercept_table(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string our_team_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_our_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.WorldModel.our_team_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string their_team_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_their_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.WorldModel.their_team_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Side our_side = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_our_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 last_set_play_start_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.last_set_play_start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Self self = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_self(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Ball ball = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .protos.Player teammates = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_teammates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .protos.Player opponents = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_opponents(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .protos.Player unknowns = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_unknowns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // map<int32, .protos.Player> our_players_dict = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.our_players_dict_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // map<int32, .protos.Player> their_players_dict = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.their_players_dict_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 our_goalie_uniform_number = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _impl_.our_goalie_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 their_goalie_uniform_number = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.their_goalie_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float offside_line_x = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 125)) {
          _impl_.offside_line_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ofside_line_x_count = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _impl_.ofside_line_x_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 kickable_teammate_id = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 136)) {
          _impl_.kickable_teammate_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 kickable_opponent_id = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
          _impl_.kickable_opponent_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Side last_kick_side = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 152)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_last_kick_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 last_kicker_uniform_number = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _impl_.last_kicker_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 cycle = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 168)) {
          _impl_.cycle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.GameModeType game_mode_type = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 176)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_game_mode_type(static_cast<::protos::GameModeType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 left_team_score = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 184)) {
          _impl_.left_team_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 right_team_score = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 192)) {
          _impl_.right_team_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_our_set_play = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 200)) {
          _impl_.is_our_set_play_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_their_set_play = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 208)) {
          _impl_.is_their_set_play_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 stoped_cycle = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 216)) {
          _impl_.stoped_cycle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 our_team_score = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 224)) {
          _impl_.our_team_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 their_team_score = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 232)) {
          _impl_.their_team_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* WorldModel::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.WorldModel)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.InterceptTable intercept_table = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::intercept_table(this),
        _Internal::intercept_table(this).GetCachedSize(), target, stream);
  }

  // string our_team_name = 2;
  if (!this->_internal_our_team_name().empty()) {
    const std::string& _s = this->_internal_our_team_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.WorldModel.our_team_name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string their_team_name = 3;
  if (!this->_internal_their_team_name().empty()) {
    const std::string& _s = this->_internal_their_team_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.WorldModel.their_team_name");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // .protos.Side our_side = 4;
  if (this->_internal_our_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_our_side(), target);
  }

  // int32 last_set_play_start_time = 5;
  if (this->_internal_last_set_play_start_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_last_set_play_start_time(), target);
  }

  // .protos.Self self = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::self(this),
        _Internal::self(this).GetCachedSize(), target, stream);
  }

  // .protos.Ball ball = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::ball(this),
        _Internal::ball(this).GetCachedSize(), target, stream);
  }

  // repeated .protos.Player teammates = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_teammates_size()); i < n; i++) {
    const auto& repfield = this->_internal_teammates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .protos.Player opponents = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_opponents_size()); i < n; i++) {
    const auto& repfield = this->_internal_opponents(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .protos.Player unknowns = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_unknowns_size()); i < n; i++) {
    const auto& repfield = this->_internal_unknowns(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // map<int32, .protos.Player> our_players_dict = 11;
  if (!this->_internal_our_players_dict().empty()) {
    using MapType = ::_pb::Map<::int32_t, ::protos::Player>;
    using WireHelper = WorldModel_OurPlayersDictEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_our_players_dict();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(11, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(11, entry.first, entry.second, target, stream);
      }
    }
  }

  // map<int32, .protos.Player> their_players_dict = 12;
  if (!this->_internal_their_players_dict().empty()) {
    using MapType = ::_pb::Map<::int32_t, ::protos::Player>;
    using WireHelper = WorldModel_TheirPlayersDictEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_their_players_dict();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(12, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(12, entry.first, entry.second, target, stream);
      }
    }
  }

  // int32 our_goalie_uniform_number = 13;
  if (this->_internal_our_goalie_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        13, this->_internal_our_goalie_uniform_number(), target);
  }

  // int32 their_goalie_uniform_number = 14;
  if (this->_internal_their_goalie_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        14, this->_internal_their_goalie_uniform_number(), target);
  }

  // float offside_line_x = 15;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_line_x = this->_internal_offside_line_x();
  ::uint32_t raw_offside_line_x;
  memcpy(&raw_offside_line_x, &tmp_offside_line_x, sizeof(tmp_offside_line_x));
  if (raw_offside_line_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        15, this->_internal_offside_line_x(), target);
  }

  // int32 ofside_line_x_count = 16;
  if (this->_internal_ofside_line_x_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        16, this->_internal_ofside_line_x_count(), target);
  }

  // int32 kickable_teammate_id = 17;
  if (this->_internal_kickable_teammate_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        17, this->_internal_kickable_teammate_id(), target);
  }

  // int32 kickable_opponent_id = 18;
  if (this->_internal_kickable_opponent_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        18, this->_internal_kickable_opponent_id(), target);
  }

  // .protos.Side last_kick_side = 19;
  if (this->_internal_last_kick_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        19, this->_internal_last_kick_side(), target);
  }

  // int32 last_kicker_uniform_number = 20;
  if (this->_internal_last_kicker_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        20, this->_internal_last_kicker_uniform_number(), target);
  }

  // int32 cycle = 21;
  if (this->_internal_cycle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        21, this->_internal_cycle(), target);
  }

  // .protos.GameModeType game_mode_type = 22;
  if (this->_internal_game_mode_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        22, this->_internal_game_mode_type(), target);
  }

  // int32 left_team_score = 23;
  if (this->_internal_left_team_score() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        23, this->_internal_left_team_score(), target);
  }

  // int32 right_team_score = 24;
  if (this->_internal_right_team_score() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        24, this->_internal_right_team_score(), target);
  }

  // bool is_our_set_play = 25;
  if (this->_internal_is_our_set_play() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        25, this->_internal_is_our_set_play(), target);
  }

  // bool is_their_set_play = 26;
  if (this->_internal_is_their_set_play() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        26, this->_internal_is_their_set_play(), target);
  }

  // int32 stoped_cycle = 27;
  if (this->_internal_stoped_cycle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        27, this->_internal_stoped_cycle(), target);
  }

  // int32 our_team_score = 28;
  if (this->_internal_our_team_score() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        28, this->_internal_our_team_score(), target);
  }

  // int32 their_team_score = 29;
  if (this->_internal_their_team_score() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        29, this->_internal_their_team_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.WorldModel)
  return target;
}

::size_t WorldModel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.WorldModel)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protos.Player teammates = 8;
  total_size += 1UL * this->_internal_teammates_size();
  for (const auto& msg : this->_internal_teammates()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .protos.Player opponents = 9;
  total_size += 1UL * this->_internal_opponents_size();
  for (const auto& msg : this->_internal_opponents()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .protos.Player unknowns = 10;
  total_size += 1UL * this->_internal_unknowns_size();
  for (const auto& msg : this->_internal_unknowns()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<int32, .protos.Player> our_players_dict = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_our_players_dict_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >::const_iterator
      it = this->_internal_our_players_dict().begin();
      it != this->_internal_our_players_dict().end(); ++it) {
    total_size += WorldModel_OurPlayersDictEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<int32, .protos.Player> their_players_dict = 12;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_their_players_dict_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >::const_iterator
      it = this->_internal_their_players_dict().begin();
      it != this->_internal_their_players_dict().end(); ++it) {
    total_size += WorldModel_TheirPlayersDictEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string our_team_name = 2;
  if (!this->_internal_our_team_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_our_team_name());
  }

  // string their_team_name = 3;
  if (!this->_internal_their_team_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_their_team_name());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .protos.InterceptTable intercept_table = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.intercept_table_);
    }

    // .protos.Self self = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.self_);
    }

    // .protos.Ball ball = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_);
    }

  }
  // .protos.Side our_side = 4;
  if (this->_internal_our_side() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_our_side());
  }

  // int32 last_set_play_start_time = 5;
  if (this->_internal_last_set_play_start_time() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_last_set_play_start_time());
  }

  // int32 our_goalie_uniform_number = 13;
  if (this->_internal_our_goalie_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_our_goalie_uniform_number());
  }

  // int32 their_goalie_uniform_number = 14;
  if (this->_internal_their_goalie_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_their_goalie_uniform_number());
  }

  // float offside_line_x = 15;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_line_x = this->_internal_offside_line_x();
  ::uint32_t raw_offside_line_x;
  memcpy(&raw_offside_line_x, &tmp_offside_line_x, sizeof(tmp_offside_line_x));
  if (raw_offside_line_x != 0) {
    total_size += 5;
  }

  // int32 ofside_line_x_count = 16;
  if (this->_internal_ofside_line_x_count() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_ofside_line_x_count());
  }

  // int32 kickable_teammate_id = 17;
  if (this->_internal_kickable_teammate_id() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_kickable_teammate_id());
  }

  // int32 kickable_opponent_id = 18;
  if (this->_internal_kickable_opponent_id() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_kickable_opponent_id());
  }

  // .protos.Side last_kick_side = 19;
  if (this->_internal_last_kick_side() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_last_kick_side());
  }

  // int32 last_kicker_uniform_number = 20;
  if (this->_internal_last_kicker_uniform_number() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_last_kicker_uniform_number());
  }

  // int32 cycle = 21;
  if (this->_internal_cycle() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_cycle());
  }

  // .protos.GameModeType game_mode_type = 22;
  if (this->_internal_game_mode_type() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_game_mode_type());
  }

  // int32 left_team_score = 23;
  if (this->_internal_left_team_score() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_left_team_score());
  }

  // int32 right_team_score = 24;
  if (this->_internal_right_team_score() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_right_team_score());
  }

  // bool is_our_set_play = 25;
  if (this->_internal_is_our_set_play() != 0) {
    total_size += 3;
  }

  // bool is_their_set_play = 26;
  if (this->_internal_is_their_set_play() != 0) {
    total_size += 3;
  }

  // int32 stoped_cycle = 27;
  if (this->_internal_stoped_cycle() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_stoped_cycle());
  }

  // int32 our_team_score = 28;
  if (this->_internal_our_team_score() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_our_team_score());
  }

  // int32 their_team_score = 29;
  if (this->_internal_their_team_score() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_their_team_score());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WorldModel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WorldModel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WorldModel::GetClassData() const { return &_class_data_; }


void WorldModel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WorldModel*>(&to_msg);
  auto& from = static_cast<const WorldModel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.WorldModel)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_teammates()->MergeFrom(from._internal_teammates());
  _this->_internal_mutable_opponents()->MergeFrom(from._internal_opponents());
  _this->_internal_mutable_unknowns()->MergeFrom(from._internal_unknowns());
  _this->_impl_.our_players_dict_.MergeFrom(from._impl_.our_players_dict_);
  _this->_impl_.their_players_dict_.MergeFrom(from._impl_.their_players_dict_);
  if (!from._internal_our_team_name().empty()) {
    _this->_internal_set_our_team_name(from._internal_our_team_name());
  }
  if (!from._internal_their_team_name().empty()) {
    _this->_internal_set_their_team_name(from._internal_their_team_name());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_intercept_table()->::protos::InterceptTable::MergeFrom(
          from._internal_intercept_table());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_self()->::protos::Self::MergeFrom(
          from._internal_self());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_ball()->::protos::Ball::MergeFrom(
          from._internal_ball());
    }
  }
  if (from._internal_our_side() != 0) {
    _this->_internal_set_our_side(from._internal_our_side());
  }
  if (from._internal_last_set_play_start_time() != 0) {
    _this->_internal_set_last_set_play_start_time(from._internal_last_set_play_start_time());
  }
  if (from._internal_our_goalie_uniform_number() != 0) {
    _this->_internal_set_our_goalie_uniform_number(from._internal_our_goalie_uniform_number());
  }
  if (from._internal_their_goalie_uniform_number() != 0) {
    _this->_internal_set_their_goalie_uniform_number(from._internal_their_goalie_uniform_number());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_line_x = from._internal_offside_line_x();
  ::uint32_t raw_offside_line_x;
  memcpy(&raw_offside_line_x, &tmp_offside_line_x, sizeof(tmp_offside_line_x));
  if (raw_offside_line_x != 0) {
    _this->_internal_set_offside_line_x(from._internal_offside_line_x());
  }
  if (from._internal_ofside_line_x_count() != 0) {
    _this->_internal_set_ofside_line_x_count(from._internal_ofside_line_x_count());
  }
  if (from._internal_kickable_teammate_id() != 0) {
    _this->_internal_set_kickable_teammate_id(from._internal_kickable_teammate_id());
  }
  if (from._internal_kickable_opponent_id() != 0) {
    _this->_internal_set_kickable_opponent_id(from._internal_kickable_opponent_id());
  }
  if (from._internal_last_kick_side() != 0) {
    _this->_internal_set_last_kick_side(from._internal_last_kick_side());
  }
  if (from._internal_last_kicker_uniform_number() != 0) {
    _this->_internal_set_last_kicker_uniform_number(from._internal_last_kicker_uniform_number());
  }
  if (from._internal_cycle() != 0) {
    _this->_internal_set_cycle(from._internal_cycle());
  }
  if (from._internal_game_mode_type() != 0) {
    _this->_internal_set_game_mode_type(from._internal_game_mode_type());
  }
  if (from._internal_left_team_score() != 0) {
    _this->_internal_set_left_team_score(from._internal_left_team_score());
  }
  if (from._internal_right_team_score() != 0) {
    _this->_internal_set_right_team_score(from._internal_right_team_score());
  }
  if (from._internal_is_our_set_play() != 0) {
    _this->_internal_set_is_our_set_play(from._internal_is_our_set_play());
  }
  if (from._internal_is_their_set_play() != 0) {
    _this->_internal_set_is_their_set_play(from._internal_is_their_set_play());
  }
  if (from._internal_stoped_cycle() != 0) {
    _this->_internal_set_stoped_cycle(from._internal_stoped_cycle());
  }
  if (from._internal_our_team_score() != 0) {
    _this->_internal_set_our_team_score(from._internal_our_team_score());
  }
  if (from._internal_their_team_score() != 0) {
    _this->_internal_set_their_team_score(from._internal_their_team_score());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WorldModel::CopyFrom(const WorldModel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.WorldModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WorldModel::IsInitialized() const {
  return true;
}

void WorldModel::InternalSwap(WorldModel* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_teammates()->InternalSwap(other->_internal_mutable_teammates());
  _internal_mutable_opponents()->InternalSwap(other->_internal_mutable_opponents());
  _internal_mutable_unknowns()->InternalSwap(other->_internal_mutable_unknowns());
  _impl_.our_players_dict_.InternalSwap(&other->_impl_.our_players_dict_);
  _impl_.their_players_dict_.InternalSwap(&other->_impl_.their_players_dict_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.our_team_name_, lhs_arena,
                                       &other->_impl_.our_team_name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.their_team_name_, lhs_arena,
                                       &other->_impl_.their_team_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WorldModel, _impl_.their_team_score_)
      + sizeof(WorldModel::_impl_.their_team_score_)
      - PROTOBUF_FIELD_OFFSET(WorldModel, _impl_.intercept_table_)>(
          reinterpret_cast<char*>(&_impl_.intercept_table_),
          reinterpret_cast<char*>(&other->_impl_.intercept_table_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WorldModel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[8]);
}
// ===================================================================

class State::_Internal {
 public:
  using HasBits = decltype(std::declval<State>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(State, _impl_._has_bits_);
  static const ::protos::WorldModel& world_model(const State* msg);
  static void set_has_world_model(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::WorldModel& full_world_model(const State* msg);
  static void set_has_full_world_model(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::protos::WorldModel&
State::_Internal::world_model(const State* msg) {
  return *msg->_impl_.world_model_;
}
const ::protos::WorldModel&
State::_Internal::full_world_model(const State* msg) {
  return *msg->_impl_.full_world_model_;
}
State::State(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.State)
}
State::State(const State& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  State* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.world_model_){nullptr}
    , decltype(_impl_.full_world_model_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.world_model_ = new ::protos::WorldModel(*from._impl_.world_model_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.full_world_model_ = new ::protos::WorldModel(*from._impl_.full_world_model_);
  }
  // @@protoc_insertion_point(copy_constructor:protos.State)
}

inline void State::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.world_model_){nullptr}
    , decltype(_impl_.full_world_model_){nullptr}
  };
}

State::~State() {
  // @@protoc_insertion_point(destructor:protos.State)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void State::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.world_model_;
  if (this != internal_default_instance()) delete _impl_.full_world_model_;
}

void State::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void State::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.State)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.world_model_ != nullptr);
      _impl_.world_model_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.full_world_model_ != nullptr);
      _impl_.full_world_model_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* State::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.WorldModel world_model = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_world_model(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.WorldModel full_world_model = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_full_world_model(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* State::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.State)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.WorldModel world_model = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::world_model(this),
        _Internal::world_model(this).GetCachedSize(), target, stream);
  }

  // .protos.WorldModel full_world_model = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::full_world_model(this),
        _Internal::full_world_model(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.State)
  return target;
}

::size_t State::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.State)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .protos.WorldModel world_model = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.world_model_);
    }

    // .protos.WorldModel full_world_model = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.full_world_model_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData State::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    State::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*State::GetClassData() const { return &_class_data_; }


void State::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<State*>(&to_msg);
  auto& from = static_cast<const State&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.State)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_world_model()->::protos::WorldModel::MergeFrom(
          from._internal_world_model());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_full_world_model()->::protos::WorldModel::MergeFrom(
          from._internal_full_world_model());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void State::CopyFrom(const State& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.State)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool State::IsInitialized() const {
  return true;
}

void State::InternalSwap(State* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(State, _impl_.full_world_model_)
      + sizeof(State::_impl_.full_world_model_)
      - PROTOBUF_FIELD_OFFSET(State, _impl_.world_model_)>(
          reinterpret_cast<char*>(&_impl_.world_model_),
          reinterpret_cast<char*>(&other->_impl_.world_model_));
}

::PROTOBUF_NAMESPACE_ID::Metadata State::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[9]);
}
// ===================================================================

class Dash::_Internal {
 public:
};

Dash::Dash(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Dash)
}
Dash::Dash(const Dash& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Dash)
}

inline void Dash::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.power_) { 0 }

    , decltype(_impl_.relative_direction_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Dash::~Dash() {
  // @@protoc_insertion_point(destructor:protos.Dash)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Dash::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Dash::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Dash::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Dash)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.power_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.relative_direction_) -
      reinterpret_cast<char*>(&_impl_.power_)) + sizeof(_impl_.relative_direction_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Dash::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float power = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float relative_direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.relative_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Dash::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Dash)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float power = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = this->_internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_power(), target);
  }

  // float relative_direction = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_relative_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Dash)
  return target;
}

::size_t Dash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Dash)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float power = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = this->_internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    total_size += 5;
  }

  // float relative_direction = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Dash::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Dash::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Dash::GetClassData() const { return &_class_data_; }


void Dash::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Dash*>(&to_msg);
  auto& from = static_cast<const Dash&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Dash)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = from._internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    _this->_internal_set_power(from._internal_power());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = from._internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    _this->_internal_set_relative_direction(from._internal_relative_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Dash::CopyFrom(const Dash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Dash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Dash::IsInitialized() const {
  return true;
}

void Dash::InternalSwap(Dash* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Dash, _impl_.relative_direction_)
      + sizeof(Dash::_impl_.relative_direction_)
      - PROTOBUF_FIELD_OFFSET(Dash, _impl_.power_)>(
          reinterpret_cast<char*>(&_impl_.power_),
          reinterpret_cast<char*>(&other->_impl_.power_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Dash::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[10]);
}
// ===================================================================

class Turn::_Internal {
 public:
};

Turn::Turn(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Turn)
}
Turn::Turn(const Turn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Turn)
}

inline void Turn::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.relative_direction_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Turn::~Turn() {
  // @@protoc_insertion_point(destructor:protos.Turn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Turn::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Turn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Turn::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Turn)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.relative_direction_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Turn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float relative_direction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.relative_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Turn::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Turn)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float relative_direction = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_relative_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Turn)
  return target;
}

::size_t Turn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Turn)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float relative_direction = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Turn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Turn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Turn::GetClassData() const { return &_class_data_; }


void Turn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Turn*>(&to_msg);
  auto& from = static_cast<const Turn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Turn)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = from._internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    _this->_internal_set_relative_direction(from._internal_relative_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Turn::CopyFrom(const Turn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Turn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Turn::IsInitialized() const {
  return true;
}

void Turn::InternalSwap(Turn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.relative_direction_, other->_impl_.relative_direction_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Turn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[11]);
}
// ===================================================================

class Kick::_Internal {
 public:
};

Kick::Kick(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Kick)
}
Kick::Kick(const Kick& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Kick)
}

inline void Kick::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.power_) { 0 }

    , decltype(_impl_.relative_direction_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Kick::~Kick() {
  // @@protoc_insertion_point(destructor:protos.Kick)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Kick::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Kick::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Kick::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Kick)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.power_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.relative_direction_) -
      reinterpret_cast<char*>(&_impl_.power_)) + sizeof(_impl_.relative_direction_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Kick::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float power = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float relative_direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.relative_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Kick::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Kick)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float power = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = this->_internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_power(), target);
  }

  // float relative_direction = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_relative_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Kick)
  return target;
}

::size_t Kick::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Kick)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float power = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = this->_internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    total_size += 5;
  }

  // float relative_direction = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = this->_internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Kick::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Kick::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Kick::GetClassData() const { return &_class_data_; }


void Kick::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Kick*>(&to_msg);
  auto& from = static_cast<const Kick&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Kick)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power = from._internal_power();
  ::uint32_t raw_power;
  memcpy(&raw_power, &tmp_power, sizeof(tmp_power));
  if (raw_power != 0) {
    _this->_internal_set_power(from._internal_power());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_relative_direction = from._internal_relative_direction();
  ::uint32_t raw_relative_direction;
  memcpy(&raw_relative_direction, &tmp_relative_direction, sizeof(tmp_relative_direction));
  if (raw_relative_direction != 0) {
    _this->_internal_set_relative_direction(from._internal_relative_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Kick::CopyFrom(const Kick& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Kick)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Kick::IsInitialized() const {
  return true;
}

void Kick::InternalSwap(Kick* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Kick, _impl_.relative_direction_)
      + sizeof(Kick::_impl_.relative_direction_)
      - PROTOBUF_FIELD_OFFSET(Kick, _impl_.power_)>(
          reinterpret_cast<char*>(&_impl_.power_),
          reinterpret_cast<char*>(&other->_impl_.power_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Kick::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[12]);
}
// ===================================================================

class Tackle::_Internal {
 public:
};

Tackle::Tackle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Tackle)
}
Tackle::Tackle(const Tackle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Tackle)
}

inline void Tackle::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.power_or_dir_) { 0 }

    , decltype(_impl_.foul_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Tackle::~Tackle() {
  // @@protoc_insertion_point(destructor:protos.Tackle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Tackle::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Tackle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Tackle::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Tackle)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.power_or_dir_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.foul_) -
      reinterpret_cast<char*>(&_impl_.power_or_dir_)) + sizeof(_impl_.foul_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Tackle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float power_or_dir = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.power_or_dir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool foul = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.foul_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Tackle::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Tackle)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float power_or_dir = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power_or_dir = this->_internal_power_or_dir();
  ::uint32_t raw_power_or_dir;
  memcpy(&raw_power_or_dir, &tmp_power_or_dir, sizeof(tmp_power_or_dir));
  if (raw_power_or_dir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_power_or_dir(), target);
  }

  // bool foul = 2;
  if (this->_internal_foul() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_foul(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Tackle)
  return target;
}

::size_t Tackle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Tackle)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float power_or_dir = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power_or_dir = this->_internal_power_or_dir();
  ::uint32_t raw_power_or_dir;
  memcpy(&raw_power_or_dir, &tmp_power_or_dir, sizeof(tmp_power_or_dir));
  if (raw_power_or_dir != 0) {
    total_size += 5;
  }

  // bool foul = 2;
  if (this->_internal_foul() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Tackle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Tackle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Tackle::GetClassData() const { return &_class_data_; }


void Tackle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Tackle*>(&to_msg);
  auto& from = static_cast<const Tackle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Tackle)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_power_or_dir = from._internal_power_or_dir();
  ::uint32_t raw_power_or_dir;
  memcpy(&raw_power_or_dir, &tmp_power_or_dir, sizeof(tmp_power_or_dir));
  if (raw_power_or_dir != 0) {
    _this->_internal_set_power_or_dir(from._internal_power_or_dir());
  }
  if (from._internal_foul() != 0) {
    _this->_internal_set_foul(from._internal_foul());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Tackle::CopyFrom(const Tackle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Tackle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tackle::IsInitialized() const {
  return true;
}

void Tackle::InternalSwap(Tackle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Tackle, _impl_.foul_)
      + sizeof(Tackle::_impl_.foul_)
      - PROTOBUF_FIELD_OFFSET(Tackle, _impl_.power_or_dir_)>(
          reinterpret_cast<char*>(&_impl_.power_or_dir_),
          reinterpret_cast<char*>(&other->_impl_.power_or_dir_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Tackle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[13]);
}
// ===================================================================

class Catch::_Internal {
 public:
};

Catch::Catch(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.Catch)
}
Catch::Catch(const Catch& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Catch* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Catch)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Catch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Catch::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Catch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[14]);
}
// ===================================================================

class Move::_Internal {
 public:
};

Move::Move(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Move)
}
Move::Move(const Move& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Move)
}

inline void Move::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.x_) { 0 }

    , decltype(_impl_.y_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Move::~Move() {
  // @@protoc_insertion_point(destructor:protos.Move)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Move::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Move::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Move::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Move)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Move::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Move::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Move)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Move)
  return target;
}

::size_t Move::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Move)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Move::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Move::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Move::GetClassData() const { return &_class_data_; }


void Move::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Move*>(&to_msg);
  auto& from = static_cast<const Move&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Move)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Move::CopyFrom(const Move& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Move)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Move::IsInitialized() const {
  return true;
}

void Move::InternalSwap(Move* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Move, _impl_.y_)
      + sizeof(Move::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(Move, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Move::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[15]);
}
// ===================================================================

class TurnNeck::_Internal {
 public:
};

TurnNeck::TurnNeck(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.TurnNeck)
}
TurnNeck::TurnNeck(const TurnNeck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.TurnNeck)
}

inline void TurnNeck::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.moment_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TurnNeck::~TurnNeck() {
  // @@protoc_insertion_point(destructor:protos.TurnNeck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TurnNeck::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void TurnNeck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TurnNeck::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.TurnNeck)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.moment_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TurnNeck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float moment = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.moment_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TurnNeck::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.TurnNeck)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float moment = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_moment = this->_internal_moment();
  ::uint32_t raw_moment;
  memcpy(&raw_moment, &tmp_moment, sizeof(tmp_moment));
  if (raw_moment != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_moment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.TurnNeck)
  return target;
}

::size_t TurnNeck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.TurnNeck)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float moment = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_moment = this->_internal_moment();
  ::uint32_t raw_moment;
  memcpy(&raw_moment, &tmp_moment, sizeof(tmp_moment));
  if (raw_moment != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TurnNeck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TurnNeck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TurnNeck::GetClassData() const { return &_class_data_; }


void TurnNeck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TurnNeck*>(&to_msg);
  auto& from = static_cast<const TurnNeck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.TurnNeck)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_moment = from._internal_moment();
  ::uint32_t raw_moment;
  memcpy(&raw_moment, &tmp_moment, sizeof(tmp_moment));
  if (raw_moment != 0) {
    _this->_internal_set_moment(from._internal_moment());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TurnNeck::CopyFrom(const TurnNeck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.TurnNeck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TurnNeck::IsInitialized() const {
  return true;
}

void TurnNeck::InternalSwap(TurnNeck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.moment_, other->_impl_.moment_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TurnNeck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[16]);
}
// ===================================================================

class ChangeView::_Internal {
 public:
};

ChangeView::ChangeView(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.ChangeView)
}
ChangeView::ChangeView(const ChangeView& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.ChangeView)
}

inline void ChangeView::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.view_width_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ChangeView::~ChangeView() {
  // @@protoc_insertion_point(destructor:protos.ChangeView)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangeView::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ChangeView::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangeView::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.ChangeView)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.view_width_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangeView::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.ViewWidth view_width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_view_width(static_cast<::protos::ViewWidth>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ChangeView::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.ChangeView)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.ViewWidth view_width = 1;
  if (this->_internal_view_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_view_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.ChangeView)
  return target;
}

::size_t ChangeView::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.ChangeView)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.ViewWidth view_width = 1;
  if (this->_internal_view_width() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_view_width());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangeView::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChangeView::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangeView::GetClassData() const { return &_class_data_; }


void ChangeView::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChangeView*>(&to_msg);
  auto& from = static_cast<const ChangeView&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.ChangeView)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_view_width() != 0) {
    _this->_internal_set_view_width(from._internal_view_width());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangeView::CopyFrom(const ChangeView& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.ChangeView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeView::IsInitialized() const {
  return true;
}

void ChangeView::InternalSwap(ChangeView* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.view_width_, other->_impl_.view_width_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangeView::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[17]);
}
// ===================================================================

class BallMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<BallMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BallMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& ball_position(const BallMessage* msg);
  static void set_has_ball_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& ball_velocity(const BallMessage* msg);
  static void set_has_ball_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::protos::Vector2D&
BallMessage::_Internal::ball_position(const BallMessage* msg) {
  return *msg->_impl_.ball_position_;
}
const ::protos::Vector2D&
BallMessage::_Internal::ball_velocity(const BallMessage* msg) {
  return *msg->_impl_.ball_velocity_;
}
BallMessage::BallMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.BallMessage)
}
BallMessage::BallMessage(const BallMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BallMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ball_position_){nullptr}
    , decltype(_impl_.ball_velocity_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.ball_position_ = new ::protos::Vector2D(*from._impl_.ball_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.ball_velocity_ = new ::protos::Vector2D(*from._impl_.ball_velocity_);
  }
  // @@protoc_insertion_point(copy_constructor:protos.BallMessage)
}

inline void BallMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ball_position_){nullptr}
    , decltype(_impl_.ball_velocity_){nullptr}
  };
}

BallMessage::~BallMessage() {
  // @@protoc_insertion_point(destructor:protos.BallMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BallMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.ball_position_;
  if (this != internal_default_instance()) delete _impl_.ball_velocity_;
}

void BallMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BallMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.BallMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.ball_position_ != nullptr);
      _impl_.ball_position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.ball_velocity_ != nullptr);
      _impl_.ball_velocity_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BallMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D ball_position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D ball_velocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BallMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.BallMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D ball_position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::ball_position(this),
        _Internal::ball_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D ball_velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::ball_velocity(this),
        _Internal::ball_velocity(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.BallMessage)
  return target;
}

::size_t BallMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.BallMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .protos.Vector2D ball_position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_position_);
    }

    // .protos.Vector2D ball_velocity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_velocity_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BallMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BallMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BallMessage::GetClassData() const { return &_class_data_; }


void BallMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BallMessage*>(&to_msg);
  auto& from = static_cast<const BallMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.BallMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_ball_position()->::protos::Vector2D::MergeFrom(
          from._internal_ball_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_ball_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_ball_velocity());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BallMessage::CopyFrom(const BallMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.BallMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BallMessage::IsInitialized() const {
  return true;
}

void BallMessage::InternalSwap(BallMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BallMessage, _impl_.ball_velocity_)
      + sizeof(BallMessage::_impl_.ball_velocity_)
      - PROTOBUF_FIELD_OFFSET(BallMessage, _impl_.ball_position_)>(
          reinterpret_cast<char*>(&_impl_.ball_position_),
          reinterpret_cast<char*>(&other->_impl_.ball_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BallMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[18]);
}
// ===================================================================

class PassMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<PassMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PassMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& receiver_point(const PassMessage* msg);
  static void set_has_receiver_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& ball_position(const PassMessage* msg);
  static void set_has_ball_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& ball_velocity(const PassMessage* msg);
  static void set_has_ball_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::protos::Vector2D&
PassMessage::_Internal::receiver_point(const PassMessage* msg) {
  return *msg->_impl_.receiver_point_;
}
const ::protos::Vector2D&
PassMessage::_Internal::ball_position(const PassMessage* msg) {
  return *msg->_impl_.ball_position_;
}
const ::protos::Vector2D&
PassMessage::_Internal::ball_velocity(const PassMessage* msg) {
  return *msg->_impl_.ball_velocity_;
}
PassMessage::PassMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.PassMessage)
}
PassMessage::PassMessage(const PassMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PassMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.receiver_point_){nullptr}
    , decltype(_impl_.ball_position_){nullptr}
    , decltype(_impl_.ball_velocity_){nullptr}
    , decltype(_impl_.receiver_uniform_number_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.receiver_point_ = new ::protos::Vector2D(*from._impl_.receiver_point_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.ball_position_ = new ::protos::Vector2D(*from._impl_.ball_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.ball_velocity_ = new ::protos::Vector2D(*from._impl_.ball_velocity_);
  }
  _this->_impl_.receiver_uniform_number_ = from._impl_.receiver_uniform_number_;
  // @@protoc_insertion_point(copy_constructor:protos.PassMessage)
}

inline void PassMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.receiver_point_){nullptr}
    , decltype(_impl_.ball_position_){nullptr}
    , decltype(_impl_.ball_velocity_){nullptr}
    , decltype(_impl_.receiver_uniform_number_) { 0 }

  };
}

PassMessage::~PassMessage() {
  // @@protoc_insertion_point(destructor:protos.PassMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PassMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.receiver_point_;
  if (this != internal_default_instance()) delete _impl_.ball_position_;
  if (this != internal_default_instance()) delete _impl_.ball_velocity_;
}

void PassMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PassMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.PassMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.receiver_point_ != nullptr);
      _impl_.receiver_point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.ball_position_ != nullptr);
      _impl_.ball_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.ball_velocity_ != nullptr);
      _impl_.ball_velocity_->Clear();
    }
  }
  _impl_.receiver_uniform_number_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PassMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 receiver_uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.receiver_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D receiver_point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_receiver_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D ball_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D ball_velocity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PassMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.PassMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 receiver_uniform_number = 1;
  if (this->_internal_receiver_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_receiver_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D receiver_point = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::receiver_point(this),
        _Internal::receiver_point(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D ball_position = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::ball_position(this),
        _Internal::ball_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D ball_velocity = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::ball_velocity(this),
        _Internal::ball_velocity(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.PassMessage)
  return target;
}

::size_t PassMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.PassMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .protos.Vector2D receiver_point = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.receiver_point_);
    }

    // .protos.Vector2D ball_position = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_position_);
    }

    // .protos.Vector2D ball_velocity = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_velocity_);
    }

  }
  // int32 receiver_uniform_number = 1;
  if (this->_internal_receiver_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_receiver_uniform_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PassMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PassMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PassMessage::GetClassData() const { return &_class_data_; }


void PassMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PassMessage*>(&to_msg);
  auto& from = static_cast<const PassMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.PassMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_receiver_point()->::protos::Vector2D::MergeFrom(
          from._internal_receiver_point());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_ball_position()->::protos::Vector2D::MergeFrom(
          from._internal_ball_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_ball_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_ball_velocity());
    }
  }
  if (from._internal_receiver_uniform_number() != 0) {
    _this->_internal_set_receiver_uniform_number(from._internal_receiver_uniform_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PassMessage::CopyFrom(const PassMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.PassMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PassMessage::IsInitialized() const {
  return true;
}

void PassMessage::InternalSwap(PassMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PassMessage, _impl_.receiver_uniform_number_)
      + sizeof(PassMessage::_impl_.receiver_uniform_number_)
      - PROTOBUF_FIELD_OFFSET(PassMessage, _impl_.receiver_point_)>(
          reinterpret_cast<char*>(&_impl_.receiver_point_),
          reinterpret_cast<char*>(&other->_impl_.receiver_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PassMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[19]);
}
// ===================================================================

class InterceptMessage::_Internal {
 public:
};

InterceptMessage::InterceptMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.InterceptMessage)
}
InterceptMessage::InterceptMessage(const InterceptMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.InterceptMessage)
}

inline void InterceptMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.our_) { false }

    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.cycle_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

InterceptMessage::~InterceptMessage() {
  // @@protoc_insertion_point(destructor:protos.InterceptMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InterceptMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void InterceptMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InterceptMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.InterceptMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.our_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.cycle_) -
      reinterpret_cast<char*>(&_impl_.our_)) + sizeof(_impl_.cycle_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InterceptMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool our = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.our_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 cycle = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.cycle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* InterceptMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.InterceptMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool our = 1;
  if (this->_internal_our() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_our(), target);
  }

  // int32 uniform_number = 2;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_uniform_number(), target);
  }

  // int32 cycle = 3;
  if (this->_internal_cycle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_cycle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.InterceptMessage)
  return target;
}

::size_t InterceptMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.InterceptMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool our = 1;
  if (this->_internal_our() != 0) {
    total_size += 2;
  }

  // int32 uniform_number = 2;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  // int32 cycle = 3;
  if (this->_internal_cycle() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_cycle());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InterceptMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InterceptMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InterceptMessage::GetClassData() const { return &_class_data_; }


void InterceptMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InterceptMessage*>(&to_msg);
  auto& from = static_cast<const InterceptMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.InterceptMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_our() != 0) {
    _this->_internal_set_our(from._internal_our());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  if (from._internal_cycle() != 0) {
    _this->_internal_set_cycle(from._internal_cycle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InterceptMessage::CopyFrom(const InterceptMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.InterceptMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InterceptMessage::IsInitialized() const {
  return true;
}

void InterceptMessage::InternalSwap(InterceptMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InterceptMessage, _impl_.cycle_)
      + sizeof(InterceptMessage::_impl_.cycle_)
      - PROTOBUF_FIELD_OFFSET(InterceptMessage, _impl_.our_)>(
          reinterpret_cast<char*>(&_impl_.our_),
          reinterpret_cast<char*>(&other->_impl_.our_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InterceptMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[20]);
}
// ===================================================================

class GoalieMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GoalieMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(GoalieMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& goalie_position(const GoalieMessage* msg);
  static void set_has_goalie_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
GoalieMessage::_Internal::goalie_position(const GoalieMessage* msg) {
  return *msg->_impl_.goalie_position_;
}
GoalieMessage::GoalieMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.GoalieMessage)
}
GoalieMessage::GoalieMessage(const GoalieMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GoalieMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.goalie_position_){nullptr}
    , decltype(_impl_.goalie_uniform_number_) {}

    , decltype(_impl_.goalie_body_direction_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.goalie_position_ = new ::protos::Vector2D(*from._impl_.goalie_position_);
  }
  ::memcpy(&_impl_.goalie_uniform_number_, &from._impl_.goalie_uniform_number_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.goalie_body_direction_) -
    reinterpret_cast<char*>(&_impl_.goalie_uniform_number_)) + sizeof(_impl_.goalie_body_direction_));
  // @@protoc_insertion_point(copy_constructor:protos.GoalieMessage)
}

inline void GoalieMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.goalie_position_){nullptr}
    , decltype(_impl_.goalie_uniform_number_) { 0 }

    , decltype(_impl_.goalie_body_direction_) { 0 }

  };
}

GoalieMessage::~GoalieMessage() {
  // @@protoc_insertion_point(destructor:protos.GoalieMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GoalieMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.goalie_position_;
}

void GoalieMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GoalieMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.GoalieMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.goalie_position_ != nullptr);
    _impl_.goalie_position_->Clear();
  }
  ::memset(&_impl_.goalie_uniform_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.goalie_body_direction_) -
      reinterpret_cast<char*>(&_impl_.goalie_uniform_number_)) + sizeof(_impl_.goalie_body_direction_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GoalieMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 goalie_uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.goalie_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D goalie_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_goalie_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float goalie_body_direction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.goalie_body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* GoalieMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.GoalieMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 goalie_uniform_number = 1;
  if (this->_internal_goalie_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_goalie_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D goalie_position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::goalie_position(this),
        _Internal::goalie_position(this).GetCachedSize(), target, stream);
  }

  // float goalie_body_direction = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = this->_internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_goalie_body_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.GoalieMessage)
  return target;
}

::size_t GoalieMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.GoalieMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D goalie_position = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.goalie_position_);
  }

  // int32 goalie_uniform_number = 1;
  if (this->_internal_goalie_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_goalie_uniform_number());
  }

  // float goalie_body_direction = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = this->_internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GoalieMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GoalieMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GoalieMessage::GetClassData() const { return &_class_data_; }


void GoalieMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GoalieMessage*>(&to_msg);
  auto& from = static_cast<const GoalieMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.GoalieMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_goalie_position()->::protos::Vector2D::MergeFrom(
        from._internal_goalie_position());
  }
  if (from._internal_goalie_uniform_number() != 0) {
    _this->_internal_set_goalie_uniform_number(from._internal_goalie_uniform_number());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = from._internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    _this->_internal_set_goalie_body_direction(from._internal_goalie_body_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GoalieMessage::CopyFrom(const GoalieMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.GoalieMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GoalieMessage::IsInitialized() const {
  return true;
}

void GoalieMessage::InternalSwap(GoalieMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GoalieMessage, _impl_.goalie_body_direction_)
      + sizeof(GoalieMessage::_impl_.goalie_body_direction_)
      - PROTOBUF_FIELD_OFFSET(GoalieMessage, _impl_.goalie_position_)>(
          reinterpret_cast<char*>(&_impl_.goalie_position_),
          reinterpret_cast<char*>(&other->_impl_.goalie_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GoalieMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[21]);
}
// ===================================================================

class GoalieAndPlayerMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GoalieAndPlayerMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(GoalieAndPlayerMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& goalie_position(const GoalieAndPlayerMessage* msg);
  static void set_has_goalie_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& player_position(const GoalieAndPlayerMessage* msg);
  static void set_has_player_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::protos::Vector2D&
GoalieAndPlayerMessage::_Internal::goalie_position(const GoalieAndPlayerMessage* msg) {
  return *msg->_impl_.goalie_position_;
}
const ::protos::Vector2D&
GoalieAndPlayerMessage::_Internal::player_position(const GoalieAndPlayerMessage* msg) {
  return *msg->_impl_.player_position_;
}
GoalieAndPlayerMessage::GoalieAndPlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.GoalieAndPlayerMessage)
}
GoalieAndPlayerMessage::GoalieAndPlayerMessage(const GoalieAndPlayerMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GoalieAndPlayerMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.goalie_position_){nullptr}
    , decltype(_impl_.player_position_){nullptr}
    , decltype(_impl_.goalie_uniform_number_) {}

    , decltype(_impl_.goalie_body_direction_) {}

    , decltype(_impl_.player_uniform_number_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.goalie_position_ = new ::protos::Vector2D(*from._impl_.goalie_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.player_position_ = new ::protos::Vector2D(*from._impl_.player_position_);
  }
  ::memcpy(&_impl_.goalie_uniform_number_, &from._impl_.goalie_uniform_number_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.player_uniform_number_) -
    reinterpret_cast<char*>(&_impl_.goalie_uniform_number_)) + sizeof(_impl_.player_uniform_number_));
  // @@protoc_insertion_point(copy_constructor:protos.GoalieAndPlayerMessage)
}

inline void GoalieAndPlayerMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.goalie_position_){nullptr}
    , decltype(_impl_.player_position_){nullptr}
    , decltype(_impl_.goalie_uniform_number_) { 0 }

    , decltype(_impl_.goalie_body_direction_) { 0 }

    , decltype(_impl_.player_uniform_number_) { 0 }

  };
}

GoalieAndPlayerMessage::~GoalieAndPlayerMessage() {
  // @@protoc_insertion_point(destructor:protos.GoalieAndPlayerMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GoalieAndPlayerMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.goalie_position_;
  if (this != internal_default_instance()) delete _impl_.player_position_;
}

void GoalieAndPlayerMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GoalieAndPlayerMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.GoalieAndPlayerMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.goalie_position_ != nullptr);
      _impl_.goalie_position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.player_position_ != nullptr);
      _impl_.player_position_->Clear();
    }
  }
  ::memset(&_impl_.goalie_uniform_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.player_uniform_number_) -
      reinterpret_cast<char*>(&_impl_.goalie_uniform_number_)) + sizeof(_impl_.player_uniform_number_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GoalieAndPlayerMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 goalie_uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.goalie_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D goalie_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_goalie_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float goalie_body_direction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.goalie_body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 player_uniform_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.player_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D player_position = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* GoalieAndPlayerMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.GoalieAndPlayerMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 goalie_uniform_number = 1;
  if (this->_internal_goalie_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_goalie_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D goalie_position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::goalie_position(this),
        _Internal::goalie_position(this).GetCachedSize(), target, stream);
  }

  // float goalie_body_direction = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = this->_internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_goalie_body_direction(), target);
  }

  // int32 player_uniform_number = 4;
  if (this->_internal_player_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_player_uniform_number(), target);
  }

  // .protos.Vector2D player_position = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::player_position(this),
        _Internal::player_position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.GoalieAndPlayerMessage)
  return target;
}

::size_t GoalieAndPlayerMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.GoalieAndPlayerMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .protos.Vector2D goalie_position = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.goalie_position_);
    }

    // .protos.Vector2D player_position = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.player_position_);
    }

  }
  // int32 goalie_uniform_number = 1;
  if (this->_internal_goalie_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_goalie_uniform_number());
  }

  // float goalie_body_direction = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = this->_internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    total_size += 5;
  }

  // int32 player_uniform_number = 4;
  if (this->_internal_player_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_player_uniform_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GoalieAndPlayerMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GoalieAndPlayerMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GoalieAndPlayerMessage::GetClassData() const { return &_class_data_; }


void GoalieAndPlayerMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GoalieAndPlayerMessage*>(&to_msg);
  auto& from = static_cast<const GoalieAndPlayerMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.GoalieAndPlayerMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_goalie_position()->::protos::Vector2D::MergeFrom(
          from._internal_goalie_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_player_position()->::protos::Vector2D::MergeFrom(
          from._internal_player_position());
    }
  }
  if (from._internal_goalie_uniform_number() != 0) {
    _this->_internal_set_goalie_uniform_number(from._internal_goalie_uniform_number());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = from._internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    _this->_internal_set_goalie_body_direction(from._internal_goalie_body_direction());
  }
  if (from._internal_player_uniform_number() != 0) {
    _this->_internal_set_player_uniform_number(from._internal_player_uniform_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GoalieAndPlayerMessage::CopyFrom(const GoalieAndPlayerMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.GoalieAndPlayerMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GoalieAndPlayerMessage::IsInitialized() const {
  return true;
}

void GoalieAndPlayerMessage::InternalSwap(GoalieAndPlayerMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GoalieAndPlayerMessage, _impl_.player_uniform_number_)
      + sizeof(GoalieAndPlayerMessage::_impl_.player_uniform_number_)
      - PROTOBUF_FIELD_OFFSET(GoalieAndPlayerMessage, _impl_.goalie_position_)>(
          reinterpret_cast<char*>(&_impl_.goalie_position_),
          reinterpret_cast<char*>(&other->_impl_.goalie_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GoalieAndPlayerMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[22]);
}
// ===================================================================

class OffsideLineMessage::_Internal {
 public:
};

OffsideLineMessage::OffsideLineMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.OffsideLineMessage)
}
OffsideLineMessage::OffsideLineMessage(const OffsideLineMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.OffsideLineMessage)
}

inline void OffsideLineMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.offside_line_x_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OffsideLineMessage::~OffsideLineMessage() {
  // @@protoc_insertion_point(destructor:protos.OffsideLineMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OffsideLineMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void OffsideLineMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OffsideLineMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.OffsideLineMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.offside_line_x_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OffsideLineMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float offside_line_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.offside_line_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OffsideLineMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.OffsideLineMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float offside_line_x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_line_x = this->_internal_offside_line_x();
  ::uint32_t raw_offside_line_x;
  memcpy(&raw_offside_line_x, &tmp_offside_line_x, sizeof(tmp_offside_line_x));
  if (raw_offside_line_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_offside_line_x(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.OffsideLineMessage)
  return target;
}

::size_t OffsideLineMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.OffsideLineMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float offside_line_x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_line_x = this->_internal_offside_line_x();
  ::uint32_t raw_offside_line_x;
  memcpy(&raw_offside_line_x, &tmp_offside_line_x, sizeof(tmp_offside_line_x));
  if (raw_offside_line_x != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OffsideLineMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OffsideLineMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OffsideLineMessage::GetClassData() const { return &_class_data_; }


void OffsideLineMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OffsideLineMessage*>(&to_msg);
  auto& from = static_cast<const OffsideLineMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.OffsideLineMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_offside_line_x = from._internal_offside_line_x();
  ::uint32_t raw_offside_line_x;
  memcpy(&raw_offside_line_x, &tmp_offside_line_x, sizeof(tmp_offside_line_x));
  if (raw_offside_line_x != 0) {
    _this->_internal_set_offside_line_x(from._internal_offside_line_x());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OffsideLineMessage::CopyFrom(const OffsideLineMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.OffsideLineMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OffsideLineMessage::IsInitialized() const {
  return true;
}

void OffsideLineMessage::InternalSwap(OffsideLineMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.offside_line_x_, other->_impl_.offside_line_x_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OffsideLineMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[23]);
}
// ===================================================================

class DefenseLineMessage::_Internal {
 public:
};

DefenseLineMessage::DefenseLineMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.DefenseLineMessage)
}
DefenseLineMessage::DefenseLineMessage(const DefenseLineMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.DefenseLineMessage)
}

inline void DefenseLineMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.defense_line_x_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DefenseLineMessage::~DefenseLineMessage() {
  // @@protoc_insertion_point(destructor:protos.DefenseLineMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DefenseLineMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void DefenseLineMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DefenseLineMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.DefenseLineMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.defense_line_x_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DefenseLineMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float defense_line_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.defense_line_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DefenseLineMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.DefenseLineMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float defense_line_x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_defense_line_x = this->_internal_defense_line_x();
  ::uint32_t raw_defense_line_x;
  memcpy(&raw_defense_line_x, &tmp_defense_line_x, sizeof(tmp_defense_line_x));
  if (raw_defense_line_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_defense_line_x(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.DefenseLineMessage)
  return target;
}

::size_t DefenseLineMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.DefenseLineMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float defense_line_x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_defense_line_x = this->_internal_defense_line_x();
  ::uint32_t raw_defense_line_x;
  memcpy(&raw_defense_line_x, &tmp_defense_line_x, sizeof(tmp_defense_line_x));
  if (raw_defense_line_x != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DefenseLineMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DefenseLineMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DefenseLineMessage::GetClassData() const { return &_class_data_; }


void DefenseLineMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DefenseLineMessage*>(&to_msg);
  auto& from = static_cast<const DefenseLineMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.DefenseLineMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_defense_line_x = from._internal_defense_line_x();
  ::uint32_t raw_defense_line_x;
  memcpy(&raw_defense_line_x, &tmp_defense_line_x, sizeof(tmp_defense_line_x));
  if (raw_defense_line_x != 0) {
    _this->_internal_set_defense_line_x(from._internal_defense_line_x());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DefenseLineMessage::CopyFrom(const DefenseLineMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.DefenseLineMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DefenseLineMessage::IsInitialized() const {
  return true;
}

void DefenseLineMessage::InternalSwap(DefenseLineMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.defense_line_x_, other->_impl_.defense_line_x_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DefenseLineMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[24]);
}
// ===================================================================

class WaitRequestMessage::_Internal {
 public:
};

WaitRequestMessage::WaitRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.WaitRequestMessage)
}
WaitRequestMessage::WaitRequestMessage(const WaitRequestMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  WaitRequestMessage* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.WaitRequestMessage)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WaitRequestMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WaitRequestMessage::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata WaitRequestMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[25]);
}
// ===================================================================

class SetplayMessage::_Internal {
 public:
};

SetplayMessage::SetplayMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.SetplayMessage)
}
SetplayMessage::SetplayMessage(const SetplayMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.SetplayMessage)
}

inline void SetplayMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.wait_step_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SetplayMessage::~SetplayMessage() {
  // @@protoc_insertion_point(destructor:protos.SetplayMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetplayMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void SetplayMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetplayMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.SetplayMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.wait_step_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetplayMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 wait_step = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.wait_step_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SetplayMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.SetplayMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 wait_step = 1;
  if (this->_internal_wait_step() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_wait_step(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.SetplayMessage)
  return target;
}

::size_t SetplayMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.SetplayMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 wait_step = 1;
  if (this->_internal_wait_step() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_wait_step());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetplayMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetplayMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetplayMessage::GetClassData() const { return &_class_data_; }


void SetplayMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetplayMessage*>(&to_msg);
  auto& from = static_cast<const SetplayMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.SetplayMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_wait_step() != 0) {
    _this->_internal_set_wait_step(from._internal_wait_step());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetplayMessage::CopyFrom(const SetplayMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.SetplayMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetplayMessage::IsInitialized() const {
  return true;
}

void SetplayMessage::InternalSwap(SetplayMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.wait_step_, other->_impl_.wait_step_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetplayMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[26]);
}
// ===================================================================

class PassRequestMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<PassRequestMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PassRequestMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& target_point(const PassRequestMessage* msg);
  static void set_has_target_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
PassRequestMessage::_Internal::target_point(const PassRequestMessage* msg) {
  return *msg->_impl_.target_point_;
}
PassRequestMessage::PassRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.PassRequestMessage)
}
PassRequestMessage::PassRequestMessage(const PassRequestMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PassRequestMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.target_point_ = new ::protos::Vector2D(*from._impl_.target_point_);
  }
  // @@protoc_insertion_point(copy_constructor:protos.PassRequestMessage)
}

inline void PassRequestMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
  };
}

PassRequestMessage::~PassRequestMessage() {
  // @@protoc_insertion_point(destructor:protos.PassRequestMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PassRequestMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_point_;
}

void PassRequestMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PassRequestMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.PassRequestMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.target_point_ != nullptr);
    _impl_.target_point_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PassRequestMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D target_point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PassRequestMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.PassRequestMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D target_point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target_point(this),
        _Internal::target_point(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.PassRequestMessage)
  return target;
}

::size_t PassRequestMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.PassRequestMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D target_point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_point_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PassRequestMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PassRequestMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PassRequestMessage::GetClassData() const { return &_class_data_; }


void PassRequestMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PassRequestMessage*>(&to_msg);
  auto& from = static_cast<const PassRequestMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.PassRequestMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_target_point()->::protos::Vector2D::MergeFrom(
        from._internal_target_point());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PassRequestMessage::CopyFrom(const PassRequestMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.PassRequestMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PassRequestMessage::IsInitialized() const {
  return true;
}

void PassRequestMessage::InternalSwap(PassRequestMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.target_point_, other->_impl_.target_point_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PassRequestMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[27]);
}
// ===================================================================

class StaminaMessage::_Internal {
 public:
};

StaminaMessage::StaminaMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.StaminaMessage)
}
StaminaMessage::StaminaMessage(const StaminaMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.StaminaMessage)
}

inline void StaminaMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.stamina_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StaminaMessage::~StaminaMessage() {
  // @@protoc_insertion_point(destructor:protos.StaminaMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaminaMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void StaminaMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaminaMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.StaminaMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stamina_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaminaMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float stamina = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.stamina_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StaminaMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.StaminaMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float stamina = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina = this->_internal_stamina();
  ::uint32_t raw_stamina;
  memcpy(&raw_stamina, &tmp_stamina, sizeof(tmp_stamina));
  if (raw_stamina != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_stamina(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.StaminaMessage)
  return target;
}

::size_t StaminaMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.StaminaMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float stamina = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina = this->_internal_stamina();
  ::uint32_t raw_stamina;
  memcpy(&raw_stamina, &tmp_stamina, sizeof(tmp_stamina));
  if (raw_stamina != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaminaMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaminaMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaminaMessage::GetClassData() const { return &_class_data_; }


void StaminaMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaminaMessage*>(&to_msg);
  auto& from = static_cast<const StaminaMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.StaminaMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina = from._internal_stamina();
  ::uint32_t raw_stamina;
  memcpy(&raw_stamina, &tmp_stamina, sizeof(tmp_stamina));
  if (raw_stamina != 0) {
    _this->_internal_set_stamina(from._internal_stamina());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaminaMessage::CopyFrom(const StaminaMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.StaminaMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaminaMessage::IsInitialized() const {
  return true;
}

void StaminaMessage::InternalSwap(StaminaMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.stamina_, other->_impl_.stamina_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StaminaMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[28]);
}
// ===================================================================

class RecoveryMessage::_Internal {
 public:
};

RecoveryMessage::RecoveryMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.RecoveryMessage)
}
RecoveryMessage::RecoveryMessage(const RecoveryMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.RecoveryMessage)
}

inline void RecoveryMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.recovery_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RecoveryMessage::~RecoveryMessage() {
  // @@protoc_insertion_point(destructor:protos.RecoveryMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RecoveryMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void RecoveryMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RecoveryMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.RecoveryMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.recovery_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RecoveryMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float recovery = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.recovery_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RecoveryMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.RecoveryMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float recovery = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recovery = this->_internal_recovery();
  ::uint32_t raw_recovery;
  memcpy(&raw_recovery, &tmp_recovery, sizeof(tmp_recovery));
  if (raw_recovery != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_recovery(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.RecoveryMessage)
  return target;
}

::size_t RecoveryMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.RecoveryMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float recovery = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recovery = this->_internal_recovery();
  ::uint32_t raw_recovery;
  memcpy(&raw_recovery, &tmp_recovery, sizeof(tmp_recovery));
  if (raw_recovery != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RecoveryMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RecoveryMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RecoveryMessage::GetClassData() const { return &_class_data_; }


void RecoveryMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RecoveryMessage*>(&to_msg);
  auto& from = static_cast<const RecoveryMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.RecoveryMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_recovery = from._internal_recovery();
  ::uint32_t raw_recovery;
  memcpy(&raw_recovery, &tmp_recovery, sizeof(tmp_recovery));
  if (raw_recovery != 0) {
    _this->_internal_set_recovery(from._internal_recovery());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RecoveryMessage::CopyFrom(const RecoveryMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.RecoveryMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecoveryMessage::IsInitialized() const {
  return true;
}

void RecoveryMessage::InternalSwap(RecoveryMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.recovery_, other->_impl_.recovery_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RecoveryMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[29]);
}
// ===================================================================

class StaminaCapacityMessage::_Internal {
 public:
};

StaminaCapacityMessage::StaminaCapacityMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.StaminaCapacityMessage)
}
StaminaCapacityMessage::StaminaCapacityMessage(const StaminaCapacityMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.StaminaCapacityMessage)
}

inline void StaminaCapacityMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.stamina_capacity_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StaminaCapacityMessage::~StaminaCapacityMessage() {
  // @@protoc_insertion_point(destructor:protos.StaminaCapacityMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaminaCapacityMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void StaminaCapacityMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaminaCapacityMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.StaminaCapacityMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stamina_capacity_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaminaCapacityMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float stamina_capacity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.stamina_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StaminaCapacityMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.StaminaCapacityMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float stamina_capacity = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_capacity = this->_internal_stamina_capacity();
  ::uint32_t raw_stamina_capacity;
  memcpy(&raw_stamina_capacity, &tmp_stamina_capacity, sizeof(tmp_stamina_capacity));
  if (raw_stamina_capacity != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_stamina_capacity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.StaminaCapacityMessage)
  return target;
}

::size_t StaminaCapacityMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.StaminaCapacityMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float stamina_capacity = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_capacity = this->_internal_stamina_capacity();
  ::uint32_t raw_stamina_capacity;
  memcpy(&raw_stamina_capacity, &tmp_stamina_capacity, sizeof(tmp_stamina_capacity));
  if (raw_stamina_capacity != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaminaCapacityMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaminaCapacityMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaminaCapacityMessage::GetClassData() const { return &_class_data_; }


void StaminaCapacityMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaminaCapacityMessage*>(&to_msg);
  auto& from = static_cast<const StaminaCapacityMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.StaminaCapacityMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_stamina_capacity = from._internal_stamina_capacity();
  ::uint32_t raw_stamina_capacity;
  memcpy(&raw_stamina_capacity, &tmp_stamina_capacity, sizeof(tmp_stamina_capacity));
  if (raw_stamina_capacity != 0) {
    _this->_internal_set_stamina_capacity(from._internal_stamina_capacity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaminaCapacityMessage::CopyFrom(const StaminaCapacityMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.StaminaCapacityMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaminaCapacityMessage::IsInitialized() const {
  return true;
}

void StaminaCapacityMessage::InternalSwap(StaminaCapacityMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.stamina_capacity_, other->_impl_.stamina_capacity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StaminaCapacityMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[30]);
}
// ===================================================================

class DribbleMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<DribbleMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DribbleMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& target_point(const DribbleMessage* msg);
  static void set_has_target_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
DribbleMessage::_Internal::target_point(const DribbleMessage* msg) {
  return *msg->_impl_.target_point_;
}
DribbleMessage::DribbleMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.DribbleMessage)
}
DribbleMessage::DribbleMessage(const DribbleMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DribbleMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.queue_count_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.target_point_ = new ::protos::Vector2D(*from._impl_.target_point_);
  }
  _this->_impl_.queue_count_ = from._impl_.queue_count_;
  // @@protoc_insertion_point(copy_constructor:protos.DribbleMessage)
}

inline void DribbleMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_point_){nullptr}
    , decltype(_impl_.queue_count_) { 0 }

  };
}

DribbleMessage::~DribbleMessage() {
  // @@protoc_insertion_point(destructor:protos.DribbleMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DribbleMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_point_;
}

void DribbleMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DribbleMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.DribbleMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.target_point_ != nullptr);
    _impl_.target_point_->Clear();
  }
  _impl_.queue_count_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DribbleMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D target_point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 queue_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.queue_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DribbleMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.DribbleMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D target_point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target_point(this),
        _Internal::target_point(this).GetCachedSize(), target, stream);
  }

  // int32 queue_count = 2;
  if (this->_internal_queue_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_queue_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.DribbleMessage)
  return target;
}

::size_t DribbleMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.DribbleMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D target_point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_point_);
  }

  // int32 queue_count = 2;
  if (this->_internal_queue_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_queue_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DribbleMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DribbleMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DribbleMessage::GetClassData() const { return &_class_data_; }


void DribbleMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DribbleMessage*>(&to_msg);
  auto& from = static_cast<const DribbleMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.DribbleMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_target_point()->::protos::Vector2D::MergeFrom(
        from._internal_target_point());
  }
  if (from._internal_queue_count() != 0) {
    _this->_internal_set_queue_count(from._internal_queue_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DribbleMessage::CopyFrom(const DribbleMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.DribbleMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DribbleMessage::IsInitialized() const {
  return true;
}

void DribbleMessage::InternalSwap(DribbleMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DribbleMessage, _impl_.queue_count_)
      + sizeof(DribbleMessage::_impl_.queue_count_)
      - PROTOBUF_FIELD_OFFSET(DribbleMessage, _impl_.target_point_)>(
          reinterpret_cast<char*>(&_impl_.target_point_),
          reinterpret_cast<char*>(&other->_impl_.target_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DribbleMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[31]);
}
// ===================================================================

class BallGoalieMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<BallGoalieMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BallGoalieMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& ball_position(const BallGoalieMessage* msg);
  static void set_has_ball_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& ball_velocity(const BallGoalieMessage* msg);
  static void set_has_ball_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& goalie_position(const BallGoalieMessage* msg);
  static void set_has_goalie_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::protos::Vector2D&
BallGoalieMessage::_Internal::ball_position(const BallGoalieMessage* msg) {
  return *msg->_impl_.ball_position_;
}
const ::protos::Vector2D&
BallGoalieMessage::_Internal::ball_velocity(const BallGoalieMessage* msg) {
  return *msg->_impl_.ball_velocity_;
}
const ::protos::Vector2D&
BallGoalieMessage::_Internal::goalie_position(const BallGoalieMessage* msg) {
  return *msg->_impl_.goalie_position_;
}
BallGoalieMessage::BallGoalieMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.BallGoalieMessage)
}
BallGoalieMessage::BallGoalieMessage(const BallGoalieMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BallGoalieMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ball_position_){nullptr}
    , decltype(_impl_.ball_velocity_){nullptr}
    , decltype(_impl_.goalie_position_){nullptr}
    , decltype(_impl_.goalie_body_direction_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.ball_position_ = new ::protos::Vector2D(*from._impl_.ball_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.ball_velocity_ = new ::protos::Vector2D(*from._impl_.ball_velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.goalie_position_ = new ::protos::Vector2D(*from._impl_.goalie_position_);
  }
  _this->_impl_.goalie_body_direction_ = from._impl_.goalie_body_direction_;
  // @@protoc_insertion_point(copy_constructor:protos.BallGoalieMessage)
}

inline void BallGoalieMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ball_position_){nullptr}
    , decltype(_impl_.ball_velocity_){nullptr}
    , decltype(_impl_.goalie_position_){nullptr}
    , decltype(_impl_.goalie_body_direction_) { 0 }

  };
}

BallGoalieMessage::~BallGoalieMessage() {
  // @@protoc_insertion_point(destructor:protos.BallGoalieMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BallGoalieMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.ball_position_;
  if (this != internal_default_instance()) delete _impl_.ball_velocity_;
  if (this != internal_default_instance()) delete _impl_.goalie_position_;
}

void BallGoalieMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BallGoalieMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.BallGoalieMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.ball_position_ != nullptr);
      _impl_.ball_position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.ball_velocity_ != nullptr);
      _impl_.ball_velocity_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.goalie_position_ != nullptr);
      _impl_.goalie_position_->Clear();
    }
  }
  _impl_.goalie_body_direction_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BallGoalieMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D ball_position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D ball_velocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D goalie_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_goalie_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float goalie_body_direction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.goalie_body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BallGoalieMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.BallGoalieMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D ball_position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::ball_position(this),
        _Internal::ball_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D ball_velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::ball_velocity(this),
        _Internal::ball_velocity(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D goalie_position = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::goalie_position(this),
        _Internal::goalie_position(this).GetCachedSize(), target, stream);
  }

  // float goalie_body_direction = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = this->_internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_goalie_body_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.BallGoalieMessage)
  return target;
}

::size_t BallGoalieMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.BallGoalieMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .protos.Vector2D ball_position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_position_);
    }

    // .protos.Vector2D ball_velocity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_velocity_);
    }

    // .protos.Vector2D goalie_position = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.goalie_position_);
    }

  }
  // float goalie_body_direction = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = this->_internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BallGoalieMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BallGoalieMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BallGoalieMessage::GetClassData() const { return &_class_data_; }


void BallGoalieMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BallGoalieMessage*>(&to_msg);
  auto& from = static_cast<const BallGoalieMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.BallGoalieMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_ball_position()->::protos::Vector2D::MergeFrom(
          from._internal_ball_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_ball_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_ball_velocity());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_goalie_position()->::protos::Vector2D::MergeFrom(
          from._internal_goalie_position());
    }
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_goalie_body_direction = from._internal_goalie_body_direction();
  ::uint32_t raw_goalie_body_direction;
  memcpy(&raw_goalie_body_direction, &tmp_goalie_body_direction, sizeof(tmp_goalie_body_direction));
  if (raw_goalie_body_direction != 0) {
    _this->_internal_set_goalie_body_direction(from._internal_goalie_body_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BallGoalieMessage::CopyFrom(const BallGoalieMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.BallGoalieMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BallGoalieMessage::IsInitialized() const {
  return true;
}

void BallGoalieMessage::InternalSwap(BallGoalieMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BallGoalieMessage, _impl_.goalie_body_direction_)
      + sizeof(BallGoalieMessage::_impl_.goalie_body_direction_)
      - PROTOBUF_FIELD_OFFSET(BallGoalieMessage, _impl_.ball_position_)>(
          reinterpret_cast<char*>(&_impl_.ball_position_),
          reinterpret_cast<char*>(&other->_impl_.ball_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BallGoalieMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[32]);
}
// ===================================================================

class OnePlayerMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<OnePlayerMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(OnePlayerMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const OnePlayerMessage* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
OnePlayerMessage::_Internal::position(const OnePlayerMessage* msg) {
  return *msg->_impl_.position_;
}
OnePlayerMessage::OnePlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.OnePlayerMessage)
}
OnePlayerMessage::OnePlayerMessage(const OnePlayerMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OnePlayerMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.uniform_number_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  _this->_impl_.uniform_number_ = from._impl_.uniform_number_;
  // @@protoc_insertion_point(copy_constructor:protos.OnePlayerMessage)
}

inline void OnePlayerMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.uniform_number_) { 0 }

  };
}

OnePlayerMessage::~OnePlayerMessage() {
  // @@protoc_insertion_point(destructor:protos.OnePlayerMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OnePlayerMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
}

void OnePlayerMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OnePlayerMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.OnePlayerMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  _impl_.uniform_number_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OnePlayerMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OnePlayerMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.OnePlayerMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 uniform_number = 1;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.OnePlayerMessage)
  return target;
}

::size_t OnePlayerMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.OnePlayerMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D position = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // int32 uniform_number = 1;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OnePlayerMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OnePlayerMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OnePlayerMessage::GetClassData() const { return &_class_data_; }


void OnePlayerMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OnePlayerMessage*>(&to_msg);
  auto& from = static_cast<const OnePlayerMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.OnePlayerMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
        from._internal_position());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OnePlayerMessage::CopyFrom(const OnePlayerMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.OnePlayerMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OnePlayerMessage::IsInitialized() const {
  return true;
}

void OnePlayerMessage::InternalSwap(OnePlayerMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OnePlayerMessage, _impl_.uniform_number_)
      + sizeof(OnePlayerMessage::_impl_.uniform_number_)
      - PROTOBUF_FIELD_OFFSET(OnePlayerMessage, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OnePlayerMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[33]);
}
// ===================================================================

class TwoPlayerMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<TwoPlayerMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TwoPlayerMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& first_position(const TwoPlayerMessage* msg);
  static void set_has_first_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& second_position(const TwoPlayerMessage* msg);
  static void set_has_second_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::protos::Vector2D&
TwoPlayerMessage::_Internal::first_position(const TwoPlayerMessage* msg) {
  return *msg->_impl_.first_position_;
}
const ::protos::Vector2D&
TwoPlayerMessage::_Internal::second_position(const TwoPlayerMessage* msg) {
  return *msg->_impl_.second_position_;
}
TwoPlayerMessage::TwoPlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.TwoPlayerMessage)
}
TwoPlayerMessage::TwoPlayerMessage(const TwoPlayerMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TwoPlayerMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.first_position_){nullptr}
    , decltype(_impl_.second_position_){nullptr}
    , decltype(_impl_.first_uniform_number_) {}

    , decltype(_impl_.second_uniform_number_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.first_position_ = new ::protos::Vector2D(*from._impl_.first_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.second_position_ = new ::protos::Vector2D(*from._impl_.second_position_);
  }
  ::memcpy(&_impl_.first_uniform_number_, &from._impl_.first_uniform_number_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.second_uniform_number_) -
    reinterpret_cast<char*>(&_impl_.first_uniform_number_)) + sizeof(_impl_.second_uniform_number_));
  // @@protoc_insertion_point(copy_constructor:protos.TwoPlayerMessage)
}

inline void TwoPlayerMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.first_position_){nullptr}
    , decltype(_impl_.second_position_){nullptr}
    , decltype(_impl_.first_uniform_number_) { 0 }

    , decltype(_impl_.second_uniform_number_) { 0 }

  };
}

TwoPlayerMessage::~TwoPlayerMessage() {
  // @@protoc_insertion_point(destructor:protos.TwoPlayerMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TwoPlayerMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.first_position_;
  if (this != internal_default_instance()) delete _impl_.second_position_;
}

void TwoPlayerMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TwoPlayerMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.TwoPlayerMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.first_position_ != nullptr);
      _impl_.first_position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.second_position_ != nullptr);
      _impl_.second_position_->Clear();
    }
  }
  ::memset(&_impl_.first_uniform_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.second_uniform_number_) -
      reinterpret_cast<char*>(&_impl_.first_uniform_number_)) + sizeof(_impl_.second_uniform_number_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TwoPlayerMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 first_uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.first_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D first_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_first_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 second_uniform_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.second_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D second_position = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_second_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TwoPlayerMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.TwoPlayerMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 first_uniform_number = 1;
  if (this->_internal_first_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_first_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D first_position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::first_position(this),
        _Internal::first_position(this).GetCachedSize(), target, stream);
  }

  // int32 second_uniform_number = 3;
  if (this->_internal_second_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_second_uniform_number(), target);
  }

  // .protos.Vector2D second_position = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::second_position(this),
        _Internal::second_position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.TwoPlayerMessage)
  return target;
}

::size_t TwoPlayerMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.TwoPlayerMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .protos.Vector2D first_position = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.first_position_);
    }

    // .protos.Vector2D second_position = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.second_position_);
    }

  }
  // int32 first_uniform_number = 1;
  if (this->_internal_first_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_first_uniform_number());
  }

  // int32 second_uniform_number = 3;
  if (this->_internal_second_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_second_uniform_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TwoPlayerMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TwoPlayerMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TwoPlayerMessage::GetClassData() const { return &_class_data_; }


void TwoPlayerMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TwoPlayerMessage*>(&to_msg);
  auto& from = static_cast<const TwoPlayerMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.TwoPlayerMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_first_position()->::protos::Vector2D::MergeFrom(
          from._internal_first_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_second_position()->::protos::Vector2D::MergeFrom(
          from._internal_second_position());
    }
  }
  if (from._internal_first_uniform_number() != 0) {
    _this->_internal_set_first_uniform_number(from._internal_first_uniform_number());
  }
  if (from._internal_second_uniform_number() != 0) {
    _this->_internal_set_second_uniform_number(from._internal_second_uniform_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TwoPlayerMessage::CopyFrom(const TwoPlayerMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.TwoPlayerMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TwoPlayerMessage::IsInitialized() const {
  return true;
}

void TwoPlayerMessage::InternalSwap(TwoPlayerMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TwoPlayerMessage, _impl_.second_uniform_number_)
      + sizeof(TwoPlayerMessage::_impl_.second_uniform_number_)
      - PROTOBUF_FIELD_OFFSET(TwoPlayerMessage, _impl_.first_position_)>(
          reinterpret_cast<char*>(&_impl_.first_position_),
          reinterpret_cast<char*>(&other->_impl_.first_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TwoPlayerMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[34]);
}
// ===================================================================

class ThreePlayerMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreePlayerMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ThreePlayerMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& first_position(const ThreePlayerMessage* msg);
  static void set_has_first_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& second_position(const ThreePlayerMessage* msg);
  static void set_has_second_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& third_position(const ThreePlayerMessage* msg);
  static void set_has_third_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::protos::Vector2D&
ThreePlayerMessage::_Internal::first_position(const ThreePlayerMessage* msg) {
  return *msg->_impl_.first_position_;
}
const ::protos::Vector2D&
ThreePlayerMessage::_Internal::second_position(const ThreePlayerMessage* msg) {
  return *msg->_impl_.second_position_;
}
const ::protos::Vector2D&
ThreePlayerMessage::_Internal::third_position(const ThreePlayerMessage* msg) {
  return *msg->_impl_.third_position_;
}
ThreePlayerMessage::ThreePlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.ThreePlayerMessage)
}
ThreePlayerMessage::ThreePlayerMessage(const ThreePlayerMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ThreePlayerMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.first_position_){nullptr}
    , decltype(_impl_.second_position_){nullptr}
    , decltype(_impl_.third_position_){nullptr}
    , decltype(_impl_.first_uniform_number_) {}

    , decltype(_impl_.second_uniform_number_) {}

    , decltype(_impl_.third_uniform_number_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.first_position_ = new ::protos::Vector2D(*from._impl_.first_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.second_position_ = new ::protos::Vector2D(*from._impl_.second_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.third_position_ = new ::protos::Vector2D(*from._impl_.third_position_);
  }
  ::memcpy(&_impl_.first_uniform_number_, &from._impl_.first_uniform_number_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.third_uniform_number_) -
    reinterpret_cast<char*>(&_impl_.first_uniform_number_)) + sizeof(_impl_.third_uniform_number_));
  // @@protoc_insertion_point(copy_constructor:protos.ThreePlayerMessage)
}

inline void ThreePlayerMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.first_position_){nullptr}
    , decltype(_impl_.second_position_){nullptr}
    , decltype(_impl_.third_position_){nullptr}
    , decltype(_impl_.first_uniform_number_) { 0 }

    , decltype(_impl_.second_uniform_number_) { 0 }

    , decltype(_impl_.third_uniform_number_) { 0 }

  };
}

ThreePlayerMessage::~ThreePlayerMessage() {
  // @@protoc_insertion_point(destructor:protos.ThreePlayerMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreePlayerMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.first_position_;
  if (this != internal_default_instance()) delete _impl_.second_position_;
  if (this != internal_default_instance()) delete _impl_.third_position_;
}

void ThreePlayerMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThreePlayerMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.ThreePlayerMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.first_position_ != nullptr);
      _impl_.first_position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.second_position_ != nullptr);
      _impl_.second_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.third_position_ != nullptr);
      _impl_.third_position_->Clear();
    }
  }
  ::memset(&_impl_.first_uniform_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.third_uniform_number_) -
      reinterpret_cast<char*>(&_impl_.first_uniform_number_)) + sizeof(_impl_.third_uniform_number_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ThreePlayerMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 first_uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.first_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D first_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_first_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 second_uniform_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.second_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D second_position = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_second_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 third_uniform_number = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.third_uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D third_position = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_third_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ThreePlayerMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.ThreePlayerMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 first_uniform_number = 1;
  if (this->_internal_first_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_first_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D first_position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::first_position(this),
        _Internal::first_position(this).GetCachedSize(), target, stream);
  }

  // int32 second_uniform_number = 3;
  if (this->_internal_second_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_second_uniform_number(), target);
  }

  // .protos.Vector2D second_position = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::second_position(this),
        _Internal::second_position(this).GetCachedSize(), target, stream);
  }

  // int32 third_uniform_number = 5;
  if (this->_internal_third_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_third_uniform_number(), target);
  }

  // .protos.Vector2D third_position = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::third_position(this),
        _Internal::third_position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.ThreePlayerMessage)
  return target;
}

::size_t ThreePlayerMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.ThreePlayerMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .protos.Vector2D first_position = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.first_position_);
    }

    // .protos.Vector2D second_position = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.second_position_);
    }

    // .protos.Vector2D third_position = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.third_position_);
    }

  }
  // int32 first_uniform_number = 1;
  if (this->_internal_first_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_first_uniform_number());
  }

  // int32 second_uniform_number = 3;
  if (this->_internal_second_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_second_uniform_number());
  }

  // int32 third_uniform_number = 5;
  if (this->_internal_third_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_third_uniform_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ThreePlayerMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ThreePlayerMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ThreePlayerMessage::GetClassData() const { return &_class_data_; }


void ThreePlayerMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ThreePlayerMessage*>(&to_msg);
  auto& from = static_cast<const ThreePlayerMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.ThreePlayerMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_first_position()->::protos::Vector2D::MergeFrom(
          from._internal_first_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_second_position()->::protos::Vector2D::MergeFrom(
          from._internal_second_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_third_position()->::protos::Vector2D::MergeFrom(
          from._internal_third_position());
    }
  }
  if (from._internal_first_uniform_number() != 0) {
    _this->_internal_set_first_uniform_number(from._internal_first_uniform_number());
  }
  if (from._internal_second_uniform_number() != 0) {
    _this->_internal_set_second_uniform_number(from._internal_second_uniform_number());
  }
  if (from._internal_third_uniform_number() != 0) {
    _this->_internal_set_third_uniform_number(from._internal_third_uniform_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ThreePlayerMessage::CopyFrom(const ThreePlayerMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.ThreePlayerMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreePlayerMessage::IsInitialized() const {
  return true;
}

void ThreePlayerMessage::InternalSwap(ThreePlayerMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ThreePlayerMessage, _impl_.third_uniform_number_)
      + sizeof(ThreePlayerMessage::_impl_.third_uniform_number_)
      - PROTOBUF_FIELD_OFFSET(ThreePlayerMessage, _impl_.first_position_)>(
          reinterpret_cast<char*>(&_impl_.first_position_),
          reinterpret_cast<char*>(&other->_impl_.first_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ThreePlayerMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[35]);
}
// ===================================================================

class SelfMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<SelfMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SelfMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& self_position(const SelfMessage* msg);
  static void set_has_self_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
SelfMessage::_Internal::self_position(const SelfMessage* msg) {
  return *msg->_impl_.self_position_;
}
SelfMessage::SelfMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.SelfMessage)
}
SelfMessage::SelfMessage(const SelfMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SelfMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.self_position_){nullptr}
    , decltype(_impl_.self_body_direction_) {}

    , decltype(_impl_.self_stamina_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.self_position_ = new ::protos::Vector2D(*from._impl_.self_position_);
  }
  ::memcpy(&_impl_.self_body_direction_, &from._impl_.self_body_direction_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.self_stamina_) -
    reinterpret_cast<char*>(&_impl_.self_body_direction_)) + sizeof(_impl_.self_stamina_));
  // @@protoc_insertion_point(copy_constructor:protos.SelfMessage)
}

inline void SelfMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.self_position_){nullptr}
    , decltype(_impl_.self_body_direction_) { 0 }

    , decltype(_impl_.self_stamina_) { 0 }

  };
}

SelfMessage::~SelfMessage() {
  // @@protoc_insertion_point(destructor:protos.SelfMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelfMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.self_position_;
}

void SelfMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SelfMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.SelfMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.self_position_ != nullptr);
    _impl_.self_position_->Clear();
  }
  ::memset(&_impl_.self_body_direction_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.self_stamina_) -
      reinterpret_cast<char*>(&_impl_.self_body_direction_)) + sizeof(_impl_.self_stamina_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SelfMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D self_position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_self_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float self_body_direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.self_body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float self_stamina = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.self_stamina_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SelfMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.SelfMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D self_position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::self_position(this),
        _Internal::self_position(this).GetCachedSize(), target, stream);
  }

  // float self_body_direction = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_self_body_direction = this->_internal_self_body_direction();
  ::uint32_t raw_self_body_direction;
  memcpy(&raw_self_body_direction, &tmp_self_body_direction, sizeof(tmp_self_body_direction));
  if (raw_self_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_self_body_direction(), target);
  }

  // float self_stamina = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_self_stamina = this->_internal_self_stamina();
  ::uint32_t raw_self_stamina;
  memcpy(&raw_self_stamina, &tmp_self_stamina, sizeof(tmp_self_stamina));
  if (raw_self_stamina != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_self_stamina(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.SelfMessage)
  return target;
}

::size_t SelfMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.SelfMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D self_position = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.self_position_);
  }

  // float self_body_direction = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_self_body_direction = this->_internal_self_body_direction();
  ::uint32_t raw_self_body_direction;
  memcpy(&raw_self_body_direction, &tmp_self_body_direction, sizeof(tmp_self_body_direction));
  if (raw_self_body_direction != 0) {
    total_size += 5;
  }

  // float self_stamina = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_self_stamina = this->_internal_self_stamina();
  ::uint32_t raw_self_stamina;
  memcpy(&raw_self_stamina, &tmp_self_stamina, sizeof(tmp_self_stamina));
  if (raw_self_stamina != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SelfMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SelfMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SelfMessage::GetClassData() const { return &_class_data_; }


void SelfMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SelfMessage*>(&to_msg);
  auto& from = static_cast<const SelfMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.SelfMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_self_position()->::protos::Vector2D::MergeFrom(
        from._internal_self_position());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_self_body_direction = from._internal_self_body_direction();
  ::uint32_t raw_self_body_direction;
  memcpy(&raw_self_body_direction, &tmp_self_body_direction, sizeof(tmp_self_body_direction));
  if (raw_self_body_direction != 0) {
    _this->_internal_set_self_body_direction(from._internal_self_body_direction());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_self_stamina = from._internal_self_stamina();
  ::uint32_t raw_self_stamina;
  memcpy(&raw_self_stamina, &tmp_self_stamina, sizeof(tmp_self_stamina));
  if (raw_self_stamina != 0) {
    _this->_internal_set_self_stamina(from._internal_self_stamina());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SelfMessage::CopyFrom(const SelfMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.SelfMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelfMessage::IsInitialized() const {
  return true;
}

void SelfMessage::InternalSwap(SelfMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SelfMessage, _impl_.self_stamina_)
      + sizeof(SelfMessage::_impl_.self_stamina_)
      - PROTOBUF_FIELD_OFFSET(SelfMessage, _impl_.self_position_)>(
          reinterpret_cast<char*>(&_impl_.self_position_),
          reinterpret_cast<char*>(&other->_impl_.self_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SelfMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[36]);
}
// ===================================================================

class TeammateMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<TeammateMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TeammateMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const TeammateMessage* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
TeammateMessage::_Internal::position(const TeammateMessage* msg) {
  return *msg->_impl_.position_;
}
TeammateMessage::TeammateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.TeammateMessage)
}
TeammateMessage::TeammateMessage(const TeammateMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TeammateMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.uniform_number_) {}

    , decltype(_impl_.body_direction_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  ::memcpy(&_impl_.uniform_number_, &from._impl_.uniform_number_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.body_direction_) -
    reinterpret_cast<char*>(&_impl_.uniform_number_)) + sizeof(_impl_.body_direction_));
  // @@protoc_insertion_point(copy_constructor:protos.TeammateMessage)
}

inline void TeammateMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.body_direction_) { 0 }

  };
}

TeammateMessage::~TeammateMessage() {
  // @@protoc_insertion_point(destructor:protos.TeammateMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TeammateMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
}

void TeammateMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TeammateMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.TeammateMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  ::memset(&_impl_.uniform_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.body_direction_) -
      reinterpret_cast<char*>(&_impl_.uniform_number_)) + sizeof(_impl_.body_direction_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TeammateMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float body_direction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TeammateMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.TeammateMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 uniform_number = 1;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // float body_direction = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_body_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.TeammateMessage)
  return target;
}

::size_t TeammateMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.TeammateMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D position = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // int32 uniform_number = 1;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  // float body_direction = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TeammateMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TeammateMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TeammateMessage::GetClassData() const { return &_class_data_; }


void TeammateMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TeammateMessage*>(&to_msg);
  auto& from = static_cast<const TeammateMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.TeammateMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
        from._internal_position());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = from._internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    _this->_internal_set_body_direction(from._internal_body_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TeammateMessage::CopyFrom(const TeammateMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.TeammateMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TeammateMessage::IsInitialized() const {
  return true;
}

void TeammateMessage::InternalSwap(TeammateMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TeammateMessage, _impl_.body_direction_)
      + sizeof(TeammateMessage::_impl_.body_direction_)
      - PROTOBUF_FIELD_OFFSET(TeammateMessage, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TeammateMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[37]);
}
// ===================================================================

class OpponentMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<OpponentMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(OpponentMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const OpponentMessage* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
OpponentMessage::_Internal::position(const OpponentMessage* msg) {
  return *msg->_impl_.position_;
}
OpponentMessage::OpponentMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.OpponentMessage)
}
OpponentMessage::OpponentMessage(const OpponentMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OpponentMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.uniform_number_) {}

    , decltype(_impl_.body_direction_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  ::memcpy(&_impl_.uniform_number_, &from._impl_.uniform_number_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.body_direction_) -
    reinterpret_cast<char*>(&_impl_.uniform_number_)) + sizeof(_impl_.body_direction_));
  // @@protoc_insertion_point(copy_constructor:protos.OpponentMessage)
}

inline void OpponentMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.body_direction_) { 0 }

  };
}

OpponentMessage::~OpponentMessage() {
  // @@protoc_insertion_point(destructor:protos.OpponentMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OpponentMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
}

void OpponentMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OpponentMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.OpponentMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  ::memset(&_impl_.uniform_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.body_direction_) -
      reinterpret_cast<char*>(&_impl_.uniform_number_)) + sizeof(_impl_.body_direction_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OpponentMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 uniform_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float body_direction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OpponentMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.OpponentMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 uniform_number = 1;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_uniform_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // float body_direction = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_body_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.OpponentMessage)
  return target;
}

::size_t OpponentMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.OpponentMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Vector2D position = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // int32 uniform_number = 1;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  // float body_direction = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OpponentMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OpponentMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OpponentMessage::GetClassData() const { return &_class_data_; }


void OpponentMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OpponentMessage*>(&to_msg);
  auto& from = static_cast<const OpponentMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.OpponentMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
        from._internal_position());
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = from._internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    _this->_internal_set_body_direction(from._internal_body_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OpponentMessage::CopyFrom(const OpponentMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.OpponentMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpponentMessage::IsInitialized() const {
  return true;
}

void OpponentMessage::InternalSwap(OpponentMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OpponentMessage, _impl_.body_direction_)
      + sizeof(OpponentMessage::_impl_.body_direction_)
      - PROTOBUF_FIELD_OFFSET(OpponentMessage, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OpponentMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[38]);
}
// ===================================================================

class BallPlayerMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<BallPlayerMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BallPlayerMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& ball_position(const BallPlayerMessage* msg);
  static void set_has_ball_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& ball_velocity(const BallPlayerMessage* msg);
  static void set_has_ball_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& player_position(const BallPlayerMessage* msg);
  static void set_has_player_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::protos::Vector2D&
BallPlayerMessage::_Internal::ball_position(const BallPlayerMessage* msg) {
  return *msg->_impl_.ball_position_;
}
const ::protos::Vector2D&
BallPlayerMessage::_Internal::ball_velocity(const BallPlayerMessage* msg) {
  return *msg->_impl_.ball_velocity_;
}
const ::protos::Vector2D&
BallPlayerMessage::_Internal::player_position(const BallPlayerMessage* msg) {
  return *msg->_impl_.player_position_;
}
BallPlayerMessage::BallPlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.BallPlayerMessage)
}
BallPlayerMessage::BallPlayerMessage(const BallPlayerMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BallPlayerMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ball_position_){nullptr}
    , decltype(_impl_.ball_velocity_){nullptr}
    , decltype(_impl_.player_position_){nullptr}
    , decltype(_impl_.uniform_number_) {}

    , decltype(_impl_.body_direction_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.ball_position_ = new ::protos::Vector2D(*from._impl_.ball_position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.ball_velocity_ = new ::protos::Vector2D(*from._impl_.ball_velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.player_position_ = new ::protos::Vector2D(*from._impl_.player_position_);
  }
  ::memcpy(&_impl_.uniform_number_, &from._impl_.uniform_number_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.body_direction_) -
    reinterpret_cast<char*>(&_impl_.uniform_number_)) + sizeof(_impl_.body_direction_));
  // @@protoc_insertion_point(copy_constructor:protos.BallPlayerMessage)
}

inline void BallPlayerMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ball_position_){nullptr}
    , decltype(_impl_.ball_velocity_){nullptr}
    , decltype(_impl_.player_position_){nullptr}
    , decltype(_impl_.uniform_number_) { 0 }

    , decltype(_impl_.body_direction_) { 0 }

  };
}

BallPlayerMessage::~BallPlayerMessage() {
  // @@protoc_insertion_point(destructor:protos.BallPlayerMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BallPlayerMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.ball_position_;
  if (this != internal_default_instance()) delete _impl_.ball_velocity_;
  if (this != internal_default_instance()) delete _impl_.player_position_;
}

void BallPlayerMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BallPlayerMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.BallPlayerMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.ball_position_ != nullptr);
      _impl_.ball_position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.ball_velocity_ != nullptr);
      _impl_.ball_velocity_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.player_position_ != nullptr);
      _impl_.player_position_->Clear();
    }
  }
  ::memset(&_impl_.uniform_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.body_direction_) -
      reinterpret_cast<char*>(&_impl_.uniform_number_)) + sizeof(_impl_.body_direction_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BallPlayerMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Vector2D ball_position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D ball_velocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 uniform_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.uniform_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D player_position = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float body_direction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.body_direction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BallPlayerMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.BallPlayerMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D ball_position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::ball_position(this),
        _Internal::ball_position(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D ball_velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::ball_velocity(this),
        _Internal::ball_velocity(this).GetCachedSize(), target, stream);
  }

  // int32 uniform_number = 3;
  if (this->_internal_uniform_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_uniform_number(), target);
  }

  // .protos.Vector2D player_position = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::player_position(this),
        _Internal::player_position(this).GetCachedSize(), target, stream);
  }

  // float body_direction = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_body_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.BallPlayerMessage)
  return target;
}

::size_t BallPlayerMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.BallPlayerMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .protos.Vector2D ball_position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_position_);
    }

    // .protos.Vector2D ball_velocity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ball_velocity_);
    }

    // .protos.Vector2D player_position = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.player_position_);
    }

  }
  // int32 uniform_number = 3;
  if (this->_internal_uniform_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_uniform_number());
  }

  // float body_direction = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = this->_internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BallPlayerMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BallPlayerMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BallPlayerMessage::GetClassData() const { return &_class_data_; }


void BallPlayerMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BallPlayerMessage*>(&to_msg);
  auto& from = static_cast<const BallPlayerMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.BallPlayerMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_ball_position()->::protos::Vector2D::MergeFrom(
          from._internal_ball_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_ball_velocity()->::protos::Vector2D::MergeFrom(
          from._internal_ball_velocity());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_player_position()->::protos::Vector2D::MergeFrom(
          from._internal_player_position());
    }
  }
  if (from._internal_uniform_number() != 0) {
    _this->_internal_set_uniform_number(from._internal_uniform_number());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_body_direction = from._internal_body_direction();
  ::uint32_t raw_body_direction;
  memcpy(&raw_body_direction, &tmp_body_direction, sizeof(tmp_body_direction));
  if (raw_body_direction != 0) {
    _this->_internal_set_body_direction(from._internal_body_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BallPlayerMessage::CopyFrom(const BallPlayerMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.BallPlayerMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BallPlayerMessage::IsInitialized() const {
  return true;
}

void BallPlayerMessage::InternalSwap(BallPlayerMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BallPlayerMessage, _impl_.body_direction_)
      + sizeof(BallPlayerMessage::_impl_.body_direction_)
      - PROTOBUF_FIELD_OFFSET(BallPlayerMessage, _impl_.ball_position_)>(
          reinterpret_cast<char*>(&_impl_.ball_position_),
          reinterpret_cast<char*>(&other->_impl_.ball_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BallPlayerMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[39]);
}
// ===================================================================

class Say::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::protos::Say, _impl_._oneof_case_);
  static const ::protos::BallMessage& ball_message(const Say* msg);
  static const ::protos::PassMessage& pass_message(const Say* msg);
  static const ::protos::InterceptMessage& intercept_message(const Say* msg);
  static const ::protos::GoalieMessage& goalie_message(const Say* msg);
  static const ::protos::GoalieAndPlayerMessage& goalie_and_player_message(const Say* msg);
  static const ::protos::OffsideLineMessage& offside_line_message(const Say* msg);
  static const ::protos::DefenseLineMessage& defense_line_message(const Say* msg);
  static const ::protos::WaitRequestMessage& wait_request_message(const Say* msg);
  static const ::protos::SetplayMessage& setplay_message(const Say* msg);
  static const ::protos::PassRequestMessage& pass_request_message(const Say* msg);
  static const ::protos::StaminaMessage& stamina_message(const Say* msg);
  static const ::protos::RecoveryMessage& recovery_message(const Say* msg);
  static const ::protos::StaminaCapacityMessage& stamina_capacity_message(const Say* msg);
  static const ::protos::DribbleMessage& dribble_message(const Say* msg);
  static const ::protos::BallGoalieMessage& ball_goalie_message(const Say* msg);
  static const ::protos::OnePlayerMessage& one_player_message(const Say* msg);
  static const ::protos::TwoPlayerMessage& two_player_message(const Say* msg);
  static const ::protos::ThreePlayerMessage& three_player_message(const Say* msg);
  static const ::protos::SelfMessage& self_message(const Say* msg);
  static const ::protos::TeammateMessage& teammate_message(const Say* msg);
  static const ::protos::OpponentMessage& opponent_message(const Say* msg);
  static const ::protos::BallPlayerMessage& ball_player_message(const Say* msg);
};

const ::protos::BallMessage&
Say::_Internal::ball_message(const Say* msg) {
  return *msg->_impl_.message_.ball_message_;
}
const ::protos::PassMessage&
Say::_Internal::pass_message(const Say* msg) {
  return *msg->_impl_.message_.pass_message_;
}
const ::protos::InterceptMessage&
Say::_Internal::intercept_message(const Say* msg) {
  return *msg->_impl_.message_.intercept_message_;
}
const ::protos::GoalieMessage&
Say::_Internal::goalie_message(const Say* msg) {
  return *msg->_impl_.message_.goalie_message_;
}
const ::protos::GoalieAndPlayerMessage&
Say::_Internal::goalie_and_player_message(const Say* msg) {
  return *msg->_impl_.message_.goalie_and_player_message_;
}
const ::protos::OffsideLineMessage&
Say::_Internal::offside_line_message(const Say* msg) {
  return *msg->_impl_.message_.offside_line_message_;
}
const ::protos::DefenseLineMessage&
Say::_Internal::defense_line_message(const Say* msg) {
  return *msg->_impl_.message_.defense_line_message_;
}
const ::protos::WaitRequestMessage&
Say::_Internal::wait_request_message(const Say* msg) {
  return *msg->_impl_.message_.wait_request_message_;
}
const ::protos::SetplayMessage&
Say::_Internal::setplay_message(const Say* msg) {
  return *msg->_impl_.message_.setplay_message_;
}
const ::protos::PassRequestMessage&
Say::_Internal::pass_request_message(const Say* msg) {
  return *msg->_impl_.message_.pass_request_message_;
}
const ::protos::StaminaMessage&
Say::_Internal::stamina_message(const Say* msg) {
  return *msg->_impl_.message_.stamina_message_;
}
const ::protos::RecoveryMessage&
Say::_Internal::recovery_message(const Say* msg) {
  return *msg->_impl_.message_.recovery_message_;
}
const ::protos::StaminaCapacityMessage&
Say::_Internal::stamina_capacity_message(const Say* msg) {
  return *msg->_impl_.message_.stamina_capacity_message_;
}
const ::protos::DribbleMessage&
Say::_Internal::dribble_message(const Say* msg) {
  return *msg->_impl_.message_.dribble_message_;
}
const ::protos::BallGoalieMessage&
Say::_Internal::ball_goalie_message(const Say* msg) {
  return *msg->_impl_.message_.ball_goalie_message_;
}
const ::protos::OnePlayerMessage&
Say::_Internal::one_player_message(const Say* msg) {
  return *msg->_impl_.message_.one_player_message_;
}
const ::protos::TwoPlayerMessage&
Say::_Internal::two_player_message(const Say* msg) {
  return *msg->_impl_.message_.two_player_message_;
}
const ::protos::ThreePlayerMessage&
Say::_Internal::three_player_message(const Say* msg) {
  return *msg->_impl_.message_.three_player_message_;
}
const ::protos::SelfMessage&
Say::_Internal::self_message(const Say* msg) {
  return *msg->_impl_.message_.self_message_;
}
const ::protos::TeammateMessage&
Say::_Internal::teammate_message(const Say* msg) {
  return *msg->_impl_.message_.teammate_message_;
}
const ::protos::OpponentMessage&
Say::_Internal::opponent_message(const Say* msg) {
  return *msg->_impl_.message_.opponent_message_;
}
const ::protos::BallPlayerMessage&
Say::_Internal::ball_player_message(const Say* msg) {
  return *msg->_impl_.message_.ball_player_message_;
}
void Say::set_allocated_ball_message(::protos::BallMessage* ball_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (ball_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball_message);
    if (message_arena != submessage_arena) {
      ball_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_message, submessage_arena);
    }
    set_has_ball_message();
    _impl_.message_.ball_message_ = ball_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.ball_message)
}
void Say::set_allocated_pass_message(::protos::PassMessage* pass_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (pass_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pass_message);
    if (message_arena != submessage_arena) {
      pass_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pass_message, submessage_arena);
    }
    set_has_pass_message();
    _impl_.message_.pass_message_ = pass_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.pass_message)
}
void Say::set_allocated_intercept_message(::protos::InterceptMessage* intercept_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (intercept_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(intercept_message);
    if (message_arena != submessage_arena) {
      intercept_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intercept_message, submessage_arena);
    }
    set_has_intercept_message();
    _impl_.message_.intercept_message_ = intercept_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.intercept_message)
}
void Say::set_allocated_goalie_message(::protos::GoalieMessage* goalie_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (goalie_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(goalie_message);
    if (message_arena != submessage_arena) {
      goalie_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, goalie_message, submessage_arena);
    }
    set_has_goalie_message();
    _impl_.message_.goalie_message_ = goalie_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.goalie_message)
}
void Say::set_allocated_goalie_and_player_message(::protos::GoalieAndPlayerMessage* goalie_and_player_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (goalie_and_player_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(goalie_and_player_message);
    if (message_arena != submessage_arena) {
      goalie_and_player_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, goalie_and_player_message, submessage_arena);
    }
    set_has_goalie_and_player_message();
    _impl_.message_.goalie_and_player_message_ = goalie_and_player_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.goalie_and_player_message)
}
void Say::set_allocated_offside_line_message(::protos::OffsideLineMessage* offside_line_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (offside_line_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(offside_line_message);
    if (message_arena != submessage_arena) {
      offside_line_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offside_line_message, submessage_arena);
    }
    set_has_offside_line_message();
    _impl_.message_.offside_line_message_ = offside_line_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.offside_line_message)
}
void Say::set_allocated_defense_line_message(::protos::DefenseLineMessage* defense_line_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (defense_line_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(defense_line_message);
    if (message_arena != submessage_arena) {
      defense_line_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, defense_line_message, submessage_arena);
    }
    set_has_defense_line_message();
    _impl_.message_.defense_line_message_ = defense_line_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.defense_line_message)
}
void Say::set_allocated_wait_request_message(::protos::WaitRequestMessage* wait_request_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (wait_request_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wait_request_message);
    if (message_arena != submessage_arena) {
      wait_request_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wait_request_message, submessage_arena);
    }
    set_has_wait_request_message();
    _impl_.message_.wait_request_message_ = wait_request_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.wait_request_message)
}
void Say::set_allocated_setplay_message(::protos::SetplayMessage* setplay_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (setplay_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(setplay_message);
    if (message_arena != submessage_arena) {
      setplay_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setplay_message, submessage_arena);
    }
    set_has_setplay_message();
    _impl_.message_.setplay_message_ = setplay_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.setplay_message)
}
void Say::set_allocated_pass_request_message(::protos::PassRequestMessage* pass_request_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (pass_request_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pass_request_message);
    if (message_arena != submessage_arena) {
      pass_request_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pass_request_message, submessage_arena);
    }
    set_has_pass_request_message();
    _impl_.message_.pass_request_message_ = pass_request_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.pass_request_message)
}
void Say::set_allocated_stamina_message(::protos::StaminaMessage* stamina_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (stamina_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stamina_message);
    if (message_arena != submessage_arena) {
      stamina_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamina_message, submessage_arena);
    }
    set_has_stamina_message();
    _impl_.message_.stamina_message_ = stamina_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.stamina_message)
}
void Say::set_allocated_recovery_message(::protos::RecoveryMessage* recovery_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (recovery_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recovery_message);
    if (message_arena != submessage_arena) {
      recovery_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recovery_message, submessage_arena);
    }
    set_has_recovery_message();
    _impl_.message_.recovery_message_ = recovery_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.recovery_message)
}
void Say::set_allocated_stamina_capacity_message(::protos::StaminaCapacityMessage* stamina_capacity_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (stamina_capacity_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stamina_capacity_message);
    if (message_arena != submessage_arena) {
      stamina_capacity_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamina_capacity_message, submessage_arena);
    }
    set_has_stamina_capacity_message();
    _impl_.message_.stamina_capacity_message_ = stamina_capacity_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.stamina_capacity_message)
}
void Say::set_allocated_dribble_message(::protos::DribbleMessage* dribble_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (dribble_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dribble_message);
    if (message_arena != submessage_arena) {
      dribble_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dribble_message, submessage_arena);
    }
    set_has_dribble_message();
    _impl_.message_.dribble_message_ = dribble_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.dribble_message)
}
void Say::set_allocated_ball_goalie_message(::protos::BallGoalieMessage* ball_goalie_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (ball_goalie_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball_goalie_message);
    if (message_arena != submessage_arena) {
      ball_goalie_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_goalie_message, submessage_arena);
    }
    set_has_ball_goalie_message();
    _impl_.message_.ball_goalie_message_ = ball_goalie_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.ball_goalie_message)
}
void Say::set_allocated_one_player_message(::protos::OnePlayerMessage* one_player_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (one_player_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(one_player_message);
    if (message_arena != submessage_arena) {
      one_player_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, one_player_message, submessage_arena);
    }
    set_has_one_player_message();
    _impl_.message_.one_player_message_ = one_player_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.one_player_message)
}
void Say::set_allocated_two_player_message(::protos::TwoPlayerMessage* two_player_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (two_player_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(two_player_message);
    if (message_arena != submessage_arena) {
      two_player_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, two_player_message, submessage_arena);
    }
    set_has_two_player_message();
    _impl_.message_.two_player_message_ = two_player_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.two_player_message)
}
void Say::set_allocated_three_player_message(::protos::ThreePlayerMessage* three_player_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (three_player_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(three_player_message);
    if (message_arena != submessage_arena) {
      three_player_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, three_player_message, submessage_arena);
    }
    set_has_three_player_message();
    _impl_.message_.three_player_message_ = three_player_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.three_player_message)
}
void Say::set_allocated_self_message(::protos::SelfMessage* self_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (self_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(self_message);
    if (message_arena != submessage_arena) {
      self_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, self_message, submessage_arena);
    }
    set_has_self_message();
    _impl_.message_.self_message_ = self_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.self_message)
}
void Say::set_allocated_teammate_message(::protos::TeammateMessage* teammate_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (teammate_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(teammate_message);
    if (message_arena != submessage_arena) {
      teammate_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, teammate_message, submessage_arena);
    }
    set_has_teammate_message();
    _impl_.message_.teammate_message_ = teammate_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.teammate_message)
}
void Say::set_allocated_opponent_message(::protos::OpponentMessage* opponent_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (opponent_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(opponent_message);
    if (message_arena != submessage_arena) {
      opponent_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opponent_message, submessage_arena);
    }
    set_has_opponent_message();
    _impl_.message_.opponent_message_ = opponent_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.opponent_message)
}
void Say::set_allocated_ball_player_message(::protos::BallPlayerMessage* ball_player_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (ball_player_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball_player_message);
    if (message_arena != submessage_arena) {
      ball_player_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_player_message, submessage_arena);
    }
    set_has_ball_player_message();
    _impl_.message_.ball_player_message_ = ball_player_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Say.ball_player_message)
}
Say::Say(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Say)
}
Say::Say(const Say& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Say* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_message();
  switch (from.message_case()) {
    case kBallMessage: {
      _this->_internal_mutable_ball_message()->::protos::BallMessage::MergeFrom(
          from._internal_ball_message());
      break;
    }
    case kPassMessage: {
      _this->_internal_mutable_pass_message()->::protos::PassMessage::MergeFrom(
          from._internal_pass_message());
      break;
    }
    case kInterceptMessage: {
      _this->_internal_mutable_intercept_message()->::protos::InterceptMessage::MergeFrom(
          from._internal_intercept_message());
      break;
    }
    case kGoalieMessage: {
      _this->_internal_mutable_goalie_message()->::protos::GoalieMessage::MergeFrom(
          from._internal_goalie_message());
      break;
    }
    case kGoalieAndPlayerMessage: {
      _this->_internal_mutable_goalie_and_player_message()->::protos::GoalieAndPlayerMessage::MergeFrom(
          from._internal_goalie_and_player_message());
      break;
    }
    case kOffsideLineMessage: {
      _this->_internal_mutable_offside_line_message()->::protos::OffsideLineMessage::MergeFrom(
          from._internal_offside_line_message());
      break;
    }
    case kDefenseLineMessage: {
      _this->_internal_mutable_defense_line_message()->::protos::DefenseLineMessage::MergeFrom(
          from._internal_defense_line_message());
      break;
    }
    case kWaitRequestMessage: {
      _this->_internal_mutable_wait_request_message()->::protos::WaitRequestMessage::MergeFrom(
          from._internal_wait_request_message());
      break;
    }
    case kSetplayMessage: {
      _this->_internal_mutable_setplay_message()->::protos::SetplayMessage::MergeFrom(
          from._internal_setplay_message());
      break;
    }
    case kPassRequestMessage: {
      _this->_internal_mutable_pass_request_message()->::protos::PassRequestMessage::MergeFrom(
          from._internal_pass_request_message());
      break;
    }
    case kStaminaMessage: {
      _this->_internal_mutable_stamina_message()->::protos::StaminaMessage::MergeFrom(
          from._internal_stamina_message());
      break;
    }
    case kRecoveryMessage: {
      _this->_internal_mutable_recovery_message()->::protos::RecoveryMessage::MergeFrom(
          from._internal_recovery_message());
      break;
    }
    case kStaminaCapacityMessage: {
      _this->_internal_mutable_stamina_capacity_message()->::protos::StaminaCapacityMessage::MergeFrom(
          from._internal_stamina_capacity_message());
      break;
    }
    case kDribbleMessage: {
      _this->_internal_mutable_dribble_message()->::protos::DribbleMessage::MergeFrom(
          from._internal_dribble_message());
      break;
    }
    case kBallGoalieMessage: {
      _this->_internal_mutable_ball_goalie_message()->::protos::BallGoalieMessage::MergeFrom(
          from._internal_ball_goalie_message());
      break;
    }
    case kOnePlayerMessage: {
      _this->_internal_mutable_one_player_message()->::protos::OnePlayerMessage::MergeFrom(
          from._internal_one_player_message());
      break;
    }
    case kTwoPlayerMessage: {
      _this->_internal_mutable_two_player_message()->::protos::TwoPlayerMessage::MergeFrom(
          from._internal_two_player_message());
      break;
    }
    case kThreePlayerMessage: {
      _this->_internal_mutable_three_player_message()->::protos::ThreePlayerMessage::MergeFrom(
          from._internal_three_player_message());
      break;
    }
    case kSelfMessage: {
      _this->_internal_mutable_self_message()->::protos::SelfMessage::MergeFrom(
          from._internal_self_message());
      break;
    }
    case kTeammateMessage: {
      _this->_internal_mutable_teammate_message()->::protos::TeammateMessage::MergeFrom(
          from._internal_teammate_message());
      break;
    }
    case kOpponentMessage: {
      _this->_internal_mutable_opponent_message()->::protos::OpponentMessage::MergeFrom(
          from._internal_opponent_message());
      break;
    }
    case kBallPlayerMessage: {
      _this->_internal_mutable_ball_player_message()->::protos::BallPlayerMessage::MergeFrom(
          from._internal_ball_player_message());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:protos.Say)
}

inline void Say::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_message();
}

Say::~Say() {
  // @@protoc_insertion_point(destructor:protos.Say)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Say::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_message()) {
    clear_message();
  }
}

void Say::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Say::clear_message() {
// @@protoc_insertion_point(one_of_clear_start:protos.Say)
  switch (message_case()) {
    case kBallMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.ball_message_;
      }
      break;
    }
    case kPassMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.pass_message_;
      }
      break;
    }
    case kInterceptMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.intercept_message_;
      }
      break;
    }
    case kGoalieMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.goalie_message_;
      }
      break;
    }
    case kGoalieAndPlayerMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.goalie_and_player_message_;
      }
      break;
    }
    case kOffsideLineMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.offside_line_message_;
      }
      break;
    }
    case kDefenseLineMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.defense_line_message_;
      }
      break;
    }
    case kWaitRequestMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.wait_request_message_;
      }
      break;
    }
    case kSetplayMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.setplay_message_;
      }
      break;
    }
    case kPassRequestMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.pass_request_message_;
      }
      break;
    }
    case kStaminaMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.stamina_message_;
      }
      break;
    }
    case kRecoveryMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.recovery_message_;
      }
      break;
    }
    case kStaminaCapacityMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.stamina_capacity_message_;
      }
      break;
    }
    case kDribbleMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.dribble_message_;
      }
      break;
    }
    case kBallGoalieMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.ball_goalie_message_;
      }
      break;
    }
    case kOnePlayerMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.one_player_message_;
      }
      break;
    }
    case kTwoPlayerMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.two_player_message_;
      }
      break;
    }
    case kThreePlayerMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.three_player_message_;
      }
      break;
    }
    case kSelfMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.self_message_;
      }
      break;
    }
    case kTeammateMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.teammate_message_;
      }
      break;
    }
    case kOpponentMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.opponent_message_;
      }
      break;
    }
    case kBallPlayerMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.ball_player_message_;
      }
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}


void Say::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Say)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_message();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Say::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.BallMessage ball_message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.PassMessage pass_message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pass_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.InterceptMessage intercept_message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_intercept_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.GoalieMessage goalie_message = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_goalie_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.GoalieAndPlayerMessage goalie_and_player_message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_goalie_and_player_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.OffsideLineMessage offside_line_message = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_offside_line_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.DefenseLineMessage defense_line_message = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_defense_line_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.WaitRequestMessage wait_request_message = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_wait_request_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.SetplayMessage setplay_message = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_setplay_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.PassRequestMessage pass_request_message = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_pass_request_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.StaminaMessage stamina_message = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_stamina_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.RecoveryMessage recovery_message = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_recovery_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.StaminaCapacityMessage stamina_capacity_message = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_stamina_capacity_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.DribbleMessage dribble_message = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_dribble_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.BallGoalieMessage ball_goalie_message = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_goalie_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.OnePlayerMessage one_player_message = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_one_player_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.TwoPlayerMessage two_player_message = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_two_player_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.ThreePlayerMessage three_player_message = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_three_player_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.SelfMessage self_message = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_self_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.TeammateMessage teammate_message = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_teammate_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.OpponentMessage opponent_message = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_opponent_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.BallPlayerMessage ball_player_message = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball_player_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Say::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Say)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (message_case()) {
    case kBallMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::ball_message(this),
          _Internal::ball_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kPassMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::pass_message(this),
          _Internal::pass_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kInterceptMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::intercept_message(this),
          _Internal::intercept_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kGoalieMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::goalie_message(this),
          _Internal::goalie_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kGoalieAndPlayerMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::goalie_and_player_message(this),
          _Internal::goalie_and_player_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kOffsideLineMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::offside_line_message(this),
          _Internal::offside_line_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kDefenseLineMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::defense_line_message(this),
          _Internal::defense_line_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kWaitRequestMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::wait_request_message(this),
          _Internal::wait_request_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kSetplayMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::setplay_message(this),
          _Internal::setplay_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kPassRequestMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::pass_request_message(this),
          _Internal::pass_request_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kStaminaMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::stamina_message(this),
          _Internal::stamina_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kRecoveryMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::recovery_message(this),
          _Internal::recovery_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kStaminaCapacityMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, _Internal::stamina_capacity_message(this),
          _Internal::stamina_capacity_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kDribbleMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, _Internal::dribble_message(this),
          _Internal::dribble_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kBallGoalieMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, _Internal::ball_goalie_message(this),
          _Internal::ball_goalie_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kOnePlayerMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, _Internal::one_player_message(this),
          _Internal::one_player_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kTwoPlayerMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(17, _Internal::two_player_message(this),
          _Internal::two_player_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kThreePlayerMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, _Internal::three_player_message(this),
          _Internal::three_player_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kSelfMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(19, _Internal::self_message(this),
          _Internal::self_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kTeammateMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, _Internal::teammate_message(this),
          _Internal::teammate_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kOpponentMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(21, _Internal::opponent_message(this),
          _Internal::opponent_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kBallPlayerMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, _Internal::ball_player_message(this),
          _Internal::ball_player_message(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Say)
  return target;
}

::size_t Say::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Say)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (message_case()) {
    // .protos.BallMessage ball_message = 1;
    case kBallMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.ball_message_);
      break;
    }
    // .protos.PassMessage pass_message = 2;
    case kPassMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.pass_message_);
      break;
    }
    // .protos.InterceptMessage intercept_message = 3;
    case kInterceptMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.intercept_message_);
      break;
    }
    // .protos.GoalieMessage goalie_message = 4;
    case kGoalieMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.goalie_message_);
      break;
    }
    // .protos.GoalieAndPlayerMessage goalie_and_player_message = 5;
    case kGoalieAndPlayerMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.goalie_and_player_message_);
      break;
    }
    // .protos.OffsideLineMessage offside_line_message = 6;
    case kOffsideLineMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.offside_line_message_);
      break;
    }
    // .protos.DefenseLineMessage defense_line_message = 7;
    case kDefenseLineMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.defense_line_message_);
      break;
    }
    // .protos.WaitRequestMessage wait_request_message = 8;
    case kWaitRequestMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.wait_request_message_);
      break;
    }
    // .protos.SetplayMessage setplay_message = 9;
    case kSetplayMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.setplay_message_);
      break;
    }
    // .protos.PassRequestMessage pass_request_message = 10;
    case kPassRequestMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.pass_request_message_);
      break;
    }
    // .protos.StaminaMessage stamina_message = 11;
    case kStaminaMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.stamina_message_);
      break;
    }
    // .protos.RecoveryMessage recovery_message = 12;
    case kRecoveryMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.recovery_message_);
      break;
    }
    // .protos.StaminaCapacityMessage stamina_capacity_message = 13;
    case kStaminaCapacityMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.stamina_capacity_message_);
      break;
    }
    // .protos.DribbleMessage dribble_message = 14;
    case kDribbleMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.dribble_message_);
      break;
    }
    // .protos.BallGoalieMessage ball_goalie_message = 15;
    case kBallGoalieMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.ball_goalie_message_);
      break;
    }
    // .protos.OnePlayerMessage one_player_message = 16;
    case kOnePlayerMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.one_player_message_);
      break;
    }
    // .protos.TwoPlayerMessage two_player_message = 17;
    case kTwoPlayerMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.two_player_message_);
      break;
    }
    // .protos.ThreePlayerMessage three_player_message = 18;
    case kThreePlayerMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.three_player_message_);
      break;
    }
    // .protos.SelfMessage self_message = 19;
    case kSelfMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.self_message_);
      break;
    }
    // .protos.TeammateMessage teammate_message = 20;
    case kTeammateMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.teammate_message_);
      break;
    }
    // .protos.OpponentMessage opponent_message = 21;
    case kOpponentMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.opponent_message_);
      break;
    }
    // .protos.BallPlayerMessage ball_player_message = 22;
    case kBallPlayerMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.ball_player_message_);
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Say::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Say::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Say::GetClassData() const { return &_class_data_; }


void Say::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Say*>(&to_msg);
  auto& from = static_cast<const Say&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Say)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.message_case()) {
    case kBallMessage: {
      _this->_internal_mutable_ball_message()->::protos::BallMessage::MergeFrom(
          from._internal_ball_message());
      break;
    }
    case kPassMessage: {
      _this->_internal_mutable_pass_message()->::protos::PassMessage::MergeFrom(
          from._internal_pass_message());
      break;
    }
    case kInterceptMessage: {
      _this->_internal_mutable_intercept_message()->::protos::InterceptMessage::MergeFrom(
          from._internal_intercept_message());
      break;
    }
    case kGoalieMessage: {
      _this->_internal_mutable_goalie_message()->::protos::GoalieMessage::MergeFrom(
          from._internal_goalie_message());
      break;
    }
    case kGoalieAndPlayerMessage: {
      _this->_internal_mutable_goalie_and_player_message()->::protos::GoalieAndPlayerMessage::MergeFrom(
          from._internal_goalie_and_player_message());
      break;
    }
    case kOffsideLineMessage: {
      _this->_internal_mutable_offside_line_message()->::protos::OffsideLineMessage::MergeFrom(
          from._internal_offside_line_message());
      break;
    }
    case kDefenseLineMessage: {
      _this->_internal_mutable_defense_line_message()->::protos::DefenseLineMessage::MergeFrom(
          from._internal_defense_line_message());
      break;
    }
    case kWaitRequestMessage: {
      _this->_internal_mutable_wait_request_message()->::protos::WaitRequestMessage::MergeFrom(
          from._internal_wait_request_message());
      break;
    }
    case kSetplayMessage: {
      _this->_internal_mutable_setplay_message()->::protos::SetplayMessage::MergeFrom(
          from._internal_setplay_message());
      break;
    }
    case kPassRequestMessage: {
      _this->_internal_mutable_pass_request_message()->::protos::PassRequestMessage::MergeFrom(
          from._internal_pass_request_message());
      break;
    }
    case kStaminaMessage: {
      _this->_internal_mutable_stamina_message()->::protos::StaminaMessage::MergeFrom(
          from._internal_stamina_message());
      break;
    }
    case kRecoveryMessage: {
      _this->_internal_mutable_recovery_message()->::protos::RecoveryMessage::MergeFrom(
          from._internal_recovery_message());
      break;
    }
    case kStaminaCapacityMessage: {
      _this->_internal_mutable_stamina_capacity_message()->::protos::StaminaCapacityMessage::MergeFrom(
          from._internal_stamina_capacity_message());
      break;
    }
    case kDribbleMessage: {
      _this->_internal_mutable_dribble_message()->::protos::DribbleMessage::MergeFrom(
          from._internal_dribble_message());
      break;
    }
    case kBallGoalieMessage: {
      _this->_internal_mutable_ball_goalie_message()->::protos::BallGoalieMessage::MergeFrom(
          from._internal_ball_goalie_message());
      break;
    }
    case kOnePlayerMessage: {
      _this->_internal_mutable_one_player_message()->::protos::OnePlayerMessage::MergeFrom(
          from._internal_one_player_message());
      break;
    }
    case kTwoPlayerMessage: {
      _this->_internal_mutable_two_player_message()->::protos::TwoPlayerMessage::MergeFrom(
          from._internal_two_player_message());
      break;
    }
    case kThreePlayerMessage: {
      _this->_internal_mutable_three_player_message()->::protos::ThreePlayerMessage::MergeFrom(
          from._internal_three_player_message());
      break;
    }
    case kSelfMessage: {
      _this->_internal_mutable_self_message()->::protos::SelfMessage::MergeFrom(
          from._internal_self_message());
      break;
    }
    case kTeammateMessage: {
      _this->_internal_mutable_teammate_message()->::protos::TeammateMessage::MergeFrom(
          from._internal_teammate_message());
      break;
    }
    case kOpponentMessage: {
      _this->_internal_mutable_opponent_message()->::protos::OpponentMessage::MergeFrom(
          from._internal_opponent_message());
      break;
    }
    case kBallPlayerMessage: {
      _this->_internal_mutable_ball_player_message()->::protos::BallPlayerMessage::MergeFrom(
          from._internal_ball_player_message());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Say::CopyFrom(const Say& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Say)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Say::IsInitialized() const {
  return true;
}

void Say::InternalSwap(Say* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.message_, other->_impl_.message_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Say::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[40]);
}
// ===================================================================

class PointTo::_Internal {
 public:
};

PointTo::PointTo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.PointTo)
}
PointTo::PointTo(const PointTo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.PointTo)
}

inline void PointTo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.x_) { 0 }

    , decltype(_impl_.y_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PointTo::~PointTo() {
  // @@protoc_insertion_point(destructor:protos.PointTo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PointTo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PointTo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PointTo::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.PointTo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PointTo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PointTo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.PointTo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.PointTo)
  return target;
}

::size_t PointTo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.PointTo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointTo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PointTo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointTo::GetClassData() const { return &_class_data_; }


void PointTo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PointTo*>(&to_msg);
  auto& from = static_cast<const PointTo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.PointTo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PointTo::CopyFrom(const PointTo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.PointTo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointTo::IsInitialized() const {
  return true;
}

void PointTo::InternalSwap(PointTo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PointTo, _impl_.y_)
      + sizeof(PointTo::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(PointTo, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PointTo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[41]);
}
// ===================================================================

class PointToOf::_Internal {
 public:
};

PointToOf::PointToOf(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.PointToOf)
}
PointToOf::PointToOf(const PointToOf& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  PointToOf* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.PointToOf)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointToOf::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointToOf::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata PointToOf::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[42]);
}
// ===================================================================

class AttentionTo::_Internal {
 public:
};

AttentionTo::AttentionTo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AttentionTo)
}
AttentionTo::AttentionTo(const AttentionTo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.AttentionTo)
}

inline void AttentionTo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.side_) { 0 }

    , decltype(_impl_.unum_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AttentionTo::~AttentionTo() {
  // @@protoc_insertion_point(destructor:protos.AttentionTo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AttentionTo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AttentionTo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AttentionTo::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AttentionTo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.side_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.unum_) -
      reinterpret_cast<char*>(&_impl_.side_)) + sizeof(_impl_.unum_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AttentionTo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Side side = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::protos::Side>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 unum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.unum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AttentionTo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AttentionTo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.Side side = 1;
  if (this->_internal_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_side(), target);
  }

  // int32 unum = 2;
  if (this->_internal_unum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_unum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AttentionTo)
  return target;
}

::size_t AttentionTo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AttentionTo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protos.Side side = 1;
  if (this->_internal_side() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  // int32 unum = 2;
  if (this->_internal_unum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_unum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AttentionTo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AttentionTo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AttentionTo::GetClassData() const { return &_class_data_; }


void AttentionTo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AttentionTo*>(&to_msg);
  auto& from = static_cast<const AttentionTo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AttentionTo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_side() != 0) {
    _this->_internal_set_side(from._internal_side());
  }
  if (from._internal_unum() != 0) {
    _this->_internal_set_unum(from._internal_unum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AttentionTo::CopyFrom(const AttentionTo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AttentionTo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AttentionTo::IsInitialized() const {
  return true;
}

void AttentionTo::InternalSwap(AttentionTo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AttentionTo, _impl_.unum_)
      + sizeof(AttentionTo::_impl_.unum_)
      - PROTOBUF_FIELD_OFFSET(AttentionTo, _impl_.side_)>(
          reinterpret_cast<char*>(&_impl_.side_),
          reinterpret_cast<char*>(&other->_impl_.side_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AttentionTo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[43]);
}
// ===================================================================

class AttentionToOf::_Internal {
 public:
};

AttentionToOf::AttentionToOf(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:protos.AttentionToOf)
}
AttentionToOf::AttentionToOf(const AttentionToOf& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  AttentionToOf* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.AttentionToOf)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AttentionToOf::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AttentionToOf::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata AttentionToOf::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[44]);
}
// ===================================================================

class AddText::_Internal {
 public:
};

AddText::AddText(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddText)
}
AddText::AddText(const AddText& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddText* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_) {}

    , decltype(_impl_.level_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), _this->GetArenaForAllocation());
  }
  _this->_impl_.level_ = from._impl_.level_;
  // @@protoc_insertion_point(copy_constructor:protos.AddText)
}

inline void AddText::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.message_) {}

    , decltype(_impl_.level_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddText::~AddText() {
  // @@protoc_insertion_point(destructor:protos.AddText)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddText::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void AddText::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddText::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddText)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _impl_.level_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddText::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddText.message"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddText::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddText)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  // string message = 2;
  if (!this->_internal_message().empty()) {
    const std::string& _s = this->_internal_message();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddText.message");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddText)
  return target;
}

::size_t AddText::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddText)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 2;
  if (!this->_internal_message().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddText::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddText::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddText::GetClassData() const { return &_class_data_; }


void AddText::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddText*>(&to_msg);
  auto& from = static_cast<const AddText&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddText)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddText::CopyFrom(const AddText& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddText)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddText::IsInitialized() const {
  return true;
}

void AddText::InternalSwap(AddText* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, lhs_arena,
                                       &other->_impl_.message_, rhs_arena);
  swap(_impl_.level_, other->_impl_.level_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AddText::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[45]);
}
// ===================================================================

class AddPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<AddPoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AddPoint, _impl_._has_bits_);
  static const ::protos::Vector2D& point(const AddPoint* msg);
  static void set_has_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
AddPoint::_Internal::point(const AddPoint* msg) {
  return *msg->_impl_.point_;
}
AddPoint::AddPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddPoint)
}
AddPoint::AddPoint(const AddPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.level_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.point_ = new ::protos::Vector2D(*from._impl_.point_);
  }
  _this->_impl_.level_ = from._impl_.level_;
  // @@protoc_insertion_point(copy_constructor:protos.AddPoint)
}

inline void AddPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.level_) { 0 }

  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddPoint::~AddPoint() {
  // @@protoc_insertion_point(destructor:protos.AddPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
  if (this != internal_default_instance()) delete _impl_.point_;
}

void AddPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.point_ != nullptr);
    _impl_.point_->Clear();
  }
  _impl_.level_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string color = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddPoint.color"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D point = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::point(this),
        _Internal::point(this).GetCachedSize(), target, stream);
  }

  // string color = 3;
  if (!this->_internal_color().empty()) {
    const std::string& _s = this->_internal_color();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddPoint.color");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddPoint)
  return target;
}

::size_t AddPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 3;
  if (!this->_internal_color().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_color());
  }

  // .protos.Vector2D point = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.point_);
  }

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddPoint::GetClassData() const { return &_class_data_; }


void AddPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddPoint*>(&to_msg);
  auto& from = static_cast<const AddPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_point()->::protos::Vector2D::MergeFrom(
        from._internal_point());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddPoint::CopyFrom(const AddPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddPoint::IsInitialized() const {
  return true;
}

void AddPoint::InternalSwap(AddPoint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_, lhs_arena,
                                       &other->_impl_.color_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddPoint, _impl_.level_)
      + sizeof(AddPoint::_impl_.level_)
      - PROTOBUF_FIELD_OFFSET(AddPoint, _impl_.point_)>(
          reinterpret_cast<char*>(&_impl_.point_),
          reinterpret_cast<char*>(&other->_impl_.point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[46]);
}
// ===================================================================

class AddLine::_Internal {
 public:
  using HasBits = decltype(std::declval<AddLine>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AddLine, _impl_._has_bits_);
  static const ::protos::Vector2D& start(const AddLine* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& end(const AddLine* msg);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::protos::Vector2D&
AddLine::_Internal::start(const AddLine* msg) {
  return *msg->_impl_.start_;
}
const ::protos::Vector2D&
AddLine::_Internal::end(const AddLine* msg) {
  return *msg->_impl_.end_;
}
AddLine::AddLine(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddLine)
}
AddLine::AddLine(const AddLine& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddLine* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , decltype(_impl_.level_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.start_ = new ::protos::Vector2D(*from._impl_.start_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.end_ = new ::protos::Vector2D(*from._impl_.end_);
  }
  _this->_impl_.level_ = from._impl_.level_;
  // @@protoc_insertion_point(copy_constructor:protos.AddLine)
}

inline void AddLine::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , decltype(_impl_.level_) { 0 }

  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddLine::~AddLine() {
  // @@protoc_insertion_point(destructor:protos.AddLine)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddLine::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.end_;
}

void AddLine::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddLine::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddLine)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.start_ != nullptr);
      _impl_.start_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.end_ != nullptr);
      _impl_.end_->Clear();
    }
  }
  _impl_.level_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddLine::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D end = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string color = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddLine.color"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddLine::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddLine)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D start = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D end = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::end(this),
        _Internal::end(this).GetCachedSize(), target, stream);
  }

  // string color = 4;
  if (!this->_internal_color().empty()) {
    const std::string& _s = this->_internal_color();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddLine.color");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddLine)
  return target;
}

::size_t AddLine::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddLine)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 4;
  if (!this->_internal_color().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_color());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .protos.Vector2D start = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.start_);
    }

    // .protos.Vector2D end = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.end_);
    }

  }
  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddLine::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddLine::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddLine::GetClassData() const { return &_class_data_; }


void AddLine::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddLine*>(&to_msg);
  auto& from = static_cast<const AddLine&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddLine)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_start()->::protos::Vector2D::MergeFrom(
          from._internal_start());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_end()->::protos::Vector2D::MergeFrom(
          from._internal_end());
    }
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddLine::CopyFrom(const AddLine& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddLine)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddLine::IsInitialized() const {
  return true;
}

void AddLine::InternalSwap(AddLine* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_, lhs_arena,
                                       &other->_impl_.color_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddLine, _impl_.level_)
      + sizeof(AddLine::_impl_.level_)
      - PROTOBUF_FIELD_OFFSET(AddLine, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddLine::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[47]);
}
// ===================================================================

class AddArc::_Internal {
 public:
  using HasBits = decltype(std::declval<AddArc>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AddArc, _impl_._has_bits_);
  static const ::protos::Vector2D& center(const AddArc* msg);
  static void set_has_center(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
AddArc::_Internal::center(const AddArc* msg) {
  return *msg->_impl_.center_;
}
AddArc::AddArc(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddArc)
}
AddArc::AddArc(const AddArc& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddArc* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.center_){nullptr}
    , decltype(_impl_.level_) {}

    , decltype(_impl_.radius_) {}

    , decltype(_impl_.start_angle_) {}

    , decltype(_impl_.span_angel_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.center_ = new ::protos::Vector2D(*from._impl_.center_);
  }
  ::memcpy(&_impl_.level_, &from._impl_.level_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.span_angel_) -
    reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.span_angel_));
  // @@protoc_insertion_point(copy_constructor:protos.AddArc)
}

inline void AddArc::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.center_){nullptr}
    , decltype(_impl_.level_) { 0 }

    , decltype(_impl_.radius_) { 0 }

    , decltype(_impl_.start_angle_) { 0 }

    , decltype(_impl_.span_angel_) { 0 }

  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddArc::~AddArc() {
  // @@protoc_insertion_point(destructor:protos.AddArc)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddArc::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
  if (this != internal_default_instance()) delete _impl_.center_;
}

void AddArc::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddArc::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddArc)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.center_ != nullptr);
    _impl_.center_->Clear();
  }
  ::memset(&_impl_.level_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.span_angel_) -
      reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.span_angel_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddArc::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D center = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_center(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float radius = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float start_angle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.start_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float span_angel = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.span_angel_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // string color = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddArc.color"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddArc::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddArc)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D center = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::center(this),
        _Internal::center(this).GetCachedSize(), target, stream);
  }

  // float radius = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  ::uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_radius(), target);
  }

  // float start_angle = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_angle = this->_internal_start_angle();
  ::uint32_t raw_start_angle;
  memcpy(&raw_start_angle, &tmp_start_angle, sizeof(tmp_start_angle));
  if (raw_start_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_start_angle(), target);
  }

  // float span_angel = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_span_angel = this->_internal_span_angel();
  ::uint32_t raw_span_angel;
  memcpy(&raw_span_angel, &tmp_span_angel, sizeof(tmp_span_angel));
  if (raw_span_angel != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_span_angel(), target);
  }

  // string color = 6;
  if (!this->_internal_color().empty()) {
    const std::string& _s = this->_internal_color();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddArc.color");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddArc)
  return target;
}

::size_t AddArc::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddArc)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 6;
  if (!this->_internal_color().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_color());
  }

  // .protos.Vector2D center = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.center_);
  }

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  // float radius = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  ::uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    total_size += 5;
  }

  // float start_angle = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_angle = this->_internal_start_angle();
  ::uint32_t raw_start_angle;
  memcpy(&raw_start_angle, &tmp_start_angle, sizeof(tmp_start_angle));
  if (raw_start_angle != 0) {
    total_size += 5;
  }

  // float span_angel = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_span_angel = this->_internal_span_angel();
  ::uint32_t raw_span_angel;
  memcpy(&raw_span_angel, &tmp_span_angel, sizeof(tmp_span_angel));
  if (raw_span_angel != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddArc::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddArc::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddArc::GetClassData() const { return &_class_data_; }


void AddArc::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddArc*>(&to_msg);
  auto& from = static_cast<const AddArc&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddArc)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_center()->::protos::Vector2D::MergeFrom(
        from._internal_center());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_radius = from._internal_radius();
  ::uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    _this->_internal_set_radius(from._internal_radius());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_angle = from._internal_start_angle();
  ::uint32_t raw_start_angle;
  memcpy(&raw_start_angle, &tmp_start_angle, sizeof(tmp_start_angle));
  if (raw_start_angle != 0) {
    _this->_internal_set_start_angle(from._internal_start_angle());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_span_angel = from._internal_span_angel();
  ::uint32_t raw_span_angel;
  memcpy(&raw_span_angel, &tmp_span_angel, sizeof(tmp_span_angel));
  if (raw_span_angel != 0) {
    _this->_internal_set_span_angel(from._internal_span_angel());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddArc::CopyFrom(const AddArc& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddArc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddArc::IsInitialized() const {
  return true;
}

void AddArc::InternalSwap(AddArc* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_, lhs_arena,
                                       &other->_impl_.color_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddArc, _impl_.span_angel_)
      + sizeof(AddArc::_impl_.span_angel_)
      - PROTOBUF_FIELD_OFFSET(AddArc, _impl_.center_)>(
          reinterpret_cast<char*>(&_impl_.center_),
          reinterpret_cast<char*>(&other->_impl_.center_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddArc::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[48]);
}
// ===================================================================

class AddCircle::_Internal {
 public:
  using HasBits = decltype(std::declval<AddCircle>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AddCircle, _impl_._has_bits_);
  static const ::protos::Vector2D& center(const AddCircle* msg);
  static void set_has_center(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
AddCircle::_Internal::center(const AddCircle* msg) {
  return *msg->_impl_.center_;
}
AddCircle::AddCircle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddCircle)
}
AddCircle::AddCircle(const AddCircle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddCircle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.center_){nullptr}
    , decltype(_impl_.level_) {}

    , decltype(_impl_.radius_) {}

    , decltype(_impl_.fill_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.center_ = new ::protos::Vector2D(*from._impl_.center_);
  }
  ::memcpy(&_impl_.level_, &from._impl_.level_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.fill_) -
    reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.fill_));
  // @@protoc_insertion_point(copy_constructor:protos.AddCircle)
}

inline void AddCircle::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.center_){nullptr}
    , decltype(_impl_.level_) { 0 }

    , decltype(_impl_.radius_) { 0 }

    , decltype(_impl_.fill_) { false }

  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddCircle::~AddCircle() {
  // @@protoc_insertion_point(destructor:protos.AddCircle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddCircle::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
  if (this != internal_default_instance()) delete _impl_.center_;
}

void AddCircle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddCircle::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddCircle)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.center_ != nullptr);
    _impl_.center_->Clear();
  }
  ::memset(&_impl_.level_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.fill_) -
      reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.fill_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddCircle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D center = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_center(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float radius = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // string color = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddCircle.color"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool fill = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.fill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddCircle::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddCircle)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D center = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::center(this),
        _Internal::center(this).GetCachedSize(), target, stream);
  }

  // float radius = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  ::uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_radius(), target);
  }

  // string color = 4;
  if (!this->_internal_color().empty()) {
    const std::string& _s = this->_internal_color();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddCircle.color");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // bool fill = 5;
  if (this->_internal_fill() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_fill(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddCircle)
  return target;
}

::size_t AddCircle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddCircle)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 4;
  if (!this->_internal_color().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_color());
  }

  // .protos.Vector2D center = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.center_);
  }

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  // float radius = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  ::uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    total_size += 5;
  }

  // bool fill = 5;
  if (this->_internal_fill() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddCircle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddCircle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddCircle::GetClassData() const { return &_class_data_; }


void AddCircle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddCircle*>(&to_msg);
  auto& from = static_cast<const AddCircle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddCircle)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_center()->::protos::Vector2D::MergeFrom(
        from._internal_center());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_radius = from._internal_radius();
  ::uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    _this->_internal_set_radius(from._internal_radius());
  }
  if (from._internal_fill() != 0) {
    _this->_internal_set_fill(from._internal_fill());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddCircle::CopyFrom(const AddCircle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddCircle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddCircle::IsInitialized() const {
  return true;
}

void AddCircle::InternalSwap(AddCircle* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_, lhs_arena,
                                       &other->_impl_.color_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddCircle, _impl_.fill_)
      + sizeof(AddCircle::_impl_.fill_)
      - PROTOBUF_FIELD_OFFSET(AddCircle, _impl_.center_)>(
          reinterpret_cast<char*>(&_impl_.center_),
          reinterpret_cast<char*>(&other->_impl_.center_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddCircle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[49]);
}
// ===================================================================

class AddTriangle::_Internal {
 public:
  using HasBits = decltype(std::declval<AddTriangle>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AddTriangle, _impl_._has_bits_);
  static const ::protos::Vector2D& point1(const AddTriangle* msg);
  static void set_has_point1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::protos::Vector2D& point2(const AddTriangle* msg);
  static void set_has_point2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::protos::Vector2D& point3(const AddTriangle* msg);
  static void set_has_point3(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::protos::Vector2D&
AddTriangle::_Internal::point1(const AddTriangle* msg) {
  return *msg->_impl_.point1_;
}
const ::protos::Vector2D&
AddTriangle::_Internal::point2(const AddTriangle* msg) {
  return *msg->_impl_.point2_;
}
const ::protos::Vector2D&
AddTriangle::_Internal::point3(const AddTriangle* msg) {
  return *msg->_impl_.point3_;
}
AddTriangle::AddTriangle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddTriangle)
}
AddTriangle::AddTriangle(const AddTriangle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddTriangle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.point1_){nullptr}
    , decltype(_impl_.point2_){nullptr}
    , decltype(_impl_.point3_){nullptr}
    , decltype(_impl_.level_) {}

    , decltype(_impl_.fill_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.point1_ = new ::protos::Vector2D(*from._impl_.point1_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.point2_ = new ::protos::Vector2D(*from._impl_.point2_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.point3_ = new ::protos::Vector2D(*from._impl_.point3_);
  }
  ::memcpy(&_impl_.level_, &from._impl_.level_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.fill_) -
    reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.fill_));
  // @@protoc_insertion_point(copy_constructor:protos.AddTriangle)
}

inline void AddTriangle::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.point1_){nullptr}
    , decltype(_impl_.point2_){nullptr}
    , decltype(_impl_.point3_){nullptr}
    , decltype(_impl_.level_) { 0 }

    , decltype(_impl_.fill_) { false }

  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddTriangle::~AddTriangle() {
  // @@protoc_insertion_point(destructor:protos.AddTriangle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddTriangle::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
  if (this != internal_default_instance()) delete _impl_.point1_;
  if (this != internal_default_instance()) delete _impl_.point2_;
  if (this != internal_default_instance()) delete _impl_.point3_;
}

void AddTriangle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddTriangle::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddTriangle)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.point1_ != nullptr);
      _impl_.point1_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.point2_ != nullptr);
      _impl_.point2_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.point3_ != nullptr);
      _impl_.point3_->Clear();
    }
  }
  ::memset(&_impl_.level_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.fill_) -
      reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.fill_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddTriangle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D point1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_point1(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D point2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_point2(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D point3 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_point3(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string color = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddTriangle.color"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool fill = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.fill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddTriangle::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddTriangle)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D point1 = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::point1(this),
        _Internal::point1(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D point2 = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::point2(this),
        _Internal::point2(this).GetCachedSize(), target, stream);
  }

  // .protos.Vector2D point3 = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::point3(this),
        _Internal::point3(this).GetCachedSize(), target, stream);
  }

  // string color = 5;
  if (!this->_internal_color().empty()) {
    const std::string& _s = this->_internal_color();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddTriangle.color");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // bool fill = 6;
  if (this->_internal_fill() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_fill(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddTriangle)
  return target;
}

::size_t AddTriangle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddTriangle)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 5;
  if (!this->_internal_color().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_color());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .protos.Vector2D point1 = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.point1_);
    }

    // .protos.Vector2D point2 = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.point2_);
    }

    // .protos.Vector2D point3 = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.point3_);
    }

  }
  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  // bool fill = 6;
  if (this->_internal_fill() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddTriangle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddTriangle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddTriangle::GetClassData() const { return &_class_data_; }


void AddTriangle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddTriangle*>(&to_msg);
  auto& from = static_cast<const AddTriangle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddTriangle)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_point1()->::protos::Vector2D::MergeFrom(
          from._internal_point1());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_point2()->::protos::Vector2D::MergeFrom(
          from._internal_point2());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_point3()->::protos::Vector2D::MergeFrom(
          from._internal_point3());
    }
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  if (from._internal_fill() != 0) {
    _this->_internal_set_fill(from._internal_fill());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddTriangle::CopyFrom(const AddTriangle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddTriangle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddTriangle::IsInitialized() const {
  return true;
}

void AddTriangle::InternalSwap(AddTriangle* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_, lhs_arena,
                                       &other->_impl_.color_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddTriangle, _impl_.fill_)
      + sizeof(AddTriangle::_impl_.fill_)
      - PROTOBUF_FIELD_OFFSET(AddTriangle, _impl_.point1_)>(
          reinterpret_cast<char*>(&_impl_.point1_),
          reinterpret_cast<char*>(&other->_impl_.point1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddTriangle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[50]);
}
// ===================================================================

class AddRectangle::_Internal {
 public:
};

AddRectangle::AddRectangle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddRectangle)
}
AddRectangle::AddRectangle(const AddRectangle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddRectangle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.color_) {}

    , decltype(_impl_.level_) {}

    , decltype(_impl_.left_) {}

    , decltype(_impl_.top_) {}

    , decltype(_impl_.length_) {}

    , decltype(_impl_.width_) {}

    , decltype(_impl_.fill_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.level_, &from._impl_.level_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.fill_) -
    reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.fill_));
  // @@protoc_insertion_point(copy_constructor:protos.AddRectangle)
}

inline void AddRectangle::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.color_) {}

    , decltype(_impl_.level_) { 0 }

    , decltype(_impl_.left_) { 0 }

    , decltype(_impl_.top_) { 0 }

    , decltype(_impl_.length_) { 0 }

    , decltype(_impl_.width_) { 0 }

    , decltype(_impl_.fill_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddRectangle::~AddRectangle() {
  // @@protoc_insertion_point(destructor:protos.AddRectangle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddRectangle::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
}

void AddRectangle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddRectangle::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddRectangle)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  ::memset(&_impl_.level_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.fill_) -
      reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.fill_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddRectangle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // float left = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.left_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float top = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.top_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float width = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // string color = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddRectangle.color"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool fill = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.fill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddRectangle::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddRectangle)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  // float left = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_left = this->_internal_left();
  ::uint32_t raw_left;
  memcpy(&raw_left, &tmp_left, sizeof(tmp_left));
  if (raw_left != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_left(), target);
  }

  // float top = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_top = this->_internal_top();
  ::uint32_t raw_top;
  memcpy(&raw_top, &tmp_top, sizeof(tmp_top));
  if (raw_top != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_top(), target);
  }

  // float length = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_length = this->_internal_length();
  ::uint32_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_length(), target);
  }

  // float width = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_width = this->_internal_width();
  ::uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_width(), target);
  }

  // string color = 6;
  if (!this->_internal_color().empty()) {
    const std::string& _s = this->_internal_color();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddRectangle.color");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // bool fill = 7;
  if (this->_internal_fill() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_fill(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddRectangle)
  return target;
}

::size_t AddRectangle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddRectangle)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 6;
  if (!this->_internal_color().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_color());
  }

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  // float left = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_left = this->_internal_left();
  ::uint32_t raw_left;
  memcpy(&raw_left, &tmp_left, sizeof(tmp_left));
  if (raw_left != 0) {
    total_size += 5;
  }

  // float top = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_top = this->_internal_top();
  ::uint32_t raw_top;
  memcpy(&raw_top, &tmp_top, sizeof(tmp_top));
  if (raw_top != 0) {
    total_size += 5;
  }

  // float length = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_length = this->_internal_length();
  ::uint32_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    total_size += 5;
  }

  // float width = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_width = this->_internal_width();
  ::uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    total_size += 5;
  }

  // bool fill = 7;
  if (this->_internal_fill() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddRectangle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddRectangle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddRectangle::GetClassData() const { return &_class_data_; }


void AddRectangle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddRectangle*>(&to_msg);
  auto& from = static_cast<const AddRectangle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddRectangle)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_left = from._internal_left();
  ::uint32_t raw_left;
  memcpy(&raw_left, &tmp_left, sizeof(tmp_left));
  if (raw_left != 0) {
    _this->_internal_set_left(from._internal_left());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_top = from._internal_top();
  ::uint32_t raw_top;
  memcpy(&raw_top, &tmp_top, sizeof(tmp_top));
  if (raw_top != 0) {
    _this->_internal_set_top(from._internal_top());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_length = from._internal_length();
  ::uint32_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    _this->_internal_set_length(from._internal_length());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_width = from._internal_width();
  ::uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  if (from._internal_fill() != 0) {
    _this->_internal_set_fill(from._internal_fill());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddRectangle::CopyFrom(const AddRectangle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddRectangle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddRectangle::IsInitialized() const {
  return true;
}

void AddRectangle::InternalSwap(AddRectangle* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_, lhs_arena,
                                       &other->_impl_.color_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddRectangle, _impl_.fill_)
      + sizeof(AddRectangle::_impl_.fill_)
      - PROTOBUF_FIELD_OFFSET(AddRectangle, _impl_.level_)>(
          reinterpret_cast<char*>(&_impl_.level_),
          reinterpret_cast<char*>(&other->_impl_.level_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddRectangle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[51]);
}
// ===================================================================

class AddSector::_Internal {
 public:
  using HasBits = decltype(std::declval<AddSector>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AddSector, _impl_._has_bits_);
  static const ::protos::Vector2D& center(const AddSector* msg);
  static void set_has_center(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
AddSector::_Internal::center(const AddSector* msg) {
  return *msg->_impl_.center_;
}
AddSector::AddSector(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddSector)
}
AddSector::AddSector(const AddSector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddSector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.center_){nullptr}
    , decltype(_impl_.level_) {}

    , decltype(_impl_.min_radius_) {}

    , decltype(_impl_.max_radius_) {}

    , decltype(_impl_.start_angle_) {}

    , decltype(_impl_.span_angel_) {}

    , decltype(_impl_.fill_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.center_ = new ::protos::Vector2D(*from._impl_.center_);
  }
  ::memcpy(&_impl_.level_, &from._impl_.level_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.fill_) -
    reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.fill_));
  // @@protoc_insertion_point(copy_constructor:protos.AddSector)
}

inline void AddSector::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_) {}

    , decltype(_impl_.center_){nullptr}
    , decltype(_impl_.level_) { 0 }

    , decltype(_impl_.min_radius_) { 0 }

    , decltype(_impl_.max_radius_) { 0 }

    , decltype(_impl_.start_angle_) { 0 }

    , decltype(_impl_.span_angel_) { 0 }

    , decltype(_impl_.fill_) { false }

  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddSector::~AddSector() {
  // @@protoc_insertion_point(destructor:protos.AddSector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddSector::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
  if (this != internal_default_instance()) delete _impl_.center_;
}

void AddSector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddSector::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddSector)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.center_ != nullptr);
    _impl_.center_->Clear();
  }
  ::memset(&_impl_.level_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.fill_) -
      reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.fill_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddSector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D center = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_center(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float min_radius = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.min_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float max_radius = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.max_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float start_angle = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.start_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float span_angel = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 53)) {
          _impl_.span_angel_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // string color = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddSector.color"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool fill = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.fill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddSector::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddSector)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D center = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::center(this),
        _Internal::center(this).GetCachedSize(), target, stream);
  }

  // float min_radius = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_radius = this->_internal_min_radius();
  ::uint32_t raw_min_radius;
  memcpy(&raw_min_radius, &tmp_min_radius, sizeof(tmp_min_radius));
  if (raw_min_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_min_radius(), target);
  }

  // float max_radius = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_radius = this->_internal_max_radius();
  ::uint32_t raw_max_radius;
  memcpy(&raw_max_radius, &tmp_max_radius, sizeof(tmp_max_radius));
  if (raw_max_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_max_radius(), target);
  }

  // float start_angle = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_angle = this->_internal_start_angle();
  ::uint32_t raw_start_angle;
  memcpy(&raw_start_angle, &tmp_start_angle, sizeof(tmp_start_angle));
  if (raw_start_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_start_angle(), target);
  }

  // float span_angel = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_span_angel = this->_internal_span_angel();
  ::uint32_t raw_span_angel;
  memcpy(&raw_span_angel, &tmp_span_angel, sizeof(tmp_span_angel));
  if (raw_span_angel != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_span_angel(), target);
  }

  // string color = 7;
  if (!this->_internal_color().empty()) {
    const std::string& _s = this->_internal_color();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddSector.color");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // bool fill = 8;
  if (this->_internal_fill() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_fill(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddSector)
  return target;
}

::size_t AddSector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddSector)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 7;
  if (!this->_internal_color().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_color());
  }

  // .protos.Vector2D center = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.center_);
  }

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  // float min_radius = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_radius = this->_internal_min_radius();
  ::uint32_t raw_min_radius;
  memcpy(&raw_min_radius, &tmp_min_radius, sizeof(tmp_min_radius));
  if (raw_min_radius != 0) {
    total_size += 5;
  }

  // float max_radius = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_radius = this->_internal_max_radius();
  ::uint32_t raw_max_radius;
  memcpy(&raw_max_radius, &tmp_max_radius, sizeof(tmp_max_radius));
  if (raw_max_radius != 0) {
    total_size += 5;
  }

  // float start_angle = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_angle = this->_internal_start_angle();
  ::uint32_t raw_start_angle;
  memcpy(&raw_start_angle, &tmp_start_angle, sizeof(tmp_start_angle));
  if (raw_start_angle != 0) {
    total_size += 5;
  }

  // float span_angel = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_span_angel = this->_internal_span_angel();
  ::uint32_t raw_span_angel;
  memcpy(&raw_span_angel, &tmp_span_angel, sizeof(tmp_span_angel));
  if (raw_span_angel != 0) {
    total_size += 5;
  }

  // bool fill = 8;
  if (this->_internal_fill() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddSector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddSector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddSector::GetClassData() const { return &_class_data_; }


void AddSector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddSector*>(&to_msg);
  auto& from = static_cast<const AddSector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddSector)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_center()->::protos::Vector2D::MergeFrom(
        from._internal_center());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_min_radius = from._internal_min_radius();
  ::uint32_t raw_min_radius;
  memcpy(&raw_min_radius, &tmp_min_radius, sizeof(tmp_min_radius));
  if (raw_min_radius != 0) {
    _this->_internal_set_min_radius(from._internal_min_radius());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_max_radius = from._internal_max_radius();
  ::uint32_t raw_max_radius;
  memcpy(&raw_max_radius, &tmp_max_radius, sizeof(tmp_max_radius));
  if (raw_max_radius != 0) {
    _this->_internal_set_max_radius(from._internal_max_radius());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_start_angle = from._internal_start_angle();
  ::uint32_t raw_start_angle;
  memcpy(&raw_start_angle, &tmp_start_angle, sizeof(tmp_start_angle));
  if (raw_start_angle != 0) {
    _this->_internal_set_start_angle(from._internal_start_angle());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_span_angel = from._internal_span_angel();
  ::uint32_t raw_span_angel;
  memcpy(&raw_span_angel, &tmp_span_angel, sizeof(tmp_span_angel));
  if (raw_span_angel != 0) {
    _this->_internal_set_span_angel(from._internal_span_angel());
  }
  if (from._internal_fill() != 0) {
    _this->_internal_set_fill(from._internal_fill());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddSector::CopyFrom(const AddSector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddSector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddSector::IsInitialized() const {
  return true;
}

void AddSector::InternalSwap(AddSector* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_, lhs_arena,
                                       &other->_impl_.color_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddSector, _impl_.fill_)
      + sizeof(AddSector::_impl_.fill_)
      - PROTOBUF_FIELD_OFFSET(AddSector, _impl_.center_)>(
          reinterpret_cast<char*>(&_impl_.center_),
          reinterpret_cast<char*>(&other->_impl_.center_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddSector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[52]);
}
// ===================================================================

class AddMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AddMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AddMessage, _impl_._has_bits_);
  static const ::protos::Vector2D& position(const AddMessage* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::protos::Vector2D&
AddMessage::_Internal::position(const AddMessage* msg) {
  return *msg->_impl_.position_;
}
AddMessage::AddMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.AddMessage)
}
AddMessage::AddMessage(const AddMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_) {}

    , decltype(_impl_.color_) {}

    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.level_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), _this->GetArenaForAllocation());
  }
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::protos::Vector2D(*from._impl_.position_);
  }
  _this->_impl_.level_ = from._impl_.level_;
  // @@protoc_insertion_point(copy_constructor:protos.AddMessage)
}

inline void AddMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_) {}

    , decltype(_impl_.color_) {}

    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.level_) { 0 }

  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.color_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddMessage::~AddMessage() {
  // @@protoc_insertion_point(destructor:protos.AddMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
  _impl_.color_.Destroy();
  if (this != internal_default_instance()) delete _impl_.position_;
}

void AddMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.AddMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _impl_.color_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  _impl_.level_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.LoggerLevel level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::protos::LoggerLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Vector2D position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddMessage.message"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string color = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.AddMessage.color"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.AddMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_level(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .protos.Vector2D position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // string message = 3;
  if (!this->_internal_message().empty()) {
    const std::string& _s = this->_internal_message();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddMessage.message");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string color = 4;
  if (!this->_internal_color().empty()) {
    const std::string& _s = this->_internal_color();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.AddMessage.color");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.AddMessage)
  return target;
}

::size_t AddMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.AddMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 3;
  if (!this->_internal_message().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  // string color = 4;
  if (!this->_internal_color().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_color());
  }

  // .protos.Vector2D position = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // .protos.LoggerLevel level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddMessage::GetClassData() const { return &_class_data_; }


void AddMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddMessage*>(&to_msg);
  auto& from = static_cast<const AddMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.AddMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_position()->::protos::Vector2D::MergeFrom(
        from._internal_position());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddMessage::CopyFrom(const AddMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.AddMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddMessage::IsInitialized() const {
  return true;
}

void AddMessage::InternalSwap(AddMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, lhs_arena,
                                       &other->_impl_.message_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_, lhs_arena,
                                       &other->_impl_.color_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddMessage, _impl_.level_)
      + sizeof(AddMessage::_impl_.level_)
      - PROTOBUF_FIELD_OFFSET(AddMessage, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[53]);
}
// ===================================================================

class Log::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::protos::Log, _impl_._oneof_case_);
  static const ::protos::AddText& add_text(const Log* msg);
  static const ::protos::AddPoint& add_point(const Log* msg);
  static const ::protos::AddLine& add_line(const Log* msg);
  static const ::protos::AddArc& add_arc(const Log* msg);
  static const ::protos::AddCircle& add_circle(const Log* msg);
  static const ::protos::AddTriangle& add_triangle(const Log* msg);
  static const ::protos::AddRectangle& add_rectangle(const Log* msg);
  static const ::protos::AddSector& add_sector(const Log* msg);
  static const ::protos::AddMessage& add_message(const Log* msg);
};

const ::protos::AddText&
Log::_Internal::add_text(const Log* msg) {
  return *msg->_impl_.log_.add_text_;
}
const ::protos::AddPoint&
Log::_Internal::add_point(const Log* msg) {
  return *msg->_impl_.log_.add_point_;
}
const ::protos::AddLine&
Log::_Internal::add_line(const Log* msg) {
  return *msg->_impl_.log_.add_line_;
}
const ::protos::AddArc&
Log::_Internal::add_arc(const Log* msg) {
  return *msg->_impl_.log_.add_arc_;
}
const ::protos::AddCircle&
Log::_Internal::add_circle(const Log* msg) {
  return *msg->_impl_.log_.add_circle_;
}
const ::protos::AddTriangle&
Log::_Internal::add_triangle(const Log* msg) {
  return *msg->_impl_.log_.add_triangle_;
}
const ::protos::AddRectangle&
Log::_Internal::add_rectangle(const Log* msg) {
  return *msg->_impl_.log_.add_rectangle_;
}
const ::protos::AddSector&
Log::_Internal::add_sector(const Log* msg) {
  return *msg->_impl_.log_.add_sector_;
}
const ::protos::AddMessage&
Log::_Internal::add_message(const Log* msg) {
  return *msg->_impl_.log_.add_message_;
}
void Log::set_allocated_add_text(::protos::AddText* add_text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_text);
    if (message_arena != submessage_arena) {
      add_text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_text, submessage_arena);
    }
    set_has_add_text();
    _impl_.log_.add_text_ = add_text;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_text)
}
void Log::set_allocated_add_point(::protos::AddPoint* add_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_point);
    if (message_arena != submessage_arena) {
      add_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_point, submessage_arena);
    }
    set_has_add_point();
    _impl_.log_.add_point_ = add_point;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_point)
}
void Log::set_allocated_add_line(::protos::AddLine* add_line) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_line) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_line);
    if (message_arena != submessage_arena) {
      add_line = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_line, submessage_arena);
    }
    set_has_add_line();
    _impl_.log_.add_line_ = add_line;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_line)
}
void Log::set_allocated_add_arc(::protos::AddArc* add_arc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_arc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_arc);
    if (message_arena != submessage_arena) {
      add_arc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_arc, submessage_arena);
    }
    set_has_add_arc();
    _impl_.log_.add_arc_ = add_arc;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_arc)
}
void Log::set_allocated_add_circle(::protos::AddCircle* add_circle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_circle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_circle);
    if (message_arena != submessage_arena) {
      add_circle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_circle, submessage_arena);
    }
    set_has_add_circle();
    _impl_.log_.add_circle_ = add_circle;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_circle)
}
void Log::set_allocated_add_triangle(::protos::AddTriangle* add_triangle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_triangle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_triangle);
    if (message_arena != submessage_arena) {
      add_triangle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_triangle, submessage_arena);
    }
    set_has_add_triangle();
    _impl_.log_.add_triangle_ = add_triangle;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_triangle)
}
void Log::set_allocated_add_rectangle(::protos::AddRectangle* add_rectangle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_rectangle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_rectangle);
    if (message_arena != submessage_arena) {
      add_rectangle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_rectangle, submessage_arena);
    }
    set_has_add_rectangle();
    _impl_.log_.add_rectangle_ = add_rectangle;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_rectangle)
}
void Log::set_allocated_add_sector(::protos::AddSector* add_sector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_sector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_sector);
    if (message_arena != submessage_arena) {
      add_sector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_sector, submessage_arena);
    }
    set_has_add_sector();
    _impl_.log_.add_sector_ = add_sector;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_sector)
}
void Log::set_allocated_add_message(::protos::AddMessage* add_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_log();
  if (add_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(add_message);
    if (message_arena != submessage_arena) {
      add_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_message, submessage_arena);
    }
    set_has_add_message();
    _impl_.log_.add_message_ = add_message;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Log.add_message)
}
Log::Log(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Log)
}
Log::Log(const Log& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Log* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.log_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_log();
  switch (from.log_case()) {
    case kAddText: {
      _this->_internal_mutable_add_text()->::protos::AddText::MergeFrom(
          from._internal_add_text());
      break;
    }
    case kAddPoint: {
      _this->_internal_mutable_add_point()->::protos::AddPoint::MergeFrom(
          from._internal_add_point());
      break;
    }
    case kAddLine: {
      _this->_internal_mutable_add_line()->::protos::AddLine::MergeFrom(
          from._internal_add_line());
      break;
    }
    case kAddArc: {
      _this->_internal_mutable_add_arc()->::protos::AddArc::MergeFrom(
          from._internal_add_arc());
      break;
    }
    case kAddCircle: {
      _this->_internal_mutable_add_circle()->::protos::AddCircle::MergeFrom(
          from._internal_add_circle());
      break;
    }
    case kAddTriangle: {
      _this->_internal_mutable_add_triangle()->::protos::AddTriangle::MergeFrom(
          from._internal_add_triangle());
      break;
    }
    case kAddRectangle: {
      _this->_internal_mutable_add_rectangle()->::protos::AddRectangle::MergeFrom(
          from._internal_add_rectangle());
      break;
    }
    case kAddSector: {
      _this->_internal_mutable_add_sector()->::protos::AddSector::MergeFrom(
          from._internal_add_sector());
      break;
    }
    case kAddMessage: {
      _this->_internal_mutable_add_message()->::protos::AddMessage::MergeFrom(
          from._internal_add_message());
      break;
    }
    case LOG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:protos.Log)
}

inline void Log::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.log_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_log();
}

Log::~Log() {
  // @@protoc_insertion_point(destructor:protos.Log)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Log::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_log()) {
    clear_log();
  }
}

void Log::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Log::clear_log() {
// @@protoc_insertion_point(one_of_clear_start:protos.Log)
  switch (log_case()) {
    case kAddText: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_text_;
      }
      break;
    }
    case kAddPoint: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_point_;
      }
      break;
    }
    case kAddLine: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_line_;
      }
      break;
    }
    case kAddArc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_arc_;
      }
      break;
    }
    case kAddCircle: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_circle_;
      }
      break;
    }
    case kAddTriangle: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_triangle_;
      }
      break;
    }
    case kAddRectangle: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_rectangle_;
      }
      break;
    }
    case kAddSector: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_sector_;
      }
      break;
    }
    case kAddMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.log_.add_message_;
      }
      break;
    }
    case LOG_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LOG_NOT_SET;
}


void Log::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Log)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_log();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Log::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.AddText add_text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_text(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AddPoint add_point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AddLine add_line = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_line(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AddArc add_arc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_arc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AddCircle add_circle = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_circle(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AddTriangle add_triangle = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_triangle(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AddRectangle add_rectangle = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_rectangle(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AddSector add_sector = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_sector(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AddMessage add_message = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_message(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Log::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Log)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (log_case()) {
    case kAddText: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::add_text(this),
          _Internal::add_text(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddPoint: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::add_point(this),
          _Internal::add_point(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddLine: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::add_line(this),
          _Internal::add_line(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddArc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::add_arc(this),
          _Internal::add_arc(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddCircle: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::add_circle(this),
          _Internal::add_circle(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddTriangle: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::add_triangle(this),
          _Internal::add_triangle(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddRectangle: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::add_rectangle(this),
          _Internal::add_rectangle(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddSector: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::add_sector(this),
          _Internal::add_sector(this).GetCachedSize(), target, stream);
      break;
    }
    case kAddMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::add_message(this),
          _Internal::add_message(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Log)
  return target;
}

::size_t Log::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Log)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (log_case()) {
    // .protos.AddText add_text = 1;
    case kAddText: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_text_);
      break;
    }
    // .protos.AddPoint add_point = 2;
    case kAddPoint: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_point_);
      break;
    }
    // .protos.AddLine add_line = 3;
    case kAddLine: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_line_);
      break;
    }
    // .protos.AddArc add_arc = 4;
    case kAddArc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_arc_);
      break;
    }
    // .protos.AddCircle add_circle = 5;
    case kAddCircle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_circle_);
      break;
    }
    // .protos.AddTriangle add_triangle = 6;
    case kAddTriangle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_triangle_);
      break;
    }
    // .protos.AddRectangle add_rectangle = 7;
    case kAddRectangle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_rectangle_);
      break;
    }
    // .protos.AddSector add_sector = 8;
    case kAddSector: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_sector_);
      break;
    }
    // .protos.AddMessage add_message = 9;
    case kAddMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.log_.add_message_);
      break;
    }
    case LOG_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Log::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Log::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Log::GetClassData() const { return &_class_data_; }


void Log::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Log*>(&to_msg);
  auto& from = static_cast<const Log&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Log)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.log_case()) {
    case kAddText: {
      _this->_internal_mutable_add_text()->::protos::AddText::MergeFrom(
          from._internal_add_text());
      break;
    }
    case kAddPoint: {
      _this->_internal_mutable_add_point()->::protos::AddPoint::MergeFrom(
          from._internal_add_point());
      break;
    }
    case kAddLine: {
      _this->_internal_mutable_add_line()->::protos::AddLine::MergeFrom(
          from._internal_add_line());
      break;
    }
    case kAddArc: {
      _this->_internal_mutable_add_arc()->::protos::AddArc::MergeFrom(
          from._internal_add_arc());
      break;
    }
    case kAddCircle: {
      _this->_internal_mutable_add_circle()->::protos::AddCircle::MergeFrom(
          from._internal_add_circle());
      break;
    }
    case kAddTriangle: {
      _this->_internal_mutable_add_triangle()->::protos::AddTriangle::MergeFrom(
          from._internal_add_triangle());
      break;
    }
    case kAddRectangle: {
      _this->_internal_mutable_add_rectangle()->::protos::AddRectangle::MergeFrom(
          from._internal_add_rectangle());
      break;
    }
    case kAddSector: {
      _this->_internal_mutable_add_sector()->::protos::AddSector::MergeFrom(
          from._internal_add_sector());
      break;
    }
    case kAddMessage: {
      _this->_internal_mutable_add_message()->::protos::AddMessage::MergeFrom(
          from._internal_add_message());
      break;
    }
    case LOG_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Log::CopyFrom(const Log& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Log)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Log::IsInitialized() const {
  return true;
}

void Log::InternalSwap(Log* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.log_, other->_impl_.log_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Log::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[54]);
}
// ===================================================================

class DebugClient::_Internal {
 public:
};

DebugClient::DebugClient(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.DebugClient)
}
DebugClient::DebugClient(const DebugClient& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DebugClient* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:protos.DebugClient)
}

inline void DebugClient::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.message_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DebugClient::~DebugClient() {
  // @@protoc_insertion_point(destructor:protos.DebugClient)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DebugClient::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void DebugClient::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DebugClient::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.DebugClient)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DebugClient::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protos.DebugClient.message"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DebugClient::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.DebugClient)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    const std::string& _s = this->_internal_message();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "protos.DebugClient.message");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.DebugClient)
  return target;
}

::size_t DebugClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.DebugClient)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DebugClient::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DebugClient::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DebugClient::GetClassData() const { return &_class_data_; }


void DebugClient::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DebugClient*>(&to_msg);
  auto& from = static_cast<const DebugClient&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.DebugClient)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DebugClient::CopyFrom(const DebugClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.DebugClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugClient::IsInitialized() const {
  return true;
}

void DebugClient::InternalSwap(DebugClient* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, lhs_arena,
                                       &other->_impl_.message_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata DebugClient::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[55]);
}
// ===================================================================

class Action::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::protos::Action, _impl_._oneof_case_);
  static const ::protos::Dash& dash(const Action* msg);
  static const ::protos::Turn& turn(const Action* msg);
  static const ::protos::Kick& kick(const Action* msg);
  static const ::protos::Tackle& tackle(const Action* msg);
  static const ::protos::Catch& catch_(const Action* msg);
  static const ::protos::Move& move(const Action* msg);
  static const ::protos::TurnNeck& turn_neck(const Action* msg);
  static const ::protos::ChangeView& change_view(const Action* msg);
  static const ::protos::Say& say(const Action* msg);
  static const ::protos::PointTo& point_to(const Action* msg);
  static const ::protos::PointToOf& point_to_of(const Action* msg);
  static const ::protos::AttentionTo& attention_to(const Action* msg);
  static const ::protos::AttentionToOf& attention_to_of(const Action* msg);
  static const ::protos::Log& log(const Action* msg);
  static const ::protos::DebugClient& debug_client(const Action* msg);
};

const ::protos::Dash&
Action::_Internal::dash(const Action* msg) {
  return *msg->_impl_.action_.dash_;
}
const ::protos::Turn&
Action::_Internal::turn(const Action* msg) {
  return *msg->_impl_.action_.turn_;
}
const ::protos::Kick&
Action::_Internal::kick(const Action* msg) {
  return *msg->_impl_.action_.kick_;
}
const ::protos::Tackle&
Action::_Internal::tackle(const Action* msg) {
  return *msg->_impl_.action_.tackle_;
}
const ::protos::Catch&
Action::_Internal::catch_(const Action* msg) {
  return *msg->_impl_.action_.catch__;
}
const ::protos::Move&
Action::_Internal::move(const Action* msg) {
  return *msg->_impl_.action_.move_;
}
const ::protos::TurnNeck&
Action::_Internal::turn_neck(const Action* msg) {
  return *msg->_impl_.action_.turn_neck_;
}
const ::protos::ChangeView&
Action::_Internal::change_view(const Action* msg) {
  return *msg->_impl_.action_.change_view_;
}
const ::protos::Say&
Action::_Internal::say(const Action* msg) {
  return *msg->_impl_.action_.say_;
}
const ::protos::PointTo&
Action::_Internal::point_to(const Action* msg) {
  return *msg->_impl_.action_.point_to_;
}
const ::protos::PointToOf&
Action::_Internal::point_to_of(const Action* msg) {
  return *msg->_impl_.action_.point_to_of_;
}
const ::protos::AttentionTo&
Action::_Internal::attention_to(const Action* msg) {
  return *msg->_impl_.action_.attention_to_;
}
const ::protos::AttentionToOf&
Action::_Internal::attention_to_of(const Action* msg) {
  return *msg->_impl_.action_.attention_to_of_;
}
const ::protos::Log&
Action::_Internal::log(const Action* msg) {
  return *msg->_impl_.action_.log_;
}
const ::protos::DebugClient&
Action::_Internal::debug_client(const Action* msg) {
  return *msg->_impl_.action_.debug_client_;
}
void Action::set_allocated_dash(::protos::Dash* dash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (dash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dash);
    if (message_arena != submessage_arena) {
      dash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dash, submessage_arena);
    }
    set_has_dash();
    _impl_.action_.dash_ = dash;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.dash)
}
void Action::set_allocated_turn(::protos::Turn* turn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (turn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(turn);
    if (message_arena != submessage_arena) {
      turn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, turn, submessage_arena);
    }
    set_has_turn();
    _impl_.action_.turn_ = turn;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.turn)
}
void Action::set_allocated_kick(::protos::Kick* kick) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (kick) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(kick);
    if (message_arena != submessage_arena) {
      kick = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kick, submessage_arena);
    }
    set_has_kick();
    _impl_.action_.kick_ = kick;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.kick)
}
void Action::set_allocated_tackle(::protos::Tackle* tackle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (tackle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tackle);
    if (message_arena != submessage_arena) {
      tackle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tackle, submessage_arena);
    }
    set_has_tackle();
    _impl_.action_.tackle_ = tackle;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.tackle)
}
void Action::set_allocated_catch_(::protos::Catch* catch_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (catch_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(catch_);
    if (message_arena != submessage_arena) {
      catch_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, catch_, submessage_arena);
    }
    set_has_catch_();
    _impl_.action_.catch__ = catch_;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.catch)
}
void Action::set_allocated_move(::protos::Move* move) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (move) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(move);
    if (message_arena != submessage_arena) {
      move = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, move, submessage_arena);
    }
    set_has_move();
    _impl_.action_.move_ = move;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.move)
}
void Action::set_allocated_turn_neck(::protos::TurnNeck* turn_neck) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (turn_neck) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(turn_neck);
    if (message_arena != submessage_arena) {
      turn_neck = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, turn_neck, submessage_arena);
    }
    set_has_turn_neck();
    _impl_.action_.turn_neck_ = turn_neck;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.turn_neck)
}
void Action::set_allocated_change_view(::protos::ChangeView* change_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (change_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(change_view);
    if (message_arena != submessage_arena) {
      change_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, change_view, submessage_arena);
    }
    set_has_change_view();
    _impl_.action_.change_view_ = change_view;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.change_view)
}
void Action::set_allocated_say(::protos::Say* say) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (say) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(say);
    if (message_arena != submessage_arena) {
      say = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, say, submessage_arena);
    }
    set_has_say();
    _impl_.action_.say_ = say;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.say)
}
void Action::set_allocated_point_to(::protos::PointTo* point_to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (point_to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point_to);
    if (message_arena != submessage_arena) {
      point_to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_to, submessage_arena);
    }
    set_has_point_to();
    _impl_.action_.point_to_ = point_to;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.point_to)
}
void Action::set_allocated_point_to_of(::protos::PointToOf* point_to_of) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (point_to_of) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point_to_of);
    if (message_arena != submessage_arena) {
      point_to_of = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_to_of, submessage_arena);
    }
    set_has_point_to_of();
    _impl_.action_.point_to_of_ = point_to_of;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.point_to_of)
}
void Action::set_allocated_attention_to(::protos::AttentionTo* attention_to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (attention_to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attention_to);
    if (message_arena != submessage_arena) {
      attention_to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attention_to, submessage_arena);
    }
    set_has_attention_to();
    _impl_.action_.attention_to_ = attention_to;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.attention_to)
}
void Action::set_allocated_attention_to_of(::protos::AttentionToOf* attention_to_of) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (attention_to_of) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attention_to_of);
    if (message_arena != submessage_arena) {
      attention_to_of = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attention_to_of, submessage_arena);
    }
    set_has_attention_to_of();
    _impl_.action_.attention_to_of_ = attention_to_of;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.attention_to_of)
}
void Action::set_allocated_log(::protos::Log* log) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (log) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(log);
    if (message_arena != submessage_arena) {
      log = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log, submessage_arena);
    }
    set_has_log();
    _impl_.action_.log_ = log;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.log)
}
void Action::set_allocated_debug_client(::protos::DebugClient* debug_client) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (debug_client) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(debug_client);
    if (message_arena != submessage_arena) {
      debug_client = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, debug_client, submessage_arena);
    }
    set_has_debug_client();
    _impl_.action_.debug_client_ = debug_client;
  }
  // @@protoc_insertion_point(field_set_allocated:protos.Action.debug_client)
}
Action::Action(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Action)
}
Action::Action(const Action& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Action* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.action_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_action();
  switch (from.action_case()) {
    case kDash: {
      _this->_internal_mutable_dash()->::protos::Dash::MergeFrom(
          from._internal_dash());
      break;
    }
    case kTurn: {
      _this->_internal_mutable_turn()->::protos::Turn::MergeFrom(
          from._internal_turn());
      break;
    }
    case kKick: {
      _this->_internal_mutable_kick()->::protos::Kick::MergeFrom(
          from._internal_kick());
      break;
    }
    case kTackle: {
      _this->_internal_mutable_tackle()->::protos::Tackle::MergeFrom(
          from._internal_tackle());
      break;
    }
    case kCatch: {
      _this->_internal_mutable_catch_()->::protos::Catch::MergeFrom(
          from._internal_catch_());
      break;
    }
    case kMove: {
      _this->_internal_mutable_move()->::protos::Move::MergeFrom(
          from._internal_move());
      break;
    }
    case kTurnNeck: {
      _this->_internal_mutable_turn_neck()->::protos::TurnNeck::MergeFrom(
          from._internal_turn_neck());
      break;
    }
    case kChangeView: {
      _this->_internal_mutable_change_view()->::protos::ChangeView::MergeFrom(
          from._internal_change_view());
      break;
    }
    case kSay: {
      _this->_internal_mutable_say()->::protos::Say::MergeFrom(
          from._internal_say());
      break;
    }
    case kPointTo: {
      _this->_internal_mutable_point_to()->::protos::PointTo::MergeFrom(
          from._internal_point_to());
      break;
    }
    case kPointToOf: {
      _this->_internal_mutable_point_to_of()->::protos::PointToOf::MergeFrom(
          from._internal_point_to_of());
      break;
    }
    case kAttentionTo: {
      _this->_internal_mutable_attention_to()->::protos::AttentionTo::MergeFrom(
          from._internal_attention_to());
      break;
    }
    case kAttentionToOf: {
      _this->_internal_mutable_attention_to_of()->::protos::AttentionToOf::MergeFrom(
          from._internal_attention_to_of());
      break;
    }
    case kLog: {
      _this->_internal_mutable_log()->::protos::Log::MergeFrom(
          from._internal_log());
      break;
    }
    case kDebugClient: {
      _this->_internal_mutable_debug_client()->::protos::DebugClient::MergeFrom(
          from._internal_debug_client());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:protos.Action)
}

inline void Action::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.action_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_action();
}

Action::~Action() {
  // @@protoc_insertion_point(destructor:protos.Action)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Action::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_action()) {
    clear_action();
  }
}

void Action::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Action::clear_action() {
// @@protoc_insertion_point(one_of_clear_start:protos.Action)
  switch (action_case()) {
    case kDash: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.dash_;
      }
      break;
    }
    case kTurn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.turn_;
      }
      break;
    }
    case kKick: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.kick_;
      }
      break;
    }
    case kTackle: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.tackle_;
      }
      break;
    }
    case kCatch: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.catch__;
      }
      break;
    }
    case kMove: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.move_;
      }
      break;
    }
    case kTurnNeck: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.turn_neck_;
      }
      break;
    }
    case kChangeView: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.change_view_;
      }
      break;
    }
    case kSay: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.say_;
      }
      break;
    }
    case kPointTo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.point_to_;
      }
      break;
    }
    case kPointToOf: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.point_to_of_;
      }
      break;
    }
    case kAttentionTo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.attention_to_;
      }
      break;
    }
    case kAttentionToOf: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.attention_to_of_;
      }
      break;
    }
    case kLog: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.log_;
      }
      break;
    }
    case kDebugClient: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.debug_client_;
      }
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}


void Action::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Action)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_action();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Action::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protos.Dash dash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dash(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Turn turn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_turn(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Kick kick = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_kick(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Tackle tackle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_tackle(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Catch catch = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_catch_(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Move move = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_move(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.TurnNeck turn_neck = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_turn_neck(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.ChangeView change_view = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_change_view(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Say say = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_say(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.PointTo point_to = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_point_to(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.PointToOf point_to_of = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_point_to_of(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AttentionTo attention_to = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_attention_to(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.AttentionToOf attention_to_of = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_attention_to_of(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.Log log = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_log(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .protos.DebugClient debug_client = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_debug_client(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Action::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Action)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (action_case()) {
    case kDash: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::dash(this),
          _Internal::dash(this).GetCachedSize(), target, stream);
      break;
    }
    case kTurn: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::turn(this),
          _Internal::turn(this).GetCachedSize(), target, stream);
      break;
    }
    case kKick: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::kick(this),
          _Internal::kick(this).GetCachedSize(), target, stream);
      break;
    }
    case kTackle: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::tackle(this),
          _Internal::tackle(this).GetCachedSize(), target, stream);
      break;
    }
    case kCatch: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::catch_(this),
          _Internal::catch_(this).GetCachedSize(), target, stream);
      break;
    }
    case kMove: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::move(this),
          _Internal::move(this).GetCachedSize(), target, stream);
      break;
    }
    case kTurnNeck: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::turn_neck(this),
          _Internal::turn_neck(this).GetCachedSize(), target, stream);
      break;
    }
    case kChangeView: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::change_view(this),
          _Internal::change_view(this).GetCachedSize(), target, stream);
      break;
    }
    case kSay: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::say(this),
          _Internal::say(this).GetCachedSize(), target, stream);
      break;
    }
    case kPointTo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::point_to(this),
          _Internal::point_to(this).GetCachedSize(), target, stream);
      break;
    }
    case kPointToOf: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::point_to_of(this),
          _Internal::point_to_of(this).GetCachedSize(), target, stream);
      break;
    }
    case kAttentionTo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::attention_to(this),
          _Internal::attention_to(this).GetCachedSize(), target, stream);
      break;
    }
    case kAttentionToOf: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, _Internal::attention_to_of(this),
          _Internal::attention_to_of(this).GetCachedSize(), target, stream);
      break;
    }
    case kLog: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, _Internal::log(this),
          _Internal::log(this).GetCachedSize(), target, stream);
      break;
    }
    case kDebugClient: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, _Internal::debug_client(this),
          _Internal::debug_client(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Action)
  return target;
}

::size_t Action::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Action)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (action_case()) {
    // .protos.Dash dash = 1;
    case kDash: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.dash_);
      break;
    }
    // .protos.Turn turn = 2;
    case kTurn: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.turn_);
      break;
    }
    // .protos.Kick kick = 3;
    case kKick: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.kick_);
      break;
    }
    // .protos.Tackle tackle = 4;
    case kTackle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.tackle_);
      break;
    }
    // .protos.Catch catch = 5;
    case kCatch: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.catch__);
      break;
    }
    // .protos.Move move = 6;
    case kMove: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.move_);
      break;
    }
    // .protos.TurnNeck turn_neck = 7;
    case kTurnNeck: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.turn_neck_);
      break;
    }
    // .protos.ChangeView change_view = 8;
    case kChangeView: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.change_view_);
      break;
    }
    // .protos.Say say = 9;
    case kSay: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.say_);
      break;
    }
    // .protos.PointTo point_to = 10;
    case kPointTo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.point_to_);
      break;
    }
    // .protos.PointToOf point_to_of = 11;
    case kPointToOf: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.point_to_of_);
      break;
    }
    // .protos.AttentionTo attention_to = 12;
    case kAttentionTo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.attention_to_);
      break;
    }
    // .protos.AttentionToOf attention_to_of = 13;
    case kAttentionToOf: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.attention_to_of_);
      break;
    }
    // .protos.Log log = 14;
    case kLog: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.log_);
      break;
    }
    // .protos.DebugClient debug_client = 15;
    case kDebugClient: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.debug_client_);
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Action::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Action::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Action::GetClassData() const { return &_class_data_; }


void Action::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Action*>(&to_msg);
  auto& from = static_cast<const Action&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Action)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.action_case()) {
    case kDash: {
      _this->_internal_mutable_dash()->::protos::Dash::MergeFrom(
          from._internal_dash());
      break;
    }
    case kTurn: {
      _this->_internal_mutable_turn()->::protos::Turn::MergeFrom(
          from._internal_turn());
      break;
    }
    case kKick: {
      _this->_internal_mutable_kick()->::protos::Kick::MergeFrom(
          from._internal_kick());
      break;
    }
    case kTackle: {
      _this->_internal_mutable_tackle()->::protos::Tackle::MergeFrom(
          from._internal_tackle());
      break;
    }
    case kCatch: {
      _this->_internal_mutable_catch_()->::protos::Catch::MergeFrom(
          from._internal_catch_());
      break;
    }
    case kMove: {
      _this->_internal_mutable_move()->::protos::Move::MergeFrom(
          from._internal_move());
      break;
    }
    case kTurnNeck: {
      _this->_internal_mutable_turn_neck()->::protos::TurnNeck::MergeFrom(
          from._internal_turn_neck());
      break;
    }
    case kChangeView: {
      _this->_internal_mutable_change_view()->::protos::ChangeView::MergeFrom(
          from._internal_change_view());
      break;
    }
    case kSay: {
      _this->_internal_mutable_say()->::protos::Say::MergeFrom(
          from._internal_say());
      break;
    }
    case kPointTo: {
      _this->_internal_mutable_point_to()->::protos::PointTo::MergeFrom(
          from._internal_point_to());
      break;
    }
    case kPointToOf: {
      _this->_internal_mutable_point_to_of()->::protos::PointToOf::MergeFrom(
          from._internal_point_to_of());
      break;
    }
    case kAttentionTo: {
      _this->_internal_mutable_attention_to()->::protos::AttentionTo::MergeFrom(
          from._internal_attention_to());
      break;
    }
    case kAttentionToOf: {
      _this->_internal_mutable_attention_to_of()->::protos::AttentionToOf::MergeFrom(
          from._internal_attention_to_of());
      break;
    }
    case kLog: {
      _this->_internal_mutable_log()->::protos::Log::MergeFrom(
          from._internal_log());
      break;
    }
    case kDebugClient: {
      _this->_internal_mutable_debug_client()->::protos::DebugClient::MergeFrom(
          from._internal_debug_client());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Action::CopyFrom(const Action& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Action)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Action::IsInitialized() const {
  return true;
}

void Action::InternalSwap(Action* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.action_, other->_impl_.action_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Action::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[56]);
}
// ===================================================================

class Actions::_Internal {
 public:
};

Actions::Actions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:protos.Actions)
}
Actions::Actions(const Actions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Actions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.actions_){from._impl_.actions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protos.Actions)
}

inline void Actions::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.actions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Actions::~Actions() {
  // @@protoc_insertion_point(destructor:protos.Actions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Actions::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_actions()->~RepeatedPtrField();
}

void Actions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Actions::Clear() {
// @@protoc_insertion_point(message_clear_start:protos.Actions)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_actions()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Actions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .protos.Action actions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_actions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Actions::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protos.Actions)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protos.Action actions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_actions_size()); i < n; i++) {
    const auto& repfield = this->_internal_actions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protos.Actions)
  return target;
}

::size_t Actions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protos.Actions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protos.Action actions = 1;
  total_size += 1UL * this->_internal_actions_size();
  for (const auto& msg : this->_internal_actions()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Actions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Actions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Actions::GetClassData() const { return &_class_data_; }


void Actions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Actions*>(&to_msg);
  auto& from = static_cast<const Actions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protos.Actions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_actions()->MergeFrom(from._internal_actions());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Actions::CopyFrom(const Actions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protos.Actions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Actions::IsInitialized() const {
  return true;
}

void Actions::InternalSwap(Actions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_actions()->InternalSwap(other->_internal_mutable_actions());
}

::PROTOBUF_NAMESPACE_ID::Metadata Actions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_service_2eproto_getter, &descriptor_table_service_2eproto_once,
      file_level_metadata_service_2eproto[57]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::protos::Vector2D*
Arena::CreateMaybeMessage< ::protos::Vector2D >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Vector2D >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Ball*
Arena::CreateMaybeMessage< ::protos::Ball >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Ball >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Player*
Arena::CreateMaybeMessage< ::protos::Player >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Player >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Self*
Arena::CreateMaybeMessage< ::protos::Self >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Self >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::InterceptInfo*
Arena::CreateMaybeMessage< ::protos::InterceptInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::InterceptInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::InterceptTable*
Arena::CreateMaybeMessage< ::protos::InterceptTable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::InterceptTable >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::WorldModel_OurPlayersDictEntry_DoNotUse*
Arena::CreateMaybeMessage< ::protos::WorldModel_OurPlayersDictEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::WorldModel_OurPlayersDictEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::WorldModel_TheirPlayersDictEntry_DoNotUse*
Arena::CreateMaybeMessage< ::protos::WorldModel_TheirPlayersDictEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::WorldModel_TheirPlayersDictEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::WorldModel*
Arena::CreateMaybeMessage< ::protos::WorldModel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::WorldModel >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::State*
Arena::CreateMaybeMessage< ::protos::State >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::State >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Dash*
Arena::CreateMaybeMessage< ::protos::Dash >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Dash >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Turn*
Arena::CreateMaybeMessage< ::protos::Turn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Turn >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Kick*
Arena::CreateMaybeMessage< ::protos::Kick >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Kick >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Tackle*
Arena::CreateMaybeMessage< ::protos::Tackle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Tackle >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Catch*
Arena::CreateMaybeMessage< ::protos::Catch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Catch >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Move*
Arena::CreateMaybeMessage< ::protos::Move >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Move >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::TurnNeck*
Arena::CreateMaybeMessage< ::protos::TurnNeck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::TurnNeck >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::ChangeView*
Arena::CreateMaybeMessage< ::protos::ChangeView >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::ChangeView >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::BallMessage*
Arena::CreateMaybeMessage< ::protos::BallMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::BallMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::PassMessage*
Arena::CreateMaybeMessage< ::protos::PassMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::PassMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::InterceptMessage*
Arena::CreateMaybeMessage< ::protos::InterceptMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::InterceptMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::GoalieMessage*
Arena::CreateMaybeMessage< ::protos::GoalieMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::GoalieMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::GoalieAndPlayerMessage*
Arena::CreateMaybeMessage< ::protos::GoalieAndPlayerMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::GoalieAndPlayerMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::OffsideLineMessage*
Arena::CreateMaybeMessage< ::protos::OffsideLineMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::OffsideLineMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::DefenseLineMessage*
Arena::CreateMaybeMessage< ::protos::DefenseLineMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::DefenseLineMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::WaitRequestMessage*
Arena::CreateMaybeMessage< ::protos::WaitRequestMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::WaitRequestMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::SetplayMessage*
Arena::CreateMaybeMessage< ::protos::SetplayMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::SetplayMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::PassRequestMessage*
Arena::CreateMaybeMessage< ::protos::PassRequestMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::PassRequestMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::StaminaMessage*
Arena::CreateMaybeMessage< ::protos::StaminaMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::StaminaMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::RecoveryMessage*
Arena::CreateMaybeMessage< ::protos::RecoveryMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::RecoveryMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::StaminaCapacityMessage*
Arena::CreateMaybeMessage< ::protos::StaminaCapacityMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::StaminaCapacityMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::DribbleMessage*
Arena::CreateMaybeMessage< ::protos::DribbleMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::DribbleMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::BallGoalieMessage*
Arena::CreateMaybeMessage< ::protos::BallGoalieMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::BallGoalieMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::OnePlayerMessage*
Arena::CreateMaybeMessage< ::protos::OnePlayerMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::OnePlayerMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::TwoPlayerMessage*
Arena::CreateMaybeMessage< ::protos::TwoPlayerMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::TwoPlayerMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::ThreePlayerMessage*
Arena::CreateMaybeMessage< ::protos::ThreePlayerMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::ThreePlayerMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::SelfMessage*
Arena::CreateMaybeMessage< ::protos::SelfMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::SelfMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::TeammateMessage*
Arena::CreateMaybeMessage< ::protos::TeammateMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::TeammateMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::OpponentMessage*
Arena::CreateMaybeMessage< ::protos::OpponentMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::OpponentMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::BallPlayerMessage*
Arena::CreateMaybeMessage< ::protos::BallPlayerMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::BallPlayerMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Say*
Arena::CreateMaybeMessage< ::protos::Say >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Say >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::PointTo*
Arena::CreateMaybeMessage< ::protos::PointTo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::PointTo >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::PointToOf*
Arena::CreateMaybeMessage< ::protos::PointToOf >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::PointToOf >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AttentionTo*
Arena::CreateMaybeMessage< ::protos::AttentionTo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AttentionTo >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AttentionToOf*
Arena::CreateMaybeMessage< ::protos::AttentionToOf >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AttentionToOf >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddText*
Arena::CreateMaybeMessage< ::protos::AddText >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddText >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddPoint*
Arena::CreateMaybeMessage< ::protos::AddPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddLine*
Arena::CreateMaybeMessage< ::protos::AddLine >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddLine >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddArc*
Arena::CreateMaybeMessage< ::protos::AddArc >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddArc >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddCircle*
Arena::CreateMaybeMessage< ::protos::AddCircle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddCircle >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddTriangle*
Arena::CreateMaybeMessage< ::protos::AddTriangle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddTriangle >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddRectangle*
Arena::CreateMaybeMessage< ::protos::AddRectangle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddRectangle >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddSector*
Arena::CreateMaybeMessage< ::protos::AddSector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddSector >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::AddMessage*
Arena::CreateMaybeMessage< ::protos::AddMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::AddMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Log*
Arena::CreateMaybeMessage< ::protos::Log >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Log >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::DebugClient*
Arena::CreateMaybeMessage< ::protos::DebugClient >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::DebugClient >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Action*
Arena::CreateMaybeMessage< ::protos::Action >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Action >(arena);
}
template<> PROTOBUF_NOINLINE ::protos::Actions*
Arena::CreateMaybeMessage< ::protos::Actions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protos::Actions >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
