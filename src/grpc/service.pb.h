// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_service_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_service_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_service_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_service_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_service_2eproto;
namespace protos {
class Action;
struct ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class Actions;
struct ActionsDefaultTypeInternal;
extern ActionsDefaultTypeInternal _Actions_default_instance_;
class AttentionTo;
struct AttentionToDefaultTypeInternal;
extern AttentionToDefaultTypeInternal _AttentionTo_default_instance_;
class AttentionToOf;
struct AttentionToOfDefaultTypeInternal;
extern AttentionToOfDefaultTypeInternal _AttentionToOf_default_instance_;
class Ball;
struct BallDefaultTypeInternal;
extern BallDefaultTypeInternal _Ball_default_instance_;
class Catch;
struct CatchDefaultTypeInternal;
extern CatchDefaultTypeInternal _Catch_default_instance_;
class ChangeView;
struct ChangeViewDefaultTypeInternal;
extern ChangeViewDefaultTypeInternal _ChangeView_default_instance_;
class Dash;
struct DashDefaultTypeInternal;
extern DashDefaultTypeInternal _Dash_default_instance_;
class DebugClient;
struct DebugClientDefaultTypeInternal;
extern DebugClientDefaultTypeInternal _DebugClient_default_instance_;
class InterceptInfo;
struct InterceptInfoDefaultTypeInternal;
extern InterceptInfoDefaultTypeInternal _InterceptInfo_default_instance_;
class InterceptTable;
struct InterceptTableDefaultTypeInternal;
extern InterceptTableDefaultTypeInternal _InterceptTable_default_instance_;
class Kick;
struct KickDefaultTypeInternal;
extern KickDefaultTypeInternal _Kick_default_instance_;
class Log;
struct LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class Move;
struct MoveDefaultTypeInternal;
extern MoveDefaultTypeInternal _Move_default_instance_;
class Player;
struct PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class PointTo;
struct PointToDefaultTypeInternal;
extern PointToDefaultTypeInternal _PointTo_default_instance_;
class PointToOf;
struct PointToOfDefaultTypeInternal;
extern PointToOfDefaultTypeInternal _PointToOf_default_instance_;
class Say;
struct SayDefaultTypeInternal;
extern SayDefaultTypeInternal _Say_default_instance_;
class Self;
struct SelfDefaultTypeInternal;
extern SelfDefaultTypeInternal _Self_default_instance_;
class State;
struct StateDefaultTypeInternal;
extern StateDefaultTypeInternal _State_default_instance_;
class Tackle;
struct TackleDefaultTypeInternal;
extern TackleDefaultTypeInternal _Tackle_default_instance_;
class Turn;
struct TurnDefaultTypeInternal;
extern TurnDefaultTypeInternal _Turn_default_instance_;
class TurnNeck;
struct TurnNeckDefaultTypeInternal;
extern TurnNeckDefaultTypeInternal _TurnNeck_default_instance_;
class Vector2D;
struct Vector2DDefaultTypeInternal;
extern Vector2DDefaultTypeInternal _Vector2D_default_instance_;
class WorldModel;
struct WorldModelDefaultTypeInternal;
extern WorldModelDefaultTypeInternal _WorldModel_default_instance_;
class WorldModel_OurPlayersDictEntry_DoNotUse;
struct WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal;
extern WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal _WorldModel_OurPlayersDictEntry_DoNotUse_default_instance_;
class WorldModel_TheirPlayersDictEntry_DoNotUse;
struct WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal;
extern WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal _WorldModel_TheirPlayersDictEntry_DoNotUse_default_instance_;
}  // namespace protos
PROTOBUF_NAMESPACE_OPEN
template <>
::protos::Action* Arena::CreateMaybeMessage<::protos::Action>(Arena*);
template <>
::protos::Actions* Arena::CreateMaybeMessage<::protos::Actions>(Arena*);
template <>
::protos::AttentionTo* Arena::CreateMaybeMessage<::protos::AttentionTo>(Arena*);
template <>
::protos::AttentionToOf* Arena::CreateMaybeMessage<::protos::AttentionToOf>(Arena*);
template <>
::protos::Ball* Arena::CreateMaybeMessage<::protos::Ball>(Arena*);
template <>
::protos::Catch* Arena::CreateMaybeMessage<::protos::Catch>(Arena*);
template <>
::protos::ChangeView* Arena::CreateMaybeMessage<::protos::ChangeView>(Arena*);
template <>
::protos::Dash* Arena::CreateMaybeMessage<::protos::Dash>(Arena*);
template <>
::protos::DebugClient* Arena::CreateMaybeMessage<::protos::DebugClient>(Arena*);
template <>
::protos::InterceptInfo* Arena::CreateMaybeMessage<::protos::InterceptInfo>(Arena*);
template <>
::protos::InterceptTable* Arena::CreateMaybeMessage<::protos::InterceptTable>(Arena*);
template <>
::protos::Kick* Arena::CreateMaybeMessage<::protos::Kick>(Arena*);
template <>
::protos::Log* Arena::CreateMaybeMessage<::protos::Log>(Arena*);
template <>
::protos::Move* Arena::CreateMaybeMessage<::protos::Move>(Arena*);
template <>
::protos::Player* Arena::CreateMaybeMessage<::protos::Player>(Arena*);
template <>
::protos::PointTo* Arena::CreateMaybeMessage<::protos::PointTo>(Arena*);
template <>
::protos::PointToOf* Arena::CreateMaybeMessage<::protos::PointToOf>(Arena*);
template <>
::protos::Say* Arena::CreateMaybeMessage<::protos::Say>(Arena*);
template <>
::protos::Self* Arena::CreateMaybeMessage<::protos::Self>(Arena*);
template <>
::protos::State* Arena::CreateMaybeMessage<::protos::State>(Arena*);
template <>
::protos::Tackle* Arena::CreateMaybeMessage<::protos::Tackle>(Arena*);
template <>
::protos::Turn* Arena::CreateMaybeMessage<::protos::Turn>(Arena*);
template <>
::protos::TurnNeck* Arena::CreateMaybeMessage<::protos::TurnNeck>(Arena*);
template <>
::protos::Vector2D* Arena::CreateMaybeMessage<::protos::Vector2D>(Arena*);
template <>
::protos::WorldModel* Arena::CreateMaybeMessage<::protos::WorldModel>(Arena*);
template <>
::protos::WorldModel_OurPlayersDictEntry_DoNotUse* Arena::CreateMaybeMessage<::protos::WorldModel_OurPlayersDictEntry_DoNotUse>(Arena*);
template <>
::protos::WorldModel_TheirPlayersDictEntry_DoNotUse* Arena::CreateMaybeMessage<::protos::WorldModel_TheirPlayersDictEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace protos {
enum ViewWidth : int {
  NARROW = 0,
  NORMAL = 1,
  WIDE = 2,
  ViewWidth_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ViewWidth_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ViewWidth_IsValid(int value);
constexpr ViewWidth ViewWidth_MIN = static_cast<ViewWidth>(0);
constexpr ViewWidth ViewWidth_MAX = static_cast<ViewWidth>(2);
constexpr int ViewWidth_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ViewWidth_descriptor();
template <typename T>
const std::string& ViewWidth_Name(T value) {
  static_assert(std::is_same<T, ViewWidth>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ViewWidth_Name().");
  return ViewWidth_Name(static_cast<ViewWidth>(value));
}
template <>
inline const std::string& ViewWidth_Name(ViewWidth value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ViewWidth_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ViewWidth_Parse(absl::string_view name, ViewWidth* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ViewWidth>(
      ViewWidth_descriptor(), name, value);
}
enum Side : int {
  UNKNOWN = 0,
  LEFT = 1,
  RIGHT = 2,
  Side_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Side_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Side_IsValid(int value);
constexpr Side Side_MIN = static_cast<Side>(0);
constexpr Side Side_MAX = static_cast<Side>(2);
constexpr int Side_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Side_descriptor();
template <typename T>
const std::string& Side_Name(T value) {
  static_assert(std::is_same<T, Side>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Side_Name().");
  return Side_Name(static_cast<Side>(value));
}
template <>
inline const std::string& Side_Name(Side value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Side_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Side_Parse(absl::string_view name, Side* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Side>(
      Side_descriptor(), name, value);
}
enum InterceptActionType : int {
  UNKNOWN_Intercept_Action_Type = 0,
  OMNI_DASH = 1,
  TURN_FORWARD_DASH = 2,
  TURN_BACKWARD_DASH = 3,
  InterceptActionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  InterceptActionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool InterceptActionType_IsValid(int value);
constexpr InterceptActionType InterceptActionType_MIN = static_cast<InterceptActionType>(0);
constexpr InterceptActionType InterceptActionType_MAX = static_cast<InterceptActionType>(3);
constexpr int InterceptActionType_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
InterceptActionType_descriptor();
template <typename T>
const std::string& InterceptActionType_Name(T value) {
  static_assert(std::is_same<T, InterceptActionType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to InterceptActionType_Name().");
  return InterceptActionType_Name(static_cast<InterceptActionType>(value));
}
template <>
inline const std::string& InterceptActionType_Name(InterceptActionType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<InterceptActionType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool InterceptActionType_Parse(absl::string_view name, InterceptActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InterceptActionType>(
      InterceptActionType_descriptor(), name, value);
}
enum GameModeType : int {
  BeforeKickOff = 0,
  TimeOver = 1,
  PlayOn = 2,
  KickOff_Left = 3,
  KickOff_Right = 4,
  KickIn_Left = 5,
  KickIn_Right = 6,
  FreeKick_Left = 7,
  FreeKick_Right = 8,
  CornerKick_Left = 9,
  CornerKick_Right = 10,
  GoalKick_Left = 11,
  GoalKick_Right = 12,
  AfterGoal_Left = 13,
  AfterGoal_Right = 14,
  OffSide_Left = 15,
  OffSide_Right = 16,
  PenaltyKick_Left = 17,
  PenaltyKick_Right = 18,
  FirstHalfOver = 19,
  Pause = 20,
  Human = 21,
  FoulCharge_Left = 22,
  FoulCharge_Right = 23,
  FoulPush_Left = 24,
  FoulPush_Right = 25,
  FoulMultipleAttacker_Left = 26,
  FoulMultipleAttacker_Right = 27,
  FoulBallOut_Left = 28,
  FoulBallOut_Right = 29,
  BackPass_Left = 30,
  BackPass_Right = 31,
  FreeKickFault_Left = 32,
  FreeKickFault_Right = 33,
  CatchFault_Left = 34,
  CatchFault_Right = 35,
  IndFreeKick_Left = 36,
  IndFreeKick_Right = 37,
  PenaltySetup_Left = 38,
  PenaltySetup_Right = 39,
  PenaltyReady_Left = 40,
  PenaltyReady_Right = 41,
  PenaltyTaken_Left = 42,
  PenaltyTaken_Right = 43,
  PenaltyMiss_Left = 44,
  PenaltyMiss_Right = 45,
  PenaltyScore_Left = 46,
  PenaltyScore_Right = 47,
  IllegalDefense_Left = 48,
  IllegalDefense_Right = 49,
  PenaltyOnfield = 50,
  PenaltyFoul = 51,
  GoalieCatch_Left = 52,
  GoalieCatch_Right = 53,
  ExtendHalf = 54,
  MODE_MAX = 55,
  GameModeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GameModeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GameModeType_IsValid(int value);
constexpr GameModeType GameModeType_MIN = static_cast<GameModeType>(0);
constexpr GameModeType GameModeType_MAX = static_cast<GameModeType>(55);
constexpr int GameModeType_ARRAYSIZE = 55 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
GameModeType_descriptor();
template <typename T>
const std::string& GameModeType_Name(T value) {
  static_assert(std::is_same<T, GameModeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GameModeType_Name().");
  return GameModeType_Name(static_cast<GameModeType>(value));
}
template <>
inline const std::string& GameModeType_Name(GameModeType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<GameModeType_descriptor,
                                                 0, 55>(
      static_cast<int>(value));
}
inline bool GameModeType_Parse(absl::string_view name, GameModeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameModeType>(
      GameModeType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Vector2D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Vector2D) */ {
 public:
  inline Vector2D() : Vector2D(nullptr) {}
  ~Vector2D() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vector2D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector2D(const Vector2D& from);
  Vector2D(Vector2D&& from) noexcept
    : Vector2D() {
    *this = ::std::move(from);
  }

  inline Vector2D& operator=(const Vector2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector2D& operator=(Vector2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector2D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector2D* internal_default_instance() {
    return reinterpret_cast<const Vector2D*>(
               &_Vector2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector2D& a, Vector2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector2D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector2D* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector2D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector2D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vector2D& from) {
    Vector2D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector2D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Vector2D";
  }
  protected:
  explicit Vector2D(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kDistFieldNumber = 3,
    kAngleFieldNumber = 4,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float dist = 3;
  void clear_dist() ;
  float dist() const;
  void set_dist(float value);

  private:
  float _internal_dist() const;
  void _internal_set_dist(float value);

  public:
  // float angle = 4;
  void clear_angle() ;
  float angle() const;
  void set_angle(float value);

  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Vector2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float dist_;
    float angle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Ball final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Ball) */ {
 public:
  inline Ball() : Ball(nullptr) {}
  ~Ball() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Ball(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ball(const Ball& from);
  Ball(Ball&& from) noexcept
    : Ball() {
    *this = ::std::move(from);
  }

  inline Ball& operator=(const Ball& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ball& operator=(Ball&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ball& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ball* internal_default_instance() {
    return reinterpret_cast<const Ball*>(
               &_Ball_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Ball& a, Ball& b) {
    a.Swap(&b);
  }
  inline void Swap(Ball* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ball* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ball* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ball>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ball& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ball& from) {
    Ball::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ball* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Ball";
  }
  protected:
  explicit Ball(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kRelativePositionFieldNumber = 2,
    kSeenPositionFieldNumber = 3,
    kHeardPositionFieldNumber = 4,
    kVelocityFieldNumber = 5,
    kSeenVelocityFieldNumber = 6,
    kHeardVelocityFieldNumber = 7,
    kPosCountFieldNumber = 8,
    kSeenPosCountFieldNumber = 9,
    kHeardPosCountFieldNumber = 10,
    kVelCountFieldNumber = 11,
    kSeenVelCountFieldNumber = 12,
    kHeardVelCountFieldNumber = 13,
    kLostCountFieldNumber = 14,
    kGhostCountFieldNumber = 15,
    kDistFromSelfFieldNumber = 16,
    kAngleFromSelfFieldNumber = 17,
  };
  // .protos.Vector2D position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* position);
  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protos::Vector2D* position);
  ::protos::Vector2D* unsafe_arena_release_position();
  // .protos.Vector2D relative_position = 2;
  bool has_relative_position() const;
  void clear_relative_position() ;
  const ::protos::Vector2D& relative_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_relative_position();
  ::protos::Vector2D* mutable_relative_position();
  void set_allocated_relative_position(::protos::Vector2D* relative_position);
  private:
  const ::protos::Vector2D& _internal_relative_position() const;
  ::protos::Vector2D* _internal_mutable_relative_position();
  public:
  void unsafe_arena_set_allocated_relative_position(
      ::protos::Vector2D* relative_position);
  ::protos::Vector2D* unsafe_arena_release_relative_position();
  // .protos.Vector2D seen_position = 3;
  bool has_seen_position() const;
  void clear_seen_position() ;
  const ::protos::Vector2D& seen_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_position();
  ::protos::Vector2D* mutable_seen_position();
  void set_allocated_seen_position(::protos::Vector2D* seen_position);
  private:
  const ::protos::Vector2D& _internal_seen_position() const;
  ::protos::Vector2D* _internal_mutable_seen_position();
  public:
  void unsafe_arena_set_allocated_seen_position(
      ::protos::Vector2D* seen_position);
  ::protos::Vector2D* unsafe_arena_release_seen_position();
  // .protos.Vector2D heard_position = 4;
  bool has_heard_position() const;
  void clear_heard_position() ;
  const ::protos::Vector2D& heard_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_heard_position();
  ::protos::Vector2D* mutable_heard_position();
  void set_allocated_heard_position(::protos::Vector2D* heard_position);
  private:
  const ::protos::Vector2D& _internal_heard_position() const;
  ::protos::Vector2D* _internal_mutable_heard_position();
  public:
  void unsafe_arena_set_allocated_heard_position(
      ::protos::Vector2D* heard_position);
  ::protos::Vector2D* unsafe_arena_release_heard_position();
  // .protos.Vector2D velocity = 5;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::protos::Vector2D& velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_velocity();
  ::protos::Vector2D* mutable_velocity();
  void set_allocated_velocity(::protos::Vector2D* velocity);
  private:
  const ::protos::Vector2D& _internal_velocity() const;
  ::protos::Vector2D* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::protos::Vector2D* velocity);
  ::protos::Vector2D* unsafe_arena_release_velocity();
  // .protos.Vector2D seen_velocity = 6;
  bool has_seen_velocity() const;
  void clear_seen_velocity() ;
  const ::protos::Vector2D& seen_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_velocity();
  ::protos::Vector2D* mutable_seen_velocity();
  void set_allocated_seen_velocity(::protos::Vector2D* seen_velocity);
  private:
  const ::protos::Vector2D& _internal_seen_velocity() const;
  ::protos::Vector2D* _internal_mutable_seen_velocity();
  public:
  void unsafe_arena_set_allocated_seen_velocity(
      ::protos::Vector2D* seen_velocity);
  ::protos::Vector2D* unsafe_arena_release_seen_velocity();
  // .protos.Vector2D heard_velocity = 7;
  bool has_heard_velocity() const;
  void clear_heard_velocity() ;
  const ::protos::Vector2D& heard_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_heard_velocity();
  ::protos::Vector2D* mutable_heard_velocity();
  void set_allocated_heard_velocity(::protos::Vector2D* heard_velocity);
  private:
  const ::protos::Vector2D& _internal_heard_velocity() const;
  ::protos::Vector2D* _internal_mutable_heard_velocity();
  public:
  void unsafe_arena_set_allocated_heard_velocity(
      ::protos::Vector2D* heard_velocity);
  ::protos::Vector2D* unsafe_arena_release_heard_velocity();
  // int32 pos_count = 8;
  void clear_pos_count() ;
  ::int32_t pos_count() const;
  void set_pos_count(::int32_t value);

  private:
  ::int32_t _internal_pos_count() const;
  void _internal_set_pos_count(::int32_t value);

  public:
  // int32 seen_pos_count = 9;
  void clear_seen_pos_count() ;
  ::int32_t seen_pos_count() const;
  void set_seen_pos_count(::int32_t value);

  private:
  ::int32_t _internal_seen_pos_count() const;
  void _internal_set_seen_pos_count(::int32_t value);

  public:
  // int32 heard_pos_count = 10;
  void clear_heard_pos_count() ;
  ::int32_t heard_pos_count() const;
  void set_heard_pos_count(::int32_t value);

  private:
  ::int32_t _internal_heard_pos_count() const;
  void _internal_set_heard_pos_count(::int32_t value);

  public:
  // int32 vel_count = 11;
  void clear_vel_count() ;
  ::int32_t vel_count() const;
  void set_vel_count(::int32_t value);

  private:
  ::int32_t _internal_vel_count() const;
  void _internal_set_vel_count(::int32_t value);

  public:
  // int32 seen_vel_count = 12;
  void clear_seen_vel_count() ;
  ::int32_t seen_vel_count() const;
  void set_seen_vel_count(::int32_t value);

  private:
  ::int32_t _internal_seen_vel_count() const;
  void _internal_set_seen_vel_count(::int32_t value);

  public:
  // int32 heard_vel_count = 13;
  void clear_heard_vel_count() ;
  ::int32_t heard_vel_count() const;
  void set_heard_vel_count(::int32_t value);

  private:
  ::int32_t _internal_heard_vel_count() const;
  void _internal_set_heard_vel_count(::int32_t value);

  public:
  // int32 lost_count = 14;
  void clear_lost_count() ;
  ::int32_t lost_count() const;
  void set_lost_count(::int32_t value);

  private:
  ::int32_t _internal_lost_count() const;
  void _internal_set_lost_count(::int32_t value);

  public:
  // int32 ghost_count = 15;
  void clear_ghost_count() ;
  ::int32_t ghost_count() const;
  void set_ghost_count(::int32_t value);

  private:
  ::int32_t _internal_ghost_count() const;
  void _internal_set_ghost_count(::int32_t value);

  public:
  // float dist_from_self = 16;
  void clear_dist_from_self() ;
  float dist_from_self() const;
  void set_dist_from_self(float value);

  private:
  float _internal_dist_from_self() const;
  void _internal_set_dist_from_self(float value);

  public:
  // float angle_from_self = 17;
  void clear_angle_from_self() ;
  float angle_from_self() const;
  void set_angle_from_self(float value);

  private:
  float _internal_angle_from_self() const;
  void _internal_set_angle_from_self(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Ball)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    ::protos::Vector2D* relative_position_;
    ::protos::Vector2D* seen_position_;
    ::protos::Vector2D* heard_position_;
    ::protos::Vector2D* velocity_;
    ::protos::Vector2D* seen_velocity_;
    ::protos::Vector2D* heard_velocity_;
    ::int32_t pos_count_;
    ::int32_t seen_pos_count_;
    ::int32_t heard_pos_count_;
    ::int32_t vel_count_;
    ::int32_t seen_vel_count_;
    ::int32_t heard_vel_count_;
    ::int32_t lost_count_;
    ::int32_t ghost_count_;
    float dist_from_self_;
    float angle_from_self_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  ~Player() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Player& from) {
    Player::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Player";
  }
  protected:
  explicit Player(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kSeenPositionFieldNumber = 2,
    kHeardPositionFieldNumber = 3,
    kVelocityFieldNumber = 4,
    kSeenVelocityFieldNumber = 5,
    kPosCountFieldNumber = 6,
    kSeenPosCountFieldNumber = 7,
    kHeardPosCountFieldNumber = 8,
    kVelCountFieldNumber = 9,
    kSeenVelCountFieldNumber = 10,
    kGhostCountFieldNumber = 11,
    kDistFromSelfFieldNumber = 12,
    kAngleFromSelfFieldNumber = 13,
    kIdFieldNumber = 14,
    kSideFieldNumber = 15,
    kUniformNumberFieldNumber = 16,
    kUniformNumberCountFieldNumber = 17,
    kBodyDirectionFieldNumber = 19,
    kBodyDirectionCountFieldNumber = 20,
    kFaceDirectionFieldNumber = 21,
    kFaceDirectionCountFieldNumber = 22,
    kPointToDirectionFieldNumber = 23,
    kPointToDirectionCountFieldNumber = 24,
    kIsGoalieFieldNumber = 18,
    kIsKickingFieldNumber = 25,
    kIsTacklingFieldNumber = 29,
    kDistFromBallFieldNumber = 26,
    kAngleFromBallFieldNumber = 27,
    kBallReachStepsFieldNumber = 28,
  };
  // .protos.Vector2D position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* position);
  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protos::Vector2D* position);
  ::protos::Vector2D* unsafe_arena_release_position();
  // .protos.Vector2D seen_position = 2;
  bool has_seen_position() const;
  void clear_seen_position() ;
  const ::protos::Vector2D& seen_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_position();
  ::protos::Vector2D* mutable_seen_position();
  void set_allocated_seen_position(::protos::Vector2D* seen_position);
  private:
  const ::protos::Vector2D& _internal_seen_position() const;
  ::protos::Vector2D* _internal_mutable_seen_position();
  public:
  void unsafe_arena_set_allocated_seen_position(
      ::protos::Vector2D* seen_position);
  ::protos::Vector2D* unsafe_arena_release_seen_position();
  // .protos.Vector2D heard_position = 3;
  bool has_heard_position() const;
  void clear_heard_position() ;
  const ::protos::Vector2D& heard_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_heard_position();
  ::protos::Vector2D* mutable_heard_position();
  void set_allocated_heard_position(::protos::Vector2D* heard_position);
  private:
  const ::protos::Vector2D& _internal_heard_position() const;
  ::protos::Vector2D* _internal_mutable_heard_position();
  public:
  void unsafe_arena_set_allocated_heard_position(
      ::protos::Vector2D* heard_position);
  ::protos::Vector2D* unsafe_arena_release_heard_position();
  // .protos.Vector2D velocity = 4;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::protos::Vector2D& velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_velocity();
  ::protos::Vector2D* mutable_velocity();
  void set_allocated_velocity(::protos::Vector2D* velocity);
  private:
  const ::protos::Vector2D& _internal_velocity() const;
  ::protos::Vector2D* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::protos::Vector2D* velocity);
  ::protos::Vector2D* unsafe_arena_release_velocity();
  // .protos.Vector2D seen_velocity = 5;
  bool has_seen_velocity() const;
  void clear_seen_velocity() ;
  const ::protos::Vector2D& seen_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_velocity();
  ::protos::Vector2D* mutable_seen_velocity();
  void set_allocated_seen_velocity(::protos::Vector2D* seen_velocity);
  private:
  const ::protos::Vector2D& _internal_seen_velocity() const;
  ::protos::Vector2D* _internal_mutable_seen_velocity();
  public:
  void unsafe_arena_set_allocated_seen_velocity(
      ::protos::Vector2D* seen_velocity);
  ::protos::Vector2D* unsafe_arena_release_seen_velocity();
  // int32 pos_count = 6;
  void clear_pos_count() ;
  ::int32_t pos_count() const;
  void set_pos_count(::int32_t value);

  private:
  ::int32_t _internal_pos_count() const;
  void _internal_set_pos_count(::int32_t value);

  public:
  // int32 seen_pos_count = 7;
  void clear_seen_pos_count() ;
  ::int32_t seen_pos_count() const;
  void set_seen_pos_count(::int32_t value);

  private:
  ::int32_t _internal_seen_pos_count() const;
  void _internal_set_seen_pos_count(::int32_t value);

  public:
  // int32 heard_pos_count = 8;
  void clear_heard_pos_count() ;
  ::int32_t heard_pos_count() const;
  void set_heard_pos_count(::int32_t value);

  private:
  ::int32_t _internal_heard_pos_count() const;
  void _internal_set_heard_pos_count(::int32_t value);

  public:
  // int32 vel_count = 9;
  void clear_vel_count() ;
  ::int32_t vel_count() const;
  void set_vel_count(::int32_t value);

  private:
  ::int32_t _internal_vel_count() const;
  void _internal_set_vel_count(::int32_t value);

  public:
  // int32 seen_vel_count = 10;
  void clear_seen_vel_count() ;
  ::int32_t seen_vel_count() const;
  void set_seen_vel_count(::int32_t value);

  private:
  ::int32_t _internal_seen_vel_count() const;
  void _internal_set_seen_vel_count(::int32_t value);

  public:
  // int32 ghost_count = 11;
  void clear_ghost_count() ;
  ::int32_t ghost_count() const;
  void set_ghost_count(::int32_t value);

  private:
  ::int32_t _internal_ghost_count() const;
  void _internal_set_ghost_count(::int32_t value);

  public:
  // float dist_from_self = 12;
  void clear_dist_from_self() ;
  float dist_from_self() const;
  void set_dist_from_self(float value);

  private:
  float _internal_dist_from_self() const;
  void _internal_set_dist_from_self(float value);

  public:
  // float angle_from_self = 13;
  void clear_angle_from_self() ;
  float angle_from_self() const;
  void set_angle_from_self(float value);

  private:
  float _internal_angle_from_self() const;
  void _internal_set_angle_from_self(float value);

  public:
  // int32 id = 14;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .protos.Side side = 15;
  void clear_side() ;
  ::protos::Side side() const;
  void set_side(::protos::Side value);

  private:
  ::protos::Side _internal_side() const;
  void _internal_set_side(::protos::Side value);

  public:
  // int32 uniform_number = 16;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // int32 uniform_number_count = 17;
  void clear_uniform_number_count() ;
  ::int32_t uniform_number_count() const;
  void set_uniform_number_count(::int32_t value);

  private:
  ::int32_t _internal_uniform_number_count() const;
  void _internal_set_uniform_number_count(::int32_t value);

  public:
  // float body_direction = 19;
  void clear_body_direction() ;
  float body_direction() const;
  void set_body_direction(float value);

  private:
  float _internal_body_direction() const;
  void _internal_set_body_direction(float value);

  public:
  // int32 body_direction_count = 20;
  void clear_body_direction_count() ;
  ::int32_t body_direction_count() const;
  void set_body_direction_count(::int32_t value);

  private:
  ::int32_t _internal_body_direction_count() const;
  void _internal_set_body_direction_count(::int32_t value);

  public:
  // float face_direction = 21;
  void clear_face_direction() ;
  float face_direction() const;
  void set_face_direction(float value);

  private:
  float _internal_face_direction() const;
  void _internal_set_face_direction(float value);

  public:
  // int32 face_direction_count = 22;
  void clear_face_direction_count() ;
  ::int32_t face_direction_count() const;
  void set_face_direction_count(::int32_t value);

  private:
  ::int32_t _internal_face_direction_count() const;
  void _internal_set_face_direction_count(::int32_t value);

  public:
  // float point_to_direction = 23;
  void clear_point_to_direction() ;
  float point_to_direction() const;
  void set_point_to_direction(float value);

  private:
  float _internal_point_to_direction() const;
  void _internal_set_point_to_direction(float value);

  public:
  // int32 point_to_direction_count = 24;
  void clear_point_to_direction_count() ;
  ::int32_t point_to_direction_count() const;
  void set_point_to_direction_count(::int32_t value);

  private:
  ::int32_t _internal_point_to_direction_count() const;
  void _internal_set_point_to_direction_count(::int32_t value);

  public:
  // bool is_goalie = 18;
  void clear_is_goalie() ;
  bool is_goalie() const;
  void set_is_goalie(bool value);

  private:
  bool _internal_is_goalie() const;
  void _internal_set_is_goalie(bool value);

  public:
  // bool is_kicking = 25;
  void clear_is_kicking() ;
  bool is_kicking() const;
  void set_is_kicking(bool value);

  private:
  bool _internal_is_kicking() const;
  void _internal_set_is_kicking(bool value);

  public:
  // bool is_tackling = 29;
  void clear_is_tackling() ;
  bool is_tackling() const;
  void set_is_tackling(bool value);

  private:
  bool _internal_is_tackling() const;
  void _internal_set_is_tackling(bool value);

  public:
  // float dist_from_ball = 26;
  void clear_dist_from_ball() ;
  float dist_from_ball() const;
  void set_dist_from_ball(float value);

  private:
  float _internal_dist_from_ball() const;
  void _internal_set_dist_from_ball(float value);

  public:
  // float angle_from_ball = 27;
  void clear_angle_from_ball() ;
  float angle_from_ball() const;
  void set_angle_from_ball(float value);

  private:
  float _internal_angle_from_ball() const;
  void _internal_set_angle_from_ball(float value);

  public:
  // int32 ball_reach_steps = 28;
  void clear_ball_reach_steps() ;
  ::int32_t ball_reach_steps() const;
  void set_ball_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_ball_reach_steps() const;
  void _internal_set_ball_reach_steps(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    ::protos::Vector2D* seen_position_;
    ::protos::Vector2D* heard_position_;
    ::protos::Vector2D* velocity_;
    ::protos::Vector2D* seen_velocity_;
    ::int32_t pos_count_;
    ::int32_t seen_pos_count_;
    ::int32_t heard_pos_count_;
    ::int32_t vel_count_;
    ::int32_t seen_vel_count_;
    ::int32_t ghost_count_;
    float dist_from_self_;
    float angle_from_self_;
    ::int32_t id_;
    int side_;
    ::int32_t uniform_number_;
    ::int32_t uniform_number_count_;
    float body_direction_;
    ::int32_t body_direction_count_;
    float face_direction_;
    ::int32_t face_direction_count_;
    float point_to_direction_;
    ::int32_t point_to_direction_count_;
    bool is_goalie_;
    bool is_kicking_;
    bool is_tackling_;
    float dist_from_ball_;
    float angle_from_ball_;
    ::int32_t ball_reach_steps_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Self final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Self) */ {
 public:
  inline Self() : Self(nullptr) {}
  ~Self() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Self(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Self(const Self& from);
  Self(Self&& from) noexcept
    : Self() {
    *this = ::std::move(from);
  }

  inline Self& operator=(const Self& from) {
    CopyFrom(from);
    return *this;
  }
  inline Self& operator=(Self&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Self& default_instance() {
    return *internal_default_instance();
  }
  static inline const Self* internal_default_instance() {
    return reinterpret_cast<const Self*>(
               &_Self_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Self& a, Self& b) {
    a.Swap(&b);
  }
  inline void Swap(Self* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Self* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Self* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Self>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Self& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Self& from) {
    Self::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Self* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Self";
  }
  protected:
  explicit Self(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kSeenPositionFieldNumber = 2,
    kHeardPositionFieldNumber = 3,
    kVelocityFieldNumber = 4,
    kSeenVelocityFieldNumber = 5,
    kPosCountFieldNumber = 6,
    kSeenPosCountFieldNumber = 7,
    kHeardPosCountFieldNumber = 8,
    kVelCountFieldNumber = 9,
    kSeenVelCountFieldNumber = 10,
    kGhostCountFieldNumber = 11,
    kIdFieldNumber = 12,
    kSideFieldNumber = 13,
    kUniformNumberFieldNumber = 14,
    kUniformNumberCountFieldNumber = 15,
    kBodyDirectionFieldNumber = 17,
    kBodyDirectionCountFieldNumber = 18,
    kFaceDirectionFieldNumber = 19,
    kFaceDirectionCountFieldNumber = 20,
    kPointToDirectionFieldNumber = 21,
    kPointToDirectionCountFieldNumber = 22,
    kDistFromBallFieldNumber = 24,
    kIsGoalieFieldNumber = 16,
    kIsKickingFieldNumber = 23,
    kIsTacklingFieldNumber = 27,
    kIsKickableFieldNumber = 30,
    kAngleFromBallFieldNumber = 25,
    kBallReachStepsFieldNumber = 26,
    kRelativeNeckDirectionFieldNumber = 28,
    kStaminaFieldNumber = 29,
    kCatchProbabilityFieldNumber = 31,
    kTackleProbabilityFieldNumber = 32,
    kFoulProbabilityFieldNumber = 33,
    kViewWidthFieldNumber = 34,
  };
  // .protos.Vector2D position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* position);
  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protos::Vector2D* position);
  ::protos::Vector2D* unsafe_arena_release_position();
  // .protos.Vector2D seen_position = 2;
  bool has_seen_position() const;
  void clear_seen_position() ;
  const ::protos::Vector2D& seen_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_position();
  ::protos::Vector2D* mutable_seen_position();
  void set_allocated_seen_position(::protos::Vector2D* seen_position);
  private:
  const ::protos::Vector2D& _internal_seen_position() const;
  ::protos::Vector2D* _internal_mutable_seen_position();
  public:
  void unsafe_arena_set_allocated_seen_position(
      ::protos::Vector2D* seen_position);
  ::protos::Vector2D* unsafe_arena_release_seen_position();
  // .protos.Vector2D heard_position = 3;
  bool has_heard_position() const;
  void clear_heard_position() ;
  const ::protos::Vector2D& heard_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_heard_position();
  ::protos::Vector2D* mutable_heard_position();
  void set_allocated_heard_position(::protos::Vector2D* heard_position);
  private:
  const ::protos::Vector2D& _internal_heard_position() const;
  ::protos::Vector2D* _internal_mutable_heard_position();
  public:
  void unsafe_arena_set_allocated_heard_position(
      ::protos::Vector2D* heard_position);
  ::protos::Vector2D* unsafe_arena_release_heard_position();
  // .protos.Vector2D velocity = 4;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::protos::Vector2D& velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_velocity();
  ::protos::Vector2D* mutable_velocity();
  void set_allocated_velocity(::protos::Vector2D* velocity);
  private:
  const ::protos::Vector2D& _internal_velocity() const;
  ::protos::Vector2D* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::protos::Vector2D* velocity);
  ::protos::Vector2D* unsafe_arena_release_velocity();
  // .protos.Vector2D seen_velocity = 5;
  bool has_seen_velocity() const;
  void clear_seen_velocity() ;
  const ::protos::Vector2D& seen_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_velocity();
  ::protos::Vector2D* mutable_seen_velocity();
  void set_allocated_seen_velocity(::protos::Vector2D* seen_velocity);
  private:
  const ::protos::Vector2D& _internal_seen_velocity() const;
  ::protos::Vector2D* _internal_mutable_seen_velocity();
  public:
  void unsafe_arena_set_allocated_seen_velocity(
      ::protos::Vector2D* seen_velocity);
  ::protos::Vector2D* unsafe_arena_release_seen_velocity();
  // int32 pos_count = 6;
  void clear_pos_count() ;
  ::int32_t pos_count() const;
  void set_pos_count(::int32_t value);

  private:
  ::int32_t _internal_pos_count() const;
  void _internal_set_pos_count(::int32_t value);

  public:
  // int32 seen_pos_count = 7;
  void clear_seen_pos_count() ;
  ::int32_t seen_pos_count() const;
  void set_seen_pos_count(::int32_t value);

  private:
  ::int32_t _internal_seen_pos_count() const;
  void _internal_set_seen_pos_count(::int32_t value);

  public:
  // int32 heard_pos_count = 8;
  void clear_heard_pos_count() ;
  ::int32_t heard_pos_count() const;
  void set_heard_pos_count(::int32_t value);

  private:
  ::int32_t _internal_heard_pos_count() const;
  void _internal_set_heard_pos_count(::int32_t value);

  public:
  // int32 vel_count = 9;
  void clear_vel_count() ;
  ::int32_t vel_count() const;
  void set_vel_count(::int32_t value);

  private:
  ::int32_t _internal_vel_count() const;
  void _internal_set_vel_count(::int32_t value);

  public:
  // int32 seen_vel_count = 10;
  void clear_seen_vel_count() ;
  ::int32_t seen_vel_count() const;
  void set_seen_vel_count(::int32_t value);

  private:
  ::int32_t _internal_seen_vel_count() const;
  void _internal_set_seen_vel_count(::int32_t value);

  public:
  // int32 ghost_count = 11;
  void clear_ghost_count() ;
  ::int32_t ghost_count() const;
  void set_ghost_count(::int32_t value);

  private:
  ::int32_t _internal_ghost_count() const;
  void _internal_set_ghost_count(::int32_t value);

  public:
  // int32 id = 12;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .protos.Side side = 13;
  void clear_side() ;
  ::protos::Side side() const;
  void set_side(::protos::Side value);

  private:
  ::protos::Side _internal_side() const;
  void _internal_set_side(::protos::Side value);

  public:
  // int32 uniform_number = 14;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // int32 uniform_number_count = 15;
  void clear_uniform_number_count() ;
  ::int32_t uniform_number_count() const;
  void set_uniform_number_count(::int32_t value);

  private:
  ::int32_t _internal_uniform_number_count() const;
  void _internal_set_uniform_number_count(::int32_t value);

  public:
  // float body_direction = 17;
  void clear_body_direction() ;
  float body_direction() const;
  void set_body_direction(float value);

  private:
  float _internal_body_direction() const;
  void _internal_set_body_direction(float value);

  public:
  // int32 body_direction_count = 18;
  void clear_body_direction_count() ;
  ::int32_t body_direction_count() const;
  void set_body_direction_count(::int32_t value);

  private:
  ::int32_t _internal_body_direction_count() const;
  void _internal_set_body_direction_count(::int32_t value);

  public:
  // float face_direction = 19;
  void clear_face_direction() ;
  float face_direction() const;
  void set_face_direction(float value);

  private:
  float _internal_face_direction() const;
  void _internal_set_face_direction(float value);

  public:
  // int32 face_direction_count = 20;
  void clear_face_direction_count() ;
  ::int32_t face_direction_count() const;
  void set_face_direction_count(::int32_t value);

  private:
  ::int32_t _internal_face_direction_count() const;
  void _internal_set_face_direction_count(::int32_t value);

  public:
  // float point_to_direction = 21;
  void clear_point_to_direction() ;
  float point_to_direction() const;
  void set_point_to_direction(float value);

  private:
  float _internal_point_to_direction() const;
  void _internal_set_point_to_direction(float value);

  public:
  // int32 point_to_direction_count = 22;
  void clear_point_to_direction_count() ;
  ::int32_t point_to_direction_count() const;
  void set_point_to_direction_count(::int32_t value);

  private:
  ::int32_t _internal_point_to_direction_count() const;
  void _internal_set_point_to_direction_count(::int32_t value);

  public:
  // float dist_from_ball = 24;
  void clear_dist_from_ball() ;
  float dist_from_ball() const;
  void set_dist_from_ball(float value);

  private:
  float _internal_dist_from_ball() const;
  void _internal_set_dist_from_ball(float value);

  public:
  // bool is_goalie = 16;
  void clear_is_goalie() ;
  bool is_goalie() const;
  void set_is_goalie(bool value);

  private:
  bool _internal_is_goalie() const;
  void _internal_set_is_goalie(bool value);

  public:
  // bool is_kicking = 23;
  void clear_is_kicking() ;
  bool is_kicking() const;
  void set_is_kicking(bool value);

  private:
  bool _internal_is_kicking() const;
  void _internal_set_is_kicking(bool value);

  public:
  // bool is_tackling = 27;
  void clear_is_tackling() ;
  bool is_tackling() const;
  void set_is_tackling(bool value);

  private:
  bool _internal_is_tackling() const;
  void _internal_set_is_tackling(bool value);

  public:
  // bool is_kickable = 30;
  void clear_is_kickable() ;
  bool is_kickable() const;
  void set_is_kickable(bool value);

  private:
  bool _internal_is_kickable() const;
  void _internal_set_is_kickable(bool value);

  public:
  // float angle_from_ball = 25;
  void clear_angle_from_ball() ;
  float angle_from_ball() const;
  void set_angle_from_ball(float value);

  private:
  float _internal_angle_from_ball() const;
  void _internal_set_angle_from_ball(float value);

  public:
  // int32 ball_reach_steps = 26;
  void clear_ball_reach_steps() ;
  ::int32_t ball_reach_steps() const;
  void set_ball_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_ball_reach_steps() const;
  void _internal_set_ball_reach_steps(::int32_t value);

  public:
  // float relative_neck_direction = 28;
  void clear_relative_neck_direction() ;
  float relative_neck_direction() const;
  void set_relative_neck_direction(float value);

  private:
  float _internal_relative_neck_direction() const;
  void _internal_set_relative_neck_direction(float value);

  public:
  // float stamina = 29;
  void clear_stamina() ;
  float stamina() const;
  void set_stamina(float value);

  private:
  float _internal_stamina() const;
  void _internal_set_stamina(float value);

  public:
  // float catch_probability = 31;
  void clear_catch_probability() ;
  float catch_probability() const;
  void set_catch_probability(float value);

  private:
  float _internal_catch_probability() const;
  void _internal_set_catch_probability(float value);

  public:
  // float tackle_probability = 32;
  void clear_tackle_probability() ;
  float tackle_probability() const;
  void set_tackle_probability(float value);

  private:
  float _internal_tackle_probability() const;
  void _internal_set_tackle_probability(float value);

  public:
  // float foul_probability = 33;
  void clear_foul_probability() ;
  float foul_probability() const;
  void set_foul_probability(float value);

  private:
  float _internal_foul_probability() const;
  void _internal_set_foul_probability(float value);

  public:
  // .protos.ViewWidth view_width = 34;
  void clear_view_width() ;
  ::protos::ViewWidth view_width() const;
  void set_view_width(::protos::ViewWidth value);

  private:
  ::protos::ViewWidth _internal_view_width() const;
  void _internal_set_view_width(::protos::ViewWidth value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Self)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    ::protos::Vector2D* seen_position_;
    ::protos::Vector2D* heard_position_;
    ::protos::Vector2D* velocity_;
    ::protos::Vector2D* seen_velocity_;
    ::int32_t pos_count_;
    ::int32_t seen_pos_count_;
    ::int32_t heard_pos_count_;
    ::int32_t vel_count_;
    ::int32_t seen_vel_count_;
    ::int32_t ghost_count_;
    ::int32_t id_;
    int side_;
    ::int32_t uniform_number_;
    ::int32_t uniform_number_count_;
    float body_direction_;
    ::int32_t body_direction_count_;
    float face_direction_;
    ::int32_t face_direction_count_;
    float point_to_direction_;
    ::int32_t point_to_direction_count_;
    float dist_from_ball_;
    bool is_goalie_;
    bool is_kicking_;
    bool is_tackling_;
    bool is_kickable_;
    float angle_from_ball_;
    ::int32_t ball_reach_steps_;
    float relative_neck_direction_;
    float stamina_;
    float catch_probability_;
    float tackle_probability_;
    float foul_probability_;
    int view_width_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class InterceptInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.InterceptInfo) */ {
 public:
  inline InterceptInfo() : InterceptInfo(nullptr) {}
  ~InterceptInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InterceptInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterceptInfo(const InterceptInfo& from);
  InterceptInfo(InterceptInfo&& from) noexcept
    : InterceptInfo() {
    *this = ::std::move(from);
  }

  inline InterceptInfo& operator=(const InterceptInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterceptInfo& operator=(InterceptInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterceptInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterceptInfo* internal_default_instance() {
    return reinterpret_cast<const InterceptInfo*>(
               &_InterceptInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InterceptInfo& a, InterceptInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(InterceptInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterceptInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterceptInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterceptInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterceptInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterceptInfo& from) {
    InterceptInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterceptInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.InterceptInfo";
  }
  protected:
  explicit InterceptInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFinalSelfPositionFieldNumber = 7,
    kActionTypeFieldNumber = 1,
    kTurnStepsFieldNumber = 2,
    kTurnAngleFieldNumber = 3,
    kDashStepsFieldNumber = 4,
    kDashPowerFieldNumber = 5,
    kDashDirFieldNumber = 6,
    kFinalBallDistFieldNumber = 8,
    kFinalStaminaFieldNumber = 9,
    kValueFieldNumber = 10,
  };
  // .protos.Vector2D final_self_position = 7;
  bool has_final_self_position() const;
  void clear_final_self_position() ;
  const ::protos::Vector2D& final_self_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_final_self_position();
  ::protos::Vector2D* mutable_final_self_position();
  void set_allocated_final_self_position(::protos::Vector2D* final_self_position);
  private:
  const ::protos::Vector2D& _internal_final_self_position() const;
  ::protos::Vector2D* _internal_mutable_final_self_position();
  public:
  void unsafe_arena_set_allocated_final_self_position(
      ::protos::Vector2D* final_self_position);
  ::protos::Vector2D* unsafe_arena_release_final_self_position();
  // .protos.InterceptActionType action_type = 1;
  void clear_action_type() ;
  ::protos::InterceptActionType action_type() const;
  void set_action_type(::protos::InterceptActionType value);

  private:
  ::protos::InterceptActionType _internal_action_type() const;
  void _internal_set_action_type(::protos::InterceptActionType value);

  public:
  // int32 turn_steps = 2;
  void clear_turn_steps() ;
  ::int32_t turn_steps() const;
  void set_turn_steps(::int32_t value);

  private:
  ::int32_t _internal_turn_steps() const;
  void _internal_set_turn_steps(::int32_t value);

  public:
  // float turn_angle = 3;
  void clear_turn_angle() ;
  float turn_angle() const;
  void set_turn_angle(float value);

  private:
  float _internal_turn_angle() const;
  void _internal_set_turn_angle(float value);

  public:
  // int32 dash_steps = 4;
  void clear_dash_steps() ;
  ::int32_t dash_steps() const;
  void set_dash_steps(::int32_t value);

  private:
  ::int32_t _internal_dash_steps() const;
  void _internal_set_dash_steps(::int32_t value);

  public:
  // float dash_power = 5;
  void clear_dash_power() ;
  float dash_power() const;
  void set_dash_power(float value);

  private:
  float _internal_dash_power() const;
  void _internal_set_dash_power(float value);

  public:
  // float dash_dir = 6;
  void clear_dash_dir() ;
  float dash_dir() const;
  void set_dash_dir(float value);

  private:
  float _internal_dash_dir() const;
  void _internal_set_dash_dir(float value);

  public:
  // float final_ball_dist = 8;
  void clear_final_ball_dist() ;
  float final_ball_dist() const;
  void set_final_ball_dist(float value);

  private:
  float _internal_final_ball_dist() const;
  void _internal_set_final_ball_dist(float value);

  public:
  // float final_stamina = 9;
  void clear_final_stamina() ;
  float final_stamina() const;
  void set_final_stamina(float value);

  private:
  float _internal_final_stamina() const;
  void _internal_set_final_stamina(float value);

  public:
  // float value = 10;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.InterceptInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* final_self_position_;
    int action_type_;
    ::int32_t turn_steps_;
    float turn_angle_;
    ::int32_t dash_steps_;
    float dash_power_;
    float dash_dir_;
    float final_ball_dist_;
    float final_stamina_;
    float value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class InterceptTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.InterceptTable) */ {
 public:
  inline InterceptTable() : InterceptTable(nullptr) {}
  ~InterceptTable() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InterceptTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterceptTable(const InterceptTable& from);
  InterceptTable(InterceptTable&& from) noexcept
    : InterceptTable() {
    *this = ::std::move(from);
  }

  inline InterceptTable& operator=(const InterceptTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterceptTable& operator=(InterceptTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterceptTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterceptTable* internal_default_instance() {
    return reinterpret_cast<const InterceptTable*>(
               &_InterceptTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InterceptTable& a, InterceptTable& b) {
    a.Swap(&b);
  }
  inline void Swap(InterceptTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterceptTable* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterceptTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterceptTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterceptTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterceptTable& from) {
    InterceptTable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterceptTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.InterceptTable";
  }
  protected:
  explicit InterceptTable(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelfInterceptInfoFieldNumber = 10,
    kSelfReachStepsFieldNumber = 1,
    kFirstTeammateReachStepsFieldNumber = 2,
    kSecondTeammateReachStepsFieldNumber = 3,
    kFirstOpponentReachStepsFieldNumber = 4,
    kSecondOpponentReachStepsFieldNumber = 5,
    kFirstTeammateIdFieldNumber = 6,
    kSecondTeammateIdFieldNumber = 7,
    kFirstOpponentIdFieldNumber = 8,
    kSecondOpponentIdFieldNumber = 9,
  };
  // repeated .protos.InterceptInfo self_intercept_info = 10;
  int self_intercept_info_size() const;
  private:
  int _internal_self_intercept_info_size() const;

  public:
  void clear_self_intercept_info() ;
  ::protos::InterceptInfo* mutable_self_intercept_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::InterceptInfo >*
      mutable_self_intercept_info();
  private:
  const ::protos::InterceptInfo& _internal_self_intercept_info(int index) const;
  ::protos::InterceptInfo* _internal_add_self_intercept_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::InterceptInfo>& _internal_self_intercept_info() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::InterceptInfo>* _internal_mutable_self_intercept_info();
  public:
  const ::protos::InterceptInfo& self_intercept_info(int index) const;
  ::protos::InterceptInfo* add_self_intercept_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::InterceptInfo >&
      self_intercept_info() const;
  // int32 self_reach_steps = 1;
  void clear_self_reach_steps() ;
  ::int32_t self_reach_steps() const;
  void set_self_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_self_reach_steps() const;
  void _internal_set_self_reach_steps(::int32_t value);

  public:
  // int32 first_teammate_reach_steps = 2;
  void clear_first_teammate_reach_steps() ;
  ::int32_t first_teammate_reach_steps() const;
  void set_first_teammate_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_first_teammate_reach_steps() const;
  void _internal_set_first_teammate_reach_steps(::int32_t value);

  public:
  // int32 second_teammate_reach_steps = 3;
  void clear_second_teammate_reach_steps() ;
  ::int32_t second_teammate_reach_steps() const;
  void set_second_teammate_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_second_teammate_reach_steps() const;
  void _internal_set_second_teammate_reach_steps(::int32_t value);

  public:
  // int32 first_opponent_reach_steps = 4;
  void clear_first_opponent_reach_steps() ;
  ::int32_t first_opponent_reach_steps() const;
  void set_first_opponent_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_first_opponent_reach_steps() const;
  void _internal_set_first_opponent_reach_steps(::int32_t value);

  public:
  // int32 second_opponent_reach_steps = 5;
  void clear_second_opponent_reach_steps() ;
  ::int32_t second_opponent_reach_steps() const;
  void set_second_opponent_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_second_opponent_reach_steps() const;
  void _internal_set_second_opponent_reach_steps(::int32_t value);

  public:
  // int32 first_teammate_id = 6;
  void clear_first_teammate_id() ;
  ::int32_t first_teammate_id() const;
  void set_first_teammate_id(::int32_t value);

  private:
  ::int32_t _internal_first_teammate_id() const;
  void _internal_set_first_teammate_id(::int32_t value);

  public:
  // int32 second_teammate_id = 7;
  void clear_second_teammate_id() ;
  ::int32_t second_teammate_id() const;
  void set_second_teammate_id(::int32_t value);

  private:
  ::int32_t _internal_second_teammate_id() const;
  void _internal_set_second_teammate_id(::int32_t value);

  public:
  // int32 first_opponent_id = 8;
  void clear_first_opponent_id() ;
  ::int32_t first_opponent_id() const;
  void set_first_opponent_id(::int32_t value);

  private:
  ::int32_t _internal_first_opponent_id() const;
  void _internal_set_first_opponent_id(::int32_t value);

  public:
  // int32 second_opponent_id = 9;
  void clear_second_opponent_id() ;
  ::int32_t second_opponent_id() const;
  void set_second_opponent_id(::int32_t value);

  private:
  ::int32_t _internal_second_opponent_id() const;
  void _internal_set_second_opponent_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.InterceptTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::InterceptInfo > self_intercept_info_;
    ::int32_t self_reach_steps_;
    ::int32_t first_teammate_reach_steps_;
    ::int32_t second_teammate_reach_steps_;
    ::int32_t first_opponent_reach_steps_;
    ::int32_t second_opponent_reach_steps_;
    ::int32_t first_teammate_id_;
    ::int32_t second_teammate_id_;
    ::int32_t first_opponent_id_;
    ::int32_t second_opponent_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class WorldModel_OurPlayersDictEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WorldModel_OurPlayersDictEntry_DoNotUse, 
    ::int32_t, ::protos::Player,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WorldModel_OurPlayersDictEntry_DoNotUse, 
    ::int32_t, ::protos::Player,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  WorldModel_OurPlayersDictEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorldModel_OurPlayersDictEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WorldModel_OurPlayersDictEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WorldModel_OurPlayersDictEntry_DoNotUse& other);
  static const WorldModel_OurPlayersDictEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WorldModel_OurPlayersDictEntry_DoNotUse*>(&_WorldModel_OurPlayersDictEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class WorldModel_TheirPlayersDictEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WorldModel_TheirPlayersDictEntry_DoNotUse, 
    ::int32_t, ::protos::Player,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WorldModel_TheirPlayersDictEntry_DoNotUse, 
    ::int32_t, ::protos::Player,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  WorldModel_TheirPlayersDictEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorldModel_TheirPlayersDictEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WorldModel_TheirPlayersDictEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WorldModel_TheirPlayersDictEntry_DoNotUse& other);
  static const WorldModel_TheirPlayersDictEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WorldModel_TheirPlayersDictEntry_DoNotUse*>(&_WorldModel_TheirPlayersDictEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class WorldModel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.WorldModel) */ {
 public:
  inline WorldModel() : WorldModel(nullptr) {}
  ~WorldModel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorldModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorldModel(const WorldModel& from);
  WorldModel(WorldModel&& from) noexcept
    : WorldModel() {
    *this = ::std::move(from);
  }

  inline WorldModel& operator=(const WorldModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldModel& operator=(WorldModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorldModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorldModel* internal_default_instance() {
    return reinterpret_cast<const WorldModel*>(
               &_WorldModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(WorldModel& a, WorldModel& b) {
    a.Swap(&b);
  }
  inline void Swap(WorldModel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldModel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorldModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorldModel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorldModel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorldModel& from) {
    WorldModel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorldModel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.WorldModel";
  }
  protected:
  explicit WorldModel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTeammatesFieldNumber = 8,
    kOpponentsFieldNumber = 9,
    kUnknownsFieldNumber = 10,
    kOurPlayersDictFieldNumber = 11,
    kTheirPlayersDictFieldNumber = 12,
    kOurTeamNameFieldNumber = 2,
    kTheirTeamNameFieldNumber = 3,
    kInterceptTableFieldNumber = 1,
    kSelfFieldNumber = 6,
    kBallFieldNumber = 7,
    kOurSideFieldNumber = 4,
    kLastSetPlayStartTimeFieldNumber = 5,
    kOurGoalieUniformNumberFieldNumber = 13,
    kTheirGoalieUniformNumberFieldNumber = 14,
    kOffsideLineXFieldNumber = 15,
    kOfsideLineXCountFieldNumber = 16,
    kKickableTeammateIdFieldNumber = 17,
    kKickableOpponentIdFieldNumber = 18,
    kLastKickSideFieldNumber = 19,
    kLastKickerUniformNumberFieldNumber = 20,
    kCycleFieldNumber = 21,
    kGameModeTypeFieldNumber = 22,
    kLeftTeamScoreFieldNumber = 23,
    kRightTeamScoreFieldNumber = 24,
    kIsOurSetPlayFieldNumber = 25,
    kIsTheirSetPlayFieldNumber = 26,
    kStopedCycleFieldNumber = 27,
    kOurTeamScoreFieldNumber = 28,
    kTheirTeamScoreFieldNumber = 29,
  };
  // repeated .protos.Player teammates = 8;
  int teammates_size() const;
  private:
  int _internal_teammates_size() const;

  public:
  void clear_teammates() ;
  ::protos::Player* mutable_teammates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >*
      mutable_teammates();
  private:
  const ::protos::Player& _internal_teammates(int index) const;
  ::protos::Player* _internal_add_teammates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>& _internal_teammates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>* _internal_mutable_teammates();
  public:
  const ::protos::Player& teammates(int index) const;
  ::protos::Player* add_teammates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >&
      teammates() const;
  // repeated .protos.Player opponents = 9;
  int opponents_size() const;
  private:
  int _internal_opponents_size() const;

  public:
  void clear_opponents() ;
  ::protos::Player* mutable_opponents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >*
      mutable_opponents();
  private:
  const ::protos::Player& _internal_opponents(int index) const;
  ::protos::Player* _internal_add_opponents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>& _internal_opponents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>* _internal_mutable_opponents();
  public:
  const ::protos::Player& opponents(int index) const;
  ::protos::Player* add_opponents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >&
      opponents() const;
  // repeated .protos.Player unknowns = 10;
  int unknowns_size() const;
  private:
  int _internal_unknowns_size() const;

  public:
  void clear_unknowns() ;
  ::protos::Player* mutable_unknowns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >*
      mutable_unknowns();
  private:
  const ::protos::Player& _internal_unknowns(int index) const;
  ::protos::Player* _internal_add_unknowns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>& _internal_unknowns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>* _internal_mutable_unknowns();
  public:
  const ::protos::Player& unknowns(int index) const;
  ::protos::Player* add_unknowns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >&
      unknowns() const;
  // map<int32, .protos.Player> our_players_dict = 11;
  int our_players_dict_size() const;
  private:
  int _internal_our_players_dict_size() const;

  public:
  void clear_our_players_dict() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >&
      _internal_our_players_dict() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >*
      _internal_mutable_our_players_dict();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >&
      our_players_dict() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >*
      mutable_our_players_dict();
  // map<int32, .protos.Player> their_players_dict = 12;
  int their_players_dict_size() const;
  private:
  int _internal_their_players_dict_size() const;

  public:
  void clear_their_players_dict() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >&
      _internal_their_players_dict() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >*
      _internal_mutable_their_players_dict();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >&
      their_players_dict() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >*
      mutable_their_players_dict();
  // string our_team_name = 2;
  void clear_our_team_name() ;
  const std::string& our_team_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_our_team_name(Arg_&& arg, Args_... args);
  std::string* mutable_our_team_name();
  PROTOBUF_NODISCARD std::string* release_our_team_name();
  void set_allocated_our_team_name(std::string* ptr);

  private:
  const std::string& _internal_our_team_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_our_team_name(
      const std::string& value);
  std::string* _internal_mutable_our_team_name();

  public:
  // string their_team_name = 3;
  void clear_their_team_name() ;
  const std::string& their_team_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_their_team_name(Arg_&& arg, Args_... args);
  std::string* mutable_their_team_name();
  PROTOBUF_NODISCARD std::string* release_their_team_name();
  void set_allocated_their_team_name(std::string* ptr);

  private:
  const std::string& _internal_their_team_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_their_team_name(
      const std::string& value);
  std::string* _internal_mutable_their_team_name();

  public:
  // .protos.InterceptTable intercept_table = 1;
  bool has_intercept_table() const;
  void clear_intercept_table() ;
  const ::protos::InterceptTable& intercept_table() const;
  PROTOBUF_NODISCARD ::protos::InterceptTable* release_intercept_table();
  ::protos::InterceptTable* mutable_intercept_table();
  void set_allocated_intercept_table(::protos::InterceptTable* intercept_table);
  private:
  const ::protos::InterceptTable& _internal_intercept_table() const;
  ::protos::InterceptTable* _internal_mutable_intercept_table();
  public:
  void unsafe_arena_set_allocated_intercept_table(
      ::protos::InterceptTable* intercept_table);
  ::protos::InterceptTable* unsafe_arena_release_intercept_table();
  // .protos.Self self = 6;
  bool has_self() const;
  void clear_self() ;
  const ::protos::Self& self() const;
  PROTOBUF_NODISCARD ::protos::Self* release_self();
  ::protos::Self* mutable_self();
  void set_allocated_self(::protos::Self* self);
  private:
  const ::protos::Self& _internal_self() const;
  ::protos::Self* _internal_mutable_self();
  public:
  void unsafe_arena_set_allocated_self(
      ::protos::Self* self);
  ::protos::Self* unsafe_arena_release_self();
  // .protos.Ball ball = 7;
  bool has_ball() const;
  void clear_ball() ;
  const ::protos::Ball& ball() const;
  PROTOBUF_NODISCARD ::protos::Ball* release_ball();
  ::protos::Ball* mutable_ball();
  void set_allocated_ball(::protos::Ball* ball);
  private:
  const ::protos::Ball& _internal_ball() const;
  ::protos::Ball* _internal_mutable_ball();
  public:
  void unsafe_arena_set_allocated_ball(
      ::protos::Ball* ball);
  ::protos::Ball* unsafe_arena_release_ball();
  // .protos.Side our_side = 4;
  void clear_our_side() ;
  ::protos::Side our_side() const;
  void set_our_side(::protos::Side value);

  private:
  ::protos::Side _internal_our_side() const;
  void _internal_set_our_side(::protos::Side value);

  public:
  // int32 last_set_play_start_time = 5;
  void clear_last_set_play_start_time() ;
  ::int32_t last_set_play_start_time() const;
  void set_last_set_play_start_time(::int32_t value);

  private:
  ::int32_t _internal_last_set_play_start_time() const;
  void _internal_set_last_set_play_start_time(::int32_t value);

  public:
  // int32 our_goalie_uniform_number = 13;
  void clear_our_goalie_uniform_number() ;
  ::int32_t our_goalie_uniform_number() const;
  void set_our_goalie_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_our_goalie_uniform_number() const;
  void _internal_set_our_goalie_uniform_number(::int32_t value);

  public:
  // int32 their_goalie_uniform_number = 14;
  void clear_their_goalie_uniform_number() ;
  ::int32_t their_goalie_uniform_number() const;
  void set_their_goalie_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_their_goalie_uniform_number() const;
  void _internal_set_their_goalie_uniform_number(::int32_t value);

  public:
  // float offside_line_x = 15;
  void clear_offside_line_x() ;
  float offside_line_x() const;
  void set_offside_line_x(float value);

  private:
  float _internal_offside_line_x() const;
  void _internal_set_offside_line_x(float value);

  public:
  // int32 ofside_line_x_count = 16;
  void clear_ofside_line_x_count() ;
  ::int32_t ofside_line_x_count() const;
  void set_ofside_line_x_count(::int32_t value);

  private:
  ::int32_t _internal_ofside_line_x_count() const;
  void _internal_set_ofside_line_x_count(::int32_t value);

  public:
  // int32 kickable_teammate_id = 17;
  void clear_kickable_teammate_id() ;
  ::int32_t kickable_teammate_id() const;
  void set_kickable_teammate_id(::int32_t value);

  private:
  ::int32_t _internal_kickable_teammate_id() const;
  void _internal_set_kickable_teammate_id(::int32_t value);

  public:
  // int32 kickable_opponent_id = 18;
  void clear_kickable_opponent_id() ;
  ::int32_t kickable_opponent_id() const;
  void set_kickable_opponent_id(::int32_t value);

  private:
  ::int32_t _internal_kickable_opponent_id() const;
  void _internal_set_kickable_opponent_id(::int32_t value);

  public:
  // .protos.Side last_kick_side = 19;
  void clear_last_kick_side() ;
  ::protos::Side last_kick_side() const;
  void set_last_kick_side(::protos::Side value);

  private:
  ::protos::Side _internal_last_kick_side() const;
  void _internal_set_last_kick_side(::protos::Side value);

  public:
  // int32 last_kicker_uniform_number = 20;
  void clear_last_kicker_uniform_number() ;
  ::int32_t last_kicker_uniform_number() const;
  void set_last_kicker_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_last_kicker_uniform_number() const;
  void _internal_set_last_kicker_uniform_number(::int32_t value);

  public:
  // int32 cycle = 21;
  void clear_cycle() ;
  ::int32_t cycle() const;
  void set_cycle(::int32_t value);

  private:
  ::int32_t _internal_cycle() const;
  void _internal_set_cycle(::int32_t value);

  public:
  // .protos.GameModeType game_mode_type = 22;
  void clear_game_mode_type() ;
  ::protos::GameModeType game_mode_type() const;
  void set_game_mode_type(::protos::GameModeType value);

  private:
  ::protos::GameModeType _internal_game_mode_type() const;
  void _internal_set_game_mode_type(::protos::GameModeType value);

  public:
  // int32 left_team_score = 23;
  void clear_left_team_score() ;
  ::int32_t left_team_score() const;
  void set_left_team_score(::int32_t value);

  private:
  ::int32_t _internal_left_team_score() const;
  void _internal_set_left_team_score(::int32_t value);

  public:
  // int32 right_team_score = 24;
  void clear_right_team_score() ;
  ::int32_t right_team_score() const;
  void set_right_team_score(::int32_t value);

  private:
  ::int32_t _internal_right_team_score() const;
  void _internal_set_right_team_score(::int32_t value);

  public:
  // bool is_our_set_play = 25;
  void clear_is_our_set_play() ;
  bool is_our_set_play() const;
  void set_is_our_set_play(bool value);

  private:
  bool _internal_is_our_set_play() const;
  void _internal_set_is_our_set_play(bool value);

  public:
  // bool is_their_set_play = 26;
  void clear_is_their_set_play() ;
  bool is_their_set_play() const;
  void set_is_their_set_play(bool value);

  private:
  bool _internal_is_their_set_play() const;
  void _internal_set_is_their_set_play(bool value);

  public:
  // int32 stoped_cycle = 27;
  void clear_stoped_cycle() ;
  ::int32_t stoped_cycle() const;
  void set_stoped_cycle(::int32_t value);

  private:
  ::int32_t _internal_stoped_cycle() const;
  void _internal_set_stoped_cycle(::int32_t value);

  public:
  // int32 our_team_score = 28;
  void clear_our_team_score() ;
  ::int32_t our_team_score() const;
  void set_our_team_score(::int32_t value);

  private:
  ::int32_t _internal_our_team_score() const;
  void _internal_set_our_team_score(::int32_t value);

  public:
  // int32 their_team_score = 29;
  void clear_their_team_score() ;
  ::int32_t their_team_score() const;
  void set_their_team_score(::int32_t value);

  private:
  ::int32_t _internal_their_team_score() const;
  void _internal_set_their_team_score(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.WorldModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player > teammates_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player > opponents_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player > unknowns_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        WorldModel_OurPlayersDictEntry_DoNotUse,
        ::int32_t, ::protos::Player,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> our_players_dict_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        WorldModel_TheirPlayersDictEntry_DoNotUse,
        ::int32_t, ::protos::Player,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> their_players_dict_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr our_team_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr their_team_name_;
    ::protos::InterceptTable* intercept_table_;
    ::protos::Self* self_;
    ::protos::Ball* ball_;
    int our_side_;
    ::int32_t last_set_play_start_time_;
    ::int32_t our_goalie_uniform_number_;
    ::int32_t their_goalie_uniform_number_;
    float offside_line_x_;
    ::int32_t ofside_line_x_count_;
    ::int32_t kickable_teammate_id_;
    ::int32_t kickable_opponent_id_;
    int last_kick_side_;
    ::int32_t last_kicker_uniform_number_;
    ::int32_t cycle_;
    int game_mode_type_;
    ::int32_t left_team_score_;
    ::int32_t right_team_score_;
    bool is_our_set_play_;
    bool is_their_set_play_;
    ::int32_t stoped_cycle_;
    ::int32_t our_team_score_;
    ::int32_t their_team_score_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class State final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.State) */ {
 public:
  inline State() : State(nullptr) {}
  ~State() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR State(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  State(const State& from);
  State(State&& from) noexcept
    : State() {
    *this = ::std::move(from);
  }

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }
  inline State& operator=(State&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const State& default_instance() {
    return *internal_default_instance();
  }
  static inline const State* internal_default_instance() {
    return reinterpret_cast<const State*>(
               &_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(State& a, State& b) {
    a.Swap(&b);
  }
  inline void Swap(State* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(State* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  State* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<State>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const State& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const State& from) {
    State::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.State";
  }
  protected:
  explicit State(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldModelFieldNumber = 1,
    kFullWorldModelFieldNumber = 2,
  };
  // .protos.WorldModel world_model = 1;
  bool has_world_model() const;
  void clear_world_model() ;
  const ::protos::WorldModel& world_model() const;
  PROTOBUF_NODISCARD ::protos::WorldModel* release_world_model();
  ::protos::WorldModel* mutable_world_model();
  void set_allocated_world_model(::protos::WorldModel* world_model);
  private:
  const ::protos::WorldModel& _internal_world_model() const;
  ::protos::WorldModel* _internal_mutable_world_model();
  public:
  void unsafe_arena_set_allocated_world_model(
      ::protos::WorldModel* world_model);
  ::protos::WorldModel* unsafe_arena_release_world_model();
  // .protos.WorldModel full_world_model = 2;
  bool has_full_world_model() const;
  void clear_full_world_model() ;
  const ::protos::WorldModel& full_world_model() const;
  PROTOBUF_NODISCARD ::protos::WorldModel* release_full_world_model();
  ::protos::WorldModel* mutable_full_world_model();
  void set_allocated_full_world_model(::protos::WorldModel* full_world_model);
  private:
  const ::protos::WorldModel& _internal_full_world_model() const;
  ::protos::WorldModel* _internal_mutable_full_world_model();
  public:
  void unsafe_arena_set_allocated_full_world_model(
      ::protos::WorldModel* full_world_model);
  ::protos::WorldModel* unsafe_arena_release_full_world_model();
  // @@protoc_insertion_point(class_scope:protos.State)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::WorldModel* world_model_;
    ::protos::WorldModel* full_world_model_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Dash final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Dash) */ {
 public:
  inline Dash() : Dash(nullptr) {}
  ~Dash() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Dash(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dash(const Dash& from);
  Dash(Dash&& from) noexcept
    : Dash() {
    *this = ::std::move(from);
  }

  inline Dash& operator=(const Dash& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dash& operator=(Dash&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dash& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dash* internal_default_instance() {
    return reinterpret_cast<const Dash*>(
               &_Dash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Dash& a, Dash& b) {
    a.Swap(&b);
  }
  inline void Swap(Dash* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dash* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dash>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dash& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Dash& from) {
    Dash::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dash* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Dash";
  }
  protected:
  explicit Dash(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPowerFieldNumber = 1,
    kRelativeDirectionFieldNumber = 2,
  };
  // float power = 1;
  void clear_power() ;
  float power() const;
  void set_power(float value);

  private:
  float _internal_power() const;
  void _internal_set_power(float value);

  public:
  // float relative_direction = 2;
  void clear_relative_direction() ;
  float relative_direction() const;
  void set_relative_direction(float value);

  private:
  float _internal_relative_direction() const;
  void _internal_set_relative_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Dash)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float power_;
    float relative_direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Turn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Turn) */ {
 public:
  inline Turn() : Turn(nullptr) {}
  ~Turn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Turn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Turn(const Turn& from);
  Turn(Turn&& from) noexcept
    : Turn() {
    *this = ::std::move(from);
  }

  inline Turn& operator=(const Turn& from) {
    CopyFrom(from);
    return *this;
  }
  inline Turn& operator=(Turn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Turn& default_instance() {
    return *internal_default_instance();
  }
  static inline const Turn* internal_default_instance() {
    return reinterpret_cast<const Turn*>(
               &_Turn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Turn& a, Turn& b) {
    a.Swap(&b);
  }
  inline void Swap(Turn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Turn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Turn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Turn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Turn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Turn& from) {
    Turn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Turn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Turn";
  }
  protected:
  explicit Turn(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelativeDirectionFieldNumber = 1,
  };
  // float relative_direction = 1;
  void clear_relative_direction() ;
  float relative_direction() const;
  void set_relative_direction(float value);

  private:
  float _internal_relative_direction() const;
  void _internal_set_relative_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Turn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float relative_direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Kick final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Kick) */ {
 public:
  inline Kick() : Kick(nullptr) {}
  ~Kick() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Kick(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Kick(const Kick& from);
  Kick(Kick&& from) noexcept
    : Kick() {
    *this = ::std::move(from);
  }

  inline Kick& operator=(const Kick& from) {
    CopyFrom(from);
    return *this;
  }
  inline Kick& operator=(Kick&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Kick& default_instance() {
    return *internal_default_instance();
  }
  static inline const Kick* internal_default_instance() {
    return reinterpret_cast<const Kick*>(
               &_Kick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Kick& a, Kick& b) {
    a.Swap(&b);
  }
  inline void Swap(Kick* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Kick* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Kick* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Kick>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Kick& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Kick& from) {
    Kick::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Kick* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Kick";
  }
  protected:
  explicit Kick(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPowerFieldNumber = 1,
    kRelativeDirectionFieldNumber = 2,
  };
  // float power = 1;
  void clear_power() ;
  float power() const;
  void set_power(float value);

  private:
  float _internal_power() const;
  void _internal_set_power(float value);

  public:
  // float relative_direction = 2;
  void clear_relative_direction() ;
  float relative_direction() const;
  void set_relative_direction(float value);

  private:
  float _internal_relative_direction() const;
  void _internal_set_relative_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Kick)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float power_;
    float relative_direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Tackle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Tackle) */ {
 public:
  inline Tackle() : Tackle(nullptr) {}
  ~Tackle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Tackle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tackle(const Tackle& from);
  Tackle(Tackle&& from) noexcept
    : Tackle() {
    *this = ::std::move(from);
  }

  inline Tackle& operator=(const Tackle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tackle& operator=(Tackle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tackle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tackle* internal_default_instance() {
    return reinterpret_cast<const Tackle*>(
               &_Tackle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Tackle& a, Tackle& b) {
    a.Swap(&b);
  }
  inline void Swap(Tackle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tackle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tackle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tackle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tackle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tackle& from) {
    Tackle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tackle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Tackle";
  }
  protected:
  explicit Tackle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPowerOrDirFieldNumber = 1,
    kFoulFieldNumber = 2,
  };
  // float power_or_dir = 1;
  void clear_power_or_dir() ;
  float power_or_dir() const;
  void set_power_or_dir(float value);

  private:
  float _internal_power_or_dir() const;
  void _internal_set_power_or_dir(float value);

  public:
  // bool foul = 2;
  void clear_foul() ;
  bool foul() const;
  void set_foul(bool value);

  private:
  bool _internal_foul() const;
  void _internal_set_foul(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Tackle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float power_or_dir_;
    bool foul_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Catch final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Catch) */ {
 public:
  inline Catch() : Catch(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Catch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Catch(const Catch& from);
  Catch(Catch&& from) noexcept
    : Catch() {
    *this = ::std::move(from);
  }

  inline Catch& operator=(const Catch& from) {
    CopyFrom(from);
    return *this;
  }
  inline Catch& operator=(Catch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Catch& default_instance() {
    return *internal_default_instance();
  }
  static inline const Catch* internal_default_instance() {
    return reinterpret_cast<const Catch*>(
               &_Catch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Catch& a, Catch& b) {
    a.Swap(&b);
  }
  inline void Swap(Catch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Catch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Catch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Catch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Catch& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Catch& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Catch";
  }
  protected:
  explicit Catch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Catch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Move) */ {
 public:
  inline Move() : Move(nullptr) {}
  ~Move() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Move(const Move& from);
  Move(Move&& from) noexcept
    : Move() {
    *this = ::std::move(from);
  }

  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline Move& operator=(Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const Move* internal_default_instance() {
    return reinterpret_cast<const Move*>(
               &_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Move& a, Move& b) {
    a.Swap(&b);
  }
  inline void Swap(Move* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Move* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Move>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Move& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Move& from) {
    Move::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Move* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Move";
  }
  protected:
  explicit Move(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class TurnNeck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.TurnNeck) */ {
 public:
  inline TurnNeck() : TurnNeck(nullptr) {}
  ~TurnNeck() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TurnNeck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TurnNeck(const TurnNeck& from);
  TurnNeck(TurnNeck&& from) noexcept
    : TurnNeck() {
    *this = ::std::move(from);
  }

  inline TurnNeck& operator=(const TurnNeck& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnNeck& operator=(TurnNeck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TurnNeck& default_instance() {
    return *internal_default_instance();
  }
  static inline const TurnNeck* internal_default_instance() {
    return reinterpret_cast<const TurnNeck*>(
               &_TurnNeck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TurnNeck& a, TurnNeck& b) {
    a.Swap(&b);
  }
  inline void Swap(TurnNeck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnNeck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TurnNeck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TurnNeck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TurnNeck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TurnNeck& from) {
    TurnNeck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TurnNeck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.TurnNeck";
  }
  protected:
  explicit TurnNeck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMomentFieldNumber = 1,
  };
  // float moment = 1;
  void clear_moment() ;
  float moment() const;
  void set_moment(float value);

  private:
  float _internal_moment() const;
  void _internal_set_moment(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.TurnNeck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float moment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class ChangeView final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.ChangeView) */ {
 public:
  inline ChangeView() : ChangeView(nullptr) {}
  ~ChangeView() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChangeView(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeView(const ChangeView& from);
  ChangeView(ChangeView&& from) noexcept
    : ChangeView() {
    *this = ::std::move(from);
  }

  inline ChangeView& operator=(const ChangeView& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeView& operator=(ChangeView&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeView& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeView* internal_default_instance() {
    return reinterpret_cast<const ChangeView*>(
               &_ChangeView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ChangeView& a, ChangeView& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeView* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeView* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeView* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeView>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeView& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeView& from) {
    ChangeView::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeView* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.ChangeView";
  }
  protected:
  explicit ChangeView(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewWidthFieldNumber = 1,
  };
  // .protos.ViewWidth view_width = 1;
  void clear_view_width() ;
  ::protos::ViewWidth view_width() const;
  void set_view_width(::protos::ViewWidth value);

  private:
  ::protos::ViewWidth _internal_view_width() const;
  void _internal_set_view_width(::protos::ViewWidth value);

  public:
  // @@protoc_insertion_point(class_scope:protos.ChangeView)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int view_width_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Say final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Say) */ {
 public:
  inline Say() : Say(nullptr) {}
  ~Say() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Say(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Say(const Say& from);
  Say(Say&& from) noexcept
    : Say() {
    *this = ::std::move(from);
  }

  inline Say& operator=(const Say& from) {
    CopyFrom(from);
    return *this;
  }
  inline Say& operator=(Say&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Say& default_instance() {
    return *internal_default_instance();
  }
  static inline const Say* internal_default_instance() {
    return reinterpret_cast<const Say*>(
               &_Say_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Say& a, Say& b) {
    a.Swap(&b);
  }
  inline void Swap(Say* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Say* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Say* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Say>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Say& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Say& from) {
    Say::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Say* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Say";
  }
  protected:
  explicit Say(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:protos.Say)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class PointTo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.PointTo) */ {
 public:
  inline PointTo() : PointTo(nullptr) {}
  ~PointTo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PointTo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointTo(const PointTo& from);
  PointTo(PointTo&& from) noexcept
    : PointTo() {
    *this = ::std::move(from);
  }

  inline PointTo& operator=(const PointTo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointTo& operator=(PointTo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointTo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointTo* internal_default_instance() {
    return reinterpret_cast<const PointTo*>(
               &_PointTo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PointTo& a, PointTo& b) {
    a.Swap(&b);
  }
  inline void Swap(PointTo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointTo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointTo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointTo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PointTo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PointTo& from) {
    PointTo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointTo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.PointTo";
  }
  protected:
  explicit PointTo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.PointTo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class PointToOf final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.PointToOf) */ {
 public:
  inline PointToOf() : PointToOf(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PointToOf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointToOf(const PointToOf& from);
  PointToOf(PointToOf&& from) noexcept
    : PointToOf() {
    *this = ::std::move(from);
  }

  inline PointToOf& operator=(const PointToOf& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointToOf& operator=(PointToOf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointToOf& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointToOf* internal_default_instance() {
    return reinterpret_cast<const PointToOf*>(
               &_PointToOf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PointToOf& a, PointToOf& b) {
    a.Swap(&b);
  }
  inline void Swap(PointToOf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointToOf* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointToOf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointToOf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PointToOf& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PointToOf& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.PointToOf";
  }
  protected:
  explicit PointToOf(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.PointToOf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AttentionTo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.AttentionTo) */ {
 public:
  inline AttentionTo() : AttentionTo(nullptr) {}
  ~AttentionTo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AttentionTo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttentionTo(const AttentionTo& from);
  AttentionTo(AttentionTo&& from) noexcept
    : AttentionTo() {
    *this = ::std::move(from);
  }

  inline AttentionTo& operator=(const AttentionTo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttentionTo& operator=(AttentionTo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttentionTo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttentionTo* internal_default_instance() {
    return reinterpret_cast<const AttentionTo*>(
               &_AttentionTo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AttentionTo& a, AttentionTo& b) {
    a.Swap(&b);
  }
  inline void Swap(AttentionTo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttentionTo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttentionTo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttentionTo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AttentionTo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AttentionTo& from) {
    AttentionTo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttentionTo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AttentionTo";
  }
  protected:
  explicit AttentionTo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnumFieldNumber = 1,
  };
  // int32 unum = 1;
  void clear_unum() ;
  ::int32_t unum() const;
  void set_unum(::int32_t value);

  private:
  ::int32_t _internal_unum() const;
  void _internal_set_unum(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AttentionTo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t unum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AttentionToOf final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.AttentionToOf) */ {
 public:
  inline AttentionToOf() : AttentionToOf(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AttentionToOf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttentionToOf(const AttentionToOf& from);
  AttentionToOf(AttentionToOf&& from) noexcept
    : AttentionToOf() {
    *this = ::std::move(from);
  }

  inline AttentionToOf& operator=(const AttentionToOf& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttentionToOf& operator=(AttentionToOf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttentionToOf& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttentionToOf* internal_default_instance() {
    return reinterpret_cast<const AttentionToOf*>(
               &_AttentionToOf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(AttentionToOf& a, AttentionToOf& b) {
    a.Swap(&b);
  }
  inline void Swap(AttentionToOf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttentionToOf* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttentionToOf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttentionToOf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AttentionToOf& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AttentionToOf& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AttentionToOf";
  }
  protected:
  explicit AttentionToOf(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.AttentionToOf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Log final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Log) */ {
 public:
  inline Log() : Log(nullptr) {}
  ~Log() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Log(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Log(const Log& from);
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Log& default_instance() {
    return *internal_default_instance();
  }
  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }
  inline void Swap(Log* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Log* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Log* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Log& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Log& from) {
    Log::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Log";
  }
  protected:
  explicit Log(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:protos.Log)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class DebugClient final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.DebugClient) */ {
 public:
  inline DebugClient() : DebugClient(nullptr) {}
  ~DebugClient() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DebugClient(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugClient(const DebugClient& from);
  DebugClient(DebugClient&& from) noexcept
    : DebugClient() {
    *this = ::std::move(from);
  }

  inline DebugClient& operator=(const DebugClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugClient& operator=(DebugClient&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugClient& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugClient* internal_default_instance() {
    return reinterpret_cast<const DebugClient*>(
               &_DebugClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(DebugClient& a, DebugClient& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugClient* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugClient* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugClient>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugClient& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugClient& from) {
    DebugClient::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugClient* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.DebugClient";
  }
  protected:
  explicit DebugClient(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:protos.DebugClient)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Action final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Action) */ {
 public:
  inline Action() : Action(nullptr) {}
  ~Action() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Action(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Action(const Action& from);
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action& operator=(Action&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Action& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kDash = 1,
    kTurn = 2,
    kKick = 3,
    kTackle = 4,
    kCatch = 5,
    kMove = 6,
    kTurnNeck = 7,
    kChangeView = 8,
    kSay = 9,
    kPointTo = 10,
    kPointToOf = 11,
    kAttentionTo = 12,
    kAttentionToOf = 13,
    kLog = 14,
    kDebugClient = 15,
    ACTION_NOT_SET = 0,
  };

  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }
  inline void Swap(Action* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Action& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Action& from) {
    Action::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Action";
  }
  protected:
  explicit Action(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDashFieldNumber = 1,
    kTurnFieldNumber = 2,
    kKickFieldNumber = 3,
    kTackleFieldNumber = 4,
    kCatchFieldNumber = 5,
    kMoveFieldNumber = 6,
    kTurnNeckFieldNumber = 7,
    kChangeViewFieldNumber = 8,
    kSayFieldNumber = 9,
    kPointToFieldNumber = 10,
    kPointToOfFieldNumber = 11,
    kAttentionToFieldNumber = 12,
    kAttentionToOfFieldNumber = 13,
    kLogFieldNumber = 14,
    kDebugClientFieldNumber = 15,
  };
  // .protos.Dash dash = 1;
  bool has_dash() const;
  private:
  bool _internal_has_dash() const;

  public:
  void clear_dash() ;
  const ::protos::Dash& dash() const;
  PROTOBUF_NODISCARD ::protos::Dash* release_dash();
  ::protos::Dash* mutable_dash();
  void set_allocated_dash(::protos::Dash* dash);
  private:
  const ::protos::Dash& _internal_dash() const;
  ::protos::Dash* _internal_mutable_dash();
  public:
  void unsafe_arena_set_allocated_dash(
      ::protos::Dash* dash);
  ::protos::Dash* unsafe_arena_release_dash();
  // .protos.Turn turn = 2;
  bool has_turn() const;
  private:
  bool _internal_has_turn() const;

  public:
  void clear_turn() ;
  const ::protos::Turn& turn() const;
  PROTOBUF_NODISCARD ::protos::Turn* release_turn();
  ::protos::Turn* mutable_turn();
  void set_allocated_turn(::protos::Turn* turn);
  private:
  const ::protos::Turn& _internal_turn() const;
  ::protos::Turn* _internal_mutable_turn();
  public:
  void unsafe_arena_set_allocated_turn(
      ::protos::Turn* turn);
  ::protos::Turn* unsafe_arena_release_turn();
  // .protos.Kick kick = 3;
  bool has_kick() const;
  private:
  bool _internal_has_kick() const;

  public:
  void clear_kick() ;
  const ::protos::Kick& kick() const;
  PROTOBUF_NODISCARD ::protos::Kick* release_kick();
  ::protos::Kick* mutable_kick();
  void set_allocated_kick(::protos::Kick* kick);
  private:
  const ::protos::Kick& _internal_kick() const;
  ::protos::Kick* _internal_mutable_kick();
  public:
  void unsafe_arena_set_allocated_kick(
      ::protos::Kick* kick);
  ::protos::Kick* unsafe_arena_release_kick();
  // .protos.Tackle tackle = 4;
  bool has_tackle() const;
  private:
  bool _internal_has_tackle() const;

  public:
  void clear_tackle() ;
  const ::protos::Tackle& tackle() const;
  PROTOBUF_NODISCARD ::protos::Tackle* release_tackle();
  ::protos::Tackle* mutable_tackle();
  void set_allocated_tackle(::protos::Tackle* tackle);
  private:
  const ::protos::Tackle& _internal_tackle() const;
  ::protos::Tackle* _internal_mutable_tackle();
  public:
  void unsafe_arena_set_allocated_tackle(
      ::protos::Tackle* tackle);
  ::protos::Tackle* unsafe_arena_release_tackle();
  // .protos.Catch catch = 5;
  bool has_catch_() const;
  private:
  bool _internal_has_catch_() const;

  public:
  void clear_catch_() ;
  const ::protos::Catch& catch_() const;
  PROTOBUF_NODISCARD ::protos::Catch* release_catch_();
  ::protos::Catch* mutable_catch_();
  void set_allocated_catch_(::protos::Catch* catch_);
  private:
  const ::protos::Catch& _internal_catch_() const;
  ::protos::Catch* _internal_mutable_catch_();
  public:
  void unsafe_arena_set_allocated_catch_(
      ::protos::Catch* catch_);
  ::protos::Catch* unsafe_arena_release_catch_();
  // .protos.Move move = 6;
  bool has_move() const;
  private:
  bool _internal_has_move() const;

  public:
  void clear_move() ;
  const ::protos::Move& move() const;
  PROTOBUF_NODISCARD ::protos::Move* release_move();
  ::protos::Move* mutable_move();
  void set_allocated_move(::protos::Move* move);
  private:
  const ::protos::Move& _internal_move() const;
  ::protos::Move* _internal_mutable_move();
  public:
  void unsafe_arena_set_allocated_move(
      ::protos::Move* move);
  ::protos::Move* unsafe_arena_release_move();
  // .protos.TurnNeck turn_neck = 7;
  bool has_turn_neck() const;
  private:
  bool _internal_has_turn_neck() const;

  public:
  void clear_turn_neck() ;
  const ::protos::TurnNeck& turn_neck() const;
  PROTOBUF_NODISCARD ::protos::TurnNeck* release_turn_neck();
  ::protos::TurnNeck* mutable_turn_neck();
  void set_allocated_turn_neck(::protos::TurnNeck* turn_neck);
  private:
  const ::protos::TurnNeck& _internal_turn_neck() const;
  ::protos::TurnNeck* _internal_mutable_turn_neck();
  public:
  void unsafe_arena_set_allocated_turn_neck(
      ::protos::TurnNeck* turn_neck);
  ::protos::TurnNeck* unsafe_arena_release_turn_neck();
  // .protos.ChangeView change_view = 8;
  bool has_change_view() const;
  private:
  bool _internal_has_change_view() const;

  public:
  void clear_change_view() ;
  const ::protos::ChangeView& change_view() const;
  PROTOBUF_NODISCARD ::protos::ChangeView* release_change_view();
  ::protos::ChangeView* mutable_change_view();
  void set_allocated_change_view(::protos::ChangeView* change_view);
  private:
  const ::protos::ChangeView& _internal_change_view() const;
  ::protos::ChangeView* _internal_mutable_change_view();
  public:
  void unsafe_arena_set_allocated_change_view(
      ::protos::ChangeView* change_view);
  ::protos::ChangeView* unsafe_arena_release_change_view();
  // .protos.Say say = 9;
  bool has_say() const;
  private:
  bool _internal_has_say() const;

  public:
  void clear_say() ;
  const ::protos::Say& say() const;
  PROTOBUF_NODISCARD ::protos::Say* release_say();
  ::protos::Say* mutable_say();
  void set_allocated_say(::protos::Say* say);
  private:
  const ::protos::Say& _internal_say() const;
  ::protos::Say* _internal_mutable_say();
  public:
  void unsafe_arena_set_allocated_say(
      ::protos::Say* say);
  ::protos::Say* unsafe_arena_release_say();
  // .protos.PointTo point_to = 10;
  bool has_point_to() const;
  private:
  bool _internal_has_point_to() const;

  public:
  void clear_point_to() ;
  const ::protos::PointTo& point_to() const;
  PROTOBUF_NODISCARD ::protos::PointTo* release_point_to();
  ::protos::PointTo* mutable_point_to();
  void set_allocated_point_to(::protos::PointTo* point_to);
  private:
  const ::protos::PointTo& _internal_point_to() const;
  ::protos::PointTo* _internal_mutable_point_to();
  public:
  void unsafe_arena_set_allocated_point_to(
      ::protos::PointTo* point_to);
  ::protos::PointTo* unsafe_arena_release_point_to();
  // .protos.PointToOf point_to_of = 11;
  bool has_point_to_of() const;
  private:
  bool _internal_has_point_to_of() const;

  public:
  void clear_point_to_of() ;
  const ::protos::PointToOf& point_to_of() const;
  PROTOBUF_NODISCARD ::protos::PointToOf* release_point_to_of();
  ::protos::PointToOf* mutable_point_to_of();
  void set_allocated_point_to_of(::protos::PointToOf* point_to_of);
  private:
  const ::protos::PointToOf& _internal_point_to_of() const;
  ::protos::PointToOf* _internal_mutable_point_to_of();
  public:
  void unsafe_arena_set_allocated_point_to_of(
      ::protos::PointToOf* point_to_of);
  ::protos::PointToOf* unsafe_arena_release_point_to_of();
  // .protos.AttentionTo attention_to = 12;
  bool has_attention_to() const;
  private:
  bool _internal_has_attention_to() const;

  public:
  void clear_attention_to() ;
  const ::protos::AttentionTo& attention_to() const;
  PROTOBUF_NODISCARD ::protos::AttentionTo* release_attention_to();
  ::protos::AttentionTo* mutable_attention_to();
  void set_allocated_attention_to(::protos::AttentionTo* attention_to);
  private:
  const ::protos::AttentionTo& _internal_attention_to() const;
  ::protos::AttentionTo* _internal_mutable_attention_to();
  public:
  void unsafe_arena_set_allocated_attention_to(
      ::protos::AttentionTo* attention_to);
  ::protos::AttentionTo* unsafe_arena_release_attention_to();
  // .protos.AttentionToOf attention_to_of = 13;
  bool has_attention_to_of() const;
  private:
  bool _internal_has_attention_to_of() const;

  public:
  void clear_attention_to_of() ;
  const ::protos::AttentionToOf& attention_to_of() const;
  PROTOBUF_NODISCARD ::protos::AttentionToOf* release_attention_to_of();
  ::protos::AttentionToOf* mutable_attention_to_of();
  void set_allocated_attention_to_of(::protos::AttentionToOf* attention_to_of);
  private:
  const ::protos::AttentionToOf& _internal_attention_to_of() const;
  ::protos::AttentionToOf* _internal_mutable_attention_to_of();
  public:
  void unsafe_arena_set_allocated_attention_to_of(
      ::protos::AttentionToOf* attention_to_of);
  ::protos::AttentionToOf* unsafe_arena_release_attention_to_of();
  // .protos.Log log = 14;
  bool has_log() const;
  private:
  bool _internal_has_log() const;

  public:
  void clear_log() ;
  const ::protos::Log& log() const;
  PROTOBUF_NODISCARD ::protos::Log* release_log();
  ::protos::Log* mutable_log();
  void set_allocated_log(::protos::Log* log);
  private:
  const ::protos::Log& _internal_log() const;
  ::protos::Log* _internal_mutable_log();
  public:
  void unsafe_arena_set_allocated_log(
      ::protos::Log* log);
  ::protos::Log* unsafe_arena_release_log();
  // .protos.DebugClient debug_client = 15;
  bool has_debug_client() const;
  private:
  bool _internal_has_debug_client() const;

  public:
  void clear_debug_client() ;
  const ::protos::DebugClient& debug_client() const;
  PROTOBUF_NODISCARD ::protos::DebugClient* release_debug_client();
  ::protos::DebugClient* mutable_debug_client();
  void set_allocated_debug_client(::protos::DebugClient* debug_client);
  private:
  const ::protos::DebugClient& _internal_debug_client() const;
  ::protos::DebugClient* _internal_mutable_debug_client();
  public:
  void unsafe_arena_set_allocated_debug_client(
      ::protos::DebugClient* debug_client);
  ::protos::DebugClient* unsafe_arena_release_debug_client();
  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:protos.Action)
 private:
  class _Internal;
  void set_has_dash();
  void set_has_turn();
  void set_has_kick();
  void set_has_tackle();
  void set_has_catch_();
  void set_has_move();
  void set_has_turn_neck();
  void set_has_change_view();
  void set_has_say();
  void set_has_point_to();
  void set_has_point_to_of();
  void set_has_attention_to();
  void set_has_attention_to_of();
  void set_has_log();
  void set_has_debug_client();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::protos::Dash* dash_;
      ::protos::Turn* turn_;
      ::protos::Kick* kick_;
      ::protos::Tackle* tackle_;
      ::protos::Catch* catch__;
      ::protos::Move* move_;
      ::protos::TurnNeck* turn_neck_;
      ::protos::ChangeView* change_view_;
      ::protos::Say* say_;
      ::protos::PointTo* point_to_;
      ::protos::PointToOf* point_to_of_;
      ::protos::AttentionTo* attention_to_;
      ::protos::AttentionToOf* attention_to_of_;
      ::protos::Log* log_;
      ::protos::DebugClient* debug_client_;
    } action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Actions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Actions) */ {
 public:
  inline Actions() : Actions(nullptr) {}
  ~Actions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Actions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Actions(const Actions& from);
  Actions(Actions&& from) noexcept
    : Actions() {
    *this = ::std::move(from);
  }

  inline Actions& operator=(const Actions& from) {
    CopyFrom(from);
    return *this;
  }
  inline Actions& operator=(Actions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Actions& default_instance() {
    return *internal_default_instance();
  }
  static inline const Actions* internal_default_instance() {
    return reinterpret_cast<const Actions*>(
               &_Actions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Actions& a, Actions& b) {
    a.Swap(&b);
  }
  inline void Swap(Actions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Actions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Actions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Actions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Actions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Actions& from) {
    Actions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Actions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Actions";
  }
  protected:
  explicit Actions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 1,
  };
  // repeated .protos.Action actions = 1;
  int actions_size() const;
  private:
  int _internal_actions_size() const;

  public:
  void clear_actions() ;
  ::protos::Action* mutable_actions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Action >*
      mutable_actions();
  private:
  const ::protos::Action& _internal_actions(int index) const;
  ::protos::Action* _internal_add_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Action>& _internal_actions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Action>* _internal_mutable_actions();
  public:
  const ::protos::Action& actions(int index) const;
  ::protos::Action* add_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Action >&
      actions() const;
  // @@protoc_insertion_point(class_scope:protos.Actions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Action > actions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vector2D

// float x = 1;
inline void Vector2D::clear_x() {
  _impl_.x_ = 0;
}
inline float Vector2D::x() const {
  // @@protoc_insertion_point(field_get:protos.Vector2D.x)
  return _internal_x();
}
inline void Vector2D::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:protos.Vector2D.x)
}
inline float Vector2D::_internal_x() const {
  return _impl_.x_;
}
inline void Vector2D::_internal_set_x(float value) {
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void Vector2D::clear_y() {
  _impl_.y_ = 0;
}
inline float Vector2D::y() const {
  // @@protoc_insertion_point(field_get:protos.Vector2D.y)
  return _internal_y();
}
inline void Vector2D::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:protos.Vector2D.y)
}
inline float Vector2D::_internal_y() const {
  return _impl_.y_;
}
inline void Vector2D::_internal_set_y(float value) {
  ;
  _impl_.y_ = value;
}

// float dist = 3;
inline void Vector2D::clear_dist() {
  _impl_.dist_ = 0;
}
inline float Vector2D::dist() const {
  // @@protoc_insertion_point(field_get:protos.Vector2D.dist)
  return _internal_dist();
}
inline void Vector2D::set_dist(float value) {
  _internal_set_dist(value);
  // @@protoc_insertion_point(field_set:protos.Vector2D.dist)
}
inline float Vector2D::_internal_dist() const {
  return _impl_.dist_;
}
inline void Vector2D::_internal_set_dist(float value) {
  ;
  _impl_.dist_ = value;
}

// float angle = 4;
inline void Vector2D::clear_angle() {
  _impl_.angle_ = 0;
}
inline float Vector2D::angle() const {
  // @@protoc_insertion_point(field_get:protos.Vector2D.angle)
  return _internal_angle();
}
inline void Vector2D::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:protos.Vector2D.angle)
}
inline float Vector2D::_internal_angle() const {
  return _impl_.angle_;
}
inline void Vector2D::_internal_set_angle(float value) {
  ;
  _impl_.angle_ = value;
}

// -------------------------------------------------------------------

// Ball

// .protos.Vector2D position = 1;
inline bool Ball::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Ball::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Ball::_internal_position() const {
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::position() const {
  // @@protoc_insertion_point(field_get:protos.Ball.position)
  return _internal_position();
}
inline void Ball::unsafe_arena_set_allocated_position(
    ::protos::Vector2D* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.position)
}
inline ::protos::Vector2D* Ball::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protos.Ball.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* Ball::mutable_position() {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.Ball.position)
  return _msg;
}
inline void Ball::set_allocated_position(::protos::Vector2D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.position)
}

// .protos.Vector2D relative_position = 2;
inline bool Ball::has_relative_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.relative_position_ != nullptr);
  return value;
}
inline void Ball::clear_relative_position() {
  if (_impl_.relative_position_ != nullptr) _impl_.relative_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& Ball::_internal_relative_position() const {
  const ::protos::Vector2D* p = _impl_.relative_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::relative_position() const {
  // @@protoc_insertion_point(field_get:protos.Ball.relative_position)
  return _internal_relative_position();
}
inline void Ball::unsafe_arena_set_allocated_relative_position(
    ::protos::Vector2D* relative_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relative_position_);
  }
  _impl_.relative_position_ = relative_position;
  if (relative_position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.relative_position)
}
inline ::protos::Vector2D* Ball::release_relative_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.relative_position_;
  _impl_.relative_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_relative_position() {
  // @@protoc_insertion_point(field_release:protos.Ball.relative_position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.relative_position_;
  _impl_.relative_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_relative_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.relative_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.relative_position_ = p;
  }
  return _impl_.relative_position_;
}
inline ::protos::Vector2D* Ball::mutable_relative_position() {
  ::protos::Vector2D* _msg = _internal_mutable_relative_position();
  // @@protoc_insertion_point(field_mutable:protos.Ball.relative_position)
  return _msg;
}
inline void Ball::set_allocated_relative_position(::protos::Vector2D* relative_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.relative_position_;
  }
  if (relative_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(relative_position);
    if (message_arena != submessage_arena) {
      relative_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relative_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.relative_position_ = relative_position;
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.relative_position)
}

// .protos.Vector2D seen_position = 3;
inline bool Ball::has_seen_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_position_ != nullptr);
  return value;
}
inline void Ball::clear_seen_position() {
  if (_impl_.seen_position_ != nullptr) _impl_.seen_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& Ball::_internal_seen_position() const {
  const ::protos::Vector2D* p = _impl_.seen_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::seen_position() const {
  // @@protoc_insertion_point(field_get:protos.Ball.seen_position)
  return _internal_seen_position();
}
inline void Ball::unsafe_arena_set_allocated_seen_position(
    ::protos::Vector2D* seen_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.seen_position_);
  }
  _impl_.seen_position_ = seen_position;
  if (seen_position) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.seen_position)
}
inline ::protos::Vector2D* Ball::release_seen_position() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_seen_position() {
  // @@protoc_insertion_point(field_release:protos.Ball.seen_position)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_seen_position() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.seen_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.seen_position_ = p;
  }
  return _impl_.seen_position_;
}
inline ::protos::Vector2D* Ball::mutable_seen_position() {
  ::protos::Vector2D* _msg = _internal_mutable_seen_position();
  // @@protoc_insertion_point(field_mutable:protos.Ball.seen_position)
  return _msg;
}
inline void Ball::set_allocated_seen_position(::protos::Vector2D* seen_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.seen_position_;
  }
  if (seen_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seen_position);
    if (message_arena != submessage_arena) {
      seen_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seen_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.seen_position_ = seen_position;
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.seen_position)
}

// .protos.Vector2D heard_position = 4;
inline bool Ball::has_heard_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heard_position_ != nullptr);
  return value;
}
inline void Ball::clear_heard_position() {
  if (_impl_.heard_position_ != nullptr) _impl_.heard_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::protos::Vector2D& Ball::_internal_heard_position() const {
  const ::protos::Vector2D* p = _impl_.heard_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::heard_position() const {
  // @@protoc_insertion_point(field_get:protos.Ball.heard_position)
  return _internal_heard_position();
}
inline void Ball::unsafe_arena_set_allocated_heard_position(
    ::protos::Vector2D* heard_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.heard_position_);
  }
  _impl_.heard_position_ = heard_position;
  if (heard_position) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.heard_position)
}
inline ::protos::Vector2D* Ball::release_heard_position() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* temp = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_heard_position() {
  // @@protoc_insertion_point(field_release:protos.Ball.heard_position)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* temp = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_heard_position() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.heard_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.heard_position_ = p;
  }
  return _impl_.heard_position_;
}
inline ::protos::Vector2D* Ball::mutable_heard_position() {
  ::protos::Vector2D* _msg = _internal_mutable_heard_position();
  // @@protoc_insertion_point(field_mutable:protos.Ball.heard_position)
  return _msg;
}
inline void Ball::set_allocated_heard_position(::protos::Vector2D* heard_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.heard_position_;
  }
  if (heard_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(heard_position);
    if (message_arena != submessage_arena) {
      heard_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heard_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.heard_position_ = heard_position;
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.heard_position)
}

// .protos.Vector2D velocity = 5;
inline bool Ball::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void Ball::clear_velocity() {
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::protos::Vector2D& Ball::_internal_velocity() const {
  const ::protos::Vector2D* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::velocity() const {
  // @@protoc_insertion_point(field_get:protos.Ball.velocity)
  return _internal_velocity();
}
inline void Ball::unsafe_arena_set_allocated_velocity(
    ::protos::Vector2D* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.velocity)
}
inline ::protos::Vector2D* Ball::release_velocity() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:protos.Ball.velocity)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_velocity() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::protos::Vector2D* Ball::mutable_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Ball.velocity)
  return _msg;
}
inline void Ball::set_allocated_velocity(::protos::Vector2D* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.velocity)
}

// .protos.Vector2D seen_velocity = 6;
inline bool Ball::has_seen_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_velocity_ != nullptr);
  return value;
}
inline void Ball::clear_seen_velocity() {
  if (_impl_.seen_velocity_ != nullptr) _impl_.seen_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::protos::Vector2D& Ball::_internal_seen_velocity() const {
  const ::protos::Vector2D* p = _impl_.seen_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::seen_velocity() const {
  // @@protoc_insertion_point(field_get:protos.Ball.seen_velocity)
  return _internal_seen_velocity();
}
inline void Ball::unsafe_arena_set_allocated_seen_velocity(
    ::protos::Vector2D* seen_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.seen_velocity_);
  }
  _impl_.seen_velocity_ = seen_velocity;
  if (seen_velocity) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.seen_velocity)
}
inline ::protos::Vector2D* Ball::release_seen_velocity() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::protos::Vector2D* temp = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_seen_velocity() {
  // @@protoc_insertion_point(field_release:protos.Ball.seen_velocity)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::protos::Vector2D* temp = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_seen_velocity() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.seen_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.seen_velocity_ = p;
  }
  return _impl_.seen_velocity_;
}
inline ::protos::Vector2D* Ball::mutable_seen_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_seen_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Ball.seen_velocity)
  return _msg;
}
inline void Ball::set_allocated_seen_velocity(::protos::Vector2D* seen_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.seen_velocity_;
  }
  if (seen_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seen_velocity);
    if (message_arena != submessage_arena) {
      seen_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seen_velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.seen_velocity_ = seen_velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.seen_velocity)
}

// .protos.Vector2D heard_velocity = 7;
inline bool Ball::has_heard_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heard_velocity_ != nullptr);
  return value;
}
inline void Ball::clear_heard_velocity() {
  if (_impl_.heard_velocity_ != nullptr) _impl_.heard_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::protos::Vector2D& Ball::_internal_heard_velocity() const {
  const ::protos::Vector2D* p = _impl_.heard_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::heard_velocity() const {
  // @@protoc_insertion_point(field_get:protos.Ball.heard_velocity)
  return _internal_heard_velocity();
}
inline void Ball::unsafe_arena_set_allocated_heard_velocity(
    ::protos::Vector2D* heard_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.heard_velocity_);
  }
  _impl_.heard_velocity_ = heard_velocity;
  if (heard_velocity) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.heard_velocity)
}
inline ::protos::Vector2D* Ball::release_heard_velocity() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::protos::Vector2D* temp = _impl_.heard_velocity_;
  _impl_.heard_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_heard_velocity() {
  // @@protoc_insertion_point(field_release:protos.Ball.heard_velocity)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::protos::Vector2D* temp = _impl_.heard_velocity_;
  _impl_.heard_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_heard_velocity() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.heard_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.heard_velocity_ = p;
  }
  return _impl_.heard_velocity_;
}
inline ::protos::Vector2D* Ball::mutable_heard_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_heard_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Ball.heard_velocity)
  return _msg;
}
inline void Ball::set_allocated_heard_velocity(::protos::Vector2D* heard_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.heard_velocity_;
  }
  if (heard_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(heard_velocity);
    if (message_arena != submessage_arena) {
      heard_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heard_velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.heard_velocity_ = heard_velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.heard_velocity)
}

// int32 pos_count = 8;
inline void Ball::clear_pos_count() {
  _impl_.pos_count_ = 0;
}
inline ::int32_t Ball::pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.pos_count)
  return _internal_pos_count();
}
inline void Ball::set_pos_count(::int32_t value) {
  _internal_set_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.pos_count)
}
inline ::int32_t Ball::_internal_pos_count() const {
  return _impl_.pos_count_;
}
inline void Ball::_internal_set_pos_count(::int32_t value) {
  ;
  _impl_.pos_count_ = value;
}

// int32 seen_pos_count = 9;
inline void Ball::clear_seen_pos_count() {
  _impl_.seen_pos_count_ = 0;
}
inline ::int32_t Ball::seen_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.seen_pos_count)
  return _internal_seen_pos_count();
}
inline void Ball::set_seen_pos_count(::int32_t value) {
  _internal_set_seen_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.seen_pos_count)
}
inline ::int32_t Ball::_internal_seen_pos_count() const {
  return _impl_.seen_pos_count_;
}
inline void Ball::_internal_set_seen_pos_count(::int32_t value) {
  ;
  _impl_.seen_pos_count_ = value;
}

// int32 heard_pos_count = 10;
inline void Ball::clear_heard_pos_count() {
  _impl_.heard_pos_count_ = 0;
}
inline ::int32_t Ball::heard_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.heard_pos_count)
  return _internal_heard_pos_count();
}
inline void Ball::set_heard_pos_count(::int32_t value) {
  _internal_set_heard_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.heard_pos_count)
}
inline ::int32_t Ball::_internal_heard_pos_count() const {
  return _impl_.heard_pos_count_;
}
inline void Ball::_internal_set_heard_pos_count(::int32_t value) {
  ;
  _impl_.heard_pos_count_ = value;
}

// int32 vel_count = 11;
inline void Ball::clear_vel_count() {
  _impl_.vel_count_ = 0;
}
inline ::int32_t Ball::vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.vel_count)
  return _internal_vel_count();
}
inline void Ball::set_vel_count(::int32_t value) {
  _internal_set_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.vel_count)
}
inline ::int32_t Ball::_internal_vel_count() const {
  return _impl_.vel_count_;
}
inline void Ball::_internal_set_vel_count(::int32_t value) {
  ;
  _impl_.vel_count_ = value;
}

// int32 seen_vel_count = 12;
inline void Ball::clear_seen_vel_count() {
  _impl_.seen_vel_count_ = 0;
}
inline ::int32_t Ball::seen_vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.seen_vel_count)
  return _internal_seen_vel_count();
}
inline void Ball::set_seen_vel_count(::int32_t value) {
  _internal_set_seen_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.seen_vel_count)
}
inline ::int32_t Ball::_internal_seen_vel_count() const {
  return _impl_.seen_vel_count_;
}
inline void Ball::_internal_set_seen_vel_count(::int32_t value) {
  ;
  _impl_.seen_vel_count_ = value;
}

// int32 heard_vel_count = 13;
inline void Ball::clear_heard_vel_count() {
  _impl_.heard_vel_count_ = 0;
}
inline ::int32_t Ball::heard_vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.heard_vel_count)
  return _internal_heard_vel_count();
}
inline void Ball::set_heard_vel_count(::int32_t value) {
  _internal_set_heard_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.heard_vel_count)
}
inline ::int32_t Ball::_internal_heard_vel_count() const {
  return _impl_.heard_vel_count_;
}
inline void Ball::_internal_set_heard_vel_count(::int32_t value) {
  ;
  _impl_.heard_vel_count_ = value;
}

// int32 lost_count = 14;
inline void Ball::clear_lost_count() {
  _impl_.lost_count_ = 0;
}
inline ::int32_t Ball::lost_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.lost_count)
  return _internal_lost_count();
}
inline void Ball::set_lost_count(::int32_t value) {
  _internal_set_lost_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.lost_count)
}
inline ::int32_t Ball::_internal_lost_count() const {
  return _impl_.lost_count_;
}
inline void Ball::_internal_set_lost_count(::int32_t value) {
  ;
  _impl_.lost_count_ = value;
}

// int32 ghost_count = 15;
inline void Ball::clear_ghost_count() {
  _impl_.ghost_count_ = 0;
}
inline ::int32_t Ball::ghost_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.ghost_count)
  return _internal_ghost_count();
}
inline void Ball::set_ghost_count(::int32_t value) {
  _internal_set_ghost_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.ghost_count)
}
inline ::int32_t Ball::_internal_ghost_count() const {
  return _impl_.ghost_count_;
}
inline void Ball::_internal_set_ghost_count(::int32_t value) {
  ;
  _impl_.ghost_count_ = value;
}

// float dist_from_self = 16;
inline void Ball::clear_dist_from_self() {
  _impl_.dist_from_self_ = 0;
}
inline float Ball::dist_from_self() const {
  // @@protoc_insertion_point(field_get:protos.Ball.dist_from_self)
  return _internal_dist_from_self();
}
inline void Ball::set_dist_from_self(float value) {
  _internal_set_dist_from_self(value);
  // @@protoc_insertion_point(field_set:protos.Ball.dist_from_self)
}
inline float Ball::_internal_dist_from_self() const {
  return _impl_.dist_from_self_;
}
inline void Ball::_internal_set_dist_from_self(float value) {
  ;
  _impl_.dist_from_self_ = value;
}

// float angle_from_self = 17;
inline void Ball::clear_angle_from_self() {
  _impl_.angle_from_self_ = 0;
}
inline float Ball::angle_from_self() const {
  // @@protoc_insertion_point(field_get:protos.Ball.angle_from_self)
  return _internal_angle_from_self();
}
inline void Ball::set_angle_from_self(float value) {
  _internal_set_angle_from_self(value);
  // @@protoc_insertion_point(field_set:protos.Ball.angle_from_self)
}
inline float Ball::_internal_angle_from_self() const {
  return _impl_.angle_from_self_;
}
inline void Ball::_internal_set_angle_from_self(float value) {
  ;
  _impl_.angle_from_self_ = value;
}

// -------------------------------------------------------------------

// Player

// .protos.Vector2D position = 1;
inline bool Player::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Player::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Player::_internal_position() const {
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Player::position() const {
  // @@protoc_insertion_point(field_get:protos.Player.position)
  return _internal_position();
}
inline void Player::unsafe_arena_set_allocated_position(
    ::protos::Vector2D* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Player.position)
}
inline ::protos::Vector2D* Player::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Player::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protos.Player.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Player::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* Player::mutable_position() {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.Player.position)
  return _msg;
}
inline void Player::set_allocated_position(::protos::Vector2D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protos.Player.position)
}

// .protos.Vector2D seen_position = 2;
inline bool Player::has_seen_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_position_ != nullptr);
  return value;
}
inline void Player::clear_seen_position() {
  if (_impl_.seen_position_ != nullptr) _impl_.seen_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& Player::_internal_seen_position() const {
  const ::protos::Vector2D* p = _impl_.seen_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Player::seen_position() const {
  // @@protoc_insertion_point(field_get:protos.Player.seen_position)
  return _internal_seen_position();
}
inline void Player::unsafe_arena_set_allocated_seen_position(
    ::protos::Vector2D* seen_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.seen_position_);
  }
  _impl_.seen_position_ = seen_position;
  if (seen_position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Player.seen_position)
}
inline ::protos::Vector2D* Player::release_seen_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Player::unsafe_arena_release_seen_position() {
  // @@protoc_insertion_point(field_release:protos.Player.seen_position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Player::_internal_mutable_seen_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.seen_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.seen_position_ = p;
  }
  return _impl_.seen_position_;
}
inline ::protos::Vector2D* Player::mutable_seen_position() {
  ::protos::Vector2D* _msg = _internal_mutable_seen_position();
  // @@protoc_insertion_point(field_mutable:protos.Player.seen_position)
  return _msg;
}
inline void Player::set_allocated_seen_position(::protos::Vector2D* seen_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.seen_position_;
  }
  if (seen_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seen_position);
    if (message_arena != submessage_arena) {
      seen_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seen_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.seen_position_ = seen_position;
  // @@protoc_insertion_point(field_set_allocated:protos.Player.seen_position)
}

// .protos.Vector2D heard_position = 3;
inline bool Player::has_heard_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heard_position_ != nullptr);
  return value;
}
inline void Player::clear_heard_position() {
  if (_impl_.heard_position_ != nullptr) _impl_.heard_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& Player::_internal_heard_position() const {
  const ::protos::Vector2D* p = _impl_.heard_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Player::heard_position() const {
  // @@protoc_insertion_point(field_get:protos.Player.heard_position)
  return _internal_heard_position();
}
inline void Player::unsafe_arena_set_allocated_heard_position(
    ::protos::Vector2D* heard_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.heard_position_);
  }
  _impl_.heard_position_ = heard_position;
  if (heard_position) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Player.heard_position)
}
inline ::protos::Vector2D* Player::release_heard_position() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Player::unsafe_arena_release_heard_position() {
  // @@protoc_insertion_point(field_release:protos.Player.heard_position)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Player::_internal_mutable_heard_position() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.heard_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.heard_position_ = p;
  }
  return _impl_.heard_position_;
}
inline ::protos::Vector2D* Player::mutable_heard_position() {
  ::protos::Vector2D* _msg = _internal_mutable_heard_position();
  // @@protoc_insertion_point(field_mutable:protos.Player.heard_position)
  return _msg;
}
inline void Player::set_allocated_heard_position(::protos::Vector2D* heard_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.heard_position_;
  }
  if (heard_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(heard_position);
    if (message_arena != submessage_arena) {
      heard_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heard_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.heard_position_ = heard_position;
  // @@protoc_insertion_point(field_set_allocated:protos.Player.heard_position)
}

// .protos.Vector2D velocity = 4;
inline bool Player::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void Player::clear_velocity() {
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::protos::Vector2D& Player::_internal_velocity() const {
  const ::protos::Vector2D* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Player::velocity() const {
  // @@protoc_insertion_point(field_get:protos.Player.velocity)
  return _internal_velocity();
}
inline void Player::unsafe_arena_set_allocated_velocity(
    ::protos::Vector2D* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Player.velocity)
}
inline ::protos::Vector2D* Player::release_velocity() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Player::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:protos.Player.velocity)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Player::_internal_mutable_velocity() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::protos::Vector2D* Player::mutable_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Player.velocity)
  return _msg;
}
inline void Player::set_allocated_velocity(::protos::Vector2D* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.Player.velocity)
}

// .protos.Vector2D seen_velocity = 5;
inline bool Player::has_seen_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_velocity_ != nullptr);
  return value;
}
inline void Player::clear_seen_velocity() {
  if (_impl_.seen_velocity_ != nullptr) _impl_.seen_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::protos::Vector2D& Player::_internal_seen_velocity() const {
  const ::protos::Vector2D* p = _impl_.seen_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Player::seen_velocity() const {
  // @@protoc_insertion_point(field_get:protos.Player.seen_velocity)
  return _internal_seen_velocity();
}
inline void Player::unsafe_arena_set_allocated_seen_velocity(
    ::protos::Vector2D* seen_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.seen_velocity_);
  }
  _impl_.seen_velocity_ = seen_velocity;
  if (seen_velocity) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Player.seen_velocity)
}
inline ::protos::Vector2D* Player::release_seen_velocity() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* temp = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Player::unsafe_arena_release_seen_velocity() {
  // @@protoc_insertion_point(field_release:protos.Player.seen_velocity)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* temp = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Player::_internal_mutable_seen_velocity() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.seen_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.seen_velocity_ = p;
  }
  return _impl_.seen_velocity_;
}
inline ::protos::Vector2D* Player::mutable_seen_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_seen_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Player.seen_velocity)
  return _msg;
}
inline void Player::set_allocated_seen_velocity(::protos::Vector2D* seen_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.seen_velocity_;
  }
  if (seen_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seen_velocity);
    if (message_arena != submessage_arena) {
      seen_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seen_velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.seen_velocity_ = seen_velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.Player.seen_velocity)
}

// int32 pos_count = 6;
inline void Player::clear_pos_count() {
  _impl_.pos_count_ = 0;
}
inline ::int32_t Player::pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.pos_count)
  return _internal_pos_count();
}
inline void Player::set_pos_count(::int32_t value) {
  _internal_set_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.pos_count)
}
inline ::int32_t Player::_internal_pos_count() const {
  return _impl_.pos_count_;
}
inline void Player::_internal_set_pos_count(::int32_t value) {
  ;
  _impl_.pos_count_ = value;
}

// int32 seen_pos_count = 7;
inline void Player::clear_seen_pos_count() {
  _impl_.seen_pos_count_ = 0;
}
inline ::int32_t Player::seen_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.seen_pos_count)
  return _internal_seen_pos_count();
}
inline void Player::set_seen_pos_count(::int32_t value) {
  _internal_set_seen_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.seen_pos_count)
}
inline ::int32_t Player::_internal_seen_pos_count() const {
  return _impl_.seen_pos_count_;
}
inline void Player::_internal_set_seen_pos_count(::int32_t value) {
  ;
  _impl_.seen_pos_count_ = value;
}

// int32 heard_pos_count = 8;
inline void Player::clear_heard_pos_count() {
  _impl_.heard_pos_count_ = 0;
}
inline ::int32_t Player::heard_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.heard_pos_count)
  return _internal_heard_pos_count();
}
inline void Player::set_heard_pos_count(::int32_t value) {
  _internal_set_heard_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.heard_pos_count)
}
inline ::int32_t Player::_internal_heard_pos_count() const {
  return _impl_.heard_pos_count_;
}
inline void Player::_internal_set_heard_pos_count(::int32_t value) {
  ;
  _impl_.heard_pos_count_ = value;
}

// int32 vel_count = 9;
inline void Player::clear_vel_count() {
  _impl_.vel_count_ = 0;
}
inline ::int32_t Player::vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.vel_count)
  return _internal_vel_count();
}
inline void Player::set_vel_count(::int32_t value) {
  _internal_set_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.vel_count)
}
inline ::int32_t Player::_internal_vel_count() const {
  return _impl_.vel_count_;
}
inline void Player::_internal_set_vel_count(::int32_t value) {
  ;
  _impl_.vel_count_ = value;
}

// int32 seen_vel_count = 10;
inline void Player::clear_seen_vel_count() {
  _impl_.seen_vel_count_ = 0;
}
inline ::int32_t Player::seen_vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.seen_vel_count)
  return _internal_seen_vel_count();
}
inline void Player::set_seen_vel_count(::int32_t value) {
  _internal_set_seen_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.seen_vel_count)
}
inline ::int32_t Player::_internal_seen_vel_count() const {
  return _impl_.seen_vel_count_;
}
inline void Player::_internal_set_seen_vel_count(::int32_t value) {
  ;
  _impl_.seen_vel_count_ = value;
}

// int32 ghost_count = 11;
inline void Player::clear_ghost_count() {
  _impl_.ghost_count_ = 0;
}
inline ::int32_t Player::ghost_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.ghost_count)
  return _internal_ghost_count();
}
inline void Player::set_ghost_count(::int32_t value) {
  _internal_set_ghost_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.ghost_count)
}
inline ::int32_t Player::_internal_ghost_count() const {
  return _impl_.ghost_count_;
}
inline void Player::_internal_set_ghost_count(::int32_t value) {
  ;
  _impl_.ghost_count_ = value;
}

// float dist_from_self = 12;
inline void Player::clear_dist_from_self() {
  _impl_.dist_from_self_ = 0;
}
inline float Player::dist_from_self() const {
  // @@protoc_insertion_point(field_get:protos.Player.dist_from_self)
  return _internal_dist_from_self();
}
inline void Player::set_dist_from_self(float value) {
  _internal_set_dist_from_self(value);
  // @@protoc_insertion_point(field_set:protos.Player.dist_from_self)
}
inline float Player::_internal_dist_from_self() const {
  return _impl_.dist_from_self_;
}
inline void Player::_internal_set_dist_from_self(float value) {
  ;
  _impl_.dist_from_self_ = value;
}

// float angle_from_self = 13;
inline void Player::clear_angle_from_self() {
  _impl_.angle_from_self_ = 0;
}
inline float Player::angle_from_self() const {
  // @@protoc_insertion_point(field_get:protos.Player.angle_from_self)
  return _internal_angle_from_self();
}
inline void Player::set_angle_from_self(float value) {
  _internal_set_angle_from_self(value);
  // @@protoc_insertion_point(field_set:protos.Player.angle_from_self)
}
inline float Player::_internal_angle_from_self() const {
  return _impl_.angle_from_self_;
}
inline void Player::_internal_set_angle_from_self(float value) {
  ;
  _impl_.angle_from_self_ = value;
}

// int32 id = 14;
inline void Player::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t Player::id() const {
  // @@protoc_insertion_point(field_get:protos.Player.id)
  return _internal_id();
}
inline void Player::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:protos.Player.id)
}
inline ::int32_t Player::_internal_id() const {
  return _impl_.id_;
}
inline void Player::_internal_set_id(::int32_t value) {
  ;
  _impl_.id_ = value;
}

// .protos.Side side = 15;
inline void Player::clear_side() {
  _impl_.side_ = 0;
}
inline ::protos::Side Player::side() const {
  // @@protoc_insertion_point(field_get:protos.Player.side)
  return _internal_side();
}
inline void Player::set_side(::protos::Side value) {
   _internal_set_side(value);
  // @@protoc_insertion_point(field_set:protos.Player.side)
}
inline ::protos::Side Player::_internal_side() const {
  return static_cast<::protos::Side>(_impl_.side_);
}
inline void Player::_internal_set_side(::protos::Side value) {
  ;
  _impl_.side_ = value;
}

// int32 uniform_number = 16;
inline void Player::clear_uniform_number() {
  _impl_.uniform_number_ = 0;
}
inline ::int32_t Player::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.Player.uniform_number)
  return _internal_uniform_number();
}
inline void Player::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.Player.uniform_number)
}
inline ::int32_t Player::_internal_uniform_number() const {
  return _impl_.uniform_number_;
}
inline void Player::_internal_set_uniform_number(::int32_t value) {
  ;
  _impl_.uniform_number_ = value;
}

// int32 uniform_number_count = 17;
inline void Player::clear_uniform_number_count() {
  _impl_.uniform_number_count_ = 0;
}
inline ::int32_t Player::uniform_number_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.uniform_number_count)
  return _internal_uniform_number_count();
}
inline void Player::set_uniform_number_count(::int32_t value) {
  _internal_set_uniform_number_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.uniform_number_count)
}
inline ::int32_t Player::_internal_uniform_number_count() const {
  return _impl_.uniform_number_count_;
}
inline void Player::_internal_set_uniform_number_count(::int32_t value) {
  ;
  _impl_.uniform_number_count_ = value;
}

// bool is_goalie = 18;
inline void Player::clear_is_goalie() {
  _impl_.is_goalie_ = false;
}
inline bool Player::is_goalie() const {
  // @@protoc_insertion_point(field_get:protos.Player.is_goalie)
  return _internal_is_goalie();
}
inline void Player::set_is_goalie(bool value) {
  _internal_set_is_goalie(value);
  // @@protoc_insertion_point(field_set:protos.Player.is_goalie)
}
inline bool Player::_internal_is_goalie() const {
  return _impl_.is_goalie_;
}
inline void Player::_internal_set_is_goalie(bool value) {
  ;
  _impl_.is_goalie_ = value;
}

// float body_direction = 19;
inline void Player::clear_body_direction() {
  _impl_.body_direction_ = 0;
}
inline float Player::body_direction() const {
  // @@protoc_insertion_point(field_get:protos.Player.body_direction)
  return _internal_body_direction();
}
inline void Player::set_body_direction(float value) {
  _internal_set_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.Player.body_direction)
}
inline float Player::_internal_body_direction() const {
  return _impl_.body_direction_;
}
inline void Player::_internal_set_body_direction(float value) {
  ;
  _impl_.body_direction_ = value;
}

// int32 body_direction_count = 20;
inline void Player::clear_body_direction_count() {
  _impl_.body_direction_count_ = 0;
}
inline ::int32_t Player::body_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.body_direction_count)
  return _internal_body_direction_count();
}
inline void Player::set_body_direction_count(::int32_t value) {
  _internal_set_body_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.body_direction_count)
}
inline ::int32_t Player::_internal_body_direction_count() const {
  return _impl_.body_direction_count_;
}
inline void Player::_internal_set_body_direction_count(::int32_t value) {
  ;
  _impl_.body_direction_count_ = value;
}

// float face_direction = 21;
inline void Player::clear_face_direction() {
  _impl_.face_direction_ = 0;
}
inline float Player::face_direction() const {
  // @@protoc_insertion_point(field_get:protos.Player.face_direction)
  return _internal_face_direction();
}
inline void Player::set_face_direction(float value) {
  _internal_set_face_direction(value);
  // @@protoc_insertion_point(field_set:protos.Player.face_direction)
}
inline float Player::_internal_face_direction() const {
  return _impl_.face_direction_;
}
inline void Player::_internal_set_face_direction(float value) {
  ;
  _impl_.face_direction_ = value;
}

// int32 face_direction_count = 22;
inline void Player::clear_face_direction_count() {
  _impl_.face_direction_count_ = 0;
}
inline ::int32_t Player::face_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.face_direction_count)
  return _internal_face_direction_count();
}
inline void Player::set_face_direction_count(::int32_t value) {
  _internal_set_face_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.face_direction_count)
}
inline ::int32_t Player::_internal_face_direction_count() const {
  return _impl_.face_direction_count_;
}
inline void Player::_internal_set_face_direction_count(::int32_t value) {
  ;
  _impl_.face_direction_count_ = value;
}

// float point_to_direction = 23;
inline void Player::clear_point_to_direction() {
  _impl_.point_to_direction_ = 0;
}
inline float Player::point_to_direction() const {
  // @@protoc_insertion_point(field_get:protos.Player.point_to_direction)
  return _internal_point_to_direction();
}
inline void Player::set_point_to_direction(float value) {
  _internal_set_point_to_direction(value);
  // @@protoc_insertion_point(field_set:protos.Player.point_to_direction)
}
inline float Player::_internal_point_to_direction() const {
  return _impl_.point_to_direction_;
}
inline void Player::_internal_set_point_to_direction(float value) {
  ;
  _impl_.point_to_direction_ = value;
}

// int32 point_to_direction_count = 24;
inline void Player::clear_point_to_direction_count() {
  _impl_.point_to_direction_count_ = 0;
}
inline ::int32_t Player::point_to_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.point_to_direction_count)
  return _internal_point_to_direction_count();
}
inline void Player::set_point_to_direction_count(::int32_t value) {
  _internal_set_point_to_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.point_to_direction_count)
}
inline ::int32_t Player::_internal_point_to_direction_count() const {
  return _impl_.point_to_direction_count_;
}
inline void Player::_internal_set_point_to_direction_count(::int32_t value) {
  ;
  _impl_.point_to_direction_count_ = value;
}

// bool is_kicking = 25;
inline void Player::clear_is_kicking() {
  _impl_.is_kicking_ = false;
}
inline bool Player::is_kicking() const {
  // @@protoc_insertion_point(field_get:protos.Player.is_kicking)
  return _internal_is_kicking();
}
inline void Player::set_is_kicking(bool value) {
  _internal_set_is_kicking(value);
  // @@protoc_insertion_point(field_set:protos.Player.is_kicking)
}
inline bool Player::_internal_is_kicking() const {
  return _impl_.is_kicking_;
}
inline void Player::_internal_set_is_kicking(bool value) {
  ;
  _impl_.is_kicking_ = value;
}

// float dist_from_ball = 26;
inline void Player::clear_dist_from_ball() {
  _impl_.dist_from_ball_ = 0;
}
inline float Player::dist_from_ball() const {
  // @@protoc_insertion_point(field_get:protos.Player.dist_from_ball)
  return _internal_dist_from_ball();
}
inline void Player::set_dist_from_ball(float value) {
  _internal_set_dist_from_ball(value);
  // @@protoc_insertion_point(field_set:protos.Player.dist_from_ball)
}
inline float Player::_internal_dist_from_ball() const {
  return _impl_.dist_from_ball_;
}
inline void Player::_internal_set_dist_from_ball(float value) {
  ;
  _impl_.dist_from_ball_ = value;
}

// float angle_from_ball = 27;
inline void Player::clear_angle_from_ball() {
  _impl_.angle_from_ball_ = 0;
}
inline float Player::angle_from_ball() const {
  // @@protoc_insertion_point(field_get:protos.Player.angle_from_ball)
  return _internal_angle_from_ball();
}
inline void Player::set_angle_from_ball(float value) {
  _internal_set_angle_from_ball(value);
  // @@protoc_insertion_point(field_set:protos.Player.angle_from_ball)
}
inline float Player::_internal_angle_from_ball() const {
  return _impl_.angle_from_ball_;
}
inline void Player::_internal_set_angle_from_ball(float value) {
  ;
  _impl_.angle_from_ball_ = value;
}

// int32 ball_reach_steps = 28;
inline void Player::clear_ball_reach_steps() {
  _impl_.ball_reach_steps_ = 0;
}
inline ::int32_t Player::ball_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.Player.ball_reach_steps)
  return _internal_ball_reach_steps();
}
inline void Player::set_ball_reach_steps(::int32_t value) {
  _internal_set_ball_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.Player.ball_reach_steps)
}
inline ::int32_t Player::_internal_ball_reach_steps() const {
  return _impl_.ball_reach_steps_;
}
inline void Player::_internal_set_ball_reach_steps(::int32_t value) {
  ;
  _impl_.ball_reach_steps_ = value;
}

// bool is_tackling = 29;
inline void Player::clear_is_tackling() {
  _impl_.is_tackling_ = false;
}
inline bool Player::is_tackling() const {
  // @@protoc_insertion_point(field_get:protos.Player.is_tackling)
  return _internal_is_tackling();
}
inline void Player::set_is_tackling(bool value) {
  _internal_set_is_tackling(value);
  // @@protoc_insertion_point(field_set:protos.Player.is_tackling)
}
inline bool Player::_internal_is_tackling() const {
  return _impl_.is_tackling_;
}
inline void Player::_internal_set_is_tackling(bool value) {
  ;
  _impl_.is_tackling_ = value;
}

// -------------------------------------------------------------------

// Self

// .protos.Vector2D position = 1;
inline bool Self::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Self::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Self::_internal_position() const {
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Self::position() const {
  // @@protoc_insertion_point(field_get:protos.Self.position)
  return _internal_position();
}
inline void Self::unsafe_arena_set_allocated_position(
    ::protos::Vector2D* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Self.position)
}
inline ::protos::Vector2D* Self::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Self::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protos.Self.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Self::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* Self::mutable_position() {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.Self.position)
  return _msg;
}
inline void Self::set_allocated_position(::protos::Vector2D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protos.Self.position)
}

// .protos.Vector2D seen_position = 2;
inline bool Self::has_seen_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_position_ != nullptr);
  return value;
}
inline void Self::clear_seen_position() {
  if (_impl_.seen_position_ != nullptr) _impl_.seen_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& Self::_internal_seen_position() const {
  const ::protos::Vector2D* p = _impl_.seen_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Self::seen_position() const {
  // @@protoc_insertion_point(field_get:protos.Self.seen_position)
  return _internal_seen_position();
}
inline void Self::unsafe_arena_set_allocated_seen_position(
    ::protos::Vector2D* seen_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.seen_position_);
  }
  _impl_.seen_position_ = seen_position;
  if (seen_position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Self.seen_position)
}
inline ::protos::Vector2D* Self::release_seen_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Self::unsafe_arena_release_seen_position() {
  // @@protoc_insertion_point(field_release:protos.Self.seen_position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Self::_internal_mutable_seen_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.seen_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.seen_position_ = p;
  }
  return _impl_.seen_position_;
}
inline ::protos::Vector2D* Self::mutable_seen_position() {
  ::protos::Vector2D* _msg = _internal_mutable_seen_position();
  // @@protoc_insertion_point(field_mutable:protos.Self.seen_position)
  return _msg;
}
inline void Self::set_allocated_seen_position(::protos::Vector2D* seen_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.seen_position_;
  }
  if (seen_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seen_position);
    if (message_arena != submessage_arena) {
      seen_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seen_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.seen_position_ = seen_position;
  // @@protoc_insertion_point(field_set_allocated:protos.Self.seen_position)
}

// .protos.Vector2D heard_position = 3;
inline bool Self::has_heard_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heard_position_ != nullptr);
  return value;
}
inline void Self::clear_heard_position() {
  if (_impl_.heard_position_ != nullptr) _impl_.heard_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& Self::_internal_heard_position() const {
  const ::protos::Vector2D* p = _impl_.heard_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Self::heard_position() const {
  // @@protoc_insertion_point(field_get:protos.Self.heard_position)
  return _internal_heard_position();
}
inline void Self::unsafe_arena_set_allocated_heard_position(
    ::protos::Vector2D* heard_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.heard_position_);
  }
  _impl_.heard_position_ = heard_position;
  if (heard_position) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Self.heard_position)
}
inline ::protos::Vector2D* Self::release_heard_position() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Self::unsafe_arena_release_heard_position() {
  // @@protoc_insertion_point(field_release:protos.Self.heard_position)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Self::_internal_mutable_heard_position() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.heard_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.heard_position_ = p;
  }
  return _impl_.heard_position_;
}
inline ::protos::Vector2D* Self::mutable_heard_position() {
  ::protos::Vector2D* _msg = _internal_mutable_heard_position();
  // @@protoc_insertion_point(field_mutable:protos.Self.heard_position)
  return _msg;
}
inline void Self::set_allocated_heard_position(::protos::Vector2D* heard_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.heard_position_;
  }
  if (heard_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(heard_position);
    if (message_arena != submessage_arena) {
      heard_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heard_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.heard_position_ = heard_position;
  // @@protoc_insertion_point(field_set_allocated:protos.Self.heard_position)
}

// .protos.Vector2D velocity = 4;
inline bool Self::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void Self::clear_velocity() {
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::protos::Vector2D& Self::_internal_velocity() const {
  const ::protos::Vector2D* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Self::velocity() const {
  // @@protoc_insertion_point(field_get:protos.Self.velocity)
  return _internal_velocity();
}
inline void Self::unsafe_arena_set_allocated_velocity(
    ::protos::Vector2D* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Self.velocity)
}
inline ::protos::Vector2D* Self::release_velocity() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Self::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:protos.Self.velocity)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Self::_internal_mutable_velocity() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::protos::Vector2D* Self::mutable_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Self.velocity)
  return _msg;
}
inline void Self::set_allocated_velocity(::protos::Vector2D* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.Self.velocity)
}

// .protos.Vector2D seen_velocity = 5;
inline bool Self::has_seen_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_velocity_ != nullptr);
  return value;
}
inline void Self::clear_seen_velocity() {
  if (_impl_.seen_velocity_ != nullptr) _impl_.seen_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::protos::Vector2D& Self::_internal_seen_velocity() const {
  const ::protos::Vector2D* p = _impl_.seen_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Self::seen_velocity() const {
  // @@protoc_insertion_point(field_get:protos.Self.seen_velocity)
  return _internal_seen_velocity();
}
inline void Self::unsafe_arena_set_allocated_seen_velocity(
    ::protos::Vector2D* seen_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.seen_velocity_);
  }
  _impl_.seen_velocity_ = seen_velocity;
  if (seen_velocity) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Self.seen_velocity)
}
inline ::protos::Vector2D* Self::release_seen_velocity() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* temp = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Self::unsafe_arena_release_seen_velocity() {
  // @@protoc_insertion_point(field_release:protos.Self.seen_velocity)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* temp = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Self::_internal_mutable_seen_velocity() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.seen_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.seen_velocity_ = p;
  }
  return _impl_.seen_velocity_;
}
inline ::protos::Vector2D* Self::mutable_seen_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_seen_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Self.seen_velocity)
  return _msg;
}
inline void Self::set_allocated_seen_velocity(::protos::Vector2D* seen_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.seen_velocity_;
  }
  if (seen_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seen_velocity);
    if (message_arena != submessage_arena) {
      seen_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seen_velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.seen_velocity_ = seen_velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.Self.seen_velocity)
}

// int32 pos_count = 6;
inline void Self::clear_pos_count() {
  _impl_.pos_count_ = 0;
}
inline ::int32_t Self::pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.pos_count)
  return _internal_pos_count();
}
inline void Self::set_pos_count(::int32_t value) {
  _internal_set_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.pos_count)
}
inline ::int32_t Self::_internal_pos_count() const {
  return _impl_.pos_count_;
}
inline void Self::_internal_set_pos_count(::int32_t value) {
  ;
  _impl_.pos_count_ = value;
}

// int32 seen_pos_count = 7;
inline void Self::clear_seen_pos_count() {
  _impl_.seen_pos_count_ = 0;
}
inline ::int32_t Self::seen_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.seen_pos_count)
  return _internal_seen_pos_count();
}
inline void Self::set_seen_pos_count(::int32_t value) {
  _internal_set_seen_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.seen_pos_count)
}
inline ::int32_t Self::_internal_seen_pos_count() const {
  return _impl_.seen_pos_count_;
}
inline void Self::_internal_set_seen_pos_count(::int32_t value) {
  ;
  _impl_.seen_pos_count_ = value;
}

// int32 heard_pos_count = 8;
inline void Self::clear_heard_pos_count() {
  _impl_.heard_pos_count_ = 0;
}
inline ::int32_t Self::heard_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.heard_pos_count)
  return _internal_heard_pos_count();
}
inline void Self::set_heard_pos_count(::int32_t value) {
  _internal_set_heard_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.heard_pos_count)
}
inline ::int32_t Self::_internal_heard_pos_count() const {
  return _impl_.heard_pos_count_;
}
inline void Self::_internal_set_heard_pos_count(::int32_t value) {
  ;
  _impl_.heard_pos_count_ = value;
}

// int32 vel_count = 9;
inline void Self::clear_vel_count() {
  _impl_.vel_count_ = 0;
}
inline ::int32_t Self::vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.vel_count)
  return _internal_vel_count();
}
inline void Self::set_vel_count(::int32_t value) {
  _internal_set_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.vel_count)
}
inline ::int32_t Self::_internal_vel_count() const {
  return _impl_.vel_count_;
}
inline void Self::_internal_set_vel_count(::int32_t value) {
  ;
  _impl_.vel_count_ = value;
}

// int32 seen_vel_count = 10;
inline void Self::clear_seen_vel_count() {
  _impl_.seen_vel_count_ = 0;
}
inline ::int32_t Self::seen_vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.seen_vel_count)
  return _internal_seen_vel_count();
}
inline void Self::set_seen_vel_count(::int32_t value) {
  _internal_set_seen_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.seen_vel_count)
}
inline ::int32_t Self::_internal_seen_vel_count() const {
  return _impl_.seen_vel_count_;
}
inline void Self::_internal_set_seen_vel_count(::int32_t value) {
  ;
  _impl_.seen_vel_count_ = value;
}

// int32 ghost_count = 11;
inline void Self::clear_ghost_count() {
  _impl_.ghost_count_ = 0;
}
inline ::int32_t Self::ghost_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.ghost_count)
  return _internal_ghost_count();
}
inline void Self::set_ghost_count(::int32_t value) {
  _internal_set_ghost_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.ghost_count)
}
inline ::int32_t Self::_internal_ghost_count() const {
  return _impl_.ghost_count_;
}
inline void Self::_internal_set_ghost_count(::int32_t value) {
  ;
  _impl_.ghost_count_ = value;
}

// int32 id = 12;
inline void Self::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t Self::id() const {
  // @@protoc_insertion_point(field_get:protos.Self.id)
  return _internal_id();
}
inline void Self::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:protos.Self.id)
}
inline ::int32_t Self::_internal_id() const {
  return _impl_.id_;
}
inline void Self::_internal_set_id(::int32_t value) {
  ;
  _impl_.id_ = value;
}

// .protos.Side side = 13;
inline void Self::clear_side() {
  _impl_.side_ = 0;
}
inline ::protos::Side Self::side() const {
  // @@protoc_insertion_point(field_get:protos.Self.side)
  return _internal_side();
}
inline void Self::set_side(::protos::Side value) {
   _internal_set_side(value);
  // @@protoc_insertion_point(field_set:protos.Self.side)
}
inline ::protos::Side Self::_internal_side() const {
  return static_cast<::protos::Side>(_impl_.side_);
}
inline void Self::_internal_set_side(::protos::Side value) {
  ;
  _impl_.side_ = value;
}

// int32 uniform_number = 14;
inline void Self::clear_uniform_number() {
  _impl_.uniform_number_ = 0;
}
inline ::int32_t Self::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.Self.uniform_number)
  return _internal_uniform_number();
}
inline void Self::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.Self.uniform_number)
}
inline ::int32_t Self::_internal_uniform_number() const {
  return _impl_.uniform_number_;
}
inline void Self::_internal_set_uniform_number(::int32_t value) {
  ;
  _impl_.uniform_number_ = value;
}

// int32 uniform_number_count = 15;
inline void Self::clear_uniform_number_count() {
  _impl_.uniform_number_count_ = 0;
}
inline ::int32_t Self::uniform_number_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.uniform_number_count)
  return _internal_uniform_number_count();
}
inline void Self::set_uniform_number_count(::int32_t value) {
  _internal_set_uniform_number_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.uniform_number_count)
}
inline ::int32_t Self::_internal_uniform_number_count() const {
  return _impl_.uniform_number_count_;
}
inline void Self::_internal_set_uniform_number_count(::int32_t value) {
  ;
  _impl_.uniform_number_count_ = value;
}

// bool is_goalie = 16;
inline void Self::clear_is_goalie() {
  _impl_.is_goalie_ = false;
}
inline bool Self::is_goalie() const {
  // @@protoc_insertion_point(field_get:protos.Self.is_goalie)
  return _internal_is_goalie();
}
inline void Self::set_is_goalie(bool value) {
  _internal_set_is_goalie(value);
  // @@protoc_insertion_point(field_set:protos.Self.is_goalie)
}
inline bool Self::_internal_is_goalie() const {
  return _impl_.is_goalie_;
}
inline void Self::_internal_set_is_goalie(bool value) {
  ;
  _impl_.is_goalie_ = value;
}

// float body_direction = 17;
inline void Self::clear_body_direction() {
  _impl_.body_direction_ = 0;
}
inline float Self::body_direction() const {
  // @@protoc_insertion_point(field_get:protos.Self.body_direction)
  return _internal_body_direction();
}
inline void Self::set_body_direction(float value) {
  _internal_set_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.Self.body_direction)
}
inline float Self::_internal_body_direction() const {
  return _impl_.body_direction_;
}
inline void Self::_internal_set_body_direction(float value) {
  ;
  _impl_.body_direction_ = value;
}

// int32 body_direction_count = 18;
inline void Self::clear_body_direction_count() {
  _impl_.body_direction_count_ = 0;
}
inline ::int32_t Self::body_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.body_direction_count)
  return _internal_body_direction_count();
}
inline void Self::set_body_direction_count(::int32_t value) {
  _internal_set_body_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.body_direction_count)
}
inline ::int32_t Self::_internal_body_direction_count() const {
  return _impl_.body_direction_count_;
}
inline void Self::_internal_set_body_direction_count(::int32_t value) {
  ;
  _impl_.body_direction_count_ = value;
}

// float face_direction = 19;
inline void Self::clear_face_direction() {
  _impl_.face_direction_ = 0;
}
inline float Self::face_direction() const {
  // @@protoc_insertion_point(field_get:protos.Self.face_direction)
  return _internal_face_direction();
}
inline void Self::set_face_direction(float value) {
  _internal_set_face_direction(value);
  // @@protoc_insertion_point(field_set:protos.Self.face_direction)
}
inline float Self::_internal_face_direction() const {
  return _impl_.face_direction_;
}
inline void Self::_internal_set_face_direction(float value) {
  ;
  _impl_.face_direction_ = value;
}

// int32 face_direction_count = 20;
inline void Self::clear_face_direction_count() {
  _impl_.face_direction_count_ = 0;
}
inline ::int32_t Self::face_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.face_direction_count)
  return _internal_face_direction_count();
}
inline void Self::set_face_direction_count(::int32_t value) {
  _internal_set_face_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.face_direction_count)
}
inline ::int32_t Self::_internal_face_direction_count() const {
  return _impl_.face_direction_count_;
}
inline void Self::_internal_set_face_direction_count(::int32_t value) {
  ;
  _impl_.face_direction_count_ = value;
}

// float point_to_direction = 21;
inline void Self::clear_point_to_direction() {
  _impl_.point_to_direction_ = 0;
}
inline float Self::point_to_direction() const {
  // @@protoc_insertion_point(field_get:protos.Self.point_to_direction)
  return _internal_point_to_direction();
}
inline void Self::set_point_to_direction(float value) {
  _internal_set_point_to_direction(value);
  // @@protoc_insertion_point(field_set:protos.Self.point_to_direction)
}
inline float Self::_internal_point_to_direction() const {
  return _impl_.point_to_direction_;
}
inline void Self::_internal_set_point_to_direction(float value) {
  ;
  _impl_.point_to_direction_ = value;
}

// int32 point_to_direction_count = 22;
inline void Self::clear_point_to_direction_count() {
  _impl_.point_to_direction_count_ = 0;
}
inline ::int32_t Self::point_to_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.point_to_direction_count)
  return _internal_point_to_direction_count();
}
inline void Self::set_point_to_direction_count(::int32_t value) {
  _internal_set_point_to_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.point_to_direction_count)
}
inline ::int32_t Self::_internal_point_to_direction_count() const {
  return _impl_.point_to_direction_count_;
}
inline void Self::_internal_set_point_to_direction_count(::int32_t value) {
  ;
  _impl_.point_to_direction_count_ = value;
}

// bool is_kicking = 23;
inline void Self::clear_is_kicking() {
  _impl_.is_kicking_ = false;
}
inline bool Self::is_kicking() const {
  // @@protoc_insertion_point(field_get:protos.Self.is_kicking)
  return _internal_is_kicking();
}
inline void Self::set_is_kicking(bool value) {
  _internal_set_is_kicking(value);
  // @@protoc_insertion_point(field_set:protos.Self.is_kicking)
}
inline bool Self::_internal_is_kicking() const {
  return _impl_.is_kicking_;
}
inline void Self::_internal_set_is_kicking(bool value) {
  ;
  _impl_.is_kicking_ = value;
}

// float dist_from_ball = 24;
inline void Self::clear_dist_from_ball() {
  _impl_.dist_from_ball_ = 0;
}
inline float Self::dist_from_ball() const {
  // @@protoc_insertion_point(field_get:protos.Self.dist_from_ball)
  return _internal_dist_from_ball();
}
inline void Self::set_dist_from_ball(float value) {
  _internal_set_dist_from_ball(value);
  // @@protoc_insertion_point(field_set:protos.Self.dist_from_ball)
}
inline float Self::_internal_dist_from_ball() const {
  return _impl_.dist_from_ball_;
}
inline void Self::_internal_set_dist_from_ball(float value) {
  ;
  _impl_.dist_from_ball_ = value;
}

// float angle_from_ball = 25;
inline void Self::clear_angle_from_ball() {
  _impl_.angle_from_ball_ = 0;
}
inline float Self::angle_from_ball() const {
  // @@protoc_insertion_point(field_get:protos.Self.angle_from_ball)
  return _internal_angle_from_ball();
}
inline void Self::set_angle_from_ball(float value) {
  _internal_set_angle_from_ball(value);
  // @@protoc_insertion_point(field_set:protos.Self.angle_from_ball)
}
inline float Self::_internal_angle_from_ball() const {
  return _impl_.angle_from_ball_;
}
inline void Self::_internal_set_angle_from_ball(float value) {
  ;
  _impl_.angle_from_ball_ = value;
}

// int32 ball_reach_steps = 26;
inline void Self::clear_ball_reach_steps() {
  _impl_.ball_reach_steps_ = 0;
}
inline ::int32_t Self::ball_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.Self.ball_reach_steps)
  return _internal_ball_reach_steps();
}
inline void Self::set_ball_reach_steps(::int32_t value) {
  _internal_set_ball_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.Self.ball_reach_steps)
}
inline ::int32_t Self::_internal_ball_reach_steps() const {
  return _impl_.ball_reach_steps_;
}
inline void Self::_internal_set_ball_reach_steps(::int32_t value) {
  ;
  _impl_.ball_reach_steps_ = value;
}

// bool is_tackling = 27;
inline void Self::clear_is_tackling() {
  _impl_.is_tackling_ = false;
}
inline bool Self::is_tackling() const {
  // @@protoc_insertion_point(field_get:protos.Self.is_tackling)
  return _internal_is_tackling();
}
inline void Self::set_is_tackling(bool value) {
  _internal_set_is_tackling(value);
  // @@protoc_insertion_point(field_set:protos.Self.is_tackling)
}
inline bool Self::_internal_is_tackling() const {
  return _impl_.is_tackling_;
}
inline void Self::_internal_set_is_tackling(bool value) {
  ;
  _impl_.is_tackling_ = value;
}

// float relative_neck_direction = 28;
inline void Self::clear_relative_neck_direction() {
  _impl_.relative_neck_direction_ = 0;
}
inline float Self::relative_neck_direction() const {
  // @@protoc_insertion_point(field_get:protos.Self.relative_neck_direction)
  return _internal_relative_neck_direction();
}
inline void Self::set_relative_neck_direction(float value) {
  _internal_set_relative_neck_direction(value);
  // @@protoc_insertion_point(field_set:protos.Self.relative_neck_direction)
}
inline float Self::_internal_relative_neck_direction() const {
  return _impl_.relative_neck_direction_;
}
inline void Self::_internal_set_relative_neck_direction(float value) {
  ;
  _impl_.relative_neck_direction_ = value;
}

// float stamina = 29;
inline void Self::clear_stamina() {
  _impl_.stamina_ = 0;
}
inline float Self::stamina() const {
  // @@protoc_insertion_point(field_get:protos.Self.stamina)
  return _internal_stamina();
}
inline void Self::set_stamina(float value) {
  _internal_set_stamina(value);
  // @@protoc_insertion_point(field_set:protos.Self.stamina)
}
inline float Self::_internal_stamina() const {
  return _impl_.stamina_;
}
inline void Self::_internal_set_stamina(float value) {
  ;
  _impl_.stamina_ = value;
}

// bool is_kickable = 30;
inline void Self::clear_is_kickable() {
  _impl_.is_kickable_ = false;
}
inline bool Self::is_kickable() const {
  // @@protoc_insertion_point(field_get:protos.Self.is_kickable)
  return _internal_is_kickable();
}
inline void Self::set_is_kickable(bool value) {
  _internal_set_is_kickable(value);
  // @@protoc_insertion_point(field_set:protos.Self.is_kickable)
}
inline bool Self::_internal_is_kickable() const {
  return _impl_.is_kickable_;
}
inline void Self::_internal_set_is_kickable(bool value) {
  ;
  _impl_.is_kickable_ = value;
}

// float catch_probability = 31;
inline void Self::clear_catch_probability() {
  _impl_.catch_probability_ = 0;
}
inline float Self::catch_probability() const {
  // @@protoc_insertion_point(field_get:protos.Self.catch_probability)
  return _internal_catch_probability();
}
inline void Self::set_catch_probability(float value) {
  _internal_set_catch_probability(value);
  // @@protoc_insertion_point(field_set:protos.Self.catch_probability)
}
inline float Self::_internal_catch_probability() const {
  return _impl_.catch_probability_;
}
inline void Self::_internal_set_catch_probability(float value) {
  ;
  _impl_.catch_probability_ = value;
}

// float tackle_probability = 32;
inline void Self::clear_tackle_probability() {
  _impl_.tackle_probability_ = 0;
}
inline float Self::tackle_probability() const {
  // @@protoc_insertion_point(field_get:protos.Self.tackle_probability)
  return _internal_tackle_probability();
}
inline void Self::set_tackle_probability(float value) {
  _internal_set_tackle_probability(value);
  // @@protoc_insertion_point(field_set:protos.Self.tackle_probability)
}
inline float Self::_internal_tackle_probability() const {
  return _impl_.tackle_probability_;
}
inline void Self::_internal_set_tackle_probability(float value) {
  ;
  _impl_.tackle_probability_ = value;
}

// float foul_probability = 33;
inline void Self::clear_foul_probability() {
  _impl_.foul_probability_ = 0;
}
inline float Self::foul_probability() const {
  // @@protoc_insertion_point(field_get:protos.Self.foul_probability)
  return _internal_foul_probability();
}
inline void Self::set_foul_probability(float value) {
  _internal_set_foul_probability(value);
  // @@protoc_insertion_point(field_set:protos.Self.foul_probability)
}
inline float Self::_internal_foul_probability() const {
  return _impl_.foul_probability_;
}
inline void Self::_internal_set_foul_probability(float value) {
  ;
  _impl_.foul_probability_ = value;
}

// .protos.ViewWidth view_width = 34;
inline void Self::clear_view_width() {
  _impl_.view_width_ = 0;
}
inline ::protos::ViewWidth Self::view_width() const {
  // @@protoc_insertion_point(field_get:protos.Self.view_width)
  return _internal_view_width();
}
inline void Self::set_view_width(::protos::ViewWidth value) {
   _internal_set_view_width(value);
  // @@protoc_insertion_point(field_set:protos.Self.view_width)
}
inline ::protos::ViewWidth Self::_internal_view_width() const {
  return static_cast<::protos::ViewWidth>(_impl_.view_width_);
}
inline void Self::_internal_set_view_width(::protos::ViewWidth value) {
  ;
  _impl_.view_width_ = value;
}

// -------------------------------------------------------------------

// InterceptInfo

// .protos.InterceptActionType action_type = 1;
inline void InterceptInfo::clear_action_type() {
  _impl_.action_type_ = 0;
}
inline ::protos::InterceptActionType InterceptInfo::action_type() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.action_type)
  return _internal_action_type();
}
inline void InterceptInfo::set_action_type(::protos::InterceptActionType value) {
   _internal_set_action_type(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.action_type)
}
inline ::protos::InterceptActionType InterceptInfo::_internal_action_type() const {
  return static_cast<::protos::InterceptActionType>(_impl_.action_type_);
}
inline void InterceptInfo::_internal_set_action_type(::protos::InterceptActionType value) {
  ;
  _impl_.action_type_ = value;
}

// int32 turn_steps = 2;
inline void InterceptInfo::clear_turn_steps() {
  _impl_.turn_steps_ = 0;
}
inline ::int32_t InterceptInfo::turn_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.turn_steps)
  return _internal_turn_steps();
}
inline void InterceptInfo::set_turn_steps(::int32_t value) {
  _internal_set_turn_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.turn_steps)
}
inline ::int32_t InterceptInfo::_internal_turn_steps() const {
  return _impl_.turn_steps_;
}
inline void InterceptInfo::_internal_set_turn_steps(::int32_t value) {
  ;
  _impl_.turn_steps_ = value;
}

// float turn_angle = 3;
inline void InterceptInfo::clear_turn_angle() {
  _impl_.turn_angle_ = 0;
}
inline float InterceptInfo::turn_angle() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.turn_angle)
  return _internal_turn_angle();
}
inline void InterceptInfo::set_turn_angle(float value) {
  _internal_set_turn_angle(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.turn_angle)
}
inline float InterceptInfo::_internal_turn_angle() const {
  return _impl_.turn_angle_;
}
inline void InterceptInfo::_internal_set_turn_angle(float value) {
  ;
  _impl_.turn_angle_ = value;
}

// int32 dash_steps = 4;
inline void InterceptInfo::clear_dash_steps() {
  _impl_.dash_steps_ = 0;
}
inline ::int32_t InterceptInfo::dash_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.dash_steps)
  return _internal_dash_steps();
}
inline void InterceptInfo::set_dash_steps(::int32_t value) {
  _internal_set_dash_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.dash_steps)
}
inline ::int32_t InterceptInfo::_internal_dash_steps() const {
  return _impl_.dash_steps_;
}
inline void InterceptInfo::_internal_set_dash_steps(::int32_t value) {
  ;
  _impl_.dash_steps_ = value;
}

// float dash_power = 5;
inline void InterceptInfo::clear_dash_power() {
  _impl_.dash_power_ = 0;
}
inline float InterceptInfo::dash_power() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.dash_power)
  return _internal_dash_power();
}
inline void InterceptInfo::set_dash_power(float value) {
  _internal_set_dash_power(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.dash_power)
}
inline float InterceptInfo::_internal_dash_power() const {
  return _impl_.dash_power_;
}
inline void InterceptInfo::_internal_set_dash_power(float value) {
  ;
  _impl_.dash_power_ = value;
}

// float dash_dir = 6;
inline void InterceptInfo::clear_dash_dir() {
  _impl_.dash_dir_ = 0;
}
inline float InterceptInfo::dash_dir() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.dash_dir)
  return _internal_dash_dir();
}
inline void InterceptInfo::set_dash_dir(float value) {
  _internal_set_dash_dir(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.dash_dir)
}
inline float InterceptInfo::_internal_dash_dir() const {
  return _impl_.dash_dir_;
}
inline void InterceptInfo::_internal_set_dash_dir(float value) {
  ;
  _impl_.dash_dir_ = value;
}

// .protos.Vector2D final_self_position = 7;
inline bool InterceptInfo::has_final_self_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.final_self_position_ != nullptr);
  return value;
}
inline void InterceptInfo::clear_final_self_position() {
  if (_impl_.final_self_position_ != nullptr) _impl_.final_self_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& InterceptInfo::_internal_final_self_position() const {
  const ::protos::Vector2D* p = _impl_.final_self_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& InterceptInfo::final_self_position() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.final_self_position)
  return _internal_final_self_position();
}
inline void InterceptInfo::unsafe_arena_set_allocated_final_self_position(
    ::protos::Vector2D* final_self_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.final_self_position_);
  }
  _impl_.final_self_position_ = final_self_position;
  if (final_self_position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.InterceptInfo.final_self_position)
}
inline ::protos::Vector2D* InterceptInfo::release_final_self_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.final_self_position_;
  _impl_.final_self_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* InterceptInfo::unsafe_arena_release_final_self_position() {
  // @@protoc_insertion_point(field_release:protos.InterceptInfo.final_self_position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.final_self_position_;
  _impl_.final_self_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* InterceptInfo::_internal_mutable_final_self_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.final_self_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.final_self_position_ = p;
  }
  return _impl_.final_self_position_;
}
inline ::protos::Vector2D* InterceptInfo::mutable_final_self_position() {
  ::protos::Vector2D* _msg = _internal_mutable_final_self_position();
  // @@protoc_insertion_point(field_mutable:protos.InterceptInfo.final_self_position)
  return _msg;
}
inline void InterceptInfo::set_allocated_final_self_position(::protos::Vector2D* final_self_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.final_self_position_;
  }
  if (final_self_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(final_self_position);
    if (message_arena != submessage_arena) {
      final_self_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, final_self_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.final_self_position_ = final_self_position;
  // @@protoc_insertion_point(field_set_allocated:protos.InterceptInfo.final_self_position)
}

// float final_ball_dist = 8;
inline void InterceptInfo::clear_final_ball_dist() {
  _impl_.final_ball_dist_ = 0;
}
inline float InterceptInfo::final_ball_dist() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.final_ball_dist)
  return _internal_final_ball_dist();
}
inline void InterceptInfo::set_final_ball_dist(float value) {
  _internal_set_final_ball_dist(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.final_ball_dist)
}
inline float InterceptInfo::_internal_final_ball_dist() const {
  return _impl_.final_ball_dist_;
}
inline void InterceptInfo::_internal_set_final_ball_dist(float value) {
  ;
  _impl_.final_ball_dist_ = value;
}

// float final_stamina = 9;
inline void InterceptInfo::clear_final_stamina() {
  _impl_.final_stamina_ = 0;
}
inline float InterceptInfo::final_stamina() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.final_stamina)
  return _internal_final_stamina();
}
inline void InterceptInfo::set_final_stamina(float value) {
  _internal_set_final_stamina(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.final_stamina)
}
inline float InterceptInfo::_internal_final_stamina() const {
  return _impl_.final_stamina_;
}
inline void InterceptInfo::_internal_set_final_stamina(float value) {
  ;
  _impl_.final_stamina_ = value;
}

// float value = 10;
inline void InterceptInfo::clear_value() {
  _impl_.value_ = 0;
}
inline float InterceptInfo::value() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.value)
  return _internal_value();
}
inline void InterceptInfo::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.value)
}
inline float InterceptInfo::_internal_value() const {
  return _impl_.value_;
}
inline void InterceptInfo::_internal_set_value(float value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// InterceptTable

// int32 self_reach_steps = 1;
inline void InterceptTable::clear_self_reach_steps() {
  _impl_.self_reach_steps_ = 0;
}
inline ::int32_t InterceptTable::self_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.self_reach_steps)
  return _internal_self_reach_steps();
}
inline void InterceptTable::set_self_reach_steps(::int32_t value) {
  _internal_set_self_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.self_reach_steps)
}
inline ::int32_t InterceptTable::_internal_self_reach_steps() const {
  return _impl_.self_reach_steps_;
}
inline void InterceptTable::_internal_set_self_reach_steps(::int32_t value) {
  ;
  _impl_.self_reach_steps_ = value;
}

// int32 first_teammate_reach_steps = 2;
inline void InterceptTable::clear_first_teammate_reach_steps() {
  _impl_.first_teammate_reach_steps_ = 0;
}
inline ::int32_t InterceptTable::first_teammate_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.first_teammate_reach_steps)
  return _internal_first_teammate_reach_steps();
}
inline void InterceptTable::set_first_teammate_reach_steps(::int32_t value) {
  _internal_set_first_teammate_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.first_teammate_reach_steps)
}
inline ::int32_t InterceptTable::_internal_first_teammate_reach_steps() const {
  return _impl_.first_teammate_reach_steps_;
}
inline void InterceptTable::_internal_set_first_teammate_reach_steps(::int32_t value) {
  ;
  _impl_.first_teammate_reach_steps_ = value;
}

// int32 second_teammate_reach_steps = 3;
inline void InterceptTable::clear_second_teammate_reach_steps() {
  _impl_.second_teammate_reach_steps_ = 0;
}
inline ::int32_t InterceptTable::second_teammate_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.second_teammate_reach_steps)
  return _internal_second_teammate_reach_steps();
}
inline void InterceptTable::set_second_teammate_reach_steps(::int32_t value) {
  _internal_set_second_teammate_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.second_teammate_reach_steps)
}
inline ::int32_t InterceptTable::_internal_second_teammate_reach_steps() const {
  return _impl_.second_teammate_reach_steps_;
}
inline void InterceptTable::_internal_set_second_teammate_reach_steps(::int32_t value) {
  ;
  _impl_.second_teammate_reach_steps_ = value;
}

// int32 first_opponent_reach_steps = 4;
inline void InterceptTable::clear_first_opponent_reach_steps() {
  _impl_.first_opponent_reach_steps_ = 0;
}
inline ::int32_t InterceptTable::first_opponent_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.first_opponent_reach_steps)
  return _internal_first_opponent_reach_steps();
}
inline void InterceptTable::set_first_opponent_reach_steps(::int32_t value) {
  _internal_set_first_opponent_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.first_opponent_reach_steps)
}
inline ::int32_t InterceptTable::_internal_first_opponent_reach_steps() const {
  return _impl_.first_opponent_reach_steps_;
}
inline void InterceptTable::_internal_set_first_opponent_reach_steps(::int32_t value) {
  ;
  _impl_.first_opponent_reach_steps_ = value;
}

// int32 second_opponent_reach_steps = 5;
inline void InterceptTable::clear_second_opponent_reach_steps() {
  _impl_.second_opponent_reach_steps_ = 0;
}
inline ::int32_t InterceptTable::second_opponent_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.second_opponent_reach_steps)
  return _internal_second_opponent_reach_steps();
}
inline void InterceptTable::set_second_opponent_reach_steps(::int32_t value) {
  _internal_set_second_opponent_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.second_opponent_reach_steps)
}
inline ::int32_t InterceptTable::_internal_second_opponent_reach_steps() const {
  return _impl_.second_opponent_reach_steps_;
}
inline void InterceptTable::_internal_set_second_opponent_reach_steps(::int32_t value) {
  ;
  _impl_.second_opponent_reach_steps_ = value;
}

// int32 first_teammate_id = 6;
inline void InterceptTable::clear_first_teammate_id() {
  _impl_.first_teammate_id_ = 0;
}
inline ::int32_t InterceptTable::first_teammate_id() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.first_teammate_id)
  return _internal_first_teammate_id();
}
inline void InterceptTable::set_first_teammate_id(::int32_t value) {
  _internal_set_first_teammate_id(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.first_teammate_id)
}
inline ::int32_t InterceptTable::_internal_first_teammate_id() const {
  return _impl_.first_teammate_id_;
}
inline void InterceptTable::_internal_set_first_teammate_id(::int32_t value) {
  ;
  _impl_.first_teammate_id_ = value;
}

// int32 second_teammate_id = 7;
inline void InterceptTable::clear_second_teammate_id() {
  _impl_.second_teammate_id_ = 0;
}
inline ::int32_t InterceptTable::second_teammate_id() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.second_teammate_id)
  return _internal_second_teammate_id();
}
inline void InterceptTable::set_second_teammate_id(::int32_t value) {
  _internal_set_second_teammate_id(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.second_teammate_id)
}
inline ::int32_t InterceptTable::_internal_second_teammate_id() const {
  return _impl_.second_teammate_id_;
}
inline void InterceptTable::_internal_set_second_teammate_id(::int32_t value) {
  ;
  _impl_.second_teammate_id_ = value;
}

// int32 first_opponent_id = 8;
inline void InterceptTable::clear_first_opponent_id() {
  _impl_.first_opponent_id_ = 0;
}
inline ::int32_t InterceptTable::first_opponent_id() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.first_opponent_id)
  return _internal_first_opponent_id();
}
inline void InterceptTable::set_first_opponent_id(::int32_t value) {
  _internal_set_first_opponent_id(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.first_opponent_id)
}
inline ::int32_t InterceptTable::_internal_first_opponent_id() const {
  return _impl_.first_opponent_id_;
}
inline void InterceptTable::_internal_set_first_opponent_id(::int32_t value) {
  ;
  _impl_.first_opponent_id_ = value;
}

// int32 second_opponent_id = 9;
inline void InterceptTable::clear_second_opponent_id() {
  _impl_.second_opponent_id_ = 0;
}
inline ::int32_t InterceptTable::second_opponent_id() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.second_opponent_id)
  return _internal_second_opponent_id();
}
inline void InterceptTable::set_second_opponent_id(::int32_t value) {
  _internal_set_second_opponent_id(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.second_opponent_id)
}
inline ::int32_t InterceptTable::_internal_second_opponent_id() const {
  return _impl_.second_opponent_id_;
}
inline void InterceptTable::_internal_set_second_opponent_id(::int32_t value) {
  ;
  _impl_.second_opponent_id_ = value;
}

// repeated .protos.InterceptInfo self_intercept_info = 10;
inline int InterceptTable::_internal_self_intercept_info_size() const {
  return _impl_.self_intercept_info_.size();
}
inline int InterceptTable::self_intercept_info_size() const {
  return _internal_self_intercept_info_size();
}
inline void InterceptTable::clear_self_intercept_info() {
  _internal_mutable_self_intercept_info()->Clear();
}
inline ::protos::InterceptInfo* InterceptTable::mutable_self_intercept_info(int index) {
  // @@protoc_insertion_point(field_mutable:protos.InterceptTable.self_intercept_info)
  return _internal_mutable_self_intercept_info()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::InterceptInfo >*
InterceptTable::mutable_self_intercept_info() {
  // @@protoc_insertion_point(field_mutable_list:protos.InterceptTable.self_intercept_info)
  return _internal_mutable_self_intercept_info();
}
inline const ::protos::InterceptInfo& InterceptTable::_internal_self_intercept_info(int index) const {
  return _internal_self_intercept_info().Get(index);
}
inline const ::protos::InterceptInfo& InterceptTable::self_intercept_info(int index) const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.self_intercept_info)
  return _internal_self_intercept_info(index);
}
inline ::protos::InterceptInfo* InterceptTable::_internal_add_self_intercept_info() {
  return _internal_mutable_self_intercept_info()->Add();
}
inline ::protos::InterceptInfo* InterceptTable::add_self_intercept_info() {
  ::protos::InterceptInfo* _add = _internal_add_self_intercept_info();
  // @@protoc_insertion_point(field_add:protos.InterceptTable.self_intercept_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::InterceptInfo >&
InterceptTable::self_intercept_info() const {
  // @@protoc_insertion_point(field_list:protos.InterceptTable.self_intercept_info)
  return _internal_self_intercept_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::InterceptInfo>&
InterceptTable::_internal_self_intercept_info() const {
  return _impl_.self_intercept_info_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::InterceptInfo>*
InterceptTable::_internal_mutable_self_intercept_info() {
  return &_impl_.self_intercept_info_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WorldModel

// .protos.InterceptTable intercept_table = 1;
inline bool WorldModel::has_intercept_table() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.intercept_table_ != nullptr);
  return value;
}
inline void WorldModel::clear_intercept_table() {
  if (_impl_.intercept_table_ != nullptr) _impl_.intercept_table_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::InterceptTable& WorldModel::_internal_intercept_table() const {
  const ::protos::InterceptTable* p = _impl_.intercept_table_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::InterceptTable&>(
      ::protos::_InterceptTable_default_instance_);
}
inline const ::protos::InterceptTable& WorldModel::intercept_table() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.intercept_table)
  return _internal_intercept_table();
}
inline void WorldModel::unsafe_arena_set_allocated_intercept_table(
    ::protos::InterceptTable* intercept_table) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.intercept_table_);
  }
  _impl_.intercept_table_ = intercept_table;
  if (intercept_table) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.WorldModel.intercept_table)
}
inline ::protos::InterceptTable* WorldModel::release_intercept_table() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::InterceptTable* temp = _impl_.intercept_table_;
  _impl_.intercept_table_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::InterceptTable* WorldModel::unsafe_arena_release_intercept_table() {
  // @@protoc_insertion_point(field_release:protos.WorldModel.intercept_table)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::InterceptTable* temp = _impl_.intercept_table_;
  _impl_.intercept_table_ = nullptr;
  return temp;
}
inline ::protos::InterceptTable* WorldModel::_internal_mutable_intercept_table() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.intercept_table_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::InterceptTable>(GetArenaForAllocation());
    _impl_.intercept_table_ = p;
  }
  return _impl_.intercept_table_;
}
inline ::protos::InterceptTable* WorldModel::mutable_intercept_table() {
  ::protos::InterceptTable* _msg = _internal_mutable_intercept_table();
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.intercept_table)
  return _msg;
}
inline void WorldModel::set_allocated_intercept_table(::protos::InterceptTable* intercept_table) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.intercept_table_;
  }
  if (intercept_table) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(intercept_table);
    if (message_arena != submessage_arena) {
      intercept_table = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intercept_table, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.intercept_table_ = intercept_table;
  // @@protoc_insertion_point(field_set_allocated:protos.WorldModel.intercept_table)
}

// string our_team_name = 2;
inline void WorldModel::clear_our_team_name() {
  _impl_.our_team_name_.ClearToEmpty();
}
inline const std::string& WorldModel::our_team_name() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.our_team_name)
  return _internal_our_team_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldModel::set_our_team_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.our_team_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.WorldModel.our_team_name)
}
inline std::string* WorldModel::mutable_our_team_name() {
  std::string* _s = _internal_mutable_our_team_name();
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.our_team_name)
  return _s;
}
inline const std::string& WorldModel::_internal_our_team_name() const {
  return _impl_.our_team_name_.Get();
}
inline void WorldModel::_internal_set_our_team_name(const std::string& value) {
  ;


  _impl_.our_team_name_.Set(value, GetArenaForAllocation());
}
inline std::string* WorldModel::_internal_mutable_our_team_name() {
  ;
  return _impl_.our_team_name_.Mutable( GetArenaForAllocation());
}
inline std::string* WorldModel::release_our_team_name() {
  // @@protoc_insertion_point(field_release:protos.WorldModel.our_team_name)
  return _impl_.our_team_name_.Release();
}
inline void WorldModel::set_allocated_our_team_name(std::string* value) {
  _impl_.our_team_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.our_team_name_.IsDefault()) {
          _impl_.our_team_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.WorldModel.our_team_name)
}

// string their_team_name = 3;
inline void WorldModel::clear_their_team_name() {
  _impl_.their_team_name_.ClearToEmpty();
}
inline const std::string& WorldModel::their_team_name() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.their_team_name)
  return _internal_their_team_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldModel::set_their_team_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.their_team_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.WorldModel.their_team_name)
}
inline std::string* WorldModel::mutable_their_team_name() {
  std::string* _s = _internal_mutable_their_team_name();
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.their_team_name)
  return _s;
}
inline const std::string& WorldModel::_internal_their_team_name() const {
  return _impl_.their_team_name_.Get();
}
inline void WorldModel::_internal_set_their_team_name(const std::string& value) {
  ;


  _impl_.their_team_name_.Set(value, GetArenaForAllocation());
}
inline std::string* WorldModel::_internal_mutable_their_team_name() {
  ;
  return _impl_.their_team_name_.Mutable( GetArenaForAllocation());
}
inline std::string* WorldModel::release_their_team_name() {
  // @@protoc_insertion_point(field_release:protos.WorldModel.their_team_name)
  return _impl_.their_team_name_.Release();
}
inline void WorldModel::set_allocated_their_team_name(std::string* value) {
  _impl_.their_team_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.their_team_name_.IsDefault()) {
          _impl_.their_team_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.WorldModel.their_team_name)
}

// .protos.Side our_side = 4;
inline void WorldModel::clear_our_side() {
  _impl_.our_side_ = 0;
}
inline ::protos::Side WorldModel::our_side() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.our_side)
  return _internal_our_side();
}
inline void WorldModel::set_our_side(::protos::Side value) {
   _internal_set_our_side(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.our_side)
}
inline ::protos::Side WorldModel::_internal_our_side() const {
  return static_cast<::protos::Side>(_impl_.our_side_);
}
inline void WorldModel::_internal_set_our_side(::protos::Side value) {
  ;
  _impl_.our_side_ = value;
}

// int32 last_set_play_start_time = 5;
inline void WorldModel::clear_last_set_play_start_time() {
  _impl_.last_set_play_start_time_ = 0;
}
inline ::int32_t WorldModel::last_set_play_start_time() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.last_set_play_start_time)
  return _internal_last_set_play_start_time();
}
inline void WorldModel::set_last_set_play_start_time(::int32_t value) {
  _internal_set_last_set_play_start_time(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.last_set_play_start_time)
}
inline ::int32_t WorldModel::_internal_last_set_play_start_time() const {
  return _impl_.last_set_play_start_time_;
}
inline void WorldModel::_internal_set_last_set_play_start_time(::int32_t value) {
  ;
  _impl_.last_set_play_start_time_ = value;
}

// .protos.Self self = 6;
inline bool WorldModel::has_self() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.self_ != nullptr);
  return value;
}
inline void WorldModel::clear_self() {
  if (_impl_.self_ != nullptr) _impl_.self_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Self& WorldModel::_internal_self() const {
  const ::protos::Self* p = _impl_.self_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Self&>(
      ::protos::_Self_default_instance_);
}
inline const ::protos::Self& WorldModel::self() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.self)
  return _internal_self();
}
inline void WorldModel::unsafe_arena_set_allocated_self(
    ::protos::Self* self) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.self_);
  }
  _impl_.self_ = self;
  if (self) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.WorldModel.self)
}
inline ::protos::Self* WorldModel::release_self() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Self* temp = _impl_.self_;
  _impl_.self_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Self* WorldModel::unsafe_arena_release_self() {
  // @@protoc_insertion_point(field_release:protos.WorldModel.self)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Self* temp = _impl_.self_;
  _impl_.self_ = nullptr;
  return temp;
}
inline ::protos::Self* WorldModel::_internal_mutable_self() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.self_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Self>(GetArenaForAllocation());
    _impl_.self_ = p;
  }
  return _impl_.self_;
}
inline ::protos::Self* WorldModel::mutable_self() {
  ::protos::Self* _msg = _internal_mutable_self();
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.self)
  return _msg;
}
inline void WorldModel::set_allocated_self(::protos::Self* self) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.self_;
  }
  if (self) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(self);
    if (message_arena != submessage_arena) {
      self = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, self, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.self_ = self;
  // @@protoc_insertion_point(field_set_allocated:protos.WorldModel.self)
}

// .protos.Ball ball = 7;
inline bool WorldModel::has_ball() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_ != nullptr);
  return value;
}
inline void WorldModel::clear_ball() {
  if (_impl_.ball_ != nullptr) _impl_.ball_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Ball& WorldModel::_internal_ball() const {
  const ::protos::Ball* p = _impl_.ball_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Ball&>(
      ::protos::_Ball_default_instance_);
}
inline const ::protos::Ball& WorldModel::ball() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.ball)
  return _internal_ball();
}
inline void WorldModel::unsafe_arena_set_allocated_ball(
    ::protos::Ball* ball) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ball_);
  }
  _impl_.ball_ = ball;
  if (ball) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.WorldModel.ball)
}
inline ::protos::Ball* WorldModel::release_ball() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Ball* temp = _impl_.ball_;
  _impl_.ball_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Ball* WorldModel::unsafe_arena_release_ball() {
  // @@protoc_insertion_point(field_release:protos.WorldModel.ball)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Ball* temp = _impl_.ball_;
  _impl_.ball_ = nullptr;
  return temp;
}
inline ::protos::Ball* WorldModel::_internal_mutable_ball() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.ball_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Ball>(GetArenaForAllocation());
    _impl_.ball_ = p;
  }
  return _impl_.ball_;
}
inline ::protos::Ball* WorldModel::mutable_ball() {
  ::protos::Ball* _msg = _internal_mutable_ball();
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.ball)
  return _msg;
}
inline void WorldModel::set_allocated_ball(::protos::Ball* ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ball_;
  }
  if (ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball);
    if (message_arena != submessage_arena) {
      ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ball_ = ball;
  // @@protoc_insertion_point(field_set_allocated:protos.WorldModel.ball)
}

// repeated .protos.Player teammates = 8;
inline int WorldModel::_internal_teammates_size() const {
  return _impl_.teammates_.size();
}
inline int WorldModel::teammates_size() const {
  return _internal_teammates_size();
}
inline void WorldModel::clear_teammates() {
  _internal_mutable_teammates()->Clear();
}
inline ::protos::Player* WorldModel::mutable_teammates(int index) {
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.teammates)
  return _internal_mutable_teammates()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >*
WorldModel::mutable_teammates() {
  // @@protoc_insertion_point(field_mutable_list:protos.WorldModel.teammates)
  return _internal_mutable_teammates();
}
inline const ::protos::Player& WorldModel::_internal_teammates(int index) const {
  return _internal_teammates().Get(index);
}
inline const ::protos::Player& WorldModel::teammates(int index) const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.teammates)
  return _internal_teammates(index);
}
inline ::protos::Player* WorldModel::_internal_add_teammates() {
  return _internal_mutable_teammates()->Add();
}
inline ::protos::Player* WorldModel::add_teammates() {
  ::protos::Player* _add = _internal_add_teammates();
  // @@protoc_insertion_point(field_add:protos.WorldModel.teammates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >&
WorldModel::teammates() const {
  // @@protoc_insertion_point(field_list:protos.WorldModel.teammates)
  return _internal_teammates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>&
WorldModel::_internal_teammates() const {
  return _impl_.teammates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>*
WorldModel::_internal_mutable_teammates() {
  return &_impl_.teammates_;
}

// repeated .protos.Player opponents = 9;
inline int WorldModel::_internal_opponents_size() const {
  return _impl_.opponents_.size();
}
inline int WorldModel::opponents_size() const {
  return _internal_opponents_size();
}
inline void WorldModel::clear_opponents() {
  _internal_mutable_opponents()->Clear();
}
inline ::protos::Player* WorldModel::mutable_opponents(int index) {
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.opponents)
  return _internal_mutable_opponents()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >*
WorldModel::mutable_opponents() {
  // @@protoc_insertion_point(field_mutable_list:protos.WorldModel.opponents)
  return _internal_mutable_opponents();
}
inline const ::protos::Player& WorldModel::_internal_opponents(int index) const {
  return _internal_opponents().Get(index);
}
inline const ::protos::Player& WorldModel::opponents(int index) const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.opponents)
  return _internal_opponents(index);
}
inline ::protos::Player* WorldModel::_internal_add_opponents() {
  return _internal_mutable_opponents()->Add();
}
inline ::protos::Player* WorldModel::add_opponents() {
  ::protos::Player* _add = _internal_add_opponents();
  // @@protoc_insertion_point(field_add:protos.WorldModel.opponents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >&
WorldModel::opponents() const {
  // @@protoc_insertion_point(field_list:protos.WorldModel.opponents)
  return _internal_opponents();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>&
WorldModel::_internal_opponents() const {
  return _impl_.opponents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>*
WorldModel::_internal_mutable_opponents() {
  return &_impl_.opponents_;
}

// repeated .protos.Player unknowns = 10;
inline int WorldModel::_internal_unknowns_size() const {
  return _impl_.unknowns_.size();
}
inline int WorldModel::unknowns_size() const {
  return _internal_unknowns_size();
}
inline void WorldModel::clear_unknowns() {
  _internal_mutable_unknowns()->Clear();
}
inline ::protos::Player* WorldModel::mutable_unknowns(int index) {
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.unknowns)
  return _internal_mutable_unknowns()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >*
WorldModel::mutable_unknowns() {
  // @@protoc_insertion_point(field_mutable_list:protos.WorldModel.unknowns)
  return _internal_mutable_unknowns();
}
inline const ::protos::Player& WorldModel::_internal_unknowns(int index) const {
  return _internal_unknowns().Get(index);
}
inline const ::protos::Player& WorldModel::unknowns(int index) const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.unknowns)
  return _internal_unknowns(index);
}
inline ::protos::Player* WorldModel::_internal_add_unknowns() {
  return _internal_mutable_unknowns()->Add();
}
inline ::protos::Player* WorldModel::add_unknowns() {
  ::protos::Player* _add = _internal_add_unknowns();
  // @@protoc_insertion_point(field_add:protos.WorldModel.unknowns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >&
WorldModel::unknowns() const {
  // @@protoc_insertion_point(field_list:protos.WorldModel.unknowns)
  return _internal_unknowns();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>&
WorldModel::_internal_unknowns() const {
  return _impl_.unknowns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>*
WorldModel::_internal_mutable_unknowns() {
  return &_impl_.unknowns_;
}

// map<int32, .protos.Player> our_players_dict = 11;
inline int WorldModel::_internal_our_players_dict_size() const {
  return _impl_.our_players_dict_.size();
}
inline int WorldModel::our_players_dict_size() const {
  return _internal_our_players_dict_size();
}
inline void WorldModel::clear_our_players_dict() {
  _impl_.our_players_dict_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >&
WorldModel::_internal_our_players_dict() const {
  return _impl_.our_players_dict_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >&
WorldModel::our_players_dict() const {
  // @@protoc_insertion_point(field_map:protos.WorldModel.our_players_dict)
  return _internal_our_players_dict();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >*
WorldModel::_internal_mutable_our_players_dict() {
  return _impl_.our_players_dict_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >*
WorldModel::mutable_our_players_dict() {
  // @@protoc_insertion_point(field_mutable_map:protos.WorldModel.our_players_dict)
  return _internal_mutable_our_players_dict();
}

// map<int32, .protos.Player> their_players_dict = 12;
inline int WorldModel::_internal_their_players_dict_size() const {
  return _impl_.their_players_dict_.size();
}
inline int WorldModel::their_players_dict_size() const {
  return _internal_their_players_dict_size();
}
inline void WorldModel::clear_their_players_dict() {
  _impl_.their_players_dict_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >&
WorldModel::_internal_their_players_dict() const {
  return _impl_.their_players_dict_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >&
WorldModel::their_players_dict() const {
  // @@protoc_insertion_point(field_map:protos.WorldModel.their_players_dict)
  return _internal_their_players_dict();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >*
WorldModel::_internal_mutable_their_players_dict() {
  return _impl_.their_players_dict_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >*
WorldModel::mutable_their_players_dict() {
  // @@protoc_insertion_point(field_mutable_map:protos.WorldModel.their_players_dict)
  return _internal_mutable_their_players_dict();
}

// int32 our_goalie_uniform_number = 13;
inline void WorldModel::clear_our_goalie_uniform_number() {
  _impl_.our_goalie_uniform_number_ = 0;
}
inline ::int32_t WorldModel::our_goalie_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.our_goalie_uniform_number)
  return _internal_our_goalie_uniform_number();
}
inline void WorldModel::set_our_goalie_uniform_number(::int32_t value) {
  _internal_set_our_goalie_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.our_goalie_uniform_number)
}
inline ::int32_t WorldModel::_internal_our_goalie_uniform_number() const {
  return _impl_.our_goalie_uniform_number_;
}
inline void WorldModel::_internal_set_our_goalie_uniform_number(::int32_t value) {
  ;
  _impl_.our_goalie_uniform_number_ = value;
}

// int32 their_goalie_uniform_number = 14;
inline void WorldModel::clear_their_goalie_uniform_number() {
  _impl_.their_goalie_uniform_number_ = 0;
}
inline ::int32_t WorldModel::their_goalie_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.their_goalie_uniform_number)
  return _internal_their_goalie_uniform_number();
}
inline void WorldModel::set_their_goalie_uniform_number(::int32_t value) {
  _internal_set_their_goalie_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.their_goalie_uniform_number)
}
inline ::int32_t WorldModel::_internal_their_goalie_uniform_number() const {
  return _impl_.their_goalie_uniform_number_;
}
inline void WorldModel::_internal_set_their_goalie_uniform_number(::int32_t value) {
  ;
  _impl_.their_goalie_uniform_number_ = value;
}

// float offside_line_x = 15;
inline void WorldModel::clear_offside_line_x() {
  _impl_.offside_line_x_ = 0;
}
inline float WorldModel::offside_line_x() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.offside_line_x)
  return _internal_offside_line_x();
}
inline void WorldModel::set_offside_line_x(float value) {
  _internal_set_offside_line_x(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.offside_line_x)
}
inline float WorldModel::_internal_offside_line_x() const {
  return _impl_.offside_line_x_;
}
inline void WorldModel::_internal_set_offside_line_x(float value) {
  ;
  _impl_.offside_line_x_ = value;
}

// int32 ofside_line_x_count = 16;
inline void WorldModel::clear_ofside_line_x_count() {
  _impl_.ofside_line_x_count_ = 0;
}
inline ::int32_t WorldModel::ofside_line_x_count() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.ofside_line_x_count)
  return _internal_ofside_line_x_count();
}
inline void WorldModel::set_ofside_line_x_count(::int32_t value) {
  _internal_set_ofside_line_x_count(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.ofside_line_x_count)
}
inline ::int32_t WorldModel::_internal_ofside_line_x_count() const {
  return _impl_.ofside_line_x_count_;
}
inline void WorldModel::_internal_set_ofside_line_x_count(::int32_t value) {
  ;
  _impl_.ofside_line_x_count_ = value;
}

// int32 kickable_teammate_id = 17;
inline void WorldModel::clear_kickable_teammate_id() {
  _impl_.kickable_teammate_id_ = 0;
}
inline ::int32_t WorldModel::kickable_teammate_id() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.kickable_teammate_id)
  return _internal_kickable_teammate_id();
}
inline void WorldModel::set_kickable_teammate_id(::int32_t value) {
  _internal_set_kickable_teammate_id(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.kickable_teammate_id)
}
inline ::int32_t WorldModel::_internal_kickable_teammate_id() const {
  return _impl_.kickable_teammate_id_;
}
inline void WorldModel::_internal_set_kickable_teammate_id(::int32_t value) {
  ;
  _impl_.kickable_teammate_id_ = value;
}

// int32 kickable_opponent_id = 18;
inline void WorldModel::clear_kickable_opponent_id() {
  _impl_.kickable_opponent_id_ = 0;
}
inline ::int32_t WorldModel::kickable_opponent_id() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.kickable_opponent_id)
  return _internal_kickable_opponent_id();
}
inline void WorldModel::set_kickable_opponent_id(::int32_t value) {
  _internal_set_kickable_opponent_id(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.kickable_opponent_id)
}
inline ::int32_t WorldModel::_internal_kickable_opponent_id() const {
  return _impl_.kickable_opponent_id_;
}
inline void WorldModel::_internal_set_kickable_opponent_id(::int32_t value) {
  ;
  _impl_.kickable_opponent_id_ = value;
}

// .protos.Side last_kick_side = 19;
inline void WorldModel::clear_last_kick_side() {
  _impl_.last_kick_side_ = 0;
}
inline ::protos::Side WorldModel::last_kick_side() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.last_kick_side)
  return _internal_last_kick_side();
}
inline void WorldModel::set_last_kick_side(::protos::Side value) {
   _internal_set_last_kick_side(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.last_kick_side)
}
inline ::protos::Side WorldModel::_internal_last_kick_side() const {
  return static_cast<::protos::Side>(_impl_.last_kick_side_);
}
inline void WorldModel::_internal_set_last_kick_side(::protos::Side value) {
  ;
  _impl_.last_kick_side_ = value;
}

// int32 last_kicker_uniform_number = 20;
inline void WorldModel::clear_last_kicker_uniform_number() {
  _impl_.last_kicker_uniform_number_ = 0;
}
inline ::int32_t WorldModel::last_kicker_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.last_kicker_uniform_number)
  return _internal_last_kicker_uniform_number();
}
inline void WorldModel::set_last_kicker_uniform_number(::int32_t value) {
  _internal_set_last_kicker_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.last_kicker_uniform_number)
}
inline ::int32_t WorldModel::_internal_last_kicker_uniform_number() const {
  return _impl_.last_kicker_uniform_number_;
}
inline void WorldModel::_internal_set_last_kicker_uniform_number(::int32_t value) {
  ;
  _impl_.last_kicker_uniform_number_ = value;
}

// int32 cycle = 21;
inline void WorldModel::clear_cycle() {
  _impl_.cycle_ = 0;
}
inline ::int32_t WorldModel::cycle() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.cycle)
  return _internal_cycle();
}
inline void WorldModel::set_cycle(::int32_t value) {
  _internal_set_cycle(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.cycle)
}
inline ::int32_t WorldModel::_internal_cycle() const {
  return _impl_.cycle_;
}
inline void WorldModel::_internal_set_cycle(::int32_t value) {
  ;
  _impl_.cycle_ = value;
}

// .protos.GameModeType game_mode_type = 22;
inline void WorldModel::clear_game_mode_type() {
  _impl_.game_mode_type_ = 0;
}
inline ::protos::GameModeType WorldModel::game_mode_type() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.game_mode_type)
  return _internal_game_mode_type();
}
inline void WorldModel::set_game_mode_type(::protos::GameModeType value) {
   _internal_set_game_mode_type(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.game_mode_type)
}
inline ::protos::GameModeType WorldModel::_internal_game_mode_type() const {
  return static_cast<::protos::GameModeType>(_impl_.game_mode_type_);
}
inline void WorldModel::_internal_set_game_mode_type(::protos::GameModeType value) {
  ;
  _impl_.game_mode_type_ = value;
}

// int32 left_team_score = 23;
inline void WorldModel::clear_left_team_score() {
  _impl_.left_team_score_ = 0;
}
inline ::int32_t WorldModel::left_team_score() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.left_team_score)
  return _internal_left_team_score();
}
inline void WorldModel::set_left_team_score(::int32_t value) {
  _internal_set_left_team_score(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.left_team_score)
}
inline ::int32_t WorldModel::_internal_left_team_score() const {
  return _impl_.left_team_score_;
}
inline void WorldModel::_internal_set_left_team_score(::int32_t value) {
  ;
  _impl_.left_team_score_ = value;
}

// int32 right_team_score = 24;
inline void WorldModel::clear_right_team_score() {
  _impl_.right_team_score_ = 0;
}
inline ::int32_t WorldModel::right_team_score() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.right_team_score)
  return _internal_right_team_score();
}
inline void WorldModel::set_right_team_score(::int32_t value) {
  _internal_set_right_team_score(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.right_team_score)
}
inline ::int32_t WorldModel::_internal_right_team_score() const {
  return _impl_.right_team_score_;
}
inline void WorldModel::_internal_set_right_team_score(::int32_t value) {
  ;
  _impl_.right_team_score_ = value;
}

// bool is_our_set_play = 25;
inline void WorldModel::clear_is_our_set_play() {
  _impl_.is_our_set_play_ = false;
}
inline bool WorldModel::is_our_set_play() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.is_our_set_play)
  return _internal_is_our_set_play();
}
inline void WorldModel::set_is_our_set_play(bool value) {
  _internal_set_is_our_set_play(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.is_our_set_play)
}
inline bool WorldModel::_internal_is_our_set_play() const {
  return _impl_.is_our_set_play_;
}
inline void WorldModel::_internal_set_is_our_set_play(bool value) {
  ;
  _impl_.is_our_set_play_ = value;
}

// bool is_their_set_play = 26;
inline void WorldModel::clear_is_their_set_play() {
  _impl_.is_their_set_play_ = false;
}
inline bool WorldModel::is_their_set_play() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.is_their_set_play)
  return _internal_is_their_set_play();
}
inline void WorldModel::set_is_their_set_play(bool value) {
  _internal_set_is_their_set_play(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.is_their_set_play)
}
inline bool WorldModel::_internal_is_their_set_play() const {
  return _impl_.is_their_set_play_;
}
inline void WorldModel::_internal_set_is_their_set_play(bool value) {
  ;
  _impl_.is_their_set_play_ = value;
}

// int32 stoped_cycle = 27;
inline void WorldModel::clear_stoped_cycle() {
  _impl_.stoped_cycle_ = 0;
}
inline ::int32_t WorldModel::stoped_cycle() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.stoped_cycle)
  return _internal_stoped_cycle();
}
inline void WorldModel::set_stoped_cycle(::int32_t value) {
  _internal_set_stoped_cycle(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.stoped_cycle)
}
inline ::int32_t WorldModel::_internal_stoped_cycle() const {
  return _impl_.stoped_cycle_;
}
inline void WorldModel::_internal_set_stoped_cycle(::int32_t value) {
  ;
  _impl_.stoped_cycle_ = value;
}

// int32 our_team_score = 28;
inline void WorldModel::clear_our_team_score() {
  _impl_.our_team_score_ = 0;
}
inline ::int32_t WorldModel::our_team_score() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.our_team_score)
  return _internal_our_team_score();
}
inline void WorldModel::set_our_team_score(::int32_t value) {
  _internal_set_our_team_score(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.our_team_score)
}
inline ::int32_t WorldModel::_internal_our_team_score() const {
  return _impl_.our_team_score_;
}
inline void WorldModel::_internal_set_our_team_score(::int32_t value) {
  ;
  _impl_.our_team_score_ = value;
}

// int32 their_team_score = 29;
inline void WorldModel::clear_their_team_score() {
  _impl_.their_team_score_ = 0;
}
inline ::int32_t WorldModel::their_team_score() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.their_team_score)
  return _internal_their_team_score();
}
inline void WorldModel::set_their_team_score(::int32_t value) {
  _internal_set_their_team_score(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.their_team_score)
}
inline ::int32_t WorldModel::_internal_their_team_score() const {
  return _impl_.their_team_score_;
}
inline void WorldModel::_internal_set_their_team_score(::int32_t value) {
  ;
  _impl_.their_team_score_ = value;
}

// -------------------------------------------------------------------

// State

// .protos.WorldModel world_model = 1;
inline bool State::has_world_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.world_model_ != nullptr);
  return value;
}
inline void State::clear_world_model() {
  if (_impl_.world_model_ != nullptr) _impl_.world_model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::WorldModel& State::_internal_world_model() const {
  const ::protos::WorldModel* p = _impl_.world_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::WorldModel&>(
      ::protos::_WorldModel_default_instance_);
}
inline const ::protos::WorldModel& State::world_model() const {
  // @@protoc_insertion_point(field_get:protos.State.world_model)
  return _internal_world_model();
}
inline void State::unsafe_arena_set_allocated_world_model(
    ::protos::WorldModel* world_model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.world_model_);
  }
  _impl_.world_model_ = world_model;
  if (world_model) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.State.world_model)
}
inline ::protos::WorldModel* State::release_world_model() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::WorldModel* temp = _impl_.world_model_;
  _impl_.world_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::WorldModel* State::unsafe_arena_release_world_model() {
  // @@protoc_insertion_point(field_release:protos.State.world_model)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::WorldModel* temp = _impl_.world_model_;
  _impl_.world_model_ = nullptr;
  return temp;
}
inline ::protos::WorldModel* State::_internal_mutable_world_model() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.world_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::WorldModel>(GetArenaForAllocation());
    _impl_.world_model_ = p;
  }
  return _impl_.world_model_;
}
inline ::protos::WorldModel* State::mutable_world_model() {
  ::protos::WorldModel* _msg = _internal_mutable_world_model();
  // @@protoc_insertion_point(field_mutable:protos.State.world_model)
  return _msg;
}
inline void State::set_allocated_world_model(::protos::WorldModel* world_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.world_model_;
  }
  if (world_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(world_model);
    if (message_arena != submessage_arena) {
      world_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, world_model, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.world_model_ = world_model;
  // @@protoc_insertion_point(field_set_allocated:protos.State.world_model)
}

// .protos.WorldModel full_world_model = 2;
inline bool State::has_full_world_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.full_world_model_ != nullptr);
  return value;
}
inline void State::clear_full_world_model() {
  if (_impl_.full_world_model_ != nullptr) _impl_.full_world_model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::WorldModel& State::_internal_full_world_model() const {
  const ::protos::WorldModel* p = _impl_.full_world_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::WorldModel&>(
      ::protos::_WorldModel_default_instance_);
}
inline const ::protos::WorldModel& State::full_world_model() const {
  // @@protoc_insertion_point(field_get:protos.State.full_world_model)
  return _internal_full_world_model();
}
inline void State::unsafe_arena_set_allocated_full_world_model(
    ::protos::WorldModel* full_world_model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.full_world_model_);
  }
  _impl_.full_world_model_ = full_world_model;
  if (full_world_model) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.State.full_world_model)
}
inline ::protos::WorldModel* State::release_full_world_model() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::WorldModel* temp = _impl_.full_world_model_;
  _impl_.full_world_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::WorldModel* State::unsafe_arena_release_full_world_model() {
  // @@protoc_insertion_point(field_release:protos.State.full_world_model)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::WorldModel* temp = _impl_.full_world_model_;
  _impl_.full_world_model_ = nullptr;
  return temp;
}
inline ::protos::WorldModel* State::_internal_mutable_full_world_model() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.full_world_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::WorldModel>(GetArenaForAllocation());
    _impl_.full_world_model_ = p;
  }
  return _impl_.full_world_model_;
}
inline ::protos::WorldModel* State::mutable_full_world_model() {
  ::protos::WorldModel* _msg = _internal_mutable_full_world_model();
  // @@protoc_insertion_point(field_mutable:protos.State.full_world_model)
  return _msg;
}
inline void State::set_allocated_full_world_model(::protos::WorldModel* full_world_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.full_world_model_;
  }
  if (full_world_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(full_world_model);
    if (message_arena != submessage_arena) {
      full_world_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, full_world_model, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.full_world_model_ = full_world_model;
  // @@protoc_insertion_point(field_set_allocated:protos.State.full_world_model)
}

// -------------------------------------------------------------------

// Dash

// float power = 1;
inline void Dash::clear_power() {
  _impl_.power_ = 0;
}
inline float Dash::power() const {
  // @@protoc_insertion_point(field_get:protos.Dash.power)
  return _internal_power();
}
inline void Dash::set_power(float value) {
  _internal_set_power(value);
  // @@protoc_insertion_point(field_set:protos.Dash.power)
}
inline float Dash::_internal_power() const {
  return _impl_.power_;
}
inline void Dash::_internal_set_power(float value) {
  ;
  _impl_.power_ = value;
}

// float relative_direction = 2;
inline void Dash::clear_relative_direction() {
  _impl_.relative_direction_ = 0;
}
inline float Dash::relative_direction() const {
  // @@protoc_insertion_point(field_get:protos.Dash.relative_direction)
  return _internal_relative_direction();
}
inline void Dash::set_relative_direction(float value) {
  _internal_set_relative_direction(value);
  // @@protoc_insertion_point(field_set:protos.Dash.relative_direction)
}
inline float Dash::_internal_relative_direction() const {
  return _impl_.relative_direction_;
}
inline void Dash::_internal_set_relative_direction(float value) {
  ;
  _impl_.relative_direction_ = value;
}

// -------------------------------------------------------------------

// Turn

// float relative_direction = 1;
inline void Turn::clear_relative_direction() {
  _impl_.relative_direction_ = 0;
}
inline float Turn::relative_direction() const {
  // @@protoc_insertion_point(field_get:protos.Turn.relative_direction)
  return _internal_relative_direction();
}
inline void Turn::set_relative_direction(float value) {
  _internal_set_relative_direction(value);
  // @@protoc_insertion_point(field_set:protos.Turn.relative_direction)
}
inline float Turn::_internal_relative_direction() const {
  return _impl_.relative_direction_;
}
inline void Turn::_internal_set_relative_direction(float value) {
  ;
  _impl_.relative_direction_ = value;
}

// -------------------------------------------------------------------

// Kick

// float power = 1;
inline void Kick::clear_power() {
  _impl_.power_ = 0;
}
inline float Kick::power() const {
  // @@protoc_insertion_point(field_get:protos.Kick.power)
  return _internal_power();
}
inline void Kick::set_power(float value) {
  _internal_set_power(value);
  // @@protoc_insertion_point(field_set:protos.Kick.power)
}
inline float Kick::_internal_power() const {
  return _impl_.power_;
}
inline void Kick::_internal_set_power(float value) {
  ;
  _impl_.power_ = value;
}

// float relative_direction = 2;
inline void Kick::clear_relative_direction() {
  _impl_.relative_direction_ = 0;
}
inline float Kick::relative_direction() const {
  // @@protoc_insertion_point(field_get:protos.Kick.relative_direction)
  return _internal_relative_direction();
}
inline void Kick::set_relative_direction(float value) {
  _internal_set_relative_direction(value);
  // @@protoc_insertion_point(field_set:protos.Kick.relative_direction)
}
inline float Kick::_internal_relative_direction() const {
  return _impl_.relative_direction_;
}
inline void Kick::_internal_set_relative_direction(float value) {
  ;
  _impl_.relative_direction_ = value;
}

// -------------------------------------------------------------------

// Tackle

// float power_or_dir = 1;
inline void Tackle::clear_power_or_dir() {
  _impl_.power_or_dir_ = 0;
}
inline float Tackle::power_or_dir() const {
  // @@protoc_insertion_point(field_get:protos.Tackle.power_or_dir)
  return _internal_power_or_dir();
}
inline void Tackle::set_power_or_dir(float value) {
  _internal_set_power_or_dir(value);
  // @@protoc_insertion_point(field_set:protos.Tackle.power_or_dir)
}
inline float Tackle::_internal_power_or_dir() const {
  return _impl_.power_or_dir_;
}
inline void Tackle::_internal_set_power_or_dir(float value) {
  ;
  _impl_.power_or_dir_ = value;
}

// bool foul = 2;
inline void Tackle::clear_foul() {
  _impl_.foul_ = false;
}
inline bool Tackle::foul() const {
  // @@protoc_insertion_point(field_get:protos.Tackle.foul)
  return _internal_foul();
}
inline void Tackle::set_foul(bool value) {
  _internal_set_foul(value);
  // @@protoc_insertion_point(field_set:protos.Tackle.foul)
}
inline bool Tackle::_internal_foul() const {
  return _impl_.foul_;
}
inline void Tackle::_internal_set_foul(bool value) {
  ;
  _impl_.foul_ = value;
}

// -------------------------------------------------------------------

// Catch

// -------------------------------------------------------------------

// Move

// float x = 1;
inline void Move::clear_x() {
  _impl_.x_ = 0;
}
inline float Move::x() const {
  // @@protoc_insertion_point(field_get:protos.Move.x)
  return _internal_x();
}
inline void Move::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:protos.Move.x)
}
inline float Move::_internal_x() const {
  return _impl_.x_;
}
inline void Move::_internal_set_x(float value) {
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void Move::clear_y() {
  _impl_.y_ = 0;
}
inline float Move::y() const {
  // @@protoc_insertion_point(field_get:protos.Move.y)
  return _internal_y();
}
inline void Move::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:protos.Move.y)
}
inline float Move::_internal_y() const {
  return _impl_.y_;
}
inline void Move::_internal_set_y(float value) {
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// TurnNeck

// float moment = 1;
inline void TurnNeck::clear_moment() {
  _impl_.moment_ = 0;
}
inline float TurnNeck::moment() const {
  // @@protoc_insertion_point(field_get:protos.TurnNeck.moment)
  return _internal_moment();
}
inline void TurnNeck::set_moment(float value) {
  _internal_set_moment(value);
  // @@protoc_insertion_point(field_set:protos.TurnNeck.moment)
}
inline float TurnNeck::_internal_moment() const {
  return _impl_.moment_;
}
inline void TurnNeck::_internal_set_moment(float value) {
  ;
  _impl_.moment_ = value;
}

// -------------------------------------------------------------------

// ChangeView

// .protos.ViewWidth view_width = 1;
inline void ChangeView::clear_view_width() {
  _impl_.view_width_ = 0;
}
inline ::protos::ViewWidth ChangeView::view_width() const {
  // @@protoc_insertion_point(field_get:protos.ChangeView.view_width)
  return _internal_view_width();
}
inline void ChangeView::set_view_width(::protos::ViewWidth value) {
   _internal_set_view_width(value);
  // @@protoc_insertion_point(field_set:protos.ChangeView.view_width)
}
inline ::protos::ViewWidth ChangeView::_internal_view_width() const {
  return static_cast<::protos::ViewWidth>(_impl_.view_width_);
}
inline void ChangeView::_internal_set_view_width(::protos::ViewWidth value) {
  ;
  _impl_.view_width_ = value;
}

// -------------------------------------------------------------------

// Say

// string message = 1;
inline void Say::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Say::message() const {
  // @@protoc_insertion_point(field_get:protos.Say.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Say::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.Say.message)
}
inline std::string* Say::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.message)
  return _s;
}
inline const std::string& Say::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Say::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Say::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* Say::release_message() {
  // @@protoc_insertion_point(field_release:protos.Say.message)
  return _impl_.message_.Release();
}
inline void Say::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.Say.message)
}

// -------------------------------------------------------------------

// PointTo

// float x = 1;
inline void PointTo::clear_x() {
  _impl_.x_ = 0;
}
inline float PointTo::x() const {
  // @@protoc_insertion_point(field_get:protos.PointTo.x)
  return _internal_x();
}
inline void PointTo::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:protos.PointTo.x)
}
inline float PointTo::_internal_x() const {
  return _impl_.x_;
}
inline void PointTo::_internal_set_x(float value) {
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void PointTo::clear_y() {
  _impl_.y_ = 0;
}
inline float PointTo::y() const {
  // @@protoc_insertion_point(field_get:protos.PointTo.y)
  return _internal_y();
}
inline void PointTo::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:protos.PointTo.y)
}
inline float PointTo::_internal_y() const {
  return _impl_.y_;
}
inline void PointTo::_internal_set_y(float value) {
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// PointToOf

// -------------------------------------------------------------------

// AttentionTo

// int32 unum = 1;
inline void AttentionTo::clear_unum() {
  _impl_.unum_ = 0;
}
inline ::int32_t AttentionTo::unum() const {
  // @@protoc_insertion_point(field_get:protos.AttentionTo.unum)
  return _internal_unum();
}
inline void AttentionTo::set_unum(::int32_t value) {
  _internal_set_unum(value);
  // @@protoc_insertion_point(field_set:protos.AttentionTo.unum)
}
inline ::int32_t AttentionTo::_internal_unum() const {
  return _impl_.unum_;
}
inline void AttentionTo::_internal_set_unum(::int32_t value) {
  ;
  _impl_.unum_ = value;
}

// -------------------------------------------------------------------

// AttentionToOf

// -------------------------------------------------------------------

// Log

// string message = 1;
inline void Log::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Log::message() const {
  // @@protoc_insertion_point(field_get:protos.Log.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Log::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.Log.message)
}
inline std::string* Log::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:protos.Log.message)
  return _s;
}
inline const std::string& Log::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Log::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* Log::release_message() {
  // @@protoc_insertion_point(field_release:protos.Log.message)
  return _impl_.message_.Release();
}
inline void Log::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.Log.message)
}

// -------------------------------------------------------------------

// DebugClient

// string message = 1;
inline void DebugClient::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& DebugClient::message() const {
  // @@protoc_insertion_point(field_get:protos.DebugClient.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DebugClient::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.DebugClient.message)
}
inline std::string* DebugClient::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:protos.DebugClient.message)
  return _s;
}
inline const std::string& DebugClient::_internal_message() const {
  return _impl_.message_.Get();
}
inline void DebugClient::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* DebugClient::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* DebugClient::release_message() {
  // @@protoc_insertion_point(field_release:protos.DebugClient.message)
  return _impl_.message_.Release();
}
inline void DebugClient::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.DebugClient.message)
}

// -------------------------------------------------------------------

// Action

// .protos.Dash dash = 1;
inline bool Action::has_dash() const {
  return action_case() == kDash;
}
inline bool Action::_internal_has_dash() const {
  return action_case() == kDash;
}
inline void Action::set_has_dash() {
  _impl_._oneof_case_[0] = kDash;
}
inline void Action::clear_dash() {
  if (action_case() == kDash) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.dash_;
    }
    clear_has_action();
  }
}
inline ::protos::Dash* Action::release_dash() {
  // @@protoc_insertion_point(field_release:protos.Action.dash)
  if (action_case() == kDash) {
    clear_has_action();
    ::protos::Dash* temp = _impl_.action_.dash_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.dash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Dash& Action::_internal_dash() const {
  return action_case() == kDash
      ? *_impl_.action_.dash_
      : reinterpret_cast<::protos::Dash&>(::protos::_Dash_default_instance_);
}
inline const ::protos::Dash& Action::dash() const {
  // @@protoc_insertion_point(field_get:protos.Action.dash)
  return _internal_dash();
}
inline ::protos::Dash* Action::unsafe_arena_release_dash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.dash)
  if (action_case() == kDash) {
    clear_has_action();
    ::protos::Dash* temp = _impl_.action_.dash_;
    _impl_.action_.dash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_dash(::protos::Dash* dash) {
  clear_action();
  if (dash) {
    set_has_dash();
    _impl_.action_.dash_ = dash;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.dash)
}
inline ::protos::Dash* Action::_internal_mutable_dash() {
  if (action_case() != kDash) {
    clear_action();
    set_has_dash();
    _impl_.action_.dash_ = CreateMaybeMessage< ::protos::Dash >(GetArenaForAllocation());
  }
  return _impl_.action_.dash_;
}
inline ::protos::Dash* Action::mutable_dash() {
  ::protos::Dash* _msg = _internal_mutable_dash();
  // @@protoc_insertion_point(field_mutable:protos.Action.dash)
  return _msg;
}

// .protos.Turn turn = 2;
inline bool Action::has_turn() const {
  return action_case() == kTurn;
}
inline bool Action::_internal_has_turn() const {
  return action_case() == kTurn;
}
inline void Action::set_has_turn() {
  _impl_._oneof_case_[0] = kTurn;
}
inline void Action::clear_turn() {
  if (action_case() == kTurn) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.turn_;
    }
    clear_has_action();
  }
}
inline ::protos::Turn* Action::release_turn() {
  // @@protoc_insertion_point(field_release:protos.Action.turn)
  if (action_case() == kTurn) {
    clear_has_action();
    ::protos::Turn* temp = _impl_.action_.turn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.turn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Turn& Action::_internal_turn() const {
  return action_case() == kTurn
      ? *_impl_.action_.turn_
      : reinterpret_cast<::protos::Turn&>(::protos::_Turn_default_instance_);
}
inline const ::protos::Turn& Action::turn() const {
  // @@protoc_insertion_point(field_get:protos.Action.turn)
  return _internal_turn();
}
inline ::protos::Turn* Action::unsafe_arena_release_turn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.turn)
  if (action_case() == kTurn) {
    clear_has_action();
    ::protos::Turn* temp = _impl_.action_.turn_;
    _impl_.action_.turn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_turn(::protos::Turn* turn) {
  clear_action();
  if (turn) {
    set_has_turn();
    _impl_.action_.turn_ = turn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.turn)
}
inline ::protos::Turn* Action::_internal_mutable_turn() {
  if (action_case() != kTurn) {
    clear_action();
    set_has_turn();
    _impl_.action_.turn_ = CreateMaybeMessage< ::protos::Turn >(GetArenaForAllocation());
  }
  return _impl_.action_.turn_;
}
inline ::protos::Turn* Action::mutable_turn() {
  ::protos::Turn* _msg = _internal_mutable_turn();
  // @@protoc_insertion_point(field_mutable:protos.Action.turn)
  return _msg;
}

// .protos.Kick kick = 3;
inline bool Action::has_kick() const {
  return action_case() == kKick;
}
inline bool Action::_internal_has_kick() const {
  return action_case() == kKick;
}
inline void Action::set_has_kick() {
  _impl_._oneof_case_[0] = kKick;
}
inline void Action::clear_kick() {
  if (action_case() == kKick) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.kick_;
    }
    clear_has_action();
  }
}
inline ::protos::Kick* Action::release_kick() {
  // @@protoc_insertion_point(field_release:protos.Action.kick)
  if (action_case() == kKick) {
    clear_has_action();
    ::protos::Kick* temp = _impl_.action_.kick_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.kick_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Kick& Action::_internal_kick() const {
  return action_case() == kKick
      ? *_impl_.action_.kick_
      : reinterpret_cast<::protos::Kick&>(::protos::_Kick_default_instance_);
}
inline const ::protos::Kick& Action::kick() const {
  // @@protoc_insertion_point(field_get:protos.Action.kick)
  return _internal_kick();
}
inline ::protos::Kick* Action::unsafe_arena_release_kick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.kick)
  if (action_case() == kKick) {
    clear_has_action();
    ::protos::Kick* temp = _impl_.action_.kick_;
    _impl_.action_.kick_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_kick(::protos::Kick* kick) {
  clear_action();
  if (kick) {
    set_has_kick();
    _impl_.action_.kick_ = kick;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.kick)
}
inline ::protos::Kick* Action::_internal_mutable_kick() {
  if (action_case() != kKick) {
    clear_action();
    set_has_kick();
    _impl_.action_.kick_ = CreateMaybeMessage< ::protos::Kick >(GetArenaForAllocation());
  }
  return _impl_.action_.kick_;
}
inline ::protos::Kick* Action::mutable_kick() {
  ::protos::Kick* _msg = _internal_mutable_kick();
  // @@protoc_insertion_point(field_mutable:protos.Action.kick)
  return _msg;
}

// .protos.Tackle tackle = 4;
inline bool Action::has_tackle() const {
  return action_case() == kTackle;
}
inline bool Action::_internal_has_tackle() const {
  return action_case() == kTackle;
}
inline void Action::set_has_tackle() {
  _impl_._oneof_case_[0] = kTackle;
}
inline void Action::clear_tackle() {
  if (action_case() == kTackle) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.tackle_;
    }
    clear_has_action();
  }
}
inline ::protos::Tackle* Action::release_tackle() {
  // @@protoc_insertion_point(field_release:protos.Action.tackle)
  if (action_case() == kTackle) {
    clear_has_action();
    ::protos::Tackle* temp = _impl_.action_.tackle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.tackle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Tackle& Action::_internal_tackle() const {
  return action_case() == kTackle
      ? *_impl_.action_.tackle_
      : reinterpret_cast<::protos::Tackle&>(::protos::_Tackle_default_instance_);
}
inline const ::protos::Tackle& Action::tackle() const {
  // @@protoc_insertion_point(field_get:protos.Action.tackle)
  return _internal_tackle();
}
inline ::protos::Tackle* Action::unsafe_arena_release_tackle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.tackle)
  if (action_case() == kTackle) {
    clear_has_action();
    ::protos::Tackle* temp = _impl_.action_.tackle_;
    _impl_.action_.tackle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_tackle(::protos::Tackle* tackle) {
  clear_action();
  if (tackle) {
    set_has_tackle();
    _impl_.action_.tackle_ = tackle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.tackle)
}
inline ::protos::Tackle* Action::_internal_mutable_tackle() {
  if (action_case() != kTackle) {
    clear_action();
    set_has_tackle();
    _impl_.action_.tackle_ = CreateMaybeMessage< ::protos::Tackle >(GetArenaForAllocation());
  }
  return _impl_.action_.tackle_;
}
inline ::protos::Tackle* Action::mutable_tackle() {
  ::protos::Tackle* _msg = _internal_mutable_tackle();
  // @@protoc_insertion_point(field_mutable:protos.Action.tackle)
  return _msg;
}

// .protos.Catch catch = 5;
inline bool Action::has_catch_() const {
  return action_case() == kCatch;
}
inline bool Action::_internal_has_catch_() const {
  return action_case() == kCatch;
}
inline void Action::set_has_catch_() {
  _impl_._oneof_case_[0] = kCatch;
}
inline void Action::clear_catch_() {
  if (action_case() == kCatch) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.catch__;
    }
    clear_has_action();
  }
}
inline ::protos::Catch* Action::release_catch_() {
  // @@protoc_insertion_point(field_release:protos.Action.catch)
  if (action_case() == kCatch) {
    clear_has_action();
    ::protos::Catch* temp = _impl_.action_.catch__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.catch__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Catch& Action::_internal_catch_() const {
  return action_case() == kCatch
      ? *_impl_.action_.catch__
      : reinterpret_cast<::protos::Catch&>(::protos::_Catch_default_instance_);
}
inline const ::protos::Catch& Action::catch_() const {
  // @@protoc_insertion_point(field_get:protos.Action.catch)
  return _internal_catch_();
}
inline ::protos::Catch* Action::unsafe_arena_release_catch_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.catch)
  if (action_case() == kCatch) {
    clear_has_action();
    ::protos::Catch* temp = _impl_.action_.catch__;
    _impl_.action_.catch__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_catch_(::protos::Catch* catch_) {
  clear_action();
  if (catch_) {
    set_has_catch_();
    _impl_.action_.catch__ = catch_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.catch)
}
inline ::protos::Catch* Action::_internal_mutable_catch_() {
  if (action_case() != kCatch) {
    clear_action();
    set_has_catch_();
    _impl_.action_.catch__ = CreateMaybeMessage< ::protos::Catch >(GetArenaForAllocation());
  }
  return _impl_.action_.catch__;
}
inline ::protos::Catch* Action::mutable_catch_() {
  ::protos::Catch* _msg = _internal_mutable_catch_();
  // @@protoc_insertion_point(field_mutable:protos.Action.catch)
  return _msg;
}

// .protos.Move move = 6;
inline bool Action::has_move() const {
  return action_case() == kMove;
}
inline bool Action::_internal_has_move() const {
  return action_case() == kMove;
}
inline void Action::set_has_move() {
  _impl_._oneof_case_[0] = kMove;
}
inline void Action::clear_move() {
  if (action_case() == kMove) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.move_;
    }
    clear_has_action();
  }
}
inline ::protos::Move* Action::release_move() {
  // @@protoc_insertion_point(field_release:protos.Action.move)
  if (action_case() == kMove) {
    clear_has_action();
    ::protos::Move* temp = _impl_.action_.move_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Move& Action::_internal_move() const {
  return action_case() == kMove
      ? *_impl_.action_.move_
      : reinterpret_cast<::protos::Move&>(::protos::_Move_default_instance_);
}
inline const ::protos::Move& Action::move() const {
  // @@protoc_insertion_point(field_get:protos.Action.move)
  return _internal_move();
}
inline ::protos::Move* Action::unsafe_arena_release_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.move)
  if (action_case() == kMove) {
    clear_has_action();
    ::protos::Move* temp = _impl_.action_.move_;
    _impl_.action_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_move(::protos::Move* move) {
  clear_action();
  if (move) {
    set_has_move();
    _impl_.action_.move_ = move;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.move)
}
inline ::protos::Move* Action::_internal_mutable_move() {
  if (action_case() != kMove) {
    clear_action();
    set_has_move();
    _impl_.action_.move_ = CreateMaybeMessage< ::protos::Move >(GetArenaForAllocation());
  }
  return _impl_.action_.move_;
}
inline ::protos::Move* Action::mutable_move() {
  ::protos::Move* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:protos.Action.move)
  return _msg;
}

// .protos.TurnNeck turn_neck = 7;
inline bool Action::has_turn_neck() const {
  return action_case() == kTurnNeck;
}
inline bool Action::_internal_has_turn_neck() const {
  return action_case() == kTurnNeck;
}
inline void Action::set_has_turn_neck() {
  _impl_._oneof_case_[0] = kTurnNeck;
}
inline void Action::clear_turn_neck() {
  if (action_case() == kTurnNeck) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.turn_neck_;
    }
    clear_has_action();
  }
}
inline ::protos::TurnNeck* Action::release_turn_neck() {
  // @@protoc_insertion_point(field_release:protos.Action.turn_neck)
  if (action_case() == kTurnNeck) {
    clear_has_action();
    ::protos::TurnNeck* temp = _impl_.action_.turn_neck_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.turn_neck_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::TurnNeck& Action::_internal_turn_neck() const {
  return action_case() == kTurnNeck
      ? *_impl_.action_.turn_neck_
      : reinterpret_cast<::protos::TurnNeck&>(::protos::_TurnNeck_default_instance_);
}
inline const ::protos::TurnNeck& Action::turn_neck() const {
  // @@protoc_insertion_point(field_get:protos.Action.turn_neck)
  return _internal_turn_neck();
}
inline ::protos::TurnNeck* Action::unsafe_arena_release_turn_neck() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.turn_neck)
  if (action_case() == kTurnNeck) {
    clear_has_action();
    ::protos::TurnNeck* temp = _impl_.action_.turn_neck_;
    _impl_.action_.turn_neck_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_turn_neck(::protos::TurnNeck* turn_neck) {
  clear_action();
  if (turn_neck) {
    set_has_turn_neck();
    _impl_.action_.turn_neck_ = turn_neck;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.turn_neck)
}
inline ::protos::TurnNeck* Action::_internal_mutable_turn_neck() {
  if (action_case() != kTurnNeck) {
    clear_action();
    set_has_turn_neck();
    _impl_.action_.turn_neck_ = CreateMaybeMessage< ::protos::TurnNeck >(GetArenaForAllocation());
  }
  return _impl_.action_.turn_neck_;
}
inline ::protos::TurnNeck* Action::mutable_turn_neck() {
  ::protos::TurnNeck* _msg = _internal_mutable_turn_neck();
  // @@protoc_insertion_point(field_mutable:protos.Action.turn_neck)
  return _msg;
}

// .protos.ChangeView change_view = 8;
inline bool Action::has_change_view() const {
  return action_case() == kChangeView;
}
inline bool Action::_internal_has_change_view() const {
  return action_case() == kChangeView;
}
inline void Action::set_has_change_view() {
  _impl_._oneof_case_[0] = kChangeView;
}
inline void Action::clear_change_view() {
  if (action_case() == kChangeView) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.change_view_;
    }
    clear_has_action();
  }
}
inline ::protos::ChangeView* Action::release_change_view() {
  // @@protoc_insertion_point(field_release:protos.Action.change_view)
  if (action_case() == kChangeView) {
    clear_has_action();
    ::protos::ChangeView* temp = _impl_.action_.change_view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.change_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::ChangeView& Action::_internal_change_view() const {
  return action_case() == kChangeView
      ? *_impl_.action_.change_view_
      : reinterpret_cast<::protos::ChangeView&>(::protos::_ChangeView_default_instance_);
}
inline const ::protos::ChangeView& Action::change_view() const {
  // @@protoc_insertion_point(field_get:protos.Action.change_view)
  return _internal_change_view();
}
inline ::protos::ChangeView* Action::unsafe_arena_release_change_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.change_view)
  if (action_case() == kChangeView) {
    clear_has_action();
    ::protos::ChangeView* temp = _impl_.action_.change_view_;
    _impl_.action_.change_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_change_view(::protos::ChangeView* change_view) {
  clear_action();
  if (change_view) {
    set_has_change_view();
    _impl_.action_.change_view_ = change_view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.change_view)
}
inline ::protos::ChangeView* Action::_internal_mutable_change_view() {
  if (action_case() != kChangeView) {
    clear_action();
    set_has_change_view();
    _impl_.action_.change_view_ = CreateMaybeMessage< ::protos::ChangeView >(GetArenaForAllocation());
  }
  return _impl_.action_.change_view_;
}
inline ::protos::ChangeView* Action::mutable_change_view() {
  ::protos::ChangeView* _msg = _internal_mutable_change_view();
  // @@protoc_insertion_point(field_mutable:protos.Action.change_view)
  return _msg;
}

// .protos.Say say = 9;
inline bool Action::has_say() const {
  return action_case() == kSay;
}
inline bool Action::_internal_has_say() const {
  return action_case() == kSay;
}
inline void Action::set_has_say() {
  _impl_._oneof_case_[0] = kSay;
}
inline void Action::clear_say() {
  if (action_case() == kSay) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.say_;
    }
    clear_has_action();
  }
}
inline ::protos::Say* Action::release_say() {
  // @@protoc_insertion_point(field_release:protos.Action.say)
  if (action_case() == kSay) {
    clear_has_action();
    ::protos::Say* temp = _impl_.action_.say_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.say_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Say& Action::_internal_say() const {
  return action_case() == kSay
      ? *_impl_.action_.say_
      : reinterpret_cast<::protos::Say&>(::protos::_Say_default_instance_);
}
inline const ::protos::Say& Action::say() const {
  // @@protoc_insertion_point(field_get:protos.Action.say)
  return _internal_say();
}
inline ::protos::Say* Action::unsafe_arena_release_say() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.say)
  if (action_case() == kSay) {
    clear_has_action();
    ::protos::Say* temp = _impl_.action_.say_;
    _impl_.action_.say_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_say(::protos::Say* say) {
  clear_action();
  if (say) {
    set_has_say();
    _impl_.action_.say_ = say;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.say)
}
inline ::protos::Say* Action::_internal_mutable_say() {
  if (action_case() != kSay) {
    clear_action();
    set_has_say();
    _impl_.action_.say_ = CreateMaybeMessage< ::protos::Say >(GetArenaForAllocation());
  }
  return _impl_.action_.say_;
}
inline ::protos::Say* Action::mutable_say() {
  ::protos::Say* _msg = _internal_mutable_say();
  // @@protoc_insertion_point(field_mutable:protos.Action.say)
  return _msg;
}

// .protos.PointTo point_to = 10;
inline bool Action::has_point_to() const {
  return action_case() == kPointTo;
}
inline bool Action::_internal_has_point_to() const {
  return action_case() == kPointTo;
}
inline void Action::set_has_point_to() {
  _impl_._oneof_case_[0] = kPointTo;
}
inline void Action::clear_point_to() {
  if (action_case() == kPointTo) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.point_to_;
    }
    clear_has_action();
  }
}
inline ::protos::PointTo* Action::release_point_to() {
  // @@protoc_insertion_point(field_release:protos.Action.point_to)
  if (action_case() == kPointTo) {
    clear_has_action();
    ::protos::PointTo* temp = _impl_.action_.point_to_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.point_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::PointTo& Action::_internal_point_to() const {
  return action_case() == kPointTo
      ? *_impl_.action_.point_to_
      : reinterpret_cast<::protos::PointTo&>(::protos::_PointTo_default_instance_);
}
inline const ::protos::PointTo& Action::point_to() const {
  // @@protoc_insertion_point(field_get:protos.Action.point_to)
  return _internal_point_to();
}
inline ::protos::PointTo* Action::unsafe_arena_release_point_to() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.point_to)
  if (action_case() == kPointTo) {
    clear_has_action();
    ::protos::PointTo* temp = _impl_.action_.point_to_;
    _impl_.action_.point_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_point_to(::protos::PointTo* point_to) {
  clear_action();
  if (point_to) {
    set_has_point_to();
    _impl_.action_.point_to_ = point_to;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.point_to)
}
inline ::protos::PointTo* Action::_internal_mutable_point_to() {
  if (action_case() != kPointTo) {
    clear_action();
    set_has_point_to();
    _impl_.action_.point_to_ = CreateMaybeMessage< ::protos::PointTo >(GetArenaForAllocation());
  }
  return _impl_.action_.point_to_;
}
inline ::protos::PointTo* Action::mutable_point_to() {
  ::protos::PointTo* _msg = _internal_mutable_point_to();
  // @@protoc_insertion_point(field_mutable:protos.Action.point_to)
  return _msg;
}

// .protos.PointToOf point_to_of = 11;
inline bool Action::has_point_to_of() const {
  return action_case() == kPointToOf;
}
inline bool Action::_internal_has_point_to_of() const {
  return action_case() == kPointToOf;
}
inline void Action::set_has_point_to_of() {
  _impl_._oneof_case_[0] = kPointToOf;
}
inline void Action::clear_point_to_of() {
  if (action_case() == kPointToOf) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.point_to_of_;
    }
    clear_has_action();
  }
}
inline ::protos::PointToOf* Action::release_point_to_of() {
  // @@protoc_insertion_point(field_release:protos.Action.point_to_of)
  if (action_case() == kPointToOf) {
    clear_has_action();
    ::protos::PointToOf* temp = _impl_.action_.point_to_of_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.point_to_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::PointToOf& Action::_internal_point_to_of() const {
  return action_case() == kPointToOf
      ? *_impl_.action_.point_to_of_
      : reinterpret_cast<::protos::PointToOf&>(::protos::_PointToOf_default_instance_);
}
inline const ::protos::PointToOf& Action::point_to_of() const {
  // @@protoc_insertion_point(field_get:protos.Action.point_to_of)
  return _internal_point_to_of();
}
inline ::protos::PointToOf* Action::unsafe_arena_release_point_to_of() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.point_to_of)
  if (action_case() == kPointToOf) {
    clear_has_action();
    ::protos::PointToOf* temp = _impl_.action_.point_to_of_;
    _impl_.action_.point_to_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_point_to_of(::protos::PointToOf* point_to_of) {
  clear_action();
  if (point_to_of) {
    set_has_point_to_of();
    _impl_.action_.point_to_of_ = point_to_of;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.point_to_of)
}
inline ::protos::PointToOf* Action::_internal_mutable_point_to_of() {
  if (action_case() != kPointToOf) {
    clear_action();
    set_has_point_to_of();
    _impl_.action_.point_to_of_ = CreateMaybeMessage< ::protos::PointToOf >(GetArenaForAllocation());
  }
  return _impl_.action_.point_to_of_;
}
inline ::protos::PointToOf* Action::mutable_point_to_of() {
  ::protos::PointToOf* _msg = _internal_mutable_point_to_of();
  // @@protoc_insertion_point(field_mutable:protos.Action.point_to_of)
  return _msg;
}

// .protos.AttentionTo attention_to = 12;
inline bool Action::has_attention_to() const {
  return action_case() == kAttentionTo;
}
inline bool Action::_internal_has_attention_to() const {
  return action_case() == kAttentionTo;
}
inline void Action::set_has_attention_to() {
  _impl_._oneof_case_[0] = kAttentionTo;
}
inline void Action::clear_attention_to() {
  if (action_case() == kAttentionTo) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.attention_to_;
    }
    clear_has_action();
  }
}
inline ::protos::AttentionTo* Action::release_attention_to() {
  // @@protoc_insertion_point(field_release:protos.Action.attention_to)
  if (action_case() == kAttentionTo) {
    clear_has_action();
    ::protos::AttentionTo* temp = _impl_.action_.attention_to_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.attention_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AttentionTo& Action::_internal_attention_to() const {
  return action_case() == kAttentionTo
      ? *_impl_.action_.attention_to_
      : reinterpret_cast<::protos::AttentionTo&>(::protos::_AttentionTo_default_instance_);
}
inline const ::protos::AttentionTo& Action::attention_to() const {
  // @@protoc_insertion_point(field_get:protos.Action.attention_to)
  return _internal_attention_to();
}
inline ::protos::AttentionTo* Action::unsafe_arena_release_attention_to() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.attention_to)
  if (action_case() == kAttentionTo) {
    clear_has_action();
    ::protos::AttentionTo* temp = _impl_.action_.attention_to_;
    _impl_.action_.attention_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_attention_to(::protos::AttentionTo* attention_to) {
  clear_action();
  if (attention_to) {
    set_has_attention_to();
    _impl_.action_.attention_to_ = attention_to;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.attention_to)
}
inline ::protos::AttentionTo* Action::_internal_mutable_attention_to() {
  if (action_case() != kAttentionTo) {
    clear_action();
    set_has_attention_to();
    _impl_.action_.attention_to_ = CreateMaybeMessage< ::protos::AttentionTo >(GetArenaForAllocation());
  }
  return _impl_.action_.attention_to_;
}
inline ::protos::AttentionTo* Action::mutable_attention_to() {
  ::protos::AttentionTo* _msg = _internal_mutable_attention_to();
  // @@protoc_insertion_point(field_mutable:protos.Action.attention_to)
  return _msg;
}

// .protos.AttentionToOf attention_to_of = 13;
inline bool Action::has_attention_to_of() const {
  return action_case() == kAttentionToOf;
}
inline bool Action::_internal_has_attention_to_of() const {
  return action_case() == kAttentionToOf;
}
inline void Action::set_has_attention_to_of() {
  _impl_._oneof_case_[0] = kAttentionToOf;
}
inline void Action::clear_attention_to_of() {
  if (action_case() == kAttentionToOf) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.attention_to_of_;
    }
    clear_has_action();
  }
}
inline ::protos::AttentionToOf* Action::release_attention_to_of() {
  // @@protoc_insertion_point(field_release:protos.Action.attention_to_of)
  if (action_case() == kAttentionToOf) {
    clear_has_action();
    ::protos::AttentionToOf* temp = _impl_.action_.attention_to_of_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.attention_to_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AttentionToOf& Action::_internal_attention_to_of() const {
  return action_case() == kAttentionToOf
      ? *_impl_.action_.attention_to_of_
      : reinterpret_cast<::protos::AttentionToOf&>(::protos::_AttentionToOf_default_instance_);
}
inline const ::protos::AttentionToOf& Action::attention_to_of() const {
  // @@protoc_insertion_point(field_get:protos.Action.attention_to_of)
  return _internal_attention_to_of();
}
inline ::protos::AttentionToOf* Action::unsafe_arena_release_attention_to_of() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.attention_to_of)
  if (action_case() == kAttentionToOf) {
    clear_has_action();
    ::protos::AttentionToOf* temp = _impl_.action_.attention_to_of_;
    _impl_.action_.attention_to_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_attention_to_of(::protos::AttentionToOf* attention_to_of) {
  clear_action();
  if (attention_to_of) {
    set_has_attention_to_of();
    _impl_.action_.attention_to_of_ = attention_to_of;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.attention_to_of)
}
inline ::protos::AttentionToOf* Action::_internal_mutable_attention_to_of() {
  if (action_case() != kAttentionToOf) {
    clear_action();
    set_has_attention_to_of();
    _impl_.action_.attention_to_of_ = CreateMaybeMessage< ::protos::AttentionToOf >(GetArenaForAllocation());
  }
  return _impl_.action_.attention_to_of_;
}
inline ::protos::AttentionToOf* Action::mutable_attention_to_of() {
  ::protos::AttentionToOf* _msg = _internal_mutable_attention_to_of();
  // @@protoc_insertion_point(field_mutable:protos.Action.attention_to_of)
  return _msg;
}

// .protos.Log log = 14;
inline bool Action::has_log() const {
  return action_case() == kLog;
}
inline bool Action::_internal_has_log() const {
  return action_case() == kLog;
}
inline void Action::set_has_log() {
  _impl_._oneof_case_[0] = kLog;
}
inline void Action::clear_log() {
  if (action_case() == kLog) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.log_;
    }
    clear_has_action();
  }
}
inline ::protos::Log* Action::release_log() {
  // @@protoc_insertion_point(field_release:protos.Action.log)
  if (action_case() == kLog) {
    clear_has_action();
    ::protos::Log* temp = _impl_.action_.log_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Log& Action::_internal_log() const {
  return action_case() == kLog
      ? *_impl_.action_.log_
      : reinterpret_cast<::protos::Log&>(::protos::_Log_default_instance_);
}
inline const ::protos::Log& Action::log() const {
  // @@protoc_insertion_point(field_get:protos.Action.log)
  return _internal_log();
}
inline ::protos::Log* Action::unsafe_arena_release_log() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.log)
  if (action_case() == kLog) {
    clear_has_action();
    ::protos::Log* temp = _impl_.action_.log_;
    _impl_.action_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_log(::protos::Log* log) {
  clear_action();
  if (log) {
    set_has_log();
    _impl_.action_.log_ = log;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.log)
}
inline ::protos::Log* Action::_internal_mutable_log() {
  if (action_case() != kLog) {
    clear_action();
    set_has_log();
    _impl_.action_.log_ = CreateMaybeMessage< ::protos::Log >(GetArenaForAllocation());
  }
  return _impl_.action_.log_;
}
inline ::protos::Log* Action::mutable_log() {
  ::protos::Log* _msg = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:protos.Action.log)
  return _msg;
}

// .protos.DebugClient debug_client = 15;
inline bool Action::has_debug_client() const {
  return action_case() == kDebugClient;
}
inline bool Action::_internal_has_debug_client() const {
  return action_case() == kDebugClient;
}
inline void Action::set_has_debug_client() {
  _impl_._oneof_case_[0] = kDebugClient;
}
inline void Action::clear_debug_client() {
  if (action_case() == kDebugClient) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.debug_client_;
    }
    clear_has_action();
  }
}
inline ::protos::DebugClient* Action::release_debug_client() {
  // @@protoc_insertion_point(field_release:protos.Action.debug_client)
  if (action_case() == kDebugClient) {
    clear_has_action();
    ::protos::DebugClient* temp = _impl_.action_.debug_client_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.debug_client_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::DebugClient& Action::_internal_debug_client() const {
  return action_case() == kDebugClient
      ? *_impl_.action_.debug_client_
      : reinterpret_cast<::protos::DebugClient&>(::protos::_DebugClient_default_instance_);
}
inline const ::protos::DebugClient& Action::debug_client() const {
  // @@protoc_insertion_point(field_get:protos.Action.debug_client)
  return _internal_debug_client();
}
inline ::protos::DebugClient* Action::unsafe_arena_release_debug_client() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.debug_client)
  if (action_case() == kDebugClient) {
    clear_has_action();
    ::protos::DebugClient* temp = _impl_.action_.debug_client_;
    _impl_.action_.debug_client_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_debug_client(::protos::DebugClient* debug_client) {
  clear_action();
  if (debug_client) {
    set_has_debug_client();
    _impl_.action_.debug_client_ = debug_client;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.debug_client)
}
inline ::protos::DebugClient* Action::_internal_mutable_debug_client() {
  if (action_case() != kDebugClient) {
    clear_action();
    set_has_debug_client();
    _impl_.action_.debug_client_ = CreateMaybeMessage< ::protos::DebugClient >(GetArenaForAllocation());
  }
  return _impl_.action_.debug_client_;
}
inline ::protos::DebugClient* Action::mutable_debug_client() {
  ::protos::DebugClient* _msg = _internal_mutable_debug_client();
  // @@protoc_insertion_point(field_mutable:protos.Action.debug_client)
  return _msg;
}

inline bool Action::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void Action::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline Action::ActionCase Action::action_case() const {
  return Action::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Actions

// repeated .protos.Action actions = 1;
inline int Actions::_internal_actions_size() const {
  return _impl_.actions_.size();
}
inline int Actions::actions_size() const {
  return _internal_actions_size();
}
inline void Actions::clear_actions() {
  _internal_mutable_actions()->Clear();
}
inline ::protos::Action* Actions::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:protos.Actions.actions)
  return _internal_mutable_actions()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Action >*
Actions::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:protos.Actions.actions)
  return _internal_mutable_actions();
}
inline const ::protos::Action& Actions::_internal_actions(int index) const {
  return _internal_actions().Get(index);
}
inline const ::protos::Action& Actions::actions(int index) const {
  // @@protoc_insertion_point(field_get:protos.Actions.actions)
  return _internal_actions(index);
}
inline ::protos::Action* Actions::_internal_add_actions() {
  return _internal_mutable_actions()->Add();
}
inline ::protos::Action* Actions::add_actions() {
  ::protos::Action* _add = _internal_add_actions();
  // @@protoc_insertion_point(field_add:protos.Actions.actions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Action >&
Actions::actions() const {
  // @@protoc_insertion_point(field_list:protos.Actions.actions)
  return _internal_actions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Action>&
Actions::_internal_actions() const {
  return _impl_.actions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Action>*
Actions::_internal_mutable_actions() {
  return &_impl_.actions_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace protos


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::protos::ViewWidth> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::protos::ViewWidth>() {
  return ::protos::ViewWidth_descriptor();
}
template <>
struct is_proto_enum<::protos::Side> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::protos::Side>() {
  return ::protos::Side_descriptor();
}
template <>
struct is_proto_enum<::protos::InterceptActionType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::protos::InterceptActionType>() {
  return ::protos::InterceptActionType_descriptor();
}
template <>
struct is_proto_enum<::protos::GameModeType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::protos::GameModeType>() {
  return ::protos::GameModeType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_service_2eproto_2epb_2eh
