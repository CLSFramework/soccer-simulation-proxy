// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_service_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_service_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_service_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_service_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_service_2eproto;
namespace protos {
class Action;
struct ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class Actions;
struct ActionsDefaultTypeInternal;
extern ActionsDefaultTypeInternal _Actions_default_instance_;
class AddArc;
struct AddArcDefaultTypeInternal;
extern AddArcDefaultTypeInternal _AddArc_default_instance_;
class AddCircle;
struct AddCircleDefaultTypeInternal;
extern AddCircleDefaultTypeInternal _AddCircle_default_instance_;
class AddLine;
struct AddLineDefaultTypeInternal;
extern AddLineDefaultTypeInternal _AddLine_default_instance_;
class AddMessage;
struct AddMessageDefaultTypeInternal;
extern AddMessageDefaultTypeInternal _AddMessage_default_instance_;
class AddPoint;
struct AddPointDefaultTypeInternal;
extern AddPointDefaultTypeInternal _AddPoint_default_instance_;
class AddRectangle;
struct AddRectangleDefaultTypeInternal;
extern AddRectangleDefaultTypeInternal _AddRectangle_default_instance_;
class AddSector;
struct AddSectorDefaultTypeInternal;
extern AddSectorDefaultTypeInternal _AddSector_default_instance_;
class AddText;
struct AddTextDefaultTypeInternal;
extern AddTextDefaultTypeInternal _AddText_default_instance_;
class AddTriangle;
struct AddTriangleDefaultTypeInternal;
extern AddTriangleDefaultTypeInternal _AddTriangle_default_instance_;
class AttentionTo;
struct AttentionToDefaultTypeInternal;
extern AttentionToDefaultTypeInternal _AttentionTo_default_instance_;
class AttentionToOf;
struct AttentionToOfDefaultTypeInternal;
extern AttentionToOfDefaultTypeInternal _AttentionToOf_default_instance_;
class Ball;
struct BallDefaultTypeInternal;
extern BallDefaultTypeInternal _Ball_default_instance_;
class BallGoalieMessage;
struct BallGoalieMessageDefaultTypeInternal;
extern BallGoalieMessageDefaultTypeInternal _BallGoalieMessage_default_instance_;
class BallMessage;
struct BallMessageDefaultTypeInternal;
extern BallMessageDefaultTypeInternal _BallMessage_default_instance_;
class BallPlayerMessage;
struct BallPlayerMessageDefaultTypeInternal;
extern BallPlayerMessageDefaultTypeInternal _BallPlayerMessage_default_instance_;
class Bhv_BeforeKickOff;
struct Bhv_BeforeKickOffDefaultTypeInternal;
extern Bhv_BeforeKickOffDefaultTypeInternal _Bhv_BeforeKickOff_default_instance_;
class Bhv_BodyNeckToBall;
struct Bhv_BodyNeckToBallDefaultTypeInternal;
extern Bhv_BodyNeckToBallDefaultTypeInternal _Bhv_BodyNeckToBall_default_instance_;
class Bhv_BodyNeckToPoint;
struct Bhv_BodyNeckToPointDefaultTypeInternal;
extern Bhv_BodyNeckToPointDefaultTypeInternal _Bhv_BodyNeckToPoint_default_instance_;
class Bhv_Emergency;
struct Bhv_EmergencyDefaultTypeInternal;
extern Bhv_EmergencyDefaultTypeInternal _Bhv_Emergency_default_instance_;
class Bhv_GoToPointLookBall;
struct Bhv_GoToPointLookBallDefaultTypeInternal;
extern Bhv_GoToPointLookBallDefaultTypeInternal _Bhv_GoToPointLookBall_default_instance_;
class Bhv_NeckBodyToBall;
struct Bhv_NeckBodyToBallDefaultTypeInternal;
extern Bhv_NeckBodyToBallDefaultTypeInternal _Bhv_NeckBodyToBall_default_instance_;
class Bhv_NeckBodyToPoint;
struct Bhv_NeckBodyToPointDefaultTypeInternal;
extern Bhv_NeckBodyToPointDefaultTypeInternal _Bhv_NeckBodyToPoint_default_instance_;
class Bhv_ScanField;
struct Bhv_ScanFieldDefaultTypeInternal;
extern Bhv_ScanFieldDefaultTypeInternal _Bhv_ScanField_default_instance_;
class Body_AdvanceBall;
struct Body_AdvanceBallDefaultTypeInternal;
extern Body_AdvanceBallDefaultTypeInternal _Body_AdvanceBall_default_instance_;
class Body_ClearBall;
struct Body_ClearBallDefaultTypeInternal;
extern Body_ClearBallDefaultTypeInternal _Body_ClearBall_default_instance_;
class Body_Dribble;
struct Body_DribbleDefaultTypeInternal;
extern Body_DribbleDefaultTypeInternal _Body_Dribble_default_instance_;
class Body_GoToPoint;
struct Body_GoToPointDefaultTypeInternal;
extern Body_GoToPointDefaultTypeInternal _Body_GoToPoint_default_instance_;
class Body_GoToPointDodge;
struct Body_GoToPointDodgeDefaultTypeInternal;
extern Body_GoToPointDodgeDefaultTypeInternal _Body_GoToPointDodge_default_instance_;
class Body_HoldBall;
struct Body_HoldBallDefaultTypeInternal;
extern Body_HoldBallDefaultTypeInternal _Body_HoldBall_default_instance_;
class Body_Intercept;
struct Body_InterceptDefaultTypeInternal;
extern Body_InterceptDefaultTypeInternal _Body_Intercept_default_instance_;
class Body_KickOneStep;
struct Body_KickOneStepDefaultTypeInternal;
extern Body_KickOneStepDefaultTypeInternal _Body_KickOneStep_default_instance_;
class Body_SmartKick;
struct Body_SmartKickDefaultTypeInternal;
extern Body_SmartKickDefaultTypeInternal _Body_SmartKick_default_instance_;
class Body_StopBall;
struct Body_StopBallDefaultTypeInternal;
extern Body_StopBallDefaultTypeInternal _Body_StopBall_default_instance_;
class Body_StopDash;
struct Body_StopDashDefaultTypeInternal;
extern Body_StopDashDefaultTypeInternal _Body_StopDash_default_instance_;
class Body_TackleToPoint;
struct Body_TackleToPointDefaultTypeInternal;
extern Body_TackleToPointDefaultTypeInternal _Body_TackleToPoint_default_instance_;
class Body_TurnToAngle;
struct Body_TurnToAngleDefaultTypeInternal;
extern Body_TurnToAngleDefaultTypeInternal _Body_TurnToAngle_default_instance_;
class Body_TurnToBall;
struct Body_TurnToBallDefaultTypeInternal;
extern Body_TurnToBallDefaultTypeInternal _Body_TurnToBall_default_instance_;
class Body_TurnToPoint;
struct Body_TurnToPointDefaultTypeInternal;
extern Body_TurnToPointDefaultTypeInternal _Body_TurnToPoint_default_instance_;
class Catch;
struct CatchDefaultTypeInternal;
extern CatchDefaultTypeInternal _Catch_default_instance_;
class ChangeView;
struct ChangeViewDefaultTypeInternal;
extern ChangeViewDefaultTypeInternal _ChangeView_default_instance_;
class Dash;
struct DashDefaultTypeInternal;
extern DashDefaultTypeInternal _Dash_default_instance_;
class DebugClient;
struct DebugClientDefaultTypeInternal;
extern DebugClientDefaultTypeInternal _DebugClient_default_instance_;
class DefenseLineMessage;
struct DefenseLineMessageDefaultTypeInternal;
extern DefenseLineMessageDefaultTypeInternal _DefenseLineMessage_default_instance_;
class DribbleMessage;
struct DribbleMessageDefaultTypeInternal;
extern DribbleMessageDefaultTypeInternal _DribbleMessage_default_instance_;
class Focus_MoveToPoint;
struct Focus_MoveToPointDefaultTypeInternal;
extern Focus_MoveToPointDefaultTypeInternal _Focus_MoveToPoint_default_instance_;
class Focus_Reset;
struct Focus_ResetDefaultTypeInternal;
extern Focus_ResetDefaultTypeInternal _Focus_Reset_default_instance_;
class GoalieAndPlayerMessage;
struct GoalieAndPlayerMessageDefaultTypeInternal;
extern GoalieAndPlayerMessageDefaultTypeInternal _GoalieAndPlayerMessage_default_instance_;
class GoalieMessage;
struct GoalieMessageDefaultTypeInternal;
extern GoalieMessageDefaultTypeInternal _GoalieMessage_default_instance_;
class InterceptInfo;
struct InterceptInfoDefaultTypeInternal;
extern InterceptInfoDefaultTypeInternal _InterceptInfo_default_instance_;
class InterceptMessage;
struct InterceptMessageDefaultTypeInternal;
extern InterceptMessageDefaultTypeInternal _InterceptMessage_default_instance_;
class InterceptTable;
struct InterceptTableDefaultTypeInternal;
extern InterceptTableDefaultTypeInternal _InterceptTable_default_instance_;
class Kick;
struct KickDefaultTypeInternal;
extern KickDefaultTypeInternal _Kick_default_instance_;
class Log;
struct LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class Move;
struct MoveDefaultTypeInternal;
extern MoveDefaultTypeInternal _Move_default_instance_;
class Neck_ScanField;
struct Neck_ScanFieldDefaultTypeInternal;
extern Neck_ScanFieldDefaultTypeInternal _Neck_ScanField_default_instance_;
class Neck_ScanPlayers;
struct Neck_ScanPlayersDefaultTypeInternal;
extern Neck_ScanPlayersDefaultTypeInternal _Neck_ScanPlayers_default_instance_;
class Neck_TurnToBall;
struct Neck_TurnToBallDefaultTypeInternal;
extern Neck_TurnToBallDefaultTypeInternal _Neck_TurnToBall_default_instance_;
class Neck_TurnToBallAndPlayer;
struct Neck_TurnToBallAndPlayerDefaultTypeInternal;
extern Neck_TurnToBallAndPlayerDefaultTypeInternal _Neck_TurnToBallAndPlayer_default_instance_;
class Neck_TurnToBallOrScan;
struct Neck_TurnToBallOrScanDefaultTypeInternal;
extern Neck_TurnToBallOrScanDefaultTypeInternal _Neck_TurnToBallOrScan_default_instance_;
class Neck_TurnToGoalieOrScan;
struct Neck_TurnToGoalieOrScanDefaultTypeInternal;
extern Neck_TurnToGoalieOrScanDefaultTypeInternal _Neck_TurnToGoalieOrScan_default_instance_;
class Neck_TurnToLowConfTeammate;
struct Neck_TurnToLowConfTeammateDefaultTypeInternal;
extern Neck_TurnToLowConfTeammateDefaultTypeInternal _Neck_TurnToLowConfTeammate_default_instance_;
class Neck_TurnToPlayerOrScan;
struct Neck_TurnToPlayerOrScanDefaultTypeInternal;
extern Neck_TurnToPlayerOrScanDefaultTypeInternal _Neck_TurnToPlayerOrScan_default_instance_;
class Neck_TurnToPoint;
struct Neck_TurnToPointDefaultTypeInternal;
extern Neck_TurnToPointDefaultTypeInternal _Neck_TurnToPoint_default_instance_;
class Neck_TurnToRelative;
struct Neck_TurnToRelativeDefaultTypeInternal;
extern Neck_TurnToRelativeDefaultTypeInternal _Neck_TurnToRelative_default_instance_;
class OffsideLineMessage;
struct OffsideLineMessageDefaultTypeInternal;
extern OffsideLineMessageDefaultTypeInternal _OffsideLineMessage_default_instance_;
class OnePlayerMessage;
struct OnePlayerMessageDefaultTypeInternal;
extern OnePlayerMessageDefaultTypeInternal _OnePlayerMessage_default_instance_;
class OpponentMessage;
struct OpponentMessageDefaultTypeInternal;
extern OpponentMessageDefaultTypeInternal _OpponentMessage_default_instance_;
class PassMessage;
struct PassMessageDefaultTypeInternal;
extern PassMessageDefaultTypeInternal _PassMessage_default_instance_;
class PassRequestMessage;
struct PassRequestMessageDefaultTypeInternal;
extern PassRequestMessageDefaultTypeInternal _PassRequestMessage_default_instance_;
class Player;
struct PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class PointTo;
struct PointToDefaultTypeInternal;
extern PointToDefaultTypeInternal _PointTo_default_instance_;
class PointToOf;
struct PointToOfDefaultTypeInternal;
extern PointToOfDefaultTypeInternal _PointToOf_default_instance_;
class RecoveryMessage;
struct RecoveryMessageDefaultTypeInternal;
extern RecoveryMessageDefaultTypeInternal _RecoveryMessage_default_instance_;
class Say;
struct SayDefaultTypeInternal;
extern SayDefaultTypeInternal _Say_default_instance_;
class Self;
struct SelfDefaultTypeInternal;
extern SelfDefaultTypeInternal _Self_default_instance_;
class SelfMessage;
struct SelfMessageDefaultTypeInternal;
extern SelfMessageDefaultTypeInternal _SelfMessage_default_instance_;
class SetplayMessage;
struct SetplayMessageDefaultTypeInternal;
extern SetplayMessageDefaultTypeInternal _SetplayMessage_default_instance_;
class StaminaCapacityMessage;
struct StaminaCapacityMessageDefaultTypeInternal;
extern StaminaCapacityMessageDefaultTypeInternal _StaminaCapacityMessage_default_instance_;
class StaminaMessage;
struct StaminaMessageDefaultTypeInternal;
extern StaminaMessageDefaultTypeInternal _StaminaMessage_default_instance_;
class State;
struct StateDefaultTypeInternal;
extern StateDefaultTypeInternal _State_default_instance_;
class Tackle;
struct TackleDefaultTypeInternal;
extern TackleDefaultTypeInternal _Tackle_default_instance_;
class TeammateMessage;
struct TeammateMessageDefaultTypeInternal;
extern TeammateMessageDefaultTypeInternal _TeammateMessage_default_instance_;
class ThreePlayerMessage;
struct ThreePlayerMessageDefaultTypeInternal;
extern ThreePlayerMessageDefaultTypeInternal _ThreePlayerMessage_default_instance_;
class Turn;
struct TurnDefaultTypeInternal;
extern TurnDefaultTypeInternal _Turn_default_instance_;
class TurnNeck;
struct TurnNeckDefaultTypeInternal;
extern TurnNeckDefaultTypeInternal _TurnNeck_default_instance_;
class TwoPlayerMessage;
struct TwoPlayerMessageDefaultTypeInternal;
extern TwoPlayerMessageDefaultTypeInternal _TwoPlayerMessage_default_instance_;
class Vector2D;
struct Vector2DDefaultTypeInternal;
extern Vector2DDefaultTypeInternal _Vector2D_default_instance_;
class View_ChangeWidth;
struct View_ChangeWidthDefaultTypeInternal;
extern View_ChangeWidthDefaultTypeInternal _View_ChangeWidth_default_instance_;
class View_Normal;
struct View_NormalDefaultTypeInternal;
extern View_NormalDefaultTypeInternal _View_Normal_default_instance_;
class View_Synch;
struct View_SynchDefaultTypeInternal;
extern View_SynchDefaultTypeInternal _View_Synch_default_instance_;
class View_Wide;
struct View_WideDefaultTypeInternal;
extern View_WideDefaultTypeInternal _View_Wide_default_instance_;
class WaitRequestMessage;
struct WaitRequestMessageDefaultTypeInternal;
extern WaitRequestMessageDefaultTypeInternal _WaitRequestMessage_default_instance_;
class WorldModel;
struct WorldModelDefaultTypeInternal;
extern WorldModelDefaultTypeInternal _WorldModel_default_instance_;
class WorldModel_OurPlayersDictEntry_DoNotUse;
struct WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal;
extern WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal _WorldModel_OurPlayersDictEntry_DoNotUse_default_instance_;
class WorldModel_TheirPlayersDictEntry_DoNotUse;
struct WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal;
extern WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal _WorldModel_TheirPlayersDictEntry_DoNotUse_default_instance_;
}  // namespace protos
PROTOBUF_NAMESPACE_OPEN
template <>
::protos::Action* Arena::CreateMaybeMessage<::protos::Action>(Arena*);
template <>
::protos::Actions* Arena::CreateMaybeMessage<::protos::Actions>(Arena*);
template <>
::protos::AddArc* Arena::CreateMaybeMessage<::protos::AddArc>(Arena*);
template <>
::protos::AddCircle* Arena::CreateMaybeMessage<::protos::AddCircle>(Arena*);
template <>
::protos::AddLine* Arena::CreateMaybeMessage<::protos::AddLine>(Arena*);
template <>
::protos::AddMessage* Arena::CreateMaybeMessage<::protos::AddMessage>(Arena*);
template <>
::protos::AddPoint* Arena::CreateMaybeMessage<::protos::AddPoint>(Arena*);
template <>
::protos::AddRectangle* Arena::CreateMaybeMessage<::protos::AddRectangle>(Arena*);
template <>
::protos::AddSector* Arena::CreateMaybeMessage<::protos::AddSector>(Arena*);
template <>
::protos::AddText* Arena::CreateMaybeMessage<::protos::AddText>(Arena*);
template <>
::protos::AddTriangle* Arena::CreateMaybeMessage<::protos::AddTriangle>(Arena*);
template <>
::protos::AttentionTo* Arena::CreateMaybeMessage<::protos::AttentionTo>(Arena*);
template <>
::protos::AttentionToOf* Arena::CreateMaybeMessage<::protos::AttentionToOf>(Arena*);
template <>
::protos::Ball* Arena::CreateMaybeMessage<::protos::Ball>(Arena*);
template <>
::protos::BallGoalieMessage* Arena::CreateMaybeMessage<::protos::BallGoalieMessage>(Arena*);
template <>
::protos::BallMessage* Arena::CreateMaybeMessage<::protos::BallMessage>(Arena*);
template <>
::protos::BallPlayerMessage* Arena::CreateMaybeMessage<::protos::BallPlayerMessage>(Arena*);
template <>
::protos::Bhv_BeforeKickOff* Arena::CreateMaybeMessage<::protos::Bhv_BeforeKickOff>(Arena*);
template <>
::protos::Bhv_BodyNeckToBall* Arena::CreateMaybeMessage<::protos::Bhv_BodyNeckToBall>(Arena*);
template <>
::protos::Bhv_BodyNeckToPoint* Arena::CreateMaybeMessage<::protos::Bhv_BodyNeckToPoint>(Arena*);
template <>
::protos::Bhv_Emergency* Arena::CreateMaybeMessage<::protos::Bhv_Emergency>(Arena*);
template <>
::protos::Bhv_GoToPointLookBall* Arena::CreateMaybeMessage<::protos::Bhv_GoToPointLookBall>(Arena*);
template <>
::protos::Bhv_NeckBodyToBall* Arena::CreateMaybeMessage<::protos::Bhv_NeckBodyToBall>(Arena*);
template <>
::protos::Bhv_NeckBodyToPoint* Arena::CreateMaybeMessage<::protos::Bhv_NeckBodyToPoint>(Arena*);
template <>
::protos::Bhv_ScanField* Arena::CreateMaybeMessage<::protos::Bhv_ScanField>(Arena*);
template <>
::protos::Body_AdvanceBall* Arena::CreateMaybeMessage<::protos::Body_AdvanceBall>(Arena*);
template <>
::protos::Body_ClearBall* Arena::CreateMaybeMessage<::protos::Body_ClearBall>(Arena*);
template <>
::protos::Body_Dribble* Arena::CreateMaybeMessage<::protos::Body_Dribble>(Arena*);
template <>
::protos::Body_GoToPoint* Arena::CreateMaybeMessage<::protos::Body_GoToPoint>(Arena*);
template <>
::protos::Body_GoToPointDodge* Arena::CreateMaybeMessage<::protos::Body_GoToPointDodge>(Arena*);
template <>
::protos::Body_HoldBall* Arena::CreateMaybeMessage<::protos::Body_HoldBall>(Arena*);
template <>
::protos::Body_Intercept* Arena::CreateMaybeMessage<::protos::Body_Intercept>(Arena*);
template <>
::protos::Body_KickOneStep* Arena::CreateMaybeMessage<::protos::Body_KickOneStep>(Arena*);
template <>
::protos::Body_SmartKick* Arena::CreateMaybeMessage<::protos::Body_SmartKick>(Arena*);
template <>
::protos::Body_StopBall* Arena::CreateMaybeMessage<::protos::Body_StopBall>(Arena*);
template <>
::protos::Body_StopDash* Arena::CreateMaybeMessage<::protos::Body_StopDash>(Arena*);
template <>
::protos::Body_TackleToPoint* Arena::CreateMaybeMessage<::protos::Body_TackleToPoint>(Arena*);
template <>
::protos::Body_TurnToAngle* Arena::CreateMaybeMessage<::protos::Body_TurnToAngle>(Arena*);
template <>
::protos::Body_TurnToBall* Arena::CreateMaybeMessage<::protos::Body_TurnToBall>(Arena*);
template <>
::protos::Body_TurnToPoint* Arena::CreateMaybeMessage<::protos::Body_TurnToPoint>(Arena*);
template <>
::protos::Catch* Arena::CreateMaybeMessage<::protos::Catch>(Arena*);
template <>
::protos::ChangeView* Arena::CreateMaybeMessage<::protos::ChangeView>(Arena*);
template <>
::protos::Dash* Arena::CreateMaybeMessage<::protos::Dash>(Arena*);
template <>
::protos::DebugClient* Arena::CreateMaybeMessage<::protos::DebugClient>(Arena*);
template <>
::protos::DefenseLineMessage* Arena::CreateMaybeMessage<::protos::DefenseLineMessage>(Arena*);
template <>
::protos::DribbleMessage* Arena::CreateMaybeMessage<::protos::DribbleMessage>(Arena*);
template <>
::protos::Focus_MoveToPoint* Arena::CreateMaybeMessage<::protos::Focus_MoveToPoint>(Arena*);
template <>
::protos::Focus_Reset* Arena::CreateMaybeMessage<::protos::Focus_Reset>(Arena*);
template <>
::protos::GoalieAndPlayerMessage* Arena::CreateMaybeMessage<::protos::GoalieAndPlayerMessage>(Arena*);
template <>
::protos::GoalieMessage* Arena::CreateMaybeMessage<::protos::GoalieMessage>(Arena*);
template <>
::protos::InterceptInfo* Arena::CreateMaybeMessage<::protos::InterceptInfo>(Arena*);
template <>
::protos::InterceptMessage* Arena::CreateMaybeMessage<::protos::InterceptMessage>(Arena*);
template <>
::protos::InterceptTable* Arena::CreateMaybeMessage<::protos::InterceptTable>(Arena*);
template <>
::protos::Kick* Arena::CreateMaybeMessage<::protos::Kick>(Arena*);
template <>
::protos::Log* Arena::CreateMaybeMessage<::protos::Log>(Arena*);
template <>
::protos::Move* Arena::CreateMaybeMessage<::protos::Move>(Arena*);
template <>
::protos::Neck_ScanField* Arena::CreateMaybeMessage<::protos::Neck_ScanField>(Arena*);
template <>
::protos::Neck_ScanPlayers* Arena::CreateMaybeMessage<::protos::Neck_ScanPlayers>(Arena*);
template <>
::protos::Neck_TurnToBall* Arena::CreateMaybeMessage<::protos::Neck_TurnToBall>(Arena*);
template <>
::protos::Neck_TurnToBallAndPlayer* Arena::CreateMaybeMessage<::protos::Neck_TurnToBallAndPlayer>(Arena*);
template <>
::protos::Neck_TurnToBallOrScan* Arena::CreateMaybeMessage<::protos::Neck_TurnToBallOrScan>(Arena*);
template <>
::protos::Neck_TurnToGoalieOrScan* Arena::CreateMaybeMessage<::protos::Neck_TurnToGoalieOrScan>(Arena*);
template <>
::protos::Neck_TurnToLowConfTeammate* Arena::CreateMaybeMessage<::protos::Neck_TurnToLowConfTeammate>(Arena*);
template <>
::protos::Neck_TurnToPlayerOrScan* Arena::CreateMaybeMessage<::protos::Neck_TurnToPlayerOrScan>(Arena*);
template <>
::protos::Neck_TurnToPoint* Arena::CreateMaybeMessage<::protos::Neck_TurnToPoint>(Arena*);
template <>
::protos::Neck_TurnToRelative* Arena::CreateMaybeMessage<::protos::Neck_TurnToRelative>(Arena*);
template <>
::protos::OffsideLineMessage* Arena::CreateMaybeMessage<::protos::OffsideLineMessage>(Arena*);
template <>
::protos::OnePlayerMessage* Arena::CreateMaybeMessage<::protos::OnePlayerMessage>(Arena*);
template <>
::protos::OpponentMessage* Arena::CreateMaybeMessage<::protos::OpponentMessage>(Arena*);
template <>
::protos::PassMessage* Arena::CreateMaybeMessage<::protos::PassMessage>(Arena*);
template <>
::protos::PassRequestMessage* Arena::CreateMaybeMessage<::protos::PassRequestMessage>(Arena*);
template <>
::protos::Player* Arena::CreateMaybeMessage<::protos::Player>(Arena*);
template <>
::protos::PointTo* Arena::CreateMaybeMessage<::protos::PointTo>(Arena*);
template <>
::protos::PointToOf* Arena::CreateMaybeMessage<::protos::PointToOf>(Arena*);
template <>
::protos::RecoveryMessage* Arena::CreateMaybeMessage<::protos::RecoveryMessage>(Arena*);
template <>
::protos::Say* Arena::CreateMaybeMessage<::protos::Say>(Arena*);
template <>
::protos::Self* Arena::CreateMaybeMessage<::protos::Self>(Arena*);
template <>
::protos::SelfMessage* Arena::CreateMaybeMessage<::protos::SelfMessage>(Arena*);
template <>
::protos::SetplayMessage* Arena::CreateMaybeMessage<::protos::SetplayMessage>(Arena*);
template <>
::protos::StaminaCapacityMessage* Arena::CreateMaybeMessage<::protos::StaminaCapacityMessage>(Arena*);
template <>
::protos::StaminaMessage* Arena::CreateMaybeMessage<::protos::StaminaMessage>(Arena*);
template <>
::protos::State* Arena::CreateMaybeMessage<::protos::State>(Arena*);
template <>
::protos::Tackle* Arena::CreateMaybeMessage<::protos::Tackle>(Arena*);
template <>
::protos::TeammateMessage* Arena::CreateMaybeMessage<::protos::TeammateMessage>(Arena*);
template <>
::protos::ThreePlayerMessage* Arena::CreateMaybeMessage<::protos::ThreePlayerMessage>(Arena*);
template <>
::protos::Turn* Arena::CreateMaybeMessage<::protos::Turn>(Arena*);
template <>
::protos::TurnNeck* Arena::CreateMaybeMessage<::protos::TurnNeck>(Arena*);
template <>
::protos::TwoPlayerMessage* Arena::CreateMaybeMessage<::protos::TwoPlayerMessage>(Arena*);
template <>
::protos::Vector2D* Arena::CreateMaybeMessage<::protos::Vector2D>(Arena*);
template <>
::protos::View_ChangeWidth* Arena::CreateMaybeMessage<::protos::View_ChangeWidth>(Arena*);
template <>
::protos::View_Normal* Arena::CreateMaybeMessage<::protos::View_Normal>(Arena*);
template <>
::protos::View_Synch* Arena::CreateMaybeMessage<::protos::View_Synch>(Arena*);
template <>
::protos::View_Wide* Arena::CreateMaybeMessage<::protos::View_Wide>(Arena*);
template <>
::protos::WaitRequestMessage* Arena::CreateMaybeMessage<::protos::WaitRequestMessage>(Arena*);
template <>
::protos::WorldModel* Arena::CreateMaybeMessage<::protos::WorldModel>(Arena*);
template <>
::protos::WorldModel_OurPlayersDictEntry_DoNotUse* Arena::CreateMaybeMessage<::protos::WorldModel_OurPlayersDictEntry_DoNotUse>(Arena*);
template <>
::protos::WorldModel_TheirPlayersDictEntry_DoNotUse* Arena::CreateMaybeMessage<::protos::WorldModel_TheirPlayersDictEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace protos {
enum ViewWidth : int {
  NARROW = 0,
  NORMAL = 1,
  WIDE = 2,
  ViewWidth_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ViewWidth_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ViewWidth_IsValid(int value);
constexpr ViewWidth ViewWidth_MIN = static_cast<ViewWidth>(0);
constexpr ViewWidth ViewWidth_MAX = static_cast<ViewWidth>(2);
constexpr int ViewWidth_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ViewWidth_descriptor();
template <typename T>
const std::string& ViewWidth_Name(T value) {
  static_assert(std::is_same<T, ViewWidth>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ViewWidth_Name().");
  return ViewWidth_Name(static_cast<ViewWidth>(value));
}
template <>
inline const std::string& ViewWidth_Name(ViewWidth value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ViewWidth_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ViewWidth_Parse(absl::string_view name, ViewWidth* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ViewWidth>(
      ViewWidth_descriptor(), name, value);
}
enum Side : int {
  UNKNOWN = 0,
  LEFT = 1,
  RIGHT = 2,
  Side_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Side_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Side_IsValid(int value);
constexpr Side Side_MIN = static_cast<Side>(0);
constexpr Side Side_MAX = static_cast<Side>(2);
constexpr int Side_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Side_descriptor();
template <typename T>
const std::string& Side_Name(T value) {
  static_assert(std::is_same<T, Side>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Side_Name().");
  return Side_Name(static_cast<Side>(value));
}
template <>
inline const std::string& Side_Name(Side value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Side_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Side_Parse(absl::string_view name, Side* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Side>(
      Side_descriptor(), name, value);
}
enum LoggerLevel : int {
  None = 0,
  SYSTEM = 1,
  SENSOR = 2,
  WORLD = 4,
  ACTION = 8,
  INTERCEPT = 16,
  KICK = 32,
  HOLD = 64,
  DRIBBLE = 128,
  PASS = 256,
  CROSS = 512,
  SHOOT = 1024,
  CLEAR = 2048,
  BLOCK = 4096,
  MARK = 8192,
  POSITIONING = 16384,
  ROLE = 32768,
  TEAM = 65536,
  COMMUNICATION = 131072,
  ANALYZER = 262144,
  ACTION_CHAIN = 524288,
  PLAN = 1048576,
  LoggerLevel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LoggerLevel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LoggerLevel_IsValid(int value);
constexpr LoggerLevel LoggerLevel_MIN = static_cast<LoggerLevel>(0);
constexpr LoggerLevel LoggerLevel_MAX = static_cast<LoggerLevel>(1048576);
constexpr int LoggerLevel_ARRAYSIZE = 1048576 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
LoggerLevel_descriptor();
template <typename T>
const std::string& LoggerLevel_Name(T value) {
  static_assert(std::is_same<T, LoggerLevel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LoggerLevel_Name().");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(LoggerLevel_descriptor(), value);
}
inline bool LoggerLevel_Parse(absl::string_view name, LoggerLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoggerLevel>(
      LoggerLevel_descriptor(), name, value);
}
enum InterceptActionType : int {
  UNKNOWN_Intercept_Action_Type = 0,
  OMNI_DASH = 1,
  TURN_FORWARD_DASH = 2,
  TURN_BACKWARD_DASH = 3,
  InterceptActionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  InterceptActionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool InterceptActionType_IsValid(int value);
constexpr InterceptActionType InterceptActionType_MIN = static_cast<InterceptActionType>(0);
constexpr InterceptActionType InterceptActionType_MAX = static_cast<InterceptActionType>(3);
constexpr int InterceptActionType_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
InterceptActionType_descriptor();
template <typename T>
const std::string& InterceptActionType_Name(T value) {
  static_assert(std::is_same<T, InterceptActionType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to InterceptActionType_Name().");
  return InterceptActionType_Name(static_cast<InterceptActionType>(value));
}
template <>
inline const std::string& InterceptActionType_Name(InterceptActionType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<InterceptActionType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool InterceptActionType_Parse(absl::string_view name, InterceptActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InterceptActionType>(
      InterceptActionType_descriptor(), name, value);
}
enum GameModeType : int {
  BeforeKickOff = 0,
  TimeOver = 1,
  PlayOn = 2,
  KickOff_Left = 3,
  KickOff_Right = 4,
  KickIn_Left = 5,
  KickIn_Right = 6,
  FreeKick_Left = 7,
  FreeKick_Right = 8,
  CornerKick_Left = 9,
  CornerKick_Right = 10,
  GoalKick_Left = 11,
  GoalKick_Right = 12,
  AfterGoal_Left = 13,
  AfterGoal_Right = 14,
  OffSide_Left = 15,
  OffSide_Right = 16,
  PenaltyKick_Left = 17,
  PenaltyKick_Right = 18,
  FirstHalfOver = 19,
  Pause = 20,
  Human = 21,
  FoulCharge_Left = 22,
  FoulCharge_Right = 23,
  FoulPush_Left = 24,
  FoulPush_Right = 25,
  FoulMultipleAttacker_Left = 26,
  FoulMultipleAttacker_Right = 27,
  FoulBallOut_Left = 28,
  FoulBallOut_Right = 29,
  BackPass_Left = 30,
  BackPass_Right = 31,
  FreeKickFault_Left = 32,
  FreeKickFault_Right = 33,
  CatchFault_Left = 34,
  CatchFault_Right = 35,
  IndFreeKick_Left = 36,
  IndFreeKick_Right = 37,
  PenaltySetup_Left = 38,
  PenaltySetup_Right = 39,
  PenaltyReady_Left = 40,
  PenaltyReady_Right = 41,
  PenaltyTaken_Left = 42,
  PenaltyTaken_Right = 43,
  PenaltyMiss_Left = 44,
  PenaltyMiss_Right = 45,
  PenaltyScore_Left = 46,
  PenaltyScore_Right = 47,
  IllegalDefense_Left = 48,
  IllegalDefense_Right = 49,
  PenaltyOnfield = 50,
  PenaltyFoul = 51,
  GoalieCatch_Left = 52,
  GoalieCatch_Right = 53,
  ExtendHalf = 54,
  MODE_MAX = 55,
  GameModeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GameModeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GameModeType_IsValid(int value);
constexpr GameModeType GameModeType_MIN = static_cast<GameModeType>(0);
constexpr GameModeType GameModeType_MAX = static_cast<GameModeType>(55);
constexpr int GameModeType_ARRAYSIZE = 55 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
GameModeType_descriptor();
template <typename T>
const std::string& GameModeType_Name(T value) {
  static_assert(std::is_same<T, GameModeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GameModeType_Name().");
  return GameModeType_Name(static_cast<GameModeType>(value));
}
template <>
inline const std::string& GameModeType_Name(GameModeType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<GameModeType_descriptor,
                                                 0, 55>(
      static_cast<int>(value));
}
inline bool GameModeType_Parse(absl::string_view name, GameModeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameModeType>(
      GameModeType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Vector2D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Vector2D) */ {
 public:
  inline Vector2D() : Vector2D(nullptr) {}
  ~Vector2D() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vector2D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector2D(const Vector2D& from);
  Vector2D(Vector2D&& from) noexcept
    : Vector2D() {
    *this = ::std::move(from);
  }

  inline Vector2D& operator=(const Vector2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector2D& operator=(Vector2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector2D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector2D* internal_default_instance() {
    return reinterpret_cast<const Vector2D*>(
               &_Vector2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector2D& a, Vector2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector2D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector2D* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector2D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector2D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vector2D& from) {
    Vector2D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector2D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Vector2D";
  }
  protected:
  explicit Vector2D(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kDistFieldNumber = 3,
    kAngleFieldNumber = 4,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float dist = 3;
  void clear_dist() ;
  float dist() const;
  void set_dist(float value);

  private:
  float _internal_dist() const;
  void _internal_set_dist(float value);

  public:
  // float angle = 4;
  void clear_angle() ;
  float angle() const;
  void set_angle(float value);

  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Vector2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float dist_;
    float angle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Ball final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Ball) */ {
 public:
  inline Ball() : Ball(nullptr) {}
  ~Ball() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Ball(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ball(const Ball& from);
  Ball(Ball&& from) noexcept
    : Ball() {
    *this = ::std::move(from);
  }

  inline Ball& operator=(const Ball& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ball& operator=(Ball&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ball& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ball* internal_default_instance() {
    return reinterpret_cast<const Ball*>(
               &_Ball_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Ball& a, Ball& b) {
    a.Swap(&b);
  }
  inline void Swap(Ball* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ball* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ball* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ball>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ball& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ball& from) {
    Ball::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ball* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Ball";
  }
  protected:
  explicit Ball(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kRelativePositionFieldNumber = 2,
    kSeenPositionFieldNumber = 3,
    kHeardPositionFieldNumber = 4,
    kVelocityFieldNumber = 5,
    kSeenVelocityFieldNumber = 6,
    kHeardVelocityFieldNumber = 7,
    kPosCountFieldNumber = 8,
    kSeenPosCountFieldNumber = 9,
    kHeardPosCountFieldNumber = 10,
    kVelCountFieldNumber = 11,
    kSeenVelCountFieldNumber = 12,
    kHeardVelCountFieldNumber = 13,
    kLostCountFieldNumber = 14,
    kGhostCountFieldNumber = 15,
    kDistFromSelfFieldNumber = 16,
    kAngleFromSelfFieldNumber = 17,
  };
  // .protos.Vector2D position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* position);
  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protos::Vector2D* position);
  ::protos::Vector2D* unsafe_arena_release_position();
  // .protos.Vector2D relative_position = 2;
  bool has_relative_position() const;
  void clear_relative_position() ;
  const ::protos::Vector2D& relative_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_relative_position();
  ::protos::Vector2D* mutable_relative_position();
  void set_allocated_relative_position(::protos::Vector2D* relative_position);
  private:
  const ::protos::Vector2D& _internal_relative_position() const;
  ::protos::Vector2D* _internal_mutable_relative_position();
  public:
  void unsafe_arena_set_allocated_relative_position(
      ::protos::Vector2D* relative_position);
  ::protos::Vector2D* unsafe_arena_release_relative_position();
  // .protos.Vector2D seen_position = 3;
  bool has_seen_position() const;
  void clear_seen_position() ;
  const ::protos::Vector2D& seen_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_position();
  ::protos::Vector2D* mutable_seen_position();
  void set_allocated_seen_position(::protos::Vector2D* seen_position);
  private:
  const ::protos::Vector2D& _internal_seen_position() const;
  ::protos::Vector2D* _internal_mutable_seen_position();
  public:
  void unsafe_arena_set_allocated_seen_position(
      ::protos::Vector2D* seen_position);
  ::protos::Vector2D* unsafe_arena_release_seen_position();
  // .protos.Vector2D heard_position = 4;
  bool has_heard_position() const;
  void clear_heard_position() ;
  const ::protos::Vector2D& heard_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_heard_position();
  ::protos::Vector2D* mutable_heard_position();
  void set_allocated_heard_position(::protos::Vector2D* heard_position);
  private:
  const ::protos::Vector2D& _internal_heard_position() const;
  ::protos::Vector2D* _internal_mutable_heard_position();
  public:
  void unsafe_arena_set_allocated_heard_position(
      ::protos::Vector2D* heard_position);
  ::protos::Vector2D* unsafe_arena_release_heard_position();
  // .protos.Vector2D velocity = 5;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::protos::Vector2D& velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_velocity();
  ::protos::Vector2D* mutable_velocity();
  void set_allocated_velocity(::protos::Vector2D* velocity);
  private:
  const ::protos::Vector2D& _internal_velocity() const;
  ::protos::Vector2D* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::protos::Vector2D* velocity);
  ::protos::Vector2D* unsafe_arena_release_velocity();
  // .protos.Vector2D seen_velocity = 6;
  bool has_seen_velocity() const;
  void clear_seen_velocity() ;
  const ::protos::Vector2D& seen_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_velocity();
  ::protos::Vector2D* mutable_seen_velocity();
  void set_allocated_seen_velocity(::protos::Vector2D* seen_velocity);
  private:
  const ::protos::Vector2D& _internal_seen_velocity() const;
  ::protos::Vector2D* _internal_mutable_seen_velocity();
  public:
  void unsafe_arena_set_allocated_seen_velocity(
      ::protos::Vector2D* seen_velocity);
  ::protos::Vector2D* unsafe_arena_release_seen_velocity();
  // .protos.Vector2D heard_velocity = 7;
  bool has_heard_velocity() const;
  void clear_heard_velocity() ;
  const ::protos::Vector2D& heard_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_heard_velocity();
  ::protos::Vector2D* mutable_heard_velocity();
  void set_allocated_heard_velocity(::protos::Vector2D* heard_velocity);
  private:
  const ::protos::Vector2D& _internal_heard_velocity() const;
  ::protos::Vector2D* _internal_mutable_heard_velocity();
  public:
  void unsafe_arena_set_allocated_heard_velocity(
      ::protos::Vector2D* heard_velocity);
  ::protos::Vector2D* unsafe_arena_release_heard_velocity();
  // int32 pos_count = 8;
  void clear_pos_count() ;
  ::int32_t pos_count() const;
  void set_pos_count(::int32_t value);

  private:
  ::int32_t _internal_pos_count() const;
  void _internal_set_pos_count(::int32_t value);

  public:
  // int32 seen_pos_count = 9;
  void clear_seen_pos_count() ;
  ::int32_t seen_pos_count() const;
  void set_seen_pos_count(::int32_t value);

  private:
  ::int32_t _internal_seen_pos_count() const;
  void _internal_set_seen_pos_count(::int32_t value);

  public:
  // int32 heard_pos_count = 10;
  void clear_heard_pos_count() ;
  ::int32_t heard_pos_count() const;
  void set_heard_pos_count(::int32_t value);

  private:
  ::int32_t _internal_heard_pos_count() const;
  void _internal_set_heard_pos_count(::int32_t value);

  public:
  // int32 vel_count = 11;
  void clear_vel_count() ;
  ::int32_t vel_count() const;
  void set_vel_count(::int32_t value);

  private:
  ::int32_t _internal_vel_count() const;
  void _internal_set_vel_count(::int32_t value);

  public:
  // int32 seen_vel_count = 12;
  void clear_seen_vel_count() ;
  ::int32_t seen_vel_count() const;
  void set_seen_vel_count(::int32_t value);

  private:
  ::int32_t _internal_seen_vel_count() const;
  void _internal_set_seen_vel_count(::int32_t value);

  public:
  // int32 heard_vel_count = 13;
  void clear_heard_vel_count() ;
  ::int32_t heard_vel_count() const;
  void set_heard_vel_count(::int32_t value);

  private:
  ::int32_t _internal_heard_vel_count() const;
  void _internal_set_heard_vel_count(::int32_t value);

  public:
  // int32 lost_count = 14;
  void clear_lost_count() ;
  ::int32_t lost_count() const;
  void set_lost_count(::int32_t value);

  private:
  ::int32_t _internal_lost_count() const;
  void _internal_set_lost_count(::int32_t value);

  public:
  // int32 ghost_count = 15;
  void clear_ghost_count() ;
  ::int32_t ghost_count() const;
  void set_ghost_count(::int32_t value);

  private:
  ::int32_t _internal_ghost_count() const;
  void _internal_set_ghost_count(::int32_t value);

  public:
  // float dist_from_self = 16;
  void clear_dist_from_self() ;
  float dist_from_self() const;
  void set_dist_from_self(float value);

  private:
  float _internal_dist_from_self() const;
  void _internal_set_dist_from_self(float value);

  public:
  // float angle_from_self = 17;
  void clear_angle_from_self() ;
  float angle_from_self() const;
  void set_angle_from_self(float value);

  private:
  float _internal_angle_from_self() const;
  void _internal_set_angle_from_self(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Ball)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    ::protos::Vector2D* relative_position_;
    ::protos::Vector2D* seen_position_;
    ::protos::Vector2D* heard_position_;
    ::protos::Vector2D* velocity_;
    ::protos::Vector2D* seen_velocity_;
    ::protos::Vector2D* heard_velocity_;
    ::int32_t pos_count_;
    ::int32_t seen_pos_count_;
    ::int32_t heard_pos_count_;
    ::int32_t vel_count_;
    ::int32_t seen_vel_count_;
    ::int32_t heard_vel_count_;
    ::int32_t lost_count_;
    ::int32_t ghost_count_;
    float dist_from_self_;
    float angle_from_self_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  ~Player() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Player& from) {
    Player::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Player";
  }
  protected:
  explicit Player(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kSeenPositionFieldNumber = 2,
    kHeardPositionFieldNumber = 3,
    kVelocityFieldNumber = 4,
    kSeenVelocityFieldNumber = 5,
    kPosCountFieldNumber = 6,
    kSeenPosCountFieldNumber = 7,
    kHeardPosCountFieldNumber = 8,
    kVelCountFieldNumber = 9,
    kSeenVelCountFieldNumber = 10,
    kGhostCountFieldNumber = 11,
    kDistFromSelfFieldNumber = 12,
    kAngleFromSelfFieldNumber = 13,
    kIdFieldNumber = 14,
    kSideFieldNumber = 15,
    kUniformNumberFieldNumber = 16,
    kUniformNumberCountFieldNumber = 17,
    kBodyDirectionFieldNumber = 19,
    kBodyDirectionCountFieldNumber = 20,
    kFaceDirectionFieldNumber = 21,
    kFaceDirectionCountFieldNumber = 22,
    kPointToDirectionFieldNumber = 23,
    kPointToDirectionCountFieldNumber = 24,
    kIsGoalieFieldNumber = 18,
    kIsKickingFieldNumber = 25,
    kIsTacklingFieldNumber = 29,
    kDistFromBallFieldNumber = 26,
    kAngleFromBallFieldNumber = 27,
    kBallReachStepsFieldNumber = 28,
  };
  // .protos.Vector2D position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* position);
  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protos::Vector2D* position);
  ::protos::Vector2D* unsafe_arena_release_position();
  // .protos.Vector2D seen_position = 2;
  bool has_seen_position() const;
  void clear_seen_position() ;
  const ::protos::Vector2D& seen_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_position();
  ::protos::Vector2D* mutable_seen_position();
  void set_allocated_seen_position(::protos::Vector2D* seen_position);
  private:
  const ::protos::Vector2D& _internal_seen_position() const;
  ::protos::Vector2D* _internal_mutable_seen_position();
  public:
  void unsafe_arena_set_allocated_seen_position(
      ::protos::Vector2D* seen_position);
  ::protos::Vector2D* unsafe_arena_release_seen_position();
  // .protos.Vector2D heard_position = 3;
  bool has_heard_position() const;
  void clear_heard_position() ;
  const ::protos::Vector2D& heard_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_heard_position();
  ::protos::Vector2D* mutable_heard_position();
  void set_allocated_heard_position(::protos::Vector2D* heard_position);
  private:
  const ::protos::Vector2D& _internal_heard_position() const;
  ::protos::Vector2D* _internal_mutable_heard_position();
  public:
  void unsafe_arena_set_allocated_heard_position(
      ::protos::Vector2D* heard_position);
  ::protos::Vector2D* unsafe_arena_release_heard_position();
  // .protos.Vector2D velocity = 4;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::protos::Vector2D& velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_velocity();
  ::protos::Vector2D* mutable_velocity();
  void set_allocated_velocity(::protos::Vector2D* velocity);
  private:
  const ::protos::Vector2D& _internal_velocity() const;
  ::protos::Vector2D* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::protos::Vector2D* velocity);
  ::protos::Vector2D* unsafe_arena_release_velocity();
  // .protos.Vector2D seen_velocity = 5;
  bool has_seen_velocity() const;
  void clear_seen_velocity() ;
  const ::protos::Vector2D& seen_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_velocity();
  ::protos::Vector2D* mutable_seen_velocity();
  void set_allocated_seen_velocity(::protos::Vector2D* seen_velocity);
  private:
  const ::protos::Vector2D& _internal_seen_velocity() const;
  ::protos::Vector2D* _internal_mutable_seen_velocity();
  public:
  void unsafe_arena_set_allocated_seen_velocity(
      ::protos::Vector2D* seen_velocity);
  ::protos::Vector2D* unsafe_arena_release_seen_velocity();
  // int32 pos_count = 6;
  void clear_pos_count() ;
  ::int32_t pos_count() const;
  void set_pos_count(::int32_t value);

  private:
  ::int32_t _internal_pos_count() const;
  void _internal_set_pos_count(::int32_t value);

  public:
  // int32 seen_pos_count = 7;
  void clear_seen_pos_count() ;
  ::int32_t seen_pos_count() const;
  void set_seen_pos_count(::int32_t value);

  private:
  ::int32_t _internal_seen_pos_count() const;
  void _internal_set_seen_pos_count(::int32_t value);

  public:
  // int32 heard_pos_count = 8;
  void clear_heard_pos_count() ;
  ::int32_t heard_pos_count() const;
  void set_heard_pos_count(::int32_t value);

  private:
  ::int32_t _internal_heard_pos_count() const;
  void _internal_set_heard_pos_count(::int32_t value);

  public:
  // int32 vel_count = 9;
  void clear_vel_count() ;
  ::int32_t vel_count() const;
  void set_vel_count(::int32_t value);

  private:
  ::int32_t _internal_vel_count() const;
  void _internal_set_vel_count(::int32_t value);

  public:
  // int32 seen_vel_count = 10;
  void clear_seen_vel_count() ;
  ::int32_t seen_vel_count() const;
  void set_seen_vel_count(::int32_t value);

  private:
  ::int32_t _internal_seen_vel_count() const;
  void _internal_set_seen_vel_count(::int32_t value);

  public:
  // int32 ghost_count = 11;
  void clear_ghost_count() ;
  ::int32_t ghost_count() const;
  void set_ghost_count(::int32_t value);

  private:
  ::int32_t _internal_ghost_count() const;
  void _internal_set_ghost_count(::int32_t value);

  public:
  // float dist_from_self = 12;
  void clear_dist_from_self() ;
  float dist_from_self() const;
  void set_dist_from_self(float value);

  private:
  float _internal_dist_from_self() const;
  void _internal_set_dist_from_self(float value);

  public:
  // float angle_from_self = 13;
  void clear_angle_from_self() ;
  float angle_from_self() const;
  void set_angle_from_self(float value);

  private:
  float _internal_angle_from_self() const;
  void _internal_set_angle_from_self(float value);

  public:
  // int32 id = 14;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .protos.Side side = 15;
  void clear_side() ;
  ::protos::Side side() const;
  void set_side(::protos::Side value);

  private:
  ::protos::Side _internal_side() const;
  void _internal_set_side(::protos::Side value);

  public:
  // int32 uniform_number = 16;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // int32 uniform_number_count = 17;
  void clear_uniform_number_count() ;
  ::int32_t uniform_number_count() const;
  void set_uniform_number_count(::int32_t value);

  private:
  ::int32_t _internal_uniform_number_count() const;
  void _internal_set_uniform_number_count(::int32_t value);

  public:
  // float body_direction = 19;
  void clear_body_direction() ;
  float body_direction() const;
  void set_body_direction(float value);

  private:
  float _internal_body_direction() const;
  void _internal_set_body_direction(float value);

  public:
  // int32 body_direction_count = 20;
  void clear_body_direction_count() ;
  ::int32_t body_direction_count() const;
  void set_body_direction_count(::int32_t value);

  private:
  ::int32_t _internal_body_direction_count() const;
  void _internal_set_body_direction_count(::int32_t value);

  public:
  // float face_direction = 21;
  void clear_face_direction() ;
  float face_direction() const;
  void set_face_direction(float value);

  private:
  float _internal_face_direction() const;
  void _internal_set_face_direction(float value);

  public:
  // int32 face_direction_count = 22;
  void clear_face_direction_count() ;
  ::int32_t face_direction_count() const;
  void set_face_direction_count(::int32_t value);

  private:
  ::int32_t _internal_face_direction_count() const;
  void _internal_set_face_direction_count(::int32_t value);

  public:
  // float point_to_direction = 23;
  void clear_point_to_direction() ;
  float point_to_direction() const;
  void set_point_to_direction(float value);

  private:
  float _internal_point_to_direction() const;
  void _internal_set_point_to_direction(float value);

  public:
  // int32 point_to_direction_count = 24;
  void clear_point_to_direction_count() ;
  ::int32_t point_to_direction_count() const;
  void set_point_to_direction_count(::int32_t value);

  private:
  ::int32_t _internal_point_to_direction_count() const;
  void _internal_set_point_to_direction_count(::int32_t value);

  public:
  // bool is_goalie = 18;
  void clear_is_goalie() ;
  bool is_goalie() const;
  void set_is_goalie(bool value);

  private:
  bool _internal_is_goalie() const;
  void _internal_set_is_goalie(bool value);

  public:
  // bool is_kicking = 25;
  void clear_is_kicking() ;
  bool is_kicking() const;
  void set_is_kicking(bool value);

  private:
  bool _internal_is_kicking() const;
  void _internal_set_is_kicking(bool value);

  public:
  // bool is_tackling = 29;
  void clear_is_tackling() ;
  bool is_tackling() const;
  void set_is_tackling(bool value);

  private:
  bool _internal_is_tackling() const;
  void _internal_set_is_tackling(bool value);

  public:
  // float dist_from_ball = 26;
  void clear_dist_from_ball() ;
  float dist_from_ball() const;
  void set_dist_from_ball(float value);

  private:
  float _internal_dist_from_ball() const;
  void _internal_set_dist_from_ball(float value);

  public:
  // float angle_from_ball = 27;
  void clear_angle_from_ball() ;
  float angle_from_ball() const;
  void set_angle_from_ball(float value);

  private:
  float _internal_angle_from_ball() const;
  void _internal_set_angle_from_ball(float value);

  public:
  // int32 ball_reach_steps = 28;
  void clear_ball_reach_steps() ;
  ::int32_t ball_reach_steps() const;
  void set_ball_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_ball_reach_steps() const;
  void _internal_set_ball_reach_steps(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    ::protos::Vector2D* seen_position_;
    ::protos::Vector2D* heard_position_;
    ::protos::Vector2D* velocity_;
    ::protos::Vector2D* seen_velocity_;
    ::int32_t pos_count_;
    ::int32_t seen_pos_count_;
    ::int32_t heard_pos_count_;
    ::int32_t vel_count_;
    ::int32_t seen_vel_count_;
    ::int32_t ghost_count_;
    float dist_from_self_;
    float angle_from_self_;
    ::int32_t id_;
    int side_;
    ::int32_t uniform_number_;
    ::int32_t uniform_number_count_;
    float body_direction_;
    ::int32_t body_direction_count_;
    float face_direction_;
    ::int32_t face_direction_count_;
    float point_to_direction_;
    ::int32_t point_to_direction_count_;
    bool is_goalie_;
    bool is_kicking_;
    bool is_tackling_;
    float dist_from_ball_;
    float angle_from_ball_;
    ::int32_t ball_reach_steps_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Self final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Self) */ {
 public:
  inline Self() : Self(nullptr) {}
  ~Self() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Self(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Self(const Self& from);
  Self(Self&& from) noexcept
    : Self() {
    *this = ::std::move(from);
  }

  inline Self& operator=(const Self& from) {
    CopyFrom(from);
    return *this;
  }
  inline Self& operator=(Self&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Self& default_instance() {
    return *internal_default_instance();
  }
  static inline const Self* internal_default_instance() {
    return reinterpret_cast<const Self*>(
               &_Self_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Self& a, Self& b) {
    a.Swap(&b);
  }
  inline void Swap(Self* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Self* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Self* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Self>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Self& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Self& from) {
    Self::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Self* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Self";
  }
  protected:
  explicit Self(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kSeenPositionFieldNumber = 2,
    kHeardPositionFieldNumber = 3,
    kVelocityFieldNumber = 4,
    kSeenVelocityFieldNumber = 5,
    kPosCountFieldNumber = 6,
    kSeenPosCountFieldNumber = 7,
    kHeardPosCountFieldNumber = 8,
    kVelCountFieldNumber = 9,
    kSeenVelCountFieldNumber = 10,
    kGhostCountFieldNumber = 11,
    kIdFieldNumber = 12,
    kSideFieldNumber = 13,
    kUniformNumberFieldNumber = 14,
    kUniformNumberCountFieldNumber = 15,
    kBodyDirectionFieldNumber = 17,
    kBodyDirectionCountFieldNumber = 18,
    kFaceDirectionFieldNumber = 19,
    kFaceDirectionCountFieldNumber = 20,
    kPointToDirectionFieldNumber = 21,
    kPointToDirectionCountFieldNumber = 22,
    kDistFromBallFieldNumber = 24,
    kIsGoalieFieldNumber = 16,
    kIsKickingFieldNumber = 23,
    kIsTacklingFieldNumber = 27,
    kIsKickableFieldNumber = 30,
    kAngleFromBallFieldNumber = 25,
    kBallReachStepsFieldNumber = 26,
    kRelativeNeckDirectionFieldNumber = 28,
    kStaminaFieldNumber = 29,
    kCatchProbabilityFieldNumber = 31,
    kTackleProbabilityFieldNumber = 32,
    kFoulProbabilityFieldNumber = 33,
    kViewWidthFieldNumber = 34,
  };
  // .protos.Vector2D position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* position);
  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protos::Vector2D* position);
  ::protos::Vector2D* unsafe_arena_release_position();
  // .protos.Vector2D seen_position = 2;
  bool has_seen_position() const;
  void clear_seen_position() ;
  const ::protos::Vector2D& seen_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_position();
  ::protos::Vector2D* mutable_seen_position();
  void set_allocated_seen_position(::protos::Vector2D* seen_position);
  private:
  const ::protos::Vector2D& _internal_seen_position() const;
  ::protos::Vector2D* _internal_mutable_seen_position();
  public:
  void unsafe_arena_set_allocated_seen_position(
      ::protos::Vector2D* seen_position);
  ::protos::Vector2D* unsafe_arena_release_seen_position();
  // .protos.Vector2D heard_position = 3;
  bool has_heard_position() const;
  void clear_heard_position() ;
  const ::protos::Vector2D& heard_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_heard_position();
  ::protos::Vector2D* mutable_heard_position();
  void set_allocated_heard_position(::protos::Vector2D* heard_position);
  private:
  const ::protos::Vector2D& _internal_heard_position() const;
  ::protos::Vector2D* _internal_mutable_heard_position();
  public:
  void unsafe_arena_set_allocated_heard_position(
      ::protos::Vector2D* heard_position);
  ::protos::Vector2D* unsafe_arena_release_heard_position();
  // .protos.Vector2D velocity = 4;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::protos::Vector2D& velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_velocity();
  ::protos::Vector2D* mutable_velocity();
  void set_allocated_velocity(::protos::Vector2D* velocity);
  private:
  const ::protos::Vector2D& _internal_velocity() const;
  ::protos::Vector2D* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::protos::Vector2D* velocity);
  ::protos::Vector2D* unsafe_arena_release_velocity();
  // .protos.Vector2D seen_velocity = 5;
  bool has_seen_velocity() const;
  void clear_seen_velocity() ;
  const ::protos::Vector2D& seen_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_velocity();
  ::protos::Vector2D* mutable_seen_velocity();
  void set_allocated_seen_velocity(::protos::Vector2D* seen_velocity);
  private:
  const ::protos::Vector2D& _internal_seen_velocity() const;
  ::protos::Vector2D* _internal_mutable_seen_velocity();
  public:
  void unsafe_arena_set_allocated_seen_velocity(
      ::protos::Vector2D* seen_velocity);
  ::protos::Vector2D* unsafe_arena_release_seen_velocity();
  // int32 pos_count = 6;
  void clear_pos_count() ;
  ::int32_t pos_count() const;
  void set_pos_count(::int32_t value);

  private:
  ::int32_t _internal_pos_count() const;
  void _internal_set_pos_count(::int32_t value);

  public:
  // int32 seen_pos_count = 7;
  void clear_seen_pos_count() ;
  ::int32_t seen_pos_count() const;
  void set_seen_pos_count(::int32_t value);

  private:
  ::int32_t _internal_seen_pos_count() const;
  void _internal_set_seen_pos_count(::int32_t value);

  public:
  // int32 heard_pos_count = 8;
  void clear_heard_pos_count() ;
  ::int32_t heard_pos_count() const;
  void set_heard_pos_count(::int32_t value);

  private:
  ::int32_t _internal_heard_pos_count() const;
  void _internal_set_heard_pos_count(::int32_t value);

  public:
  // int32 vel_count = 9;
  void clear_vel_count() ;
  ::int32_t vel_count() const;
  void set_vel_count(::int32_t value);

  private:
  ::int32_t _internal_vel_count() const;
  void _internal_set_vel_count(::int32_t value);

  public:
  // int32 seen_vel_count = 10;
  void clear_seen_vel_count() ;
  ::int32_t seen_vel_count() const;
  void set_seen_vel_count(::int32_t value);

  private:
  ::int32_t _internal_seen_vel_count() const;
  void _internal_set_seen_vel_count(::int32_t value);

  public:
  // int32 ghost_count = 11;
  void clear_ghost_count() ;
  ::int32_t ghost_count() const;
  void set_ghost_count(::int32_t value);

  private:
  ::int32_t _internal_ghost_count() const;
  void _internal_set_ghost_count(::int32_t value);

  public:
  // int32 id = 12;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .protos.Side side = 13;
  void clear_side() ;
  ::protos::Side side() const;
  void set_side(::protos::Side value);

  private:
  ::protos::Side _internal_side() const;
  void _internal_set_side(::protos::Side value);

  public:
  // int32 uniform_number = 14;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // int32 uniform_number_count = 15;
  void clear_uniform_number_count() ;
  ::int32_t uniform_number_count() const;
  void set_uniform_number_count(::int32_t value);

  private:
  ::int32_t _internal_uniform_number_count() const;
  void _internal_set_uniform_number_count(::int32_t value);

  public:
  // float body_direction = 17;
  void clear_body_direction() ;
  float body_direction() const;
  void set_body_direction(float value);

  private:
  float _internal_body_direction() const;
  void _internal_set_body_direction(float value);

  public:
  // int32 body_direction_count = 18;
  void clear_body_direction_count() ;
  ::int32_t body_direction_count() const;
  void set_body_direction_count(::int32_t value);

  private:
  ::int32_t _internal_body_direction_count() const;
  void _internal_set_body_direction_count(::int32_t value);

  public:
  // float face_direction = 19;
  void clear_face_direction() ;
  float face_direction() const;
  void set_face_direction(float value);

  private:
  float _internal_face_direction() const;
  void _internal_set_face_direction(float value);

  public:
  // int32 face_direction_count = 20;
  void clear_face_direction_count() ;
  ::int32_t face_direction_count() const;
  void set_face_direction_count(::int32_t value);

  private:
  ::int32_t _internal_face_direction_count() const;
  void _internal_set_face_direction_count(::int32_t value);

  public:
  // float point_to_direction = 21;
  void clear_point_to_direction() ;
  float point_to_direction() const;
  void set_point_to_direction(float value);

  private:
  float _internal_point_to_direction() const;
  void _internal_set_point_to_direction(float value);

  public:
  // int32 point_to_direction_count = 22;
  void clear_point_to_direction_count() ;
  ::int32_t point_to_direction_count() const;
  void set_point_to_direction_count(::int32_t value);

  private:
  ::int32_t _internal_point_to_direction_count() const;
  void _internal_set_point_to_direction_count(::int32_t value);

  public:
  // float dist_from_ball = 24;
  void clear_dist_from_ball() ;
  float dist_from_ball() const;
  void set_dist_from_ball(float value);

  private:
  float _internal_dist_from_ball() const;
  void _internal_set_dist_from_ball(float value);

  public:
  // bool is_goalie = 16;
  void clear_is_goalie() ;
  bool is_goalie() const;
  void set_is_goalie(bool value);

  private:
  bool _internal_is_goalie() const;
  void _internal_set_is_goalie(bool value);

  public:
  // bool is_kicking = 23;
  void clear_is_kicking() ;
  bool is_kicking() const;
  void set_is_kicking(bool value);

  private:
  bool _internal_is_kicking() const;
  void _internal_set_is_kicking(bool value);

  public:
  // bool is_tackling = 27;
  void clear_is_tackling() ;
  bool is_tackling() const;
  void set_is_tackling(bool value);

  private:
  bool _internal_is_tackling() const;
  void _internal_set_is_tackling(bool value);

  public:
  // bool is_kickable = 30;
  void clear_is_kickable() ;
  bool is_kickable() const;
  void set_is_kickable(bool value);

  private:
  bool _internal_is_kickable() const;
  void _internal_set_is_kickable(bool value);

  public:
  // float angle_from_ball = 25;
  void clear_angle_from_ball() ;
  float angle_from_ball() const;
  void set_angle_from_ball(float value);

  private:
  float _internal_angle_from_ball() const;
  void _internal_set_angle_from_ball(float value);

  public:
  // int32 ball_reach_steps = 26;
  void clear_ball_reach_steps() ;
  ::int32_t ball_reach_steps() const;
  void set_ball_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_ball_reach_steps() const;
  void _internal_set_ball_reach_steps(::int32_t value);

  public:
  // float relative_neck_direction = 28;
  void clear_relative_neck_direction() ;
  float relative_neck_direction() const;
  void set_relative_neck_direction(float value);

  private:
  float _internal_relative_neck_direction() const;
  void _internal_set_relative_neck_direction(float value);

  public:
  // float stamina = 29;
  void clear_stamina() ;
  float stamina() const;
  void set_stamina(float value);

  private:
  float _internal_stamina() const;
  void _internal_set_stamina(float value);

  public:
  // float catch_probability = 31;
  void clear_catch_probability() ;
  float catch_probability() const;
  void set_catch_probability(float value);

  private:
  float _internal_catch_probability() const;
  void _internal_set_catch_probability(float value);

  public:
  // float tackle_probability = 32;
  void clear_tackle_probability() ;
  float tackle_probability() const;
  void set_tackle_probability(float value);

  private:
  float _internal_tackle_probability() const;
  void _internal_set_tackle_probability(float value);

  public:
  // float foul_probability = 33;
  void clear_foul_probability() ;
  float foul_probability() const;
  void set_foul_probability(float value);

  private:
  float _internal_foul_probability() const;
  void _internal_set_foul_probability(float value);

  public:
  // .protos.ViewWidth view_width = 34;
  void clear_view_width() ;
  ::protos::ViewWidth view_width() const;
  void set_view_width(::protos::ViewWidth value);

  private:
  ::protos::ViewWidth _internal_view_width() const;
  void _internal_set_view_width(::protos::ViewWidth value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Self)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    ::protos::Vector2D* seen_position_;
    ::protos::Vector2D* heard_position_;
    ::protos::Vector2D* velocity_;
    ::protos::Vector2D* seen_velocity_;
    ::int32_t pos_count_;
    ::int32_t seen_pos_count_;
    ::int32_t heard_pos_count_;
    ::int32_t vel_count_;
    ::int32_t seen_vel_count_;
    ::int32_t ghost_count_;
    ::int32_t id_;
    int side_;
    ::int32_t uniform_number_;
    ::int32_t uniform_number_count_;
    float body_direction_;
    ::int32_t body_direction_count_;
    float face_direction_;
    ::int32_t face_direction_count_;
    float point_to_direction_;
    ::int32_t point_to_direction_count_;
    float dist_from_ball_;
    bool is_goalie_;
    bool is_kicking_;
    bool is_tackling_;
    bool is_kickable_;
    float angle_from_ball_;
    ::int32_t ball_reach_steps_;
    float relative_neck_direction_;
    float stamina_;
    float catch_probability_;
    float tackle_probability_;
    float foul_probability_;
    int view_width_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class InterceptInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.InterceptInfo) */ {
 public:
  inline InterceptInfo() : InterceptInfo(nullptr) {}
  ~InterceptInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InterceptInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterceptInfo(const InterceptInfo& from);
  InterceptInfo(InterceptInfo&& from) noexcept
    : InterceptInfo() {
    *this = ::std::move(from);
  }

  inline InterceptInfo& operator=(const InterceptInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterceptInfo& operator=(InterceptInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterceptInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterceptInfo* internal_default_instance() {
    return reinterpret_cast<const InterceptInfo*>(
               &_InterceptInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InterceptInfo& a, InterceptInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(InterceptInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterceptInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterceptInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterceptInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterceptInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterceptInfo& from) {
    InterceptInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterceptInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.InterceptInfo";
  }
  protected:
  explicit InterceptInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFinalSelfPositionFieldNumber = 7,
    kActionTypeFieldNumber = 1,
    kTurnStepsFieldNumber = 2,
    kTurnAngleFieldNumber = 3,
    kDashStepsFieldNumber = 4,
    kDashPowerFieldNumber = 5,
    kDashDirFieldNumber = 6,
    kFinalBallDistFieldNumber = 8,
    kFinalStaminaFieldNumber = 9,
    kValueFieldNumber = 10,
  };
  // .protos.Vector2D final_self_position = 7;
  bool has_final_self_position() const;
  void clear_final_self_position() ;
  const ::protos::Vector2D& final_self_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_final_self_position();
  ::protos::Vector2D* mutable_final_self_position();
  void set_allocated_final_self_position(::protos::Vector2D* final_self_position);
  private:
  const ::protos::Vector2D& _internal_final_self_position() const;
  ::protos::Vector2D* _internal_mutable_final_self_position();
  public:
  void unsafe_arena_set_allocated_final_self_position(
      ::protos::Vector2D* final_self_position);
  ::protos::Vector2D* unsafe_arena_release_final_self_position();
  // .protos.InterceptActionType action_type = 1;
  void clear_action_type() ;
  ::protos::InterceptActionType action_type() const;
  void set_action_type(::protos::InterceptActionType value);

  private:
  ::protos::InterceptActionType _internal_action_type() const;
  void _internal_set_action_type(::protos::InterceptActionType value);

  public:
  // int32 turn_steps = 2;
  void clear_turn_steps() ;
  ::int32_t turn_steps() const;
  void set_turn_steps(::int32_t value);

  private:
  ::int32_t _internal_turn_steps() const;
  void _internal_set_turn_steps(::int32_t value);

  public:
  // float turn_angle = 3;
  void clear_turn_angle() ;
  float turn_angle() const;
  void set_turn_angle(float value);

  private:
  float _internal_turn_angle() const;
  void _internal_set_turn_angle(float value);

  public:
  // int32 dash_steps = 4;
  void clear_dash_steps() ;
  ::int32_t dash_steps() const;
  void set_dash_steps(::int32_t value);

  private:
  ::int32_t _internal_dash_steps() const;
  void _internal_set_dash_steps(::int32_t value);

  public:
  // float dash_power = 5;
  void clear_dash_power() ;
  float dash_power() const;
  void set_dash_power(float value);

  private:
  float _internal_dash_power() const;
  void _internal_set_dash_power(float value);

  public:
  // float dash_dir = 6;
  void clear_dash_dir() ;
  float dash_dir() const;
  void set_dash_dir(float value);

  private:
  float _internal_dash_dir() const;
  void _internal_set_dash_dir(float value);

  public:
  // float final_ball_dist = 8;
  void clear_final_ball_dist() ;
  float final_ball_dist() const;
  void set_final_ball_dist(float value);

  private:
  float _internal_final_ball_dist() const;
  void _internal_set_final_ball_dist(float value);

  public:
  // float final_stamina = 9;
  void clear_final_stamina() ;
  float final_stamina() const;
  void set_final_stamina(float value);

  private:
  float _internal_final_stamina() const;
  void _internal_set_final_stamina(float value);

  public:
  // float value = 10;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.InterceptInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* final_self_position_;
    int action_type_;
    ::int32_t turn_steps_;
    float turn_angle_;
    ::int32_t dash_steps_;
    float dash_power_;
    float dash_dir_;
    float final_ball_dist_;
    float final_stamina_;
    float value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class InterceptTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.InterceptTable) */ {
 public:
  inline InterceptTable() : InterceptTable(nullptr) {}
  ~InterceptTable() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InterceptTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterceptTable(const InterceptTable& from);
  InterceptTable(InterceptTable&& from) noexcept
    : InterceptTable() {
    *this = ::std::move(from);
  }

  inline InterceptTable& operator=(const InterceptTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterceptTable& operator=(InterceptTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterceptTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterceptTable* internal_default_instance() {
    return reinterpret_cast<const InterceptTable*>(
               &_InterceptTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InterceptTable& a, InterceptTable& b) {
    a.Swap(&b);
  }
  inline void Swap(InterceptTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterceptTable* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterceptTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterceptTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterceptTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterceptTable& from) {
    InterceptTable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterceptTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.InterceptTable";
  }
  protected:
  explicit InterceptTable(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelfInterceptInfoFieldNumber = 10,
    kSelfReachStepsFieldNumber = 1,
    kFirstTeammateReachStepsFieldNumber = 2,
    kSecondTeammateReachStepsFieldNumber = 3,
    kFirstOpponentReachStepsFieldNumber = 4,
    kSecondOpponentReachStepsFieldNumber = 5,
    kFirstTeammateIdFieldNumber = 6,
    kSecondTeammateIdFieldNumber = 7,
    kFirstOpponentIdFieldNumber = 8,
    kSecondOpponentIdFieldNumber = 9,
  };
  // repeated .protos.InterceptInfo self_intercept_info = 10;
  int self_intercept_info_size() const;
  private:
  int _internal_self_intercept_info_size() const;

  public:
  void clear_self_intercept_info() ;
  ::protos::InterceptInfo* mutable_self_intercept_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::InterceptInfo >*
      mutable_self_intercept_info();
  private:
  const ::protos::InterceptInfo& _internal_self_intercept_info(int index) const;
  ::protos::InterceptInfo* _internal_add_self_intercept_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::InterceptInfo>& _internal_self_intercept_info() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::InterceptInfo>* _internal_mutable_self_intercept_info();
  public:
  const ::protos::InterceptInfo& self_intercept_info(int index) const;
  ::protos::InterceptInfo* add_self_intercept_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::InterceptInfo >&
      self_intercept_info() const;
  // int32 self_reach_steps = 1;
  void clear_self_reach_steps() ;
  ::int32_t self_reach_steps() const;
  void set_self_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_self_reach_steps() const;
  void _internal_set_self_reach_steps(::int32_t value);

  public:
  // int32 first_teammate_reach_steps = 2;
  void clear_first_teammate_reach_steps() ;
  ::int32_t first_teammate_reach_steps() const;
  void set_first_teammate_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_first_teammate_reach_steps() const;
  void _internal_set_first_teammate_reach_steps(::int32_t value);

  public:
  // int32 second_teammate_reach_steps = 3;
  void clear_second_teammate_reach_steps() ;
  ::int32_t second_teammate_reach_steps() const;
  void set_second_teammate_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_second_teammate_reach_steps() const;
  void _internal_set_second_teammate_reach_steps(::int32_t value);

  public:
  // int32 first_opponent_reach_steps = 4;
  void clear_first_opponent_reach_steps() ;
  ::int32_t first_opponent_reach_steps() const;
  void set_first_opponent_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_first_opponent_reach_steps() const;
  void _internal_set_first_opponent_reach_steps(::int32_t value);

  public:
  // int32 second_opponent_reach_steps = 5;
  void clear_second_opponent_reach_steps() ;
  ::int32_t second_opponent_reach_steps() const;
  void set_second_opponent_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_second_opponent_reach_steps() const;
  void _internal_set_second_opponent_reach_steps(::int32_t value);

  public:
  // int32 first_teammate_id = 6;
  void clear_first_teammate_id() ;
  ::int32_t first_teammate_id() const;
  void set_first_teammate_id(::int32_t value);

  private:
  ::int32_t _internal_first_teammate_id() const;
  void _internal_set_first_teammate_id(::int32_t value);

  public:
  // int32 second_teammate_id = 7;
  void clear_second_teammate_id() ;
  ::int32_t second_teammate_id() const;
  void set_second_teammate_id(::int32_t value);

  private:
  ::int32_t _internal_second_teammate_id() const;
  void _internal_set_second_teammate_id(::int32_t value);

  public:
  // int32 first_opponent_id = 8;
  void clear_first_opponent_id() ;
  ::int32_t first_opponent_id() const;
  void set_first_opponent_id(::int32_t value);

  private:
  ::int32_t _internal_first_opponent_id() const;
  void _internal_set_first_opponent_id(::int32_t value);

  public:
  // int32 second_opponent_id = 9;
  void clear_second_opponent_id() ;
  ::int32_t second_opponent_id() const;
  void set_second_opponent_id(::int32_t value);

  private:
  ::int32_t _internal_second_opponent_id() const;
  void _internal_set_second_opponent_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.InterceptTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::InterceptInfo > self_intercept_info_;
    ::int32_t self_reach_steps_;
    ::int32_t first_teammate_reach_steps_;
    ::int32_t second_teammate_reach_steps_;
    ::int32_t first_opponent_reach_steps_;
    ::int32_t second_opponent_reach_steps_;
    ::int32_t first_teammate_id_;
    ::int32_t second_teammate_id_;
    ::int32_t first_opponent_id_;
    ::int32_t second_opponent_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class WorldModel_OurPlayersDictEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WorldModel_OurPlayersDictEntry_DoNotUse, 
    ::int32_t, ::protos::Player,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WorldModel_OurPlayersDictEntry_DoNotUse, 
    ::int32_t, ::protos::Player,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  WorldModel_OurPlayersDictEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorldModel_OurPlayersDictEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WorldModel_OurPlayersDictEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WorldModel_OurPlayersDictEntry_DoNotUse& other);
  static const WorldModel_OurPlayersDictEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WorldModel_OurPlayersDictEntry_DoNotUse*>(&_WorldModel_OurPlayersDictEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class WorldModel_TheirPlayersDictEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WorldModel_TheirPlayersDictEntry_DoNotUse, 
    ::int32_t, ::protos::Player,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WorldModel_TheirPlayersDictEntry_DoNotUse, 
    ::int32_t, ::protos::Player,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  WorldModel_TheirPlayersDictEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorldModel_TheirPlayersDictEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WorldModel_TheirPlayersDictEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WorldModel_TheirPlayersDictEntry_DoNotUse& other);
  static const WorldModel_TheirPlayersDictEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WorldModel_TheirPlayersDictEntry_DoNotUse*>(&_WorldModel_TheirPlayersDictEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class WorldModel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.WorldModel) */ {
 public:
  inline WorldModel() : WorldModel(nullptr) {}
  ~WorldModel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorldModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorldModel(const WorldModel& from);
  WorldModel(WorldModel&& from) noexcept
    : WorldModel() {
    *this = ::std::move(from);
  }

  inline WorldModel& operator=(const WorldModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldModel& operator=(WorldModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorldModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorldModel* internal_default_instance() {
    return reinterpret_cast<const WorldModel*>(
               &_WorldModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(WorldModel& a, WorldModel& b) {
    a.Swap(&b);
  }
  inline void Swap(WorldModel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldModel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorldModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorldModel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorldModel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorldModel& from) {
    WorldModel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorldModel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.WorldModel";
  }
  protected:
  explicit WorldModel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTeammatesFieldNumber = 8,
    kOpponentsFieldNumber = 9,
    kUnknownsFieldNumber = 10,
    kOurPlayersDictFieldNumber = 11,
    kTheirPlayersDictFieldNumber = 12,
    kOurTeamNameFieldNumber = 2,
    kTheirTeamNameFieldNumber = 3,
    kInterceptTableFieldNumber = 1,
    kSelfFieldNumber = 6,
    kBallFieldNumber = 7,
    kOurSideFieldNumber = 4,
    kLastSetPlayStartTimeFieldNumber = 5,
    kOurGoalieUniformNumberFieldNumber = 13,
    kTheirGoalieUniformNumberFieldNumber = 14,
    kOffsideLineXFieldNumber = 15,
    kOfsideLineXCountFieldNumber = 16,
    kKickableTeammateIdFieldNumber = 17,
    kKickableOpponentIdFieldNumber = 18,
    kLastKickSideFieldNumber = 19,
    kLastKickerUniformNumberFieldNumber = 20,
    kCycleFieldNumber = 21,
    kGameModeTypeFieldNumber = 22,
    kLeftTeamScoreFieldNumber = 23,
    kRightTeamScoreFieldNumber = 24,
    kIsOurSetPlayFieldNumber = 25,
    kIsTheirSetPlayFieldNumber = 26,
    kStopedCycleFieldNumber = 27,
    kOurTeamScoreFieldNumber = 28,
    kTheirTeamScoreFieldNumber = 29,
  };
  // repeated .protos.Player teammates = 8;
  int teammates_size() const;
  private:
  int _internal_teammates_size() const;

  public:
  void clear_teammates() ;
  ::protos::Player* mutable_teammates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >*
      mutable_teammates();
  private:
  const ::protos::Player& _internal_teammates(int index) const;
  ::protos::Player* _internal_add_teammates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>& _internal_teammates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>* _internal_mutable_teammates();
  public:
  const ::protos::Player& teammates(int index) const;
  ::protos::Player* add_teammates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >&
      teammates() const;
  // repeated .protos.Player opponents = 9;
  int opponents_size() const;
  private:
  int _internal_opponents_size() const;

  public:
  void clear_opponents() ;
  ::protos::Player* mutable_opponents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >*
      mutable_opponents();
  private:
  const ::protos::Player& _internal_opponents(int index) const;
  ::protos::Player* _internal_add_opponents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>& _internal_opponents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>* _internal_mutable_opponents();
  public:
  const ::protos::Player& opponents(int index) const;
  ::protos::Player* add_opponents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >&
      opponents() const;
  // repeated .protos.Player unknowns = 10;
  int unknowns_size() const;
  private:
  int _internal_unknowns_size() const;

  public:
  void clear_unknowns() ;
  ::protos::Player* mutable_unknowns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >*
      mutable_unknowns();
  private:
  const ::protos::Player& _internal_unknowns(int index) const;
  ::protos::Player* _internal_add_unknowns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>& _internal_unknowns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>* _internal_mutable_unknowns();
  public:
  const ::protos::Player& unknowns(int index) const;
  ::protos::Player* add_unknowns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >&
      unknowns() const;
  // map<int32, .protos.Player> our_players_dict = 11;
  int our_players_dict_size() const;
  private:
  int _internal_our_players_dict_size() const;

  public:
  void clear_our_players_dict() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >&
      _internal_our_players_dict() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >*
      _internal_mutable_our_players_dict();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >&
      our_players_dict() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >*
      mutable_our_players_dict();
  // map<int32, .protos.Player> their_players_dict = 12;
  int their_players_dict_size() const;
  private:
  int _internal_their_players_dict_size() const;

  public:
  void clear_their_players_dict() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >&
      _internal_their_players_dict() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >*
      _internal_mutable_their_players_dict();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >&
      their_players_dict() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >*
      mutable_their_players_dict();
  // string our_team_name = 2;
  void clear_our_team_name() ;
  const std::string& our_team_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_our_team_name(Arg_&& arg, Args_... args);
  std::string* mutable_our_team_name();
  PROTOBUF_NODISCARD std::string* release_our_team_name();
  void set_allocated_our_team_name(std::string* ptr);

  private:
  const std::string& _internal_our_team_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_our_team_name(
      const std::string& value);
  std::string* _internal_mutable_our_team_name();

  public:
  // string their_team_name = 3;
  void clear_their_team_name() ;
  const std::string& their_team_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_their_team_name(Arg_&& arg, Args_... args);
  std::string* mutable_their_team_name();
  PROTOBUF_NODISCARD std::string* release_their_team_name();
  void set_allocated_their_team_name(std::string* ptr);

  private:
  const std::string& _internal_their_team_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_their_team_name(
      const std::string& value);
  std::string* _internal_mutable_their_team_name();

  public:
  // .protos.InterceptTable intercept_table = 1;
  bool has_intercept_table() const;
  void clear_intercept_table() ;
  const ::protos::InterceptTable& intercept_table() const;
  PROTOBUF_NODISCARD ::protos::InterceptTable* release_intercept_table();
  ::protos::InterceptTable* mutable_intercept_table();
  void set_allocated_intercept_table(::protos::InterceptTable* intercept_table);
  private:
  const ::protos::InterceptTable& _internal_intercept_table() const;
  ::protos::InterceptTable* _internal_mutable_intercept_table();
  public:
  void unsafe_arena_set_allocated_intercept_table(
      ::protos::InterceptTable* intercept_table);
  ::protos::InterceptTable* unsafe_arena_release_intercept_table();
  // .protos.Self self = 6;
  bool has_self() const;
  void clear_self() ;
  const ::protos::Self& self() const;
  PROTOBUF_NODISCARD ::protos::Self* release_self();
  ::protos::Self* mutable_self();
  void set_allocated_self(::protos::Self* self);
  private:
  const ::protos::Self& _internal_self() const;
  ::protos::Self* _internal_mutable_self();
  public:
  void unsafe_arena_set_allocated_self(
      ::protos::Self* self);
  ::protos::Self* unsafe_arena_release_self();
  // .protos.Ball ball = 7;
  bool has_ball() const;
  void clear_ball() ;
  const ::protos::Ball& ball() const;
  PROTOBUF_NODISCARD ::protos::Ball* release_ball();
  ::protos::Ball* mutable_ball();
  void set_allocated_ball(::protos::Ball* ball);
  private:
  const ::protos::Ball& _internal_ball() const;
  ::protos::Ball* _internal_mutable_ball();
  public:
  void unsafe_arena_set_allocated_ball(
      ::protos::Ball* ball);
  ::protos::Ball* unsafe_arena_release_ball();
  // .protos.Side our_side = 4;
  void clear_our_side() ;
  ::protos::Side our_side() const;
  void set_our_side(::protos::Side value);

  private:
  ::protos::Side _internal_our_side() const;
  void _internal_set_our_side(::protos::Side value);

  public:
  // int32 last_set_play_start_time = 5;
  void clear_last_set_play_start_time() ;
  ::int32_t last_set_play_start_time() const;
  void set_last_set_play_start_time(::int32_t value);

  private:
  ::int32_t _internal_last_set_play_start_time() const;
  void _internal_set_last_set_play_start_time(::int32_t value);

  public:
  // int32 our_goalie_uniform_number = 13;
  void clear_our_goalie_uniform_number() ;
  ::int32_t our_goalie_uniform_number() const;
  void set_our_goalie_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_our_goalie_uniform_number() const;
  void _internal_set_our_goalie_uniform_number(::int32_t value);

  public:
  // int32 their_goalie_uniform_number = 14;
  void clear_their_goalie_uniform_number() ;
  ::int32_t their_goalie_uniform_number() const;
  void set_their_goalie_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_their_goalie_uniform_number() const;
  void _internal_set_their_goalie_uniform_number(::int32_t value);

  public:
  // float offside_line_x = 15;
  void clear_offside_line_x() ;
  float offside_line_x() const;
  void set_offside_line_x(float value);

  private:
  float _internal_offside_line_x() const;
  void _internal_set_offside_line_x(float value);

  public:
  // int32 ofside_line_x_count = 16;
  void clear_ofside_line_x_count() ;
  ::int32_t ofside_line_x_count() const;
  void set_ofside_line_x_count(::int32_t value);

  private:
  ::int32_t _internal_ofside_line_x_count() const;
  void _internal_set_ofside_line_x_count(::int32_t value);

  public:
  // int32 kickable_teammate_id = 17;
  void clear_kickable_teammate_id() ;
  ::int32_t kickable_teammate_id() const;
  void set_kickable_teammate_id(::int32_t value);

  private:
  ::int32_t _internal_kickable_teammate_id() const;
  void _internal_set_kickable_teammate_id(::int32_t value);

  public:
  // int32 kickable_opponent_id = 18;
  void clear_kickable_opponent_id() ;
  ::int32_t kickable_opponent_id() const;
  void set_kickable_opponent_id(::int32_t value);

  private:
  ::int32_t _internal_kickable_opponent_id() const;
  void _internal_set_kickable_opponent_id(::int32_t value);

  public:
  // .protos.Side last_kick_side = 19;
  void clear_last_kick_side() ;
  ::protos::Side last_kick_side() const;
  void set_last_kick_side(::protos::Side value);

  private:
  ::protos::Side _internal_last_kick_side() const;
  void _internal_set_last_kick_side(::protos::Side value);

  public:
  // int32 last_kicker_uniform_number = 20;
  void clear_last_kicker_uniform_number() ;
  ::int32_t last_kicker_uniform_number() const;
  void set_last_kicker_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_last_kicker_uniform_number() const;
  void _internal_set_last_kicker_uniform_number(::int32_t value);

  public:
  // int32 cycle = 21;
  void clear_cycle() ;
  ::int32_t cycle() const;
  void set_cycle(::int32_t value);

  private:
  ::int32_t _internal_cycle() const;
  void _internal_set_cycle(::int32_t value);

  public:
  // .protos.GameModeType game_mode_type = 22;
  void clear_game_mode_type() ;
  ::protos::GameModeType game_mode_type() const;
  void set_game_mode_type(::protos::GameModeType value);

  private:
  ::protos::GameModeType _internal_game_mode_type() const;
  void _internal_set_game_mode_type(::protos::GameModeType value);

  public:
  // int32 left_team_score = 23;
  void clear_left_team_score() ;
  ::int32_t left_team_score() const;
  void set_left_team_score(::int32_t value);

  private:
  ::int32_t _internal_left_team_score() const;
  void _internal_set_left_team_score(::int32_t value);

  public:
  // int32 right_team_score = 24;
  void clear_right_team_score() ;
  ::int32_t right_team_score() const;
  void set_right_team_score(::int32_t value);

  private:
  ::int32_t _internal_right_team_score() const;
  void _internal_set_right_team_score(::int32_t value);

  public:
  // bool is_our_set_play = 25;
  void clear_is_our_set_play() ;
  bool is_our_set_play() const;
  void set_is_our_set_play(bool value);

  private:
  bool _internal_is_our_set_play() const;
  void _internal_set_is_our_set_play(bool value);

  public:
  // bool is_their_set_play = 26;
  void clear_is_their_set_play() ;
  bool is_their_set_play() const;
  void set_is_their_set_play(bool value);

  private:
  bool _internal_is_their_set_play() const;
  void _internal_set_is_their_set_play(bool value);

  public:
  // int32 stoped_cycle = 27;
  void clear_stoped_cycle() ;
  ::int32_t stoped_cycle() const;
  void set_stoped_cycle(::int32_t value);

  private:
  ::int32_t _internal_stoped_cycle() const;
  void _internal_set_stoped_cycle(::int32_t value);

  public:
  // int32 our_team_score = 28;
  void clear_our_team_score() ;
  ::int32_t our_team_score() const;
  void set_our_team_score(::int32_t value);

  private:
  ::int32_t _internal_our_team_score() const;
  void _internal_set_our_team_score(::int32_t value);

  public:
  // int32 their_team_score = 29;
  void clear_their_team_score() ;
  ::int32_t their_team_score() const;
  void set_their_team_score(::int32_t value);

  private:
  ::int32_t _internal_their_team_score() const;
  void _internal_set_their_team_score(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.WorldModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player > teammates_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player > opponents_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player > unknowns_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        WorldModel_OurPlayersDictEntry_DoNotUse,
        ::int32_t, ::protos::Player,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> our_players_dict_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        WorldModel_TheirPlayersDictEntry_DoNotUse,
        ::int32_t, ::protos::Player,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> their_players_dict_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr our_team_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr their_team_name_;
    ::protos::InterceptTable* intercept_table_;
    ::protos::Self* self_;
    ::protos::Ball* ball_;
    int our_side_;
    ::int32_t last_set_play_start_time_;
    ::int32_t our_goalie_uniform_number_;
    ::int32_t their_goalie_uniform_number_;
    float offside_line_x_;
    ::int32_t ofside_line_x_count_;
    ::int32_t kickable_teammate_id_;
    ::int32_t kickable_opponent_id_;
    int last_kick_side_;
    ::int32_t last_kicker_uniform_number_;
    ::int32_t cycle_;
    int game_mode_type_;
    ::int32_t left_team_score_;
    ::int32_t right_team_score_;
    bool is_our_set_play_;
    bool is_their_set_play_;
    ::int32_t stoped_cycle_;
    ::int32_t our_team_score_;
    ::int32_t their_team_score_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class State final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.State) */ {
 public:
  inline State() : State(nullptr) {}
  ~State() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR State(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  State(const State& from);
  State(State&& from) noexcept
    : State() {
    *this = ::std::move(from);
  }

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }
  inline State& operator=(State&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const State& default_instance() {
    return *internal_default_instance();
  }
  static inline const State* internal_default_instance() {
    return reinterpret_cast<const State*>(
               &_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(State& a, State& b) {
    a.Swap(&b);
  }
  inline void Swap(State* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(State* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  State* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<State>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const State& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const State& from) {
    State::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.State";
  }
  protected:
  explicit State(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldModelFieldNumber = 1,
    kFullWorldModelFieldNumber = 2,
  };
  // .protos.WorldModel world_model = 1;
  bool has_world_model() const;
  void clear_world_model() ;
  const ::protos::WorldModel& world_model() const;
  PROTOBUF_NODISCARD ::protos::WorldModel* release_world_model();
  ::protos::WorldModel* mutable_world_model();
  void set_allocated_world_model(::protos::WorldModel* world_model);
  private:
  const ::protos::WorldModel& _internal_world_model() const;
  ::protos::WorldModel* _internal_mutable_world_model();
  public:
  void unsafe_arena_set_allocated_world_model(
      ::protos::WorldModel* world_model);
  ::protos::WorldModel* unsafe_arena_release_world_model();
  // .protos.WorldModel full_world_model = 2;
  bool has_full_world_model() const;
  void clear_full_world_model() ;
  const ::protos::WorldModel& full_world_model() const;
  PROTOBUF_NODISCARD ::protos::WorldModel* release_full_world_model();
  ::protos::WorldModel* mutable_full_world_model();
  void set_allocated_full_world_model(::protos::WorldModel* full_world_model);
  private:
  const ::protos::WorldModel& _internal_full_world_model() const;
  ::protos::WorldModel* _internal_mutable_full_world_model();
  public:
  void unsafe_arena_set_allocated_full_world_model(
      ::protos::WorldModel* full_world_model);
  ::protos::WorldModel* unsafe_arena_release_full_world_model();
  // @@protoc_insertion_point(class_scope:protos.State)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::WorldModel* world_model_;
    ::protos::WorldModel* full_world_model_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Dash final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Dash) */ {
 public:
  inline Dash() : Dash(nullptr) {}
  ~Dash() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Dash(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dash(const Dash& from);
  Dash(Dash&& from) noexcept
    : Dash() {
    *this = ::std::move(from);
  }

  inline Dash& operator=(const Dash& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dash& operator=(Dash&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dash& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dash* internal_default_instance() {
    return reinterpret_cast<const Dash*>(
               &_Dash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Dash& a, Dash& b) {
    a.Swap(&b);
  }
  inline void Swap(Dash* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dash* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dash>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dash& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Dash& from) {
    Dash::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dash* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Dash";
  }
  protected:
  explicit Dash(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPowerFieldNumber = 1,
    kRelativeDirectionFieldNumber = 2,
  };
  // float power = 1;
  void clear_power() ;
  float power() const;
  void set_power(float value);

  private:
  float _internal_power() const;
  void _internal_set_power(float value);

  public:
  // float relative_direction = 2;
  void clear_relative_direction() ;
  float relative_direction() const;
  void set_relative_direction(float value);

  private:
  float _internal_relative_direction() const;
  void _internal_set_relative_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Dash)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float power_;
    float relative_direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Turn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Turn) */ {
 public:
  inline Turn() : Turn(nullptr) {}
  ~Turn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Turn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Turn(const Turn& from);
  Turn(Turn&& from) noexcept
    : Turn() {
    *this = ::std::move(from);
  }

  inline Turn& operator=(const Turn& from) {
    CopyFrom(from);
    return *this;
  }
  inline Turn& operator=(Turn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Turn& default_instance() {
    return *internal_default_instance();
  }
  static inline const Turn* internal_default_instance() {
    return reinterpret_cast<const Turn*>(
               &_Turn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Turn& a, Turn& b) {
    a.Swap(&b);
  }
  inline void Swap(Turn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Turn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Turn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Turn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Turn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Turn& from) {
    Turn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Turn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Turn";
  }
  protected:
  explicit Turn(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelativeDirectionFieldNumber = 1,
  };
  // float relative_direction = 1;
  void clear_relative_direction() ;
  float relative_direction() const;
  void set_relative_direction(float value);

  private:
  float _internal_relative_direction() const;
  void _internal_set_relative_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Turn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float relative_direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Kick final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Kick) */ {
 public:
  inline Kick() : Kick(nullptr) {}
  ~Kick() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Kick(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Kick(const Kick& from);
  Kick(Kick&& from) noexcept
    : Kick() {
    *this = ::std::move(from);
  }

  inline Kick& operator=(const Kick& from) {
    CopyFrom(from);
    return *this;
  }
  inline Kick& operator=(Kick&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Kick& default_instance() {
    return *internal_default_instance();
  }
  static inline const Kick* internal_default_instance() {
    return reinterpret_cast<const Kick*>(
               &_Kick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Kick& a, Kick& b) {
    a.Swap(&b);
  }
  inline void Swap(Kick* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Kick* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Kick* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Kick>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Kick& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Kick& from) {
    Kick::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Kick* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Kick";
  }
  protected:
  explicit Kick(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPowerFieldNumber = 1,
    kRelativeDirectionFieldNumber = 2,
  };
  // float power = 1;
  void clear_power() ;
  float power() const;
  void set_power(float value);

  private:
  float _internal_power() const;
  void _internal_set_power(float value);

  public:
  // float relative_direction = 2;
  void clear_relative_direction() ;
  float relative_direction() const;
  void set_relative_direction(float value);

  private:
  float _internal_relative_direction() const;
  void _internal_set_relative_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Kick)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float power_;
    float relative_direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Tackle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Tackle) */ {
 public:
  inline Tackle() : Tackle(nullptr) {}
  ~Tackle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Tackle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tackle(const Tackle& from);
  Tackle(Tackle&& from) noexcept
    : Tackle() {
    *this = ::std::move(from);
  }

  inline Tackle& operator=(const Tackle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tackle& operator=(Tackle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tackle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tackle* internal_default_instance() {
    return reinterpret_cast<const Tackle*>(
               &_Tackle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Tackle& a, Tackle& b) {
    a.Swap(&b);
  }
  inline void Swap(Tackle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tackle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tackle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tackle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tackle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tackle& from) {
    Tackle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tackle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Tackle";
  }
  protected:
  explicit Tackle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPowerOrDirFieldNumber = 1,
    kFoulFieldNumber = 2,
  };
  // float power_or_dir = 1;
  void clear_power_or_dir() ;
  float power_or_dir() const;
  void set_power_or_dir(float value);

  private:
  float _internal_power_or_dir() const;
  void _internal_set_power_or_dir(float value);

  public:
  // bool foul = 2;
  void clear_foul() ;
  bool foul() const;
  void set_foul(bool value);

  private:
  bool _internal_foul() const;
  void _internal_set_foul(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Tackle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float power_or_dir_;
    bool foul_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Catch final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Catch) */ {
 public:
  inline Catch() : Catch(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Catch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Catch(const Catch& from);
  Catch(Catch&& from) noexcept
    : Catch() {
    *this = ::std::move(from);
  }

  inline Catch& operator=(const Catch& from) {
    CopyFrom(from);
    return *this;
  }
  inline Catch& operator=(Catch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Catch& default_instance() {
    return *internal_default_instance();
  }
  static inline const Catch* internal_default_instance() {
    return reinterpret_cast<const Catch*>(
               &_Catch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Catch& a, Catch& b) {
    a.Swap(&b);
  }
  inline void Swap(Catch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Catch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Catch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Catch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Catch& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Catch& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Catch";
  }
  protected:
  explicit Catch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Catch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Move) */ {
 public:
  inline Move() : Move(nullptr) {}
  ~Move() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Move(const Move& from);
  Move(Move&& from) noexcept
    : Move() {
    *this = ::std::move(from);
  }

  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline Move& operator=(Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const Move* internal_default_instance() {
    return reinterpret_cast<const Move*>(
               &_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Move& a, Move& b) {
    a.Swap(&b);
  }
  inline void Swap(Move* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Move* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Move>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Move& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Move& from) {
    Move::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Move* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Move";
  }
  protected:
  explicit Move(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class TurnNeck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.TurnNeck) */ {
 public:
  inline TurnNeck() : TurnNeck(nullptr) {}
  ~TurnNeck() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TurnNeck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TurnNeck(const TurnNeck& from);
  TurnNeck(TurnNeck&& from) noexcept
    : TurnNeck() {
    *this = ::std::move(from);
  }

  inline TurnNeck& operator=(const TurnNeck& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnNeck& operator=(TurnNeck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TurnNeck& default_instance() {
    return *internal_default_instance();
  }
  static inline const TurnNeck* internal_default_instance() {
    return reinterpret_cast<const TurnNeck*>(
               &_TurnNeck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TurnNeck& a, TurnNeck& b) {
    a.Swap(&b);
  }
  inline void Swap(TurnNeck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnNeck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TurnNeck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TurnNeck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TurnNeck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TurnNeck& from) {
    TurnNeck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TurnNeck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.TurnNeck";
  }
  protected:
  explicit TurnNeck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMomentFieldNumber = 1,
  };
  // float moment = 1;
  void clear_moment() ;
  float moment() const;
  void set_moment(float value);

  private:
  float _internal_moment() const;
  void _internal_set_moment(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.TurnNeck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float moment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class ChangeView final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.ChangeView) */ {
 public:
  inline ChangeView() : ChangeView(nullptr) {}
  ~ChangeView() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChangeView(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeView(const ChangeView& from);
  ChangeView(ChangeView&& from) noexcept
    : ChangeView() {
    *this = ::std::move(from);
  }

  inline ChangeView& operator=(const ChangeView& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeView& operator=(ChangeView&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeView& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeView* internal_default_instance() {
    return reinterpret_cast<const ChangeView*>(
               &_ChangeView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ChangeView& a, ChangeView& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeView* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeView* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeView* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeView>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeView& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeView& from) {
    ChangeView::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeView* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.ChangeView";
  }
  protected:
  explicit ChangeView(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewWidthFieldNumber = 1,
  };
  // .protos.ViewWidth view_width = 1;
  void clear_view_width() ;
  ::protos::ViewWidth view_width() const;
  void set_view_width(::protos::ViewWidth value);

  private:
  ::protos::ViewWidth _internal_view_width() const;
  void _internal_set_view_width(::protos::ViewWidth value);

  public:
  // @@protoc_insertion_point(class_scope:protos.ChangeView)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int view_width_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class BallMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.BallMessage) */ {
 public:
  inline BallMessage() : BallMessage(nullptr) {}
  ~BallMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BallMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BallMessage(const BallMessage& from);
  BallMessage(BallMessage&& from) noexcept
    : BallMessage() {
    *this = ::std::move(from);
  }

  inline BallMessage& operator=(const BallMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BallMessage& operator=(BallMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BallMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BallMessage* internal_default_instance() {
    return reinterpret_cast<const BallMessage*>(
               &_BallMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BallMessage& a, BallMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BallMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BallMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BallMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BallMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BallMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BallMessage& from) {
    BallMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BallMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.BallMessage";
  }
  protected:
  explicit BallMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBallPositionFieldNumber = 1,
    kBallVelocityFieldNumber = 2,
  };
  // .protos.Vector2D ball_position = 1;
  bool has_ball_position() const;
  void clear_ball_position() ;
  const ::protos::Vector2D& ball_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_ball_position();
  ::protos::Vector2D* mutable_ball_position();
  void set_allocated_ball_position(::protos::Vector2D* ball_position);
  private:
  const ::protos::Vector2D& _internal_ball_position() const;
  ::protos::Vector2D* _internal_mutable_ball_position();
  public:
  void unsafe_arena_set_allocated_ball_position(
      ::protos::Vector2D* ball_position);
  ::protos::Vector2D* unsafe_arena_release_ball_position();
  // .protos.Vector2D ball_velocity = 2;
  bool has_ball_velocity() const;
  void clear_ball_velocity() ;
  const ::protos::Vector2D& ball_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_ball_velocity();
  ::protos::Vector2D* mutable_ball_velocity();
  void set_allocated_ball_velocity(::protos::Vector2D* ball_velocity);
  private:
  const ::protos::Vector2D& _internal_ball_velocity() const;
  ::protos::Vector2D* _internal_mutable_ball_velocity();
  public:
  void unsafe_arena_set_allocated_ball_velocity(
      ::protos::Vector2D* ball_velocity);
  ::protos::Vector2D* unsafe_arena_release_ball_velocity();
  // @@protoc_insertion_point(class_scope:protos.BallMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* ball_position_;
    ::protos::Vector2D* ball_velocity_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class PassMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.PassMessage) */ {
 public:
  inline PassMessage() : PassMessage(nullptr) {}
  ~PassMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PassMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PassMessage(const PassMessage& from);
  PassMessage(PassMessage&& from) noexcept
    : PassMessage() {
    *this = ::std::move(from);
  }

  inline PassMessage& operator=(const PassMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PassMessage& operator=(PassMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PassMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PassMessage* internal_default_instance() {
    return reinterpret_cast<const PassMessage*>(
               &_PassMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PassMessage& a, PassMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PassMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PassMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PassMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PassMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PassMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PassMessage& from) {
    PassMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PassMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.PassMessage";
  }
  protected:
  explicit PassMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReceiverPointFieldNumber = 2,
    kBallPositionFieldNumber = 3,
    kBallVelocityFieldNumber = 4,
    kReceiverUniformNumberFieldNumber = 1,
  };
  // .protos.Vector2D receiver_point = 2;
  bool has_receiver_point() const;
  void clear_receiver_point() ;
  const ::protos::Vector2D& receiver_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_receiver_point();
  ::protos::Vector2D* mutable_receiver_point();
  void set_allocated_receiver_point(::protos::Vector2D* receiver_point);
  private:
  const ::protos::Vector2D& _internal_receiver_point() const;
  ::protos::Vector2D* _internal_mutable_receiver_point();
  public:
  void unsafe_arena_set_allocated_receiver_point(
      ::protos::Vector2D* receiver_point);
  ::protos::Vector2D* unsafe_arena_release_receiver_point();
  // .protos.Vector2D ball_position = 3;
  bool has_ball_position() const;
  void clear_ball_position() ;
  const ::protos::Vector2D& ball_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_ball_position();
  ::protos::Vector2D* mutable_ball_position();
  void set_allocated_ball_position(::protos::Vector2D* ball_position);
  private:
  const ::protos::Vector2D& _internal_ball_position() const;
  ::protos::Vector2D* _internal_mutable_ball_position();
  public:
  void unsafe_arena_set_allocated_ball_position(
      ::protos::Vector2D* ball_position);
  ::protos::Vector2D* unsafe_arena_release_ball_position();
  // .protos.Vector2D ball_velocity = 4;
  bool has_ball_velocity() const;
  void clear_ball_velocity() ;
  const ::protos::Vector2D& ball_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_ball_velocity();
  ::protos::Vector2D* mutable_ball_velocity();
  void set_allocated_ball_velocity(::protos::Vector2D* ball_velocity);
  private:
  const ::protos::Vector2D& _internal_ball_velocity() const;
  ::protos::Vector2D* _internal_mutable_ball_velocity();
  public:
  void unsafe_arena_set_allocated_ball_velocity(
      ::protos::Vector2D* ball_velocity);
  ::protos::Vector2D* unsafe_arena_release_ball_velocity();
  // int32 receiver_uniform_number = 1;
  void clear_receiver_uniform_number() ;
  ::int32_t receiver_uniform_number() const;
  void set_receiver_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_receiver_uniform_number() const;
  void _internal_set_receiver_uniform_number(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.PassMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* receiver_point_;
    ::protos::Vector2D* ball_position_;
    ::protos::Vector2D* ball_velocity_;
    ::int32_t receiver_uniform_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class InterceptMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.InterceptMessage) */ {
 public:
  inline InterceptMessage() : InterceptMessage(nullptr) {}
  ~InterceptMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InterceptMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterceptMessage(const InterceptMessage& from);
  InterceptMessage(InterceptMessage&& from) noexcept
    : InterceptMessage() {
    *this = ::std::move(from);
  }

  inline InterceptMessage& operator=(const InterceptMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterceptMessage& operator=(InterceptMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterceptMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterceptMessage* internal_default_instance() {
    return reinterpret_cast<const InterceptMessage*>(
               &_InterceptMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(InterceptMessage& a, InterceptMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InterceptMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterceptMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterceptMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterceptMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterceptMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterceptMessage& from) {
    InterceptMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterceptMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.InterceptMessage";
  }
  protected:
  explicit InterceptMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOurFieldNumber = 1,
    kUniformNumberFieldNumber = 2,
    kCycleFieldNumber = 3,
  };
  // bool our = 1;
  void clear_our() ;
  bool our() const;
  void set_our(bool value);

  private:
  bool _internal_our() const;
  void _internal_set_our(bool value);

  public:
  // int32 uniform_number = 2;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // int32 cycle = 3;
  void clear_cycle() ;
  ::int32_t cycle() const;
  void set_cycle(::int32_t value);

  private:
  ::int32_t _internal_cycle() const;
  void _internal_set_cycle(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.InterceptMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool our_;
    ::int32_t uniform_number_;
    ::int32_t cycle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class GoalieMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.GoalieMessage) */ {
 public:
  inline GoalieMessage() : GoalieMessage(nullptr) {}
  ~GoalieMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GoalieMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GoalieMessage(const GoalieMessage& from);
  GoalieMessage(GoalieMessage&& from) noexcept
    : GoalieMessage() {
    *this = ::std::move(from);
  }

  inline GoalieMessage& operator=(const GoalieMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoalieMessage& operator=(GoalieMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoalieMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoalieMessage* internal_default_instance() {
    return reinterpret_cast<const GoalieMessage*>(
               &_GoalieMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GoalieMessage& a, GoalieMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GoalieMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoalieMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoalieMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GoalieMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GoalieMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GoalieMessage& from) {
    GoalieMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GoalieMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.GoalieMessage";
  }
  protected:
  explicit GoalieMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoaliePositionFieldNumber = 2,
    kGoalieUniformNumberFieldNumber = 1,
    kGoalieBodyDirectionFieldNumber = 3,
  };
  // .protos.Vector2D goalie_position = 2;
  bool has_goalie_position() const;
  void clear_goalie_position() ;
  const ::protos::Vector2D& goalie_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_goalie_position();
  ::protos::Vector2D* mutable_goalie_position();
  void set_allocated_goalie_position(::protos::Vector2D* goalie_position);
  private:
  const ::protos::Vector2D& _internal_goalie_position() const;
  ::protos::Vector2D* _internal_mutable_goalie_position();
  public:
  void unsafe_arena_set_allocated_goalie_position(
      ::protos::Vector2D* goalie_position);
  ::protos::Vector2D* unsafe_arena_release_goalie_position();
  // int32 goalie_uniform_number = 1;
  void clear_goalie_uniform_number() ;
  ::int32_t goalie_uniform_number() const;
  void set_goalie_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_goalie_uniform_number() const;
  void _internal_set_goalie_uniform_number(::int32_t value);

  public:
  // float goalie_body_direction = 3;
  void clear_goalie_body_direction() ;
  float goalie_body_direction() const;
  void set_goalie_body_direction(float value);

  private:
  float _internal_goalie_body_direction() const;
  void _internal_set_goalie_body_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.GoalieMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* goalie_position_;
    ::int32_t goalie_uniform_number_;
    float goalie_body_direction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class GoalieAndPlayerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.GoalieAndPlayerMessage) */ {
 public:
  inline GoalieAndPlayerMessage() : GoalieAndPlayerMessage(nullptr) {}
  ~GoalieAndPlayerMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GoalieAndPlayerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GoalieAndPlayerMessage(const GoalieAndPlayerMessage& from);
  GoalieAndPlayerMessage(GoalieAndPlayerMessage&& from) noexcept
    : GoalieAndPlayerMessage() {
    *this = ::std::move(from);
  }

  inline GoalieAndPlayerMessage& operator=(const GoalieAndPlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoalieAndPlayerMessage& operator=(GoalieAndPlayerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoalieAndPlayerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoalieAndPlayerMessage* internal_default_instance() {
    return reinterpret_cast<const GoalieAndPlayerMessage*>(
               &_GoalieAndPlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GoalieAndPlayerMessage& a, GoalieAndPlayerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GoalieAndPlayerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoalieAndPlayerMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoalieAndPlayerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GoalieAndPlayerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GoalieAndPlayerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GoalieAndPlayerMessage& from) {
    GoalieAndPlayerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GoalieAndPlayerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.GoalieAndPlayerMessage";
  }
  protected:
  explicit GoalieAndPlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoaliePositionFieldNumber = 2,
    kPlayerPositionFieldNumber = 5,
    kGoalieUniformNumberFieldNumber = 1,
    kGoalieBodyDirectionFieldNumber = 3,
    kPlayerUniformNumberFieldNumber = 4,
  };
  // .protos.Vector2D goalie_position = 2;
  bool has_goalie_position() const;
  void clear_goalie_position() ;
  const ::protos::Vector2D& goalie_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_goalie_position();
  ::protos::Vector2D* mutable_goalie_position();
  void set_allocated_goalie_position(::protos::Vector2D* goalie_position);
  private:
  const ::protos::Vector2D& _internal_goalie_position() const;
  ::protos::Vector2D* _internal_mutable_goalie_position();
  public:
  void unsafe_arena_set_allocated_goalie_position(
      ::protos::Vector2D* goalie_position);
  ::protos::Vector2D* unsafe_arena_release_goalie_position();
  // .protos.Vector2D player_position = 5;
  bool has_player_position() const;
  void clear_player_position() ;
  const ::protos::Vector2D& player_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_player_position();
  ::protos::Vector2D* mutable_player_position();
  void set_allocated_player_position(::protos::Vector2D* player_position);
  private:
  const ::protos::Vector2D& _internal_player_position() const;
  ::protos::Vector2D* _internal_mutable_player_position();
  public:
  void unsafe_arena_set_allocated_player_position(
      ::protos::Vector2D* player_position);
  ::protos::Vector2D* unsafe_arena_release_player_position();
  // int32 goalie_uniform_number = 1;
  void clear_goalie_uniform_number() ;
  ::int32_t goalie_uniform_number() const;
  void set_goalie_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_goalie_uniform_number() const;
  void _internal_set_goalie_uniform_number(::int32_t value);

  public:
  // float goalie_body_direction = 3;
  void clear_goalie_body_direction() ;
  float goalie_body_direction() const;
  void set_goalie_body_direction(float value);

  private:
  float _internal_goalie_body_direction() const;
  void _internal_set_goalie_body_direction(float value);

  public:
  // int32 player_uniform_number = 4;
  void clear_player_uniform_number() ;
  ::int32_t player_uniform_number() const;
  void set_player_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_player_uniform_number() const;
  void _internal_set_player_uniform_number(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.GoalieAndPlayerMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* goalie_position_;
    ::protos::Vector2D* player_position_;
    ::int32_t goalie_uniform_number_;
    float goalie_body_direction_;
    ::int32_t player_uniform_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class OffsideLineMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.OffsideLineMessage) */ {
 public:
  inline OffsideLineMessage() : OffsideLineMessage(nullptr) {}
  ~OffsideLineMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OffsideLineMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OffsideLineMessage(const OffsideLineMessage& from);
  OffsideLineMessage(OffsideLineMessage&& from) noexcept
    : OffsideLineMessage() {
    *this = ::std::move(from);
  }

  inline OffsideLineMessage& operator=(const OffsideLineMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OffsideLineMessage& operator=(OffsideLineMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OffsideLineMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OffsideLineMessage* internal_default_instance() {
    return reinterpret_cast<const OffsideLineMessage*>(
               &_OffsideLineMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(OffsideLineMessage& a, OffsideLineMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OffsideLineMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OffsideLineMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OffsideLineMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OffsideLineMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OffsideLineMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OffsideLineMessage& from) {
    OffsideLineMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OffsideLineMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.OffsideLineMessage";
  }
  protected:
  explicit OffsideLineMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsideLineXFieldNumber = 1,
  };
  // float offside_line_x = 1;
  void clear_offside_line_x() ;
  float offside_line_x() const;
  void set_offside_line_x(float value);

  private:
  float _internal_offside_line_x() const;
  void _internal_set_offside_line_x(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.OffsideLineMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float offside_line_x_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class DefenseLineMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.DefenseLineMessage) */ {
 public:
  inline DefenseLineMessage() : DefenseLineMessage(nullptr) {}
  ~DefenseLineMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DefenseLineMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefenseLineMessage(const DefenseLineMessage& from);
  DefenseLineMessage(DefenseLineMessage&& from) noexcept
    : DefenseLineMessage() {
    *this = ::std::move(from);
  }

  inline DefenseLineMessage& operator=(const DefenseLineMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefenseLineMessage& operator=(DefenseLineMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefenseLineMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefenseLineMessage* internal_default_instance() {
    return reinterpret_cast<const DefenseLineMessage*>(
               &_DefenseLineMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(DefenseLineMessage& a, DefenseLineMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DefenseLineMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefenseLineMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefenseLineMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefenseLineMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DefenseLineMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DefenseLineMessage& from) {
    DefenseLineMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefenseLineMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.DefenseLineMessage";
  }
  protected:
  explicit DefenseLineMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefenseLineXFieldNumber = 1,
  };
  // float defense_line_x = 1;
  void clear_defense_line_x() ;
  float defense_line_x() const;
  void set_defense_line_x(float value);

  private:
  float _internal_defense_line_x() const;
  void _internal_set_defense_line_x(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.DefenseLineMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float defense_line_x_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class WaitRequestMessage final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.WaitRequestMessage) */ {
 public:
  inline WaitRequestMessage() : WaitRequestMessage(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WaitRequestMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaitRequestMessage(const WaitRequestMessage& from);
  WaitRequestMessage(WaitRequestMessage&& from) noexcept
    : WaitRequestMessage() {
    *this = ::std::move(from);
  }

  inline WaitRequestMessage& operator=(const WaitRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitRequestMessage& operator=(WaitRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WaitRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitRequestMessage* internal_default_instance() {
    return reinterpret_cast<const WaitRequestMessage*>(
               &_WaitRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(WaitRequestMessage& a, WaitRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(WaitRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitRequestMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaitRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WaitRequestMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const WaitRequestMessage& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const WaitRequestMessage& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.WaitRequestMessage";
  }
  protected:
  explicit WaitRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.WaitRequestMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class SetplayMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.SetplayMessage) */ {
 public:
  inline SetplayMessage() : SetplayMessage(nullptr) {}
  ~SetplayMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetplayMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetplayMessage(const SetplayMessage& from);
  SetplayMessage(SetplayMessage&& from) noexcept
    : SetplayMessage() {
    *this = ::std::move(from);
  }

  inline SetplayMessage& operator=(const SetplayMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetplayMessage& operator=(SetplayMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetplayMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetplayMessage* internal_default_instance() {
    return reinterpret_cast<const SetplayMessage*>(
               &_SetplayMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SetplayMessage& a, SetplayMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SetplayMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetplayMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetplayMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetplayMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetplayMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetplayMessage& from) {
    SetplayMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetplayMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.SetplayMessage";
  }
  protected:
  explicit SetplayMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWaitStepFieldNumber = 1,
  };
  // int32 wait_step = 1;
  void clear_wait_step() ;
  ::int32_t wait_step() const;
  void set_wait_step(::int32_t value);

  private:
  ::int32_t _internal_wait_step() const;
  void _internal_set_wait_step(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.SetplayMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t wait_step_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class PassRequestMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.PassRequestMessage) */ {
 public:
  inline PassRequestMessage() : PassRequestMessage(nullptr) {}
  ~PassRequestMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PassRequestMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PassRequestMessage(const PassRequestMessage& from);
  PassRequestMessage(PassRequestMessage&& from) noexcept
    : PassRequestMessage() {
    *this = ::std::move(from);
  }

  inline PassRequestMessage& operator=(const PassRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PassRequestMessage& operator=(PassRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PassRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PassRequestMessage* internal_default_instance() {
    return reinterpret_cast<const PassRequestMessage*>(
               &_PassRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(PassRequestMessage& a, PassRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PassRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PassRequestMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PassRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PassRequestMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PassRequestMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PassRequestMessage& from) {
    PassRequestMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PassRequestMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.PassRequestMessage";
  }
  protected:
  explicit PassRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* target_point);
  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();
  public:
  void unsafe_arena_set_allocated_target_point(
      ::protos::Vector2D* target_point);
  ::protos::Vector2D* unsafe_arena_release_target_point();
  // @@protoc_insertion_point(class_scope:protos.PassRequestMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class StaminaMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.StaminaMessage) */ {
 public:
  inline StaminaMessage() : StaminaMessage(nullptr) {}
  ~StaminaMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StaminaMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaminaMessage(const StaminaMessage& from);
  StaminaMessage(StaminaMessage&& from) noexcept
    : StaminaMessage() {
    *this = ::std::move(from);
  }

  inline StaminaMessage& operator=(const StaminaMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaminaMessage& operator=(StaminaMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaminaMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaminaMessage* internal_default_instance() {
    return reinterpret_cast<const StaminaMessage*>(
               &_StaminaMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(StaminaMessage& a, StaminaMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StaminaMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaminaMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaminaMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaminaMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaminaMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaminaMessage& from) {
    StaminaMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaminaMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.StaminaMessage";
  }
  protected:
  explicit StaminaMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStaminaFieldNumber = 1,
  };
  // float stamina = 1;
  void clear_stamina() ;
  float stamina() const;
  void set_stamina(float value);

  private:
  float _internal_stamina() const;
  void _internal_set_stamina(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.StaminaMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float stamina_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class RecoveryMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.RecoveryMessage) */ {
 public:
  inline RecoveryMessage() : RecoveryMessage(nullptr) {}
  ~RecoveryMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecoveryMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecoveryMessage(const RecoveryMessage& from);
  RecoveryMessage(RecoveryMessage&& from) noexcept
    : RecoveryMessage() {
    *this = ::std::move(from);
  }

  inline RecoveryMessage& operator=(const RecoveryMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecoveryMessage& operator=(RecoveryMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecoveryMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecoveryMessage* internal_default_instance() {
    return reinterpret_cast<const RecoveryMessage*>(
               &_RecoveryMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(RecoveryMessage& a, RecoveryMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RecoveryMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecoveryMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecoveryMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecoveryMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecoveryMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecoveryMessage& from) {
    RecoveryMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecoveryMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.RecoveryMessage";
  }
  protected:
  explicit RecoveryMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecoveryFieldNumber = 1,
  };
  // float recovery = 1;
  void clear_recovery() ;
  float recovery() const;
  void set_recovery(float value);

  private:
  float _internal_recovery() const;
  void _internal_set_recovery(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.RecoveryMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float recovery_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class StaminaCapacityMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.StaminaCapacityMessage) */ {
 public:
  inline StaminaCapacityMessage() : StaminaCapacityMessage(nullptr) {}
  ~StaminaCapacityMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StaminaCapacityMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaminaCapacityMessage(const StaminaCapacityMessage& from);
  StaminaCapacityMessage(StaminaCapacityMessage&& from) noexcept
    : StaminaCapacityMessage() {
    *this = ::std::move(from);
  }

  inline StaminaCapacityMessage& operator=(const StaminaCapacityMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaminaCapacityMessage& operator=(StaminaCapacityMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaminaCapacityMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaminaCapacityMessage* internal_default_instance() {
    return reinterpret_cast<const StaminaCapacityMessage*>(
               &_StaminaCapacityMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(StaminaCapacityMessage& a, StaminaCapacityMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StaminaCapacityMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaminaCapacityMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaminaCapacityMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaminaCapacityMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaminaCapacityMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaminaCapacityMessage& from) {
    StaminaCapacityMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaminaCapacityMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.StaminaCapacityMessage";
  }
  protected:
  explicit StaminaCapacityMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStaminaCapacityFieldNumber = 1,
  };
  // float stamina_capacity = 1;
  void clear_stamina_capacity() ;
  float stamina_capacity() const;
  void set_stamina_capacity(float value);

  private:
  float _internal_stamina_capacity() const;
  void _internal_set_stamina_capacity(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.StaminaCapacityMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float stamina_capacity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class DribbleMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.DribbleMessage) */ {
 public:
  inline DribbleMessage() : DribbleMessage(nullptr) {}
  ~DribbleMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DribbleMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DribbleMessage(const DribbleMessage& from);
  DribbleMessage(DribbleMessage&& from) noexcept
    : DribbleMessage() {
    *this = ::std::move(from);
  }

  inline DribbleMessage& operator=(const DribbleMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DribbleMessage& operator=(DribbleMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DribbleMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DribbleMessage* internal_default_instance() {
    return reinterpret_cast<const DribbleMessage*>(
               &_DribbleMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(DribbleMessage& a, DribbleMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DribbleMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DribbleMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DribbleMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DribbleMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DribbleMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DribbleMessage& from) {
    DribbleMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DribbleMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.DribbleMessage";
  }
  protected:
  explicit DribbleMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kQueueCountFieldNumber = 2,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* target_point);
  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();
  public:
  void unsafe_arena_set_allocated_target_point(
      ::protos::Vector2D* target_point);
  ::protos::Vector2D* unsafe_arena_release_target_point();
  // int32 queue_count = 2;
  void clear_queue_count() ;
  ::int32_t queue_count() const;
  void set_queue_count(::int32_t value);

  private:
  ::int32_t _internal_queue_count() const;
  void _internal_set_queue_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.DribbleMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    ::int32_t queue_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class BallGoalieMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.BallGoalieMessage) */ {
 public:
  inline BallGoalieMessage() : BallGoalieMessage(nullptr) {}
  ~BallGoalieMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BallGoalieMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BallGoalieMessage(const BallGoalieMessage& from);
  BallGoalieMessage(BallGoalieMessage&& from) noexcept
    : BallGoalieMessage() {
    *this = ::std::move(from);
  }

  inline BallGoalieMessage& operator=(const BallGoalieMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BallGoalieMessage& operator=(BallGoalieMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BallGoalieMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BallGoalieMessage* internal_default_instance() {
    return reinterpret_cast<const BallGoalieMessage*>(
               &_BallGoalieMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(BallGoalieMessage& a, BallGoalieMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BallGoalieMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BallGoalieMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BallGoalieMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BallGoalieMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BallGoalieMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BallGoalieMessage& from) {
    BallGoalieMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BallGoalieMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.BallGoalieMessage";
  }
  protected:
  explicit BallGoalieMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBallPositionFieldNumber = 1,
    kBallVelocityFieldNumber = 2,
    kGoaliePositionFieldNumber = 3,
    kGoalieBodyDirectionFieldNumber = 4,
  };
  // .protos.Vector2D ball_position = 1;
  bool has_ball_position() const;
  void clear_ball_position() ;
  const ::protos::Vector2D& ball_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_ball_position();
  ::protos::Vector2D* mutable_ball_position();
  void set_allocated_ball_position(::protos::Vector2D* ball_position);
  private:
  const ::protos::Vector2D& _internal_ball_position() const;
  ::protos::Vector2D* _internal_mutable_ball_position();
  public:
  void unsafe_arena_set_allocated_ball_position(
      ::protos::Vector2D* ball_position);
  ::protos::Vector2D* unsafe_arena_release_ball_position();
  // .protos.Vector2D ball_velocity = 2;
  bool has_ball_velocity() const;
  void clear_ball_velocity() ;
  const ::protos::Vector2D& ball_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_ball_velocity();
  ::protos::Vector2D* mutable_ball_velocity();
  void set_allocated_ball_velocity(::protos::Vector2D* ball_velocity);
  private:
  const ::protos::Vector2D& _internal_ball_velocity() const;
  ::protos::Vector2D* _internal_mutable_ball_velocity();
  public:
  void unsafe_arena_set_allocated_ball_velocity(
      ::protos::Vector2D* ball_velocity);
  ::protos::Vector2D* unsafe_arena_release_ball_velocity();
  // .protos.Vector2D goalie_position = 3;
  bool has_goalie_position() const;
  void clear_goalie_position() ;
  const ::protos::Vector2D& goalie_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_goalie_position();
  ::protos::Vector2D* mutable_goalie_position();
  void set_allocated_goalie_position(::protos::Vector2D* goalie_position);
  private:
  const ::protos::Vector2D& _internal_goalie_position() const;
  ::protos::Vector2D* _internal_mutable_goalie_position();
  public:
  void unsafe_arena_set_allocated_goalie_position(
      ::protos::Vector2D* goalie_position);
  ::protos::Vector2D* unsafe_arena_release_goalie_position();
  // float goalie_body_direction = 4;
  void clear_goalie_body_direction() ;
  float goalie_body_direction() const;
  void set_goalie_body_direction(float value);

  private:
  float _internal_goalie_body_direction() const;
  void _internal_set_goalie_body_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.BallGoalieMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* ball_position_;
    ::protos::Vector2D* ball_velocity_;
    ::protos::Vector2D* goalie_position_;
    float goalie_body_direction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class OnePlayerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.OnePlayerMessage) */ {
 public:
  inline OnePlayerMessage() : OnePlayerMessage(nullptr) {}
  ~OnePlayerMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OnePlayerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnePlayerMessage(const OnePlayerMessage& from);
  OnePlayerMessage(OnePlayerMessage&& from) noexcept
    : OnePlayerMessage() {
    *this = ::std::move(from);
  }

  inline OnePlayerMessage& operator=(const OnePlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnePlayerMessage& operator=(OnePlayerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnePlayerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnePlayerMessage* internal_default_instance() {
    return reinterpret_cast<const OnePlayerMessage*>(
               &_OnePlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(OnePlayerMessage& a, OnePlayerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OnePlayerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnePlayerMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnePlayerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnePlayerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OnePlayerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OnePlayerMessage& from) {
    OnePlayerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OnePlayerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.OnePlayerMessage";
  }
  protected:
  explicit OnePlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kUniformNumberFieldNumber = 1,
  };
  // .protos.Vector2D position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* position);
  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protos::Vector2D* position);
  ::protos::Vector2D* unsafe_arena_release_position();
  // int32 uniform_number = 1;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.OnePlayerMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    ::int32_t uniform_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class TwoPlayerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.TwoPlayerMessage) */ {
 public:
  inline TwoPlayerMessage() : TwoPlayerMessage(nullptr) {}
  ~TwoPlayerMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TwoPlayerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TwoPlayerMessage(const TwoPlayerMessage& from);
  TwoPlayerMessage(TwoPlayerMessage&& from) noexcept
    : TwoPlayerMessage() {
    *this = ::std::move(from);
  }

  inline TwoPlayerMessage& operator=(const TwoPlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TwoPlayerMessage& operator=(TwoPlayerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TwoPlayerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TwoPlayerMessage* internal_default_instance() {
    return reinterpret_cast<const TwoPlayerMessage*>(
               &_TwoPlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(TwoPlayerMessage& a, TwoPlayerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TwoPlayerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TwoPlayerMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TwoPlayerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TwoPlayerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TwoPlayerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TwoPlayerMessage& from) {
    TwoPlayerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TwoPlayerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.TwoPlayerMessage";
  }
  protected:
  explicit TwoPlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstPositionFieldNumber = 2,
    kSecondPositionFieldNumber = 4,
    kFirstUniformNumberFieldNumber = 1,
    kSecondUniformNumberFieldNumber = 3,
  };
  // .protos.Vector2D first_position = 2;
  bool has_first_position() const;
  void clear_first_position() ;
  const ::protos::Vector2D& first_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_first_position();
  ::protos::Vector2D* mutable_first_position();
  void set_allocated_first_position(::protos::Vector2D* first_position);
  private:
  const ::protos::Vector2D& _internal_first_position() const;
  ::protos::Vector2D* _internal_mutable_first_position();
  public:
  void unsafe_arena_set_allocated_first_position(
      ::protos::Vector2D* first_position);
  ::protos::Vector2D* unsafe_arena_release_first_position();
  // .protos.Vector2D second_position = 4;
  bool has_second_position() const;
  void clear_second_position() ;
  const ::protos::Vector2D& second_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_second_position();
  ::protos::Vector2D* mutable_second_position();
  void set_allocated_second_position(::protos::Vector2D* second_position);
  private:
  const ::protos::Vector2D& _internal_second_position() const;
  ::protos::Vector2D* _internal_mutable_second_position();
  public:
  void unsafe_arena_set_allocated_second_position(
      ::protos::Vector2D* second_position);
  ::protos::Vector2D* unsafe_arena_release_second_position();
  // int32 first_uniform_number = 1;
  void clear_first_uniform_number() ;
  ::int32_t first_uniform_number() const;
  void set_first_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_first_uniform_number() const;
  void _internal_set_first_uniform_number(::int32_t value);

  public:
  // int32 second_uniform_number = 3;
  void clear_second_uniform_number() ;
  ::int32_t second_uniform_number() const;
  void set_second_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_second_uniform_number() const;
  void _internal_set_second_uniform_number(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.TwoPlayerMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* first_position_;
    ::protos::Vector2D* second_position_;
    ::int32_t first_uniform_number_;
    ::int32_t second_uniform_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class ThreePlayerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.ThreePlayerMessage) */ {
 public:
  inline ThreePlayerMessage() : ThreePlayerMessage(nullptr) {}
  ~ThreePlayerMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ThreePlayerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThreePlayerMessage(const ThreePlayerMessage& from);
  ThreePlayerMessage(ThreePlayerMessage&& from) noexcept
    : ThreePlayerMessage() {
    *this = ::std::move(from);
  }

  inline ThreePlayerMessage& operator=(const ThreePlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreePlayerMessage& operator=(ThreePlayerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThreePlayerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThreePlayerMessage* internal_default_instance() {
    return reinterpret_cast<const ThreePlayerMessage*>(
               &_ThreePlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ThreePlayerMessage& a, ThreePlayerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ThreePlayerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreePlayerMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThreePlayerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThreePlayerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ThreePlayerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ThreePlayerMessage& from) {
    ThreePlayerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThreePlayerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.ThreePlayerMessage";
  }
  protected:
  explicit ThreePlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstPositionFieldNumber = 2,
    kSecondPositionFieldNumber = 4,
    kThirdPositionFieldNumber = 6,
    kFirstUniformNumberFieldNumber = 1,
    kSecondUniformNumberFieldNumber = 3,
    kThirdUniformNumberFieldNumber = 5,
  };
  // .protos.Vector2D first_position = 2;
  bool has_first_position() const;
  void clear_first_position() ;
  const ::protos::Vector2D& first_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_first_position();
  ::protos::Vector2D* mutable_first_position();
  void set_allocated_first_position(::protos::Vector2D* first_position);
  private:
  const ::protos::Vector2D& _internal_first_position() const;
  ::protos::Vector2D* _internal_mutable_first_position();
  public:
  void unsafe_arena_set_allocated_first_position(
      ::protos::Vector2D* first_position);
  ::protos::Vector2D* unsafe_arena_release_first_position();
  // .protos.Vector2D second_position = 4;
  bool has_second_position() const;
  void clear_second_position() ;
  const ::protos::Vector2D& second_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_second_position();
  ::protos::Vector2D* mutable_second_position();
  void set_allocated_second_position(::protos::Vector2D* second_position);
  private:
  const ::protos::Vector2D& _internal_second_position() const;
  ::protos::Vector2D* _internal_mutable_second_position();
  public:
  void unsafe_arena_set_allocated_second_position(
      ::protos::Vector2D* second_position);
  ::protos::Vector2D* unsafe_arena_release_second_position();
  // .protos.Vector2D third_position = 6;
  bool has_third_position() const;
  void clear_third_position() ;
  const ::protos::Vector2D& third_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_third_position();
  ::protos::Vector2D* mutable_third_position();
  void set_allocated_third_position(::protos::Vector2D* third_position);
  private:
  const ::protos::Vector2D& _internal_third_position() const;
  ::protos::Vector2D* _internal_mutable_third_position();
  public:
  void unsafe_arena_set_allocated_third_position(
      ::protos::Vector2D* third_position);
  ::protos::Vector2D* unsafe_arena_release_third_position();
  // int32 first_uniform_number = 1;
  void clear_first_uniform_number() ;
  ::int32_t first_uniform_number() const;
  void set_first_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_first_uniform_number() const;
  void _internal_set_first_uniform_number(::int32_t value);

  public:
  // int32 second_uniform_number = 3;
  void clear_second_uniform_number() ;
  ::int32_t second_uniform_number() const;
  void set_second_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_second_uniform_number() const;
  void _internal_set_second_uniform_number(::int32_t value);

  public:
  // int32 third_uniform_number = 5;
  void clear_third_uniform_number() ;
  ::int32_t third_uniform_number() const;
  void set_third_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_third_uniform_number() const;
  void _internal_set_third_uniform_number(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.ThreePlayerMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* first_position_;
    ::protos::Vector2D* second_position_;
    ::protos::Vector2D* third_position_;
    ::int32_t first_uniform_number_;
    ::int32_t second_uniform_number_;
    ::int32_t third_uniform_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class SelfMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.SelfMessage) */ {
 public:
  inline SelfMessage() : SelfMessage(nullptr) {}
  ~SelfMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SelfMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelfMessage(const SelfMessage& from);
  SelfMessage(SelfMessage&& from) noexcept
    : SelfMessage() {
    *this = ::std::move(from);
  }

  inline SelfMessage& operator=(const SelfMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelfMessage& operator=(SelfMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelfMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelfMessage* internal_default_instance() {
    return reinterpret_cast<const SelfMessage*>(
               &_SelfMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(SelfMessage& a, SelfMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SelfMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelfMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelfMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelfMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelfMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelfMessage& from) {
    SelfMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelfMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.SelfMessage";
  }
  protected:
  explicit SelfMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelfPositionFieldNumber = 1,
    kSelfBodyDirectionFieldNumber = 2,
    kSelfStaminaFieldNumber = 3,
  };
  // .protos.Vector2D self_position = 1;
  bool has_self_position() const;
  void clear_self_position() ;
  const ::protos::Vector2D& self_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_self_position();
  ::protos::Vector2D* mutable_self_position();
  void set_allocated_self_position(::protos::Vector2D* self_position);
  private:
  const ::protos::Vector2D& _internal_self_position() const;
  ::protos::Vector2D* _internal_mutable_self_position();
  public:
  void unsafe_arena_set_allocated_self_position(
      ::protos::Vector2D* self_position);
  ::protos::Vector2D* unsafe_arena_release_self_position();
  // float self_body_direction = 2;
  void clear_self_body_direction() ;
  float self_body_direction() const;
  void set_self_body_direction(float value);

  private:
  float _internal_self_body_direction() const;
  void _internal_set_self_body_direction(float value);

  public:
  // float self_stamina = 3;
  void clear_self_stamina() ;
  float self_stamina() const;
  void set_self_stamina(float value);

  private:
  float _internal_self_stamina() const;
  void _internal_set_self_stamina(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.SelfMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* self_position_;
    float self_body_direction_;
    float self_stamina_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class TeammateMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.TeammateMessage) */ {
 public:
  inline TeammateMessage() : TeammateMessage(nullptr) {}
  ~TeammateMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TeammateMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TeammateMessage(const TeammateMessage& from);
  TeammateMessage(TeammateMessage&& from) noexcept
    : TeammateMessage() {
    *this = ::std::move(from);
  }

  inline TeammateMessage& operator=(const TeammateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeammateMessage& operator=(TeammateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TeammateMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TeammateMessage* internal_default_instance() {
    return reinterpret_cast<const TeammateMessage*>(
               &_TeammateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(TeammateMessage& a, TeammateMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TeammateMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TeammateMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TeammateMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TeammateMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TeammateMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TeammateMessage& from) {
    TeammateMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeammateMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.TeammateMessage";
  }
  protected:
  explicit TeammateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kUniformNumberFieldNumber = 1,
    kBodyDirectionFieldNumber = 3,
  };
  // .protos.Vector2D position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* position);
  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protos::Vector2D* position);
  ::protos::Vector2D* unsafe_arena_release_position();
  // int32 uniform_number = 1;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // float body_direction = 3;
  void clear_body_direction() ;
  float body_direction() const;
  void set_body_direction(float value);

  private:
  float _internal_body_direction() const;
  void _internal_set_body_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.TeammateMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    ::int32_t uniform_number_;
    float body_direction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class OpponentMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.OpponentMessage) */ {
 public:
  inline OpponentMessage() : OpponentMessage(nullptr) {}
  ~OpponentMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OpponentMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpponentMessage(const OpponentMessage& from);
  OpponentMessage(OpponentMessage&& from) noexcept
    : OpponentMessage() {
    *this = ::std::move(from);
  }

  inline OpponentMessage& operator=(const OpponentMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpponentMessage& operator=(OpponentMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpponentMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpponentMessage* internal_default_instance() {
    return reinterpret_cast<const OpponentMessage*>(
               &_OpponentMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(OpponentMessage& a, OpponentMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OpponentMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpponentMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpponentMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpponentMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpponentMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpponentMessage& from) {
    OpponentMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpponentMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.OpponentMessage";
  }
  protected:
  explicit OpponentMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kUniformNumberFieldNumber = 1,
    kBodyDirectionFieldNumber = 3,
  };
  // .protos.Vector2D position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* position);
  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protos::Vector2D* position);
  ::protos::Vector2D* unsafe_arena_release_position();
  // int32 uniform_number = 1;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // float body_direction = 3;
  void clear_body_direction() ;
  float body_direction() const;
  void set_body_direction(float value);

  private:
  float _internal_body_direction() const;
  void _internal_set_body_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.OpponentMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    ::int32_t uniform_number_;
    float body_direction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class BallPlayerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.BallPlayerMessage) */ {
 public:
  inline BallPlayerMessage() : BallPlayerMessage(nullptr) {}
  ~BallPlayerMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BallPlayerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BallPlayerMessage(const BallPlayerMessage& from);
  BallPlayerMessage(BallPlayerMessage&& from) noexcept
    : BallPlayerMessage() {
    *this = ::std::move(from);
  }

  inline BallPlayerMessage& operator=(const BallPlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BallPlayerMessage& operator=(BallPlayerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BallPlayerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BallPlayerMessage* internal_default_instance() {
    return reinterpret_cast<const BallPlayerMessage*>(
               &_BallPlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(BallPlayerMessage& a, BallPlayerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BallPlayerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BallPlayerMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BallPlayerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BallPlayerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BallPlayerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BallPlayerMessage& from) {
    BallPlayerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BallPlayerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.BallPlayerMessage";
  }
  protected:
  explicit BallPlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBallPositionFieldNumber = 1,
    kBallVelocityFieldNumber = 2,
    kPlayerPositionFieldNumber = 4,
    kUniformNumberFieldNumber = 3,
    kBodyDirectionFieldNumber = 5,
  };
  // .protos.Vector2D ball_position = 1;
  bool has_ball_position() const;
  void clear_ball_position() ;
  const ::protos::Vector2D& ball_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_ball_position();
  ::protos::Vector2D* mutable_ball_position();
  void set_allocated_ball_position(::protos::Vector2D* ball_position);
  private:
  const ::protos::Vector2D& _internal_ball_position() const;
  ::protos::Vector2D* _internal_mutable_ball_position();
  public:
  void unsafe_arena_set_allocated_ball_position(
      ::protos::Vector2D* ball_position);
  ::protos::Vector2D* unsafe_arena_release_ball_position();
  // .protos.Vector2D ball_velocity = 2;
  bool has_ball_velocity() const;
  void clear_ball_velocity() ;
  const ::protos::Vector2D& ball_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_ball_velocity();
  ::protos::Vector2D* mutable_ball_velocity();
  void set_allocated_ball_velocity(::protos::Vector2D* ball_velocity);
  private:
  const ::protos::Vector2D& _internal_ball_velocity() const;
  ::protos::Vector2D* _internal_mutable_ball_velocity();
  public:
  void unsafe_arena_set_allocated_ball_velocity(
      ::protos::Vector2D* ball_velocity);
  ::protos::Vector2D* unsafe_arena_release_ball_velocity();
  // .protos.Vector2D player_position = 4;
  bool has_player_position() const;
  void clear_player_position() ;
  const ::protos::Vector2D& player_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_player_position();
  ::protos::Vector2D* mutable_player_position();
  void set_allocated_player_position(::protos::Vector2D* player_position);
  private:
  const ::protos::Vector2D& _internal_player_position() const;
  ::protos::Vector2D* _internal_mutable_player_position();
  public:
  void unsafe_arena_set_allocated_player_position(
      ::protos::Vector2D* player_position);
  ::protos::Vector2D* unsafe_arena_release_player_position();
  // int32 uniform_number = 3;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // float body_direction = 5;
  void clear_body_direction() ;
  float body_direction() const;
  void set_body_direction(float value);

  private:
  float _internal_body_direction() const;
  void _internal_set_body_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.BallPlayerMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* ball_position_;
    ::protos::Vector2D* ball_velocity_;
    ::protos::Vector2D* player_position_;
    ::int32_t uniform_number_;
    float body_direction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Say final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Say) */ {
 public:
  inline Say() : Say(nullptr) {}
  ~Say() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Say(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Say(const Say& from);
  Say(Say&& from) noexcept
    : Say() {
    *this = ::std::move(from);
  }

  inline Say& operator=(const Say& from) {
    CopyFrom(from);
    return *this;
  }
  inline Say& operator=(Say&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Say& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kBallMessage = 1,
    kPassMessage = 2,
    kInterceptMessage = 3,
    kGoalieMessage = 4,
    kGoalieAndPlayerMessage = 5,
    kOffsideLineMessage = 6,
    kDefenseLineMessage = 7,
    kWaitRequestMessage = 8,
    kSetplayMessage = 9,
    kPassRequestMessage = 10,
    kStaminaMessage = 11,
    kRecoveryMessage = 12,
    kStaminaCapacityMessage = 13,
    kDribbleMessage = 14,
    kBallGoalieMessage = 15,
    kOnePlayerMessage = 16,
    kTwoPlayerMessage = 17,
    kThreePlayerMessage = 18,
    kSelfMessage = 19,
    kTeammateMessage = 20,
    kOpponentMessage = 21,
    kBallPlayerMessage = 22,
    MESSAGE_NOT_SET = 0,
  };

  static inline const Say* internal_default_instance() {
    return reinterpret_cast<const Say*>(
               &_Say_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(Say& a, Say& b) {
    a.Swap(&b);
  }
  inline void Swap(Say* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Say* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Say* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Say>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Say& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Say& from) {
    Say::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Say* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Say";
  }
  protected:
  explicit Say(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBallMessageFieldNumber = 1,
    kPassMessageFieldNumber = 2,
    kInterceptMessageFieldNumber = 3,
    kGoalieMessageFieldNumber = 4,
    kGoalieAndPlayerMessageFieldNumber = 5,
    kOffsideLineMessageFieldNumber = 6,
    kDefenseLineMessageFieldNumber = 7,
    kWaitRequestMessageFieldNumber = 8,
    kSetplayMessageFieldNumber = 9,
    kPassRequestMessageFieldNumber = 10,
    kStaminaMessageFieldNumber = 11,
    kRecoveryMessageFieldNumber = 12,
    kStaminaCapacityMessageFieldNumber = 13,
    kDribbleMessageFieldNumber = 14,
    kBallGoalieMessageFieldNumber = 15,
    kOnePlayerMessageFieldNumber = 16,
    kTwoPlayerMessageFieldNumber = 17,
    kThreePlayerMessageFieldNumber = 18,
    kSelfMessageFieldNumber = 19,
    kTeammateMessageFieldNumber = 20,
    kOpponentMessageFieldNumber = 21,
    kBallPlayerMessageFieldNumber = 22,
  };
  // .protos.BallMessage ball_message = 1;
  bool has_ball_message() const;
  private:
  bool _internal_has_ball_message() const;

  public:
  void clear_ball_message() ;
  const ::protos::BallMessage& ball_message() const;
  PROTOBUF_NODISCARD ::protos::BallMessage* release_ball_message();
  ::protos::BallMessage* mutable_ball_message();
  void set_allocated_ball_message(::protos::BallMessage* ball_message);
  private:
  const ::protos::BallMessage& _internal_ball_message() const;
  ::protos::BallMessage* _internal_mutable_ball_message();
  public:
  void unsafe_arena_set_allocated_ball_message(
      ::protos::BallMessage* ball_message);
  ::protos::BallMessage* unsafe_arena_release_ball_message();
  // .protos.PassMessage pass_message = 2;
  bool has_pass_message() const;
  private:
  bool _internal_has_pass_message() const;

  public:
  void clear_pass_message() ;
  const ::protos::PassMessage& pass_message() const;
  PROTOBUF_NODISCARD ::protos::PassMessage* release_pass_message();
  ::protos::PassMessage* mutable_pass_message();
  void set_allocated_pass_message(::protos::PassMessage* pass_message);
  private:
  const ::protos::PassMessage& _internal_pass_message() const;
  ::protos::PassMessage* _internal_mutable_pass_message();
  public:
  void unsafe_arena_set_allocated_pass_message(
      ::protos::PassMessage* pass_message);
  ::protos::PassMessage* unsafe_arena_release_pass_message();
  // .protos.InterceptMessage intercept_message = 3;
  bool has_intercept_message() const;
  private:
  bool _internal_has_intercept_message() const;

  public:
  void clear_intercept_message() ;
  const ::protos::InterceptMessage& intercept_message() const;
  PROTOBUF_NODISCARD ::protos::InterceptMessage* release_intercept_message();
  ::protos::InterceptMessage* mutable_intercept_message();
  void set_allocated_intercept_message(::protos::InterceptMessage* intercept_message);
  private:
  const ::protos::InterceptMessage& _internal_intercept_message() const;
  ::protos::InterceptMessage* _internal_mutable_intercept_message();
  public:
  void unsafe_arena_set_allocated_intercept_message(
      ::protos::InterceptMessage* intercept_message);
  ::protos::InterceptMessage* unsafe_arena_release_intercept_message();
  // .protos.GoalieMessage goalie_message = 4;
  bool has_goalie_message() const;
  private:
  bool _internal_has_goalie_message() const;

  public:
  void clear_goalie_message() ;
  const ::protos::GoalieMessage& goalie_message() const;
  PROTOBUF_NODISCARD ::protos::GoalieMessage* release_goalie_message();
  ::protos::GoalieMessage* mutable_goalie_message();
  void set_allocated_goalie_message(::protos::GoalieMessage* goalie_message);
  private:
  const ::protos::GoalieMessage& _internal_goalie_message() const;
  ::protos::GoalieMessage* _internal_mutable_goalie_message();
  public:
  void unsafe_arena_set_allocated_goalie_message(
      ::protos::GoalieMessage* goalie_message);
  ::protos::GoalieMessage* unsafe_arena_release_goalie_message();
  // .protos.GoalieAndPlayerMessage goalie_and_player_message = 5;
  bool has_goalie_and_player_message() const;
  private:
  bool _internal_has_goalie_and_player_message() const;

  public:
  void clear_goalie_and_player_message() ;
  const ::protos::GoalieAndPlayerMessage& goalie_and_player_message() const;
  PROTOBUF_NODISCARD ::protos::GoalieAndPlayerMessage* release_goalie_and_player_message();
  ::protos::GoalieAndPlayerMessage* mutable_goalie_and_player_message();
  void set_allocated_goalie_and_player_message(::protos::GoalieAndPlayerMessage* goalie_and_player_message);
  private:
  const ::protos::GoalieAndPlayerMessage& _internal_goalie_and_player_message() const;
  ::protos::GoalieAndPlayerMessage* _internal_mutable_goalie_and_player_message();
  public:
  void unsafe_arena_set_allocated_goalie_and_player_message(
      ::protos::GoalieAndPlayerMessage* goalie_and_player_message);
  ::protos::GoalieAndPlayerMessage* unsafe_arena_release_goalie_and_player_message();
  // .protos.OffsideLineMessage offside_line_message = 6;
  bool has_offside_line_message() const;
  private:
  bool _internal_has_offside_line_message() const;

  public:
  void clear_offside_line_message() ;
  const ::protos::OffsideLineMessage& offside_line_message() const;
  PROTOBUF_NODISCARD ::protos::OffsideLineMessage* release_offside_line_message();
  ::protos::OffsideLineMessage* mutable_offside_line_message();
  void set_allocated_offside_line_message(::protos::OffsideLineMessage* offside_line_message);
  private:
  const ::protos::OffsideLineMessage& _internal_offside_line_message() const;
  ::protos::OffsideLineMessage* _internal_mutable_offside_line_message();
  public:
  void unsafe_arena_set_allocated_offside_line_message(
      ::protos::OffsideLineMessage* offside_line_message);
  ::protos::OffsideLineMessage* unsafe_arena_release_offside_line_message();
  // .protos.DefenseLineMessage defense_line_message = 7;
  bool has_defense_line_message() const;
  private:
  bool _internal_has_defense_line_message() const;

  public:
  void clear_defense_line_message() ;
  const ::protos::DefenseLineMessage& defense_line_message() const;
  PROTOBUF_NODISCARD ::protos::DefenseLineMessage* release_defense_line_message();
  ::protos::DefenseLineMessage* mutable_defense_line_message();
  void set_allocated_defense_line_message(::protos::DefenseLineMessage* defense_line_message);
  private:
  const ::protos::DefenseLineMessage& _internal_defense_line_message() const;
  ::protos::DefenseLineMessage* _internal_mutable_defense_line_message();
  public:
  void unsafe_arena_set_allocated_defense_line_message(
      ::protos::DefenseLineMessage* defense_line_message);
  ::protos::DefenseLineMessage* unsafe_arena_release_defense_line_message();
  // .protos.WaitRequestMessage wait_request_message = 8;
  bool has_wait_request_message() const;
  private:
  bool _internal_has_wait_request_message() const;

  public:
  void clear_wait_request_message() ;
  const ::protos::WaitRequestMessage& wait_request_message() const;
  PROTOBUF_NODISCARD ::protos::WaitRequestMessage* release_wait_request_message();
  ::protos::WaitRequestMessage* mutable_wait_request_message();
  void set_allocated_wait_request_message(::protos::WaitRequestMessage* wait_request_message);
  private:
  const ::protos::WaitRequestMessage& _internal_wait_request_message() const;
  ::protos::WaitRequestMessage* _internal_mutable_wait_request_message();
  public:
  void unsafe_arena_set_allocated_wait_request_message(
      ::protos::WaitRequestMessage* wait_request_message);
  ::protos::WaitRequestMessage* unsafe_arena_release_wait_request_message();
  // .protos.SetplayMessage setplay_message = 9;
  bool has_setplay_message() const;
  private:
  bool _internal_has_setplay_message() const;

  public:
  void clear_setplay_message() ;
  const ::protos::SetplayMessage& setplay_message() const;
  PROTOBUF_NODISCARD ::protos::SetplayMessage* release_setplay_message();
  ::protos::SetplayMessage* mutable_setplay_message();
  void set_allocated_setplay_message(::protos::SetplayMessage* setplay_message);
  private:
  const ::protos::SetplayMessage& _internal_setplay_message() const;
  ::protos::SetplayMessage* _internal_mutable_setplay_message();
  public:
  void unsafe_arena_set_allocated_setplay_message(
      ::protos::SetplayMessage* setplay_message);
  ::protos::SetplayMessage* unsafe_arena_release_setplay_message();
  // .protos.PassRequestMessage pass_request_message = 10;
  bool has_pass_request_message() const;
  private:
  bool _internal_has_pass_request_message() const;

  public:
  void clear_pass_request_message() ;
  const ::protos::PassRequestMessage& pass_request_message() const;
  PROTOBUF_NODISCARD ::protos::PassRequestMessage* release_pass_request_message();
  ::protos::PassRequestMessage* mutable_pass_request_message();
  void set_allocated_pass_request_message(::protos::PassRequestMessage* pass_request_message);
  private:
  const ::protos::PassRequestMessage& _internal_pass_request_message() const;
  ::protos::PassRequestMessage* _internal_mutable_pass_request_message();
  public:
  void unsafe_arena_set_allocated_pass_request_message(
      ::protos::PassRequestMessage* pass_request_message);
  ::protos::PassRequestMessage* unsafe_arena_release_pass_request_message();
  // .protos.StaminaMessage stamina_message = 11;
  bool has_stamina_message() const;
  private:
  bool _internal_has_stamina_message() const;

  public:
  void clear_stamina_message() ;
  const ::protos::StaminaMessage& stamina_message() const;
  PROTOBUF_NODISCARD ::protos::StaminaMessage* release_stamina_message();
  ::protos::StaminaMessage* mutable_stamina_message();
  void set_allocated_stamina_message(::protos::StaminaMessage* stamina_message);
  private:
  const ::protos::StaminaMessage& _internal_stamina_message() const;
  ::protos::StaminaMessage* _internal_mutable_stamina_message();
  public:
  void unsafe_arena_set_allocated_stamina_message(
      ::protos::StaminaMessage* stamina_message);
  ::protos::StaminaMessage* unsafe_arena_release_stamina_message();
  // .protos.RecoveryMessage recovery_message = 12;
  bool has_recovery_message() const;
  private:
  bool _internal_has_recovery_message() const;

  public:
  void clear_recovery_message() ;
  const ::protos::RecoveryMessage& recovery_message() const;
  PROTOBUF_NODISCARD ::protos::RecoveryMessage* release_recovery_message();
  ::protos::RecoveryMessage* mutable_recovery_message();
  void set_allocated_recovery_message(::protos::RecoveryMessage* recovery_message);
  private:
  const ::protos::RecoveryMessage& _internal_recovery_message() const;
  ::protos::RecoveryMessage* _internal_mutable_recovery_message();
  public:
  void unsafe_arena_set_allocated_recovery_message(
      ::protos::RecoveryMessage* recovery_message);
  ::protos::RecoveryMessage* unsafe_arena_release_recovery_message();
  // .protos.StaminaCapacityMessage stamina_capacity_message = 13;
  bool has_stamina_capacity_message() const;
  private:
  bool _internal_has_stamina_capacity_message() const;

  public:
  void clear_stamina_capacity_message() ;
  const ::protos::StaminaCapacityMessage& stamina_capacity_message() const;
  PROTOBUF_NODISCARD ::protos::StaminaCapacityMessage* release_stamina_capacity_message();
  ::protos::StaminaCapacityMessage* mutable_stamina_capacity_message();
  void set_allocated_stamina_capacity_message(::protos::StaminaCapacityMessage* stamina_capacity_message);
  private:
  const ::protos::StaminaCapacityMessage& _internal_stamina_capacity_message() const;
  ::protos::StaminaCapacityMessage* _internal_mutable_stamina_capacity_message();
  public:
  void unsafe_arena_set_allocated_stamina_capacity_message(
      ::protos::StaminaCapacityMessage* stamina_capacity_message);
  ::protos::StaminaCapacityMessage* unsafe_arena_release_stamina_capacity_message();
  // .protos.DribbleMessage dribble_message = 14;
  bool has_dribble_message() const;
  private:
  bool _internal_has_dribble_message() const;

  public:
  void clear_dribble_message() ;
  const ::protos::DribbleMessage& dribble_message() const;
  PROTOBUF_NODISCARD ::protos::DribbleMessage* release_dribble_message();
  ::protos::DribbleMessage* mutable_dribble_message();
  void set_allocated_dribble_message(::protos::DribbleMessage* dribble_message);
  private:
  const ::protos::DribbleMessage& _internal_dribble_message() const;
  ::protos::DribbleMessage* _internal_mutable_dribble_message();
  public:
  void unsafe_arena_set_allocated_dribble_message(
      ::protos::DribbleMessage* dribble_message);
  ::protos::DribbleMessage* unsafe_arena_release_dribble_message();
  // .protos.BallGoalieMessage ball_goalie_message = 15;
  bool has_ball_goalie_message() const;
  private:
  bool _internal_has_ball_goalie_message() const;

  public:
  void clear_ball_goalie_message() ;
  const ::protos::BallGoalieMessage& ball_goalie_message() const;
  PROTOBUF_NODISCARD ::protos::BallGoalieMessage* release_ball_goalie_message();
  ::protos::BallGoalieMessage* mutable_ball_goalie_message();
  void set_allocated_ball_goalie_message(::protos::BallGoalieMessage* ball_goalie_message);
  private:
  const ::protos::BallGoalieMessage& _internal_ball_goalie_message() const;
  ::protos::BallGoalieMessage* _internal_mutable_ball_goalie_message();
  public:
  void unsafe_arena_set_allocated_ball_goalie_message(
      ::protos::BallGoalieMessage* ball_goalie_message);
  ::protos::BallGoalieMessage* unsafe_arena_release_ball_goalie_message();
  // .protos.OnePlayerMessage one_player_message = 16;
  bool has_one_player_message() const;
  private:
  bool _internal_has_one_player_message() const;

  public:
  void clear_one_player_message() ;
  const ::protos::OnePlayerMessage& one_player_message() const;
  PROTOBUF_NODISCARD ::protos::OnePlayerMessage* release_one_player_message();
  ::protos::OnePlayerMessage* mutable_one_player_message();
  void set_allocated_one_player_message(::protos::OnePlayerMessage* one_player_message);
  private:
  const ::protos::OnePlayerMessage& _internal_one_player_message() const;
  ::protos::OnePlayerMessage* _internal_mutable_one_player_message();
  public:
  void unsafe_arena_set_allocated_one_player_message(
      ::protos::OnePlayerMessage* one_player_message);
  ::protos::OnePlayerMessage* unsafe_arena_release_one_player_message();
  // .protos.TwoPlayerMessage two_player_message = 17;
  bool has_two_player_message() const;
  private:
  bool _internal_has_two_player_message() const;

  public:
  void clear_two_player_message() ;
  const ::protos::TwoPlayerMessage& two_player_message() const;
  PROTOBUF_NODISCARD ::protos::TwoPlayerMessage* release_two_player_message();
  ::protos::TwoPlayerMessage* mutable_two_player_message();
  void set_allocated_two_player_message(::protos::TwoPlayerMessage* two_player_message);
  private:
  const ::protos::TwoPlayerMessage& _internal_two_player_message() const;
  ::protos::TwoPlayerMessage* _internal_mutable_two_player_message();
  public:
  void unsafe_arena_set_allocated_two_player_message(
      ::protos::TwoPlayerMessage* two_player_message);
  ::protos::TwoPlayerMessage* unsafe_arena_release_two_player_message();
  // .protos.ThreePlayerMessage three_player_message = 18;
  bool has_three_player_message() const;
  private:
  bool _internal_has_three_player_message() const;

  public:
  void clear_three_player_message() ;
  const ::protos::ThreePlayerMessage& three_player_message() const;
  PROTOBUF_NODISCARD ::protos::ThreePlayerMessage* release_three_player_message();
  ::protos::ThreePlayerMessage* mutable_three_player_message();
  void set_allocated_three_player_message(::protos::ThreePlayerMessage* three_player_message);
  private:
  const ::protos::ThreePlayerMessage& _internal_three_player_message() const;
  ::protos::ThreePlayerMessage* _internal_mutable_three_player_message();
  public:
  void unsafe_arena_set_allocated_three_player_message(
      ::protos::ThreePlayerMessage* three_player_message);
  ::protos::ThreePlayerMessage* unsafe_arena_release_three_player_message();
  // .protos.SelfMessage self_message = 19;
  bool has_self_message() const;
  private:
  bool _internal_has_self_message() const;

  public:
  void clear_self_message() ;
  const ::protos::SelfMessage& self_message() const;
  PROTOBUF_NODISCARD ::protos::SelfMessage* release_self_message();
  ::protos::SelfMessage* mutable_self_message();
  void set_allocated_self_message(::protos::SelfMessage* self_message);
  private:
  const ::protos::SelfMessage& _internal_self_message() const;
  ::protos::SelfMessage* _internal_mutable_self_message();
  public:
  void unsafe_arena_set_allocated_self_message(
      ::protos::SelfMessage* self_message);
  ::protos::SelfMessage* unsafe_arena_release_self_message();
  // .protos.TeammateMessage teammate_message = 20;
  bool has_teammate_message() const;
  private:
  bool _internal_has_teammate_message() const;

  public:
  void clear_teammate_message() ;
  const ::protos::TeammateMessage& teammate_message() const;
  PROTOBUF_NODISCARD ::protos::TeammateMessage* release_teammate_message();
  ::protos::TeammateMessage* mutable_teammate_message();
  void set_allocated_teammate_message(::protos::TeammateMessage* teammate_message);
  private:
  const ::protos::TeammateMessage& _internal_teammate_message() const;
  ::protos::TeammateMessage* _internal_mutable_teammate_message();
  public:
  void unsafe_arena_set_allocated_teammate_message(
      ::protos::TeammateMessage* teammate_message);
  ::protos::TeammateMessage* unsafe_arena_release_teammate_message();
  // .protos.OpponentMessage opponent_message = 21;
  bool has_opponent_message() const;
  private:
  bool _internal_has_opponent_message() const;

  public:
  void clear_opponent_message() ;
  const ::protos::OpponentMessage& opponent_message() const;
  PROTOBUF_NODISCARD ::protos::OpponentMessage* release_opponent_message();
  ::protos::OpponentMessage* mutable_opponent_message();
  void set_allocated_opponent_message(::protos::OpponentMessage* opponent_message);
  private:
  const ::protos::OpponentMessage& _internal_opponent_message() const;
  ::protos::OpponentMessage* _internal_mutable_opponent_message();
  public:
  void unsafe_arena_set_allocated_opponent_message(
      ::protos::OpponentMessage* opponent_message);
  ::protos::OpponentMessage* unsafe_arena_release_opponent_message();
  // .protos.BallPlayerMessage ball_player_message = 22;
  bool has_ball_player_message() const;
  private:
  bool _internal_has_ball_player_message() const;

  public:
  void clear_ball_player_message() ;
  const ::protos::BallPlayerMessage& ball_player_message() const;
  PROTOBUF_NODISCARD ::protos::BallPlayerMessage* release_ball_player_message();
  ::protos::BallPlayerMessage* mutable_ball_player_message();
  void set_allocated_ball_player_message(::protos::BallPlayerMessage* ball_player_message);
  private:
  const ::protos::BallPlayerMessage& _internal_ball_player_message() const;
  ::protos::BallPlayerMessage* _internal_mutable_ball_player_message();
  public:
  void unsafe_arena_set_allocated_ball_player_message(
      ::protos::BallPlayerMessage* ball_player_message);
  ::protos::BallPlayerMessage* unsafe_arena_release_ball_player_message();
  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:protos.Say)
 private:
  class _Internal;
  void set_has_ball_message();
  void set_has_pass_message();
  void set_has_intercept_message();
  void set_has_goalie_message();
  void set_has_goalie_and_player_message();
  void set_has_offside_line_message();
  void set_has_defense_line_message();
  void set_has_wait_request_message();
  void set_has_setplay_message();
  void set_has_pass_request_message();
  void set_has_stamina_message();
  void set_has_recovery_message();
  void set_has_stamina_capacity_message();
  void set_has_dribble_message();
  void set_has_ball_goalie_message();
  void set_has_one_player_message();
  void set_has_two_player_message();
  void set_has_three_player_message();
  void set_has_self_message();
  void set_has_teammate_message();
  void set_has_opponent_message();
  void set_has_ball_player_message();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::protos::BallMessage* ball_message_;
      ::protos::PassMessage* pass_message_;
      ::protos::InterceptMessage* intercept_message_;
      ::protos::GoalieMessage* goalie_message_;
      ::protos::GoalieAndPlayerMessage* goalie_and_player_message_;
      ::protos::OffsideLineMessage* offside_line_message_;
      ::protos::DefenseLineMessage* defense_line_message_;
      ::protos::WaitRequestMessage* wait_request_message_;
      ::protos::SetplayMessage* setplay_message_;
      ::protos::PassRequestMessage* pass_request_message_;
      ::protos::StaminaMessage* stamina_message_;
      ::protos::RecoveryMessage* recovery_message_;
      ::protos::StaminaCapacityMessage* stamina_capacity_message_;
      ::protos::DribbleMessage* dribble_message_;
      ::protos::BallGoalieMessage* ball_goalie_message_;
      ::protos::OnePlayerMessage* one_player_message_;
      ::protos::TwoPlayerMessage* two_player_message_;
      ::protos::ThreePlayerMessage* three_player_message_;
      ::protos::SelfMessage* self_message_;
      ::protos::TeammateMessage* teammate_message_;
      ::protos::OpponentMessage* opponent_message_;
      ::protos::BallPlayerMessage* ball_player_message_;
    } message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class PointTo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.PointTo) */ {
 public:
  inline PointTo() : PointTo(nullptr) {}
  ~PointTo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PointTo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointTo(const PointTo& from);
  PointTo(PointTo&& from) noexcept
    : PointTo() {
    *this = ::std::move(from);
  }

  inline PointTo& operator=(const PointTo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointTo& operator=(PointTo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointTo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointTo* internal_default_instance() {
    return reinterpret_cast<const PointTo*>(
               &_PointTo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(PointTo& a, PointTo& b) {
    a.Swap(&b);
  }
  inline void Swap(PointTo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointTo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointTo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointTo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PointTo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PointTo& from) {
    PointTo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointTo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.PointTo";
  }
  protected:
  explicit PointTo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.PointTo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class PointToOf final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.PointToOf) */ {
 public:
  inline PointToOf() : PointToOf(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PointToOf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointToOf(const PointToOf& from);
  PointToOf(PointToOf&& from) noexcept
    : PointToOf() {
    *this = ::std::move(from);
  }

  inline PointToOf& operator=(const PointToOf& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointToOf& operator=(PointToOf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointToOf& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointToOf* internal_default_instance() {
    return reinterpret_cast<const PointToOf*>(
               &_PointToOf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(PointToOf& a, PointToOf& b) {
    a.Swap(&b);
  }
  inline void Swap(PointToOf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointToOf* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointToOf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointToOf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PointToOf& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PointToOf& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.PointToOf";
  }
  protected:
  explicit PointToOf(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.PointToOf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AttentionTo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.AttentionTo) */ {
 public:
  inline AttentionTo() : AttentionTo(nullptr) {}
  ~AttentionTo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AttentionTo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttentionTo(const AttentionTo& from);
  AttentionTo(AttentionTo&& from) noexcept
    : AttentionTo() {
    *this = ::std::move(from);
  }

  inline AttentionTo& operator=(const AttentionTo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttentionTo& operator=(AttentionTo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttentionTo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttentionTo* internal_default_instance() {
    return reinterpret_cast<const AttentionTo*>(
               &_AttentionTo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(AttentionTo& a, AttentionTo& b) {
    a.Swap(&b);
  }
  inline void Swap(AttentionTo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttentionTo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttentionTo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttentionTo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AttentionTo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AttentionTo& from) {
    AttentionTo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttentionTo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AttentionTo";
  }
  protected:
  explicit AttentionTo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSideFieldNumber = 1,
    kUnumFieldNumber = 2,
  };
  // .protos.Side side = 1;
  void clear_side() ;
  ::protos::Side side() const;
  void set_side(::protos::Side value);

  private:
  ::protos::Side _internal_side() const;
  void _internal_set_side(::protos::Side value);

  public:
  // int32 unum = 2;
  void clear_unum() ;
  ::int32_t unum() const;
  void set_unum(::int32_t value);

  private:
  ::int32_t _internal_unum() const;
  void _internal_set_unum(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AttentionTo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int side_;
    ::int32_t unum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AttentionToOf final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.AttentionToOf) */ {
 public:
  inline AttentionToOf() : AttentionToOf(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AttentionToOf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttentionToOf(const AttentionToOf& from);
  AttentionToOf(AttentionToOf&& from) noexcept
    : AttentionToOf() {
    *this = ::std::move(from);
  }

  inline AttentionToOf& operator=(const AttentionToOf& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttentionToOf& operator=(AttentionToOf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttentionToOf& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttentionToOf* internal_default_instance() {
    return reinterpret_cast<const AttentionToOf*>(
               &_AttentionToOf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(AttentionToOf& a, AttentionToOf& b) {
    a.Swap(&b);
  }
  inline void Swap(AttentionToOf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttentionToOf* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttentionToOf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttentionToOf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AttentionToOf& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AttentionToOf& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AttentionToOf";
  }
  protected:
  explicit AttentionToOf(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.AttentionToOf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddText final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.AddText) */ {
 public:
  inline AddText() : AddText(nullptr) {}
  ~AddText() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddText(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddText(const AddText& from);
  AddText(AddText&& from) noexcept
    : AddText() {
    *this = ::std::move(from);
  }

  inline AddText& operator=(const AddText& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddText& operator=(AddText&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddText& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddText* internal_default_instance() {
    return reinterpret_cast<const AddText*>(
               &_AddText_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(AddText& a, AddText& b) {
    a.Swap(&b);
  }
  inline void Swap(AddText* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddText* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddText* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddText>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddText& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddText& from) {
    AddText::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddText* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddText";
  }
  protected:
  explicit AddText(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kLevelFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddText)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.AddPoint) */ {
 public:
  inline AddPoint() : AddPoint(nullptr) {}
  ~AddPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddPoint(const AddPoint& from);
  AddPoint(AddPoint&& from) noexcept
    : AddPoint() {
    *this = ::std::move(from);
  }

  inline AddPoint& operator=(const AddPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddPoint& operator=(AddPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddPoint* internal_default_instance() {
    return reinterpret_cast<const AddPoint*>(
               &_AddPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(AddPoint& a, AddPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(AddPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddPoint& from) {
    AddPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddPoint";
  }
  protected:
  explicit AddPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 3,
    kPointFieldNumber = 2,
    kLevelFieldNumber = 1,
  };
  // string color = 3;
  void clear_color() ;
  const std::string& color() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* ptr);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .protos.Vector2D point = 2;
  bool has_point() const;
  void clear_point() ;
  const ::protos::Vector2D& point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_point();
  ::protos::Vector2D* mutable_point();
  void set_allocated_point(::protos::Vector2D* point);
  private:
  const ::protos::Vector2D& _internal_point() const;
  ::protos::Vector2D* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::protos::Vector2D* point);
  ::protos::Vector2D* unsafe_arena_release_point();
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    ::protos::Vector2D* point_;
    int level_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddLine final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.AddLine) */ {
 public:
  inline AddLine() : AddLine(nullptr) {}
  ~AddLine() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddLine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddLine(const AddLine& from);
  AddLine(AddLine&& from) noexcept
    : AddLine() {
    *this = ::std::move(from);
  }

  inline AddLine& operator=(const AddLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddLine& operator=(AddLine&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddLine* internal_default_instance() {
    return reinterpret_cast<const AddLine*>(
               &_AddLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(AddLine& a, AddLine& b) {
    a.Swap(&b);
  }
  inline void Swap(AddLine* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddLine* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddLine>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddLine& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddLine& from) {
    AddLine::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddLine* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddLine";
  }
  protected:
  explicit AddLine(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 4,
    kStartFieldNumber = 2,
    kEndFieldNumber = 3,
    kLevelFieldNumber = 1,
  };
  // string color = 4;
  void clear_color() ;
  const std::string& color() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* ptr);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .protos.Vector2D start = 2;
  bool has_start() const;
  void clear_start() ;
  const ::protos::Vector2D& start() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_start();
  ::protos::Vector2D* mutable_start();
  void set_allocated_start(::protos::Vector2D* start);
  private:
  const ::protos::Vector2D& _internal_start() const;
  ::protos::Vector2D* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::protos::Vector2D* start);
  ::protos::Vector2D* unsafe_arena_release_start();
  // .protos.Vector2D end = 3;
  bool has_end() const;
  void clear_end() ;
  const ::protos::Vector2D& end() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_end();
  ::protos::Vector2D* mutable_end();
  void set_allocated_end(::protos::Vector2D* end);
  private:
  const ::protos::Vector2D& _internal_end() const;
  ::protos::Vector2D* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::protos::Vector2D* end);
  ::protos::Vector2D* unsafe_arena_release_end();
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddLine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    ::protos::Vector2D* start_;
    ::protos::Vector2D* end_;
    int level_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddArc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.AddArc) */ {
 public:
  inline AddArc() : AddArc(nullptr) {}
  ~AddArc() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddArc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddArc(const AddArc& from);
  AddArc(AddArc&& from) noexcept
    : AddArc() {
    *this = ::std::move(from);
  }

  inline AddArc& operator=(const AddArc& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddArc& operator=(AddArc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddArc& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddArc* internal_default_instance() {
    return reinterpret_cast<const AddArc*>(
               &_AddArc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(AddArc& a, AddArc& b) {
    a.Swap(&b);
  }
  inline void Swap(AddArc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddArc* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddArc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddArc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddArc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddArc& from) {
    AddArc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddArc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddArc";
  }
  protected:
  explicit AddArc(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 6,
    kCenterFieldNumber = 2,
    kLevelFieldNumber = 1,
    kRadiusFieldNumber = 3,
    kStartAngleFieldNumber = 4,
    kSpanAngelFieldNumber = 5,
  };
  // string color = 6;
  void clear_color() ;
  const std::string& color() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* ptr);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .protos.Vector2D center = 2;
  bool has_center() const;
  void clear_center() ;
  const ::protos::Vector2D& center() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_center();
  ::protos::Vector2D* mutable_center();
  void set_allocated_center(::protos::Vector2D* center);
  private:
  const ::protos::Vector2D& _internal_center() const;
  ::protos::Vector2D* _internal_mutable_center();
  public:
  void unsafe_arena_set_allocated_center(
      ::protos::Vector2D* center);
  ::protos::Vector2D* unsafe_arena_release_center();
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // float radius = 3;
  void clear_radius() ;
  float radius() const;
  void set_radius(float value);

  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);

  public:
  // float start_angle = 4;
  void clear_start_angle() ;
  float start_angle() const;
  void set_start_angle(float value);

  private:
  float _internal_start_angle() const;
  void _internal_set_start_angle(float value);

  public:
  // float span_angel = 5;
  void clear_span_angel() ;
  float span_angel() const;
  void set_span_angel(float value);

  private:
  float _internal_span_angel() const;
  void _internal_set_span_angel(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddArc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    ::protos::Vector2D* center_;
    int level_;
    float radius_;
    float start_angle_;
    float span_angel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddCircle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.AddCircle) */ {
 public:
  inline AddCircle() : AddCircle(nullptr) {}
  ~AddCircle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddCircle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddCircle(const AddCircle& from);
  AddCircle(AddCircle&& from) noexcept
    : AddCircle() {
    *this = ::std::move(from);
  }

  inline AddCircle& operator=(const AddCircle& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddCircle& operator=(AddCircle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddCircle& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddCircle* internal_default_instance() {
    return reinterpret_cast<const AddCircle*>(
               &_AddCircle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(AddCircle& a, AddCircle& b) {
    a.Swap(&b);
  }
  inline void Swap(AddCircle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddCircle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddCircle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddCircle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddCircle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddCircle& from) {
    AddCircle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddCircle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddCircle";
  }
  protected:
  explicit AddCircle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 4,
    kCenterFieldNumber = 2,
    kLevelFieldNumber = 1,
    kRadiusFieldNumber = 3,
    kFillFieldNumber = 5,
  };
  // string color = 4;
  void clear_color() ;
  const std::string& color() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* ptr);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .protos.Vector2D center = 2;
  bool has_center() const;
  void clear_center() ;
  const ::protos::Vector2D& center() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_center();
  ::protos::Vector2D* mutable_center();
  void set_allocated_center(::protos::Vector2D* center);
  private:
  const ::protos::Vector2D& _internal_center() const;
  ::protos::Vector2D* _internal_mutable_center();
  public:
  void unsafe_arena_set_allocated_center(
      ::protos::Vector2D* center);
  ::protos::Vector2D* unsafe_arena_release_center();
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // float radius = 3;
  void clear_radius() ;
  float radius() const;
  void set_radius(float value);

  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);

  public:
  // bool fill = 5;
  void clear_fill() ;
  bool fill() const;
  void set_fill(bool value);

  private:
  bool _internal_fill() const;
  void _internal_set_fill(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddCircle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    ::protos::Vector2D* center_;
    int level_;
    float radius_;
    bool fill_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddTriangle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.AddTriangle) */ {
 public:
  inline AddTriangle() : AddTriangle(nullptr) {}
  ~AddTriangle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddTriangle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddTriangle(const AddTriangle& from);
  AddTriangle(AddTriangle&& from) noexcept
    : AddTriangle() {
    *this = ::std::move(from);
  }

  inline AddTriangle& operator=(const AddTriangle& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddTriangle& operator=(AddTriangle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddTriangle& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddTriangle* internal_default_instance() {
    return reinterpret_cast<const AddTriangle*>(
               &_AddTriangle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(AddTriangle& a, AddTriangle& b) {
    a.Swap(&b);
  }
  inline void Swap(AddTriangle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddTriangle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddTriangle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddTriangle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddTriangle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddTriangle& from) {
    AddTriangle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTriangle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddTriangle";
  }
  protected:
  explicit AddTriangle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 5,
    kPoint1FieldNumber = 2,
    kPoint2FieldNumber = 3,
    kPoint3FieldNumber = 4,
    kLevelFieldNumber = 1,
    kFillFieldNumber = 6,
  };
  // string color = 5;
  void clear_color() ;
  const std::string& color() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* ptr);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .protos.Vector2D point1 = 2;
  bool has_point1() const;
  void clear_point1() ;
  const ::protos::Vector2D& point1() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_point1();
  ::protos::Vector2D* mutable_point1();
  void set_allocated_point1(::protos::Vector2D* point1);
  private:
  const ::protos::Vector2D& _internal_point1() const;
  ::protos::Vector2D* _internal_mutable_point1();
  public:
  void unsafe_arena_set_allocated_point1(
      ::protos::Vector2D* point1);
  ::protos::Vector2D* unsafe_arena_release_point1();
  // .protos.Vector2D point2 = 3;
  bool has_point2() const;
  void clear_point2() ;
  const ::protos::Vector2D& point2() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_point2();
  ::protos::Vector2D* mutable_point2();
  void set_allocated_point2(::protos::Vector2D* point2);
  private:
  const ::protos::Vector2D& _internal_point2() const;
  ::protos::Vector2D* _internal_mutable_point2();
  public:
  void unsafe_arena_set_allocated_point2(
      ::protos::Vector2D* point2);
  ::protos::Vector2D* unsafe_arena_release_point2();
  // .protos.Vector2D point3 = 4;
  bool has_point3() const;
  void clear_point3() ;
  const ::protos::Vector2D& point3() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_point3();
  ::protos::Vector2D* mutable_point3();
  void set_allocated_point3(::protos::Vector2D* point3);
  private:
  const ::protos::Vector2D& _internal_point3() const;
  ::protos::Vector2D* _internal_mutable_point3();
  public:
  void unsafe_arena_set_allocated_point3(
      ::protos::Vector2D* point3);
  ::protos::Vector2D* unsafe_arena_release_point3();
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // bool fill = 6;
  void clear_fill() ;
  bool fill() const;
  void set_fill(bool value);

  private:
  bool _internal_fill() const;
  void _internal_set_fill(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddTriangle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    ::protos::Vector2D* point1_;
    ::protos::Vector2D* point2_;
    ::protos::Vector2D* point3_;
    int level_;
    bool fill_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddRectangle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.AddRectangle) */ {
 public:
  inline AddRectangle() : AddRectangle(nullptr) {}
  ~AddRectangle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddRectangle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddRectangle(const AddRectangle& from);
  AddRectangle(AddRectangle&& from) noexcept
    : AddRectangle() {
    *this = ::std::move(from);
  }

  inline AddRectangle& operator=(const AddRectangle& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddRectangle& operator=(AddRectangle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddRectangle& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddRectangle* internal_default_instance() {
    return reinterpret_cast<const AddRectangle*>(
               &_AddRectangle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(AddRectangle& a, AddRectangle& b) {
    a.Swap(&b);
  }
  inline void Swap(AddRectangle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddRectangle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddRectangle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddRectangle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddRectangle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddRectangle& from) {
    AddRectangle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddRectangle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddRectangle";
  }
  protected:
  explicit AddRectangle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 6,
    kLevelFieldNumber = 1,
    kLeftFieldNumber = 2,
    kTopFieldNumber = 3,
    kLengthFieldNumber = 4,
    kWidthFieldNumber = 5,
    kFillFieldNumber = 7,
  };
  // string color = 6;
  void clear_color() ;
  const std::string& color() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* ptr);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // float left = 2;
  void clear_left() ;
  float left() const;
  void set_left(float value);

  private:
  float _internal_left() const;
  void _internal_set_left(float value);

  public:
  // float top = 3;
  void clear_top() ;
  float top() const;
  void set_top(float value);

  private:
  float _internal_top() const;
  void _internal_set_top(float value);

  public:
  // float length = 4;
  void clear_length() ;
  float length() const;
  void set_length(float value);

  private:
  float _internal_length() const;
  void _internal_set_length(float value);

  public:
  // float width = 5;
  void clear_width() ;
  float width() const;
  void set_width(float value);

  private:
  float _internal_width() const;
  void _internal_set_width(float value);

  public:
  // bool fill = 7;
  void clear_fill() ;
  bool fill() const;
  void set_fill(bool value);

  private:
  bool _internal_fill() const;
  void _internal_set_fill(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddRectangle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    int level_;
    float left_;
    float top_;
    float length_;
    float width_;
    bool fill_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddSector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.AddSector) */ {
 public:
  inline AddSector() : AddSector(nullptr) {}
  ~AddSector() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddSector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddSector(const AddSector& from);
  AddSector(AddSector&& from) noexcept
    : AddSector() {
    *this = ::std::move(from);
  }

  inline AddSector& operator=(const AddSector& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddSector& operator=(AddSector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddSector& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddSector* internal_default_instance() {
    return reinterpret_cast<const AddSector*>(
               &_AddSector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(AddSector& a, AddSector& b) {
    a.Swap(&b);
  }
  inline void Swap(AddSector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddSector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddSector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddSector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddSector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddSector& from) {
    AddSector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddSector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddSector";
  }
  protected:
  explicit AddSector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 7,
    kCenterFieldNumber = 2,
    kLevelFieldNumber = 1,
    kMinRadiusFieldNumber = 3,
    kMaxRadiusFieldNumber = 4,
    kStartAngleFieldNumber = 5,
    kSpanAngelFieldNumber = 6,
    kFillFieldNumber = 8,
  };
  // string color = 7;
  void clear_color() ;
  const std::string& color() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* ptr);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .protos.Vector2D center = 2;
  bool has_center() const;
  void clear_center() ;
  const ::protos::Vector2D& center() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_center();
  ::protos::Vector2D* mutable_center();
  void set_allocated_center(::protos::Vector2D* center);
  private:
  const ::protos::Vector2D& _internal_center() const;
  ::protos::Vector2D* _internal_mutable_center();
  public:
  void unsafe_arena_set_allocated_center(
      ::protos::Vector2D* center);
  ::protos::Vector2D* unsafe_arena_release_center();
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // float min_radius = 3;
  void clear_min_radius() ;
  float min_radius() const;
  void set_min_radius(float value);

  private:
  float _internal_min_radius() const;
  void _internal_set_min_radius(float value);

  public:
  // float max_radius = 4;
  void clear_max_radius() ;
  float max_radius() const;
  void set_max_radius(float value);

  private:
  float _internal_max_radius() const;
  void _internal_set_max_radius(float value);

  public:
  // float start_angle = 5;
  void clear_start_angle() ;
  float start_angle() const;
  void set_start_angle(float value);

  private:
  float _internal_start_angle() const;
  void _internal_set_start_angle(float value);

  public:
  // float span_angel = 6;
  void clear_span_angel() ;
  float span_angel() const;
  void set_span_angel(float value);

  private:
  float _internal_span_angel() const;
  void _internal_set_span_angel(float value);

  public:
  // bool fill = 8;
  void clear_fill() ;
  bool fill() const;
  void set_fill(bool value);

  private:
  bool _internal_fill() const;
  void _internal_set_fill(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddSector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    ::protos::Vector2D* center_;
    int level_;
    float min_radius_;
    float max_radius_;
    float start_angle_;
    float span_angel_;
    bool fill_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.AddMessage) */ {
 public:
  inline AddMessage() : AddMessage(nullptr) {}
  ~AddMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddMessage(const AddMessage& from);
  AddMessage(AddMessage&& from) noexcept
    : AddMessage() {
    *this = ::std::move(from);
  }

  inline AddMessage& operator=(const AddMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddMessage& operator=(AddMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddMessage* internal_default_instance() {
    return reinterpret_cast<const AddMessage*>(
               &_AddMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(AddMessage& a, AddMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AddMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddMessage& from) {
    AddMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddMessage";
  }
  protected:
  explicit AddMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kColorFieldNumber = 4,
    kPositionFieldNumber = 2,
    kLevelFieldNumber = 1,
  };
  // string message = 3;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // string color = 4;
  void clear_color() ;
  const std::string& color() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* ptr);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .protos.Vector2D position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* position);
  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protos::Vector2D* position);
  ::protos::Vector2D* unsafe_arena_release_position();
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    ::protos::Vector2D* position_;
    int level_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Log final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Log) */ {
 public:
  inline Log() : Log(nullptr) {}
  ~Log() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Log(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Log(const Log& from);
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Log& default_instance() {
    return *internal_default_instance();
  }
  enum LogCase {
    kAddText = 1,
    kAddPoint = 2,
    kAddLine = 3,
    kAddArc = 4,
    kAddCircle = 5,
    kAddTriangle = 6,
    kAddRectangle = 7,
    kAddSector = 8,
    kAddMessage = 9,
    LOG_NOT_SET = 0,
  };

  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }
  inline void Swap(Log* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Log* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Log* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Log& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Log& from) {
    Log::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Log";
  }
  protected:
  explicit Log(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddTextFieldNumber = 1,
    kAddPointFieldNumber = 2,
    kAddLineFieldNumber = 3,
    kAddArcFieldNumber = 4,
    kAddCircleFieldNumber = 5,
    kAddTriangleFieldNumber = 6,
    kAddRectangleFieldNumber = 7,
    kAddSectorFieldNumber = 8,
    kAddMessageFieldNumber = 9,
  };
  // .protos.AddText add_text = 1;
  bool has_add_text() const;
  private:
  bool _internal_has_add_text() const;

  public:
  void clear_add_text() ;
  const ::protos::AddText& add_text() const;
  PROTOBUF_NODISCARD ::protos::AddText* release_add_text();
  ::protos::AddText* mutable_add_text();
  void set_allocated_add_text(::protos::AddText* add_text);
  private:
  const ::protos::AddText& _internal_add_text() const;
  ::protos::AddText* _internal_mutable_add_text();
  public:
  void unsafe_arena_set_allocated_add_text(
      ::protos::AddText* add_text);
  ::protos::AddText* unsafe_arena_release_add_text();
  // .protos.AddPoint add_point = 2;
  bool has_add_point() const;
  private:
  bool _internal_has_add_point() const;

  public:
  void clear_add_point() ;
  const ::protos::AddPoint& add_point() const;
  PROTOBUF_NODISCARD ::protos::AddPoint* release_add_point();
  ::protos::AddPoint* mutable_add_point();
  void set_allocated_add_point(::protos::AddPoint* add_point);
  private:
  const ::protos::AddPoint& _internal_add_point() const;
  ::protos::AddPoint* _internal_mutable_add_point();
  public:
  void unsafe_arena_set_allocated_add_point(
      ::protos::AddPoint* add_point);
  ::protos::AddPoint* unsafe_arena_release_add_point();
  // .protos.AddLine add_line = 3;
  bool has_add_line() const;
  private:
  bool _internal_has_add_line() const;

  public:
  void clear_add_line() ;
  const ::protos::AddLine& add_line() const;
  PROTOBUF_NODISCARD ::protos::AddLine* release_add_line();
  ::protos::AddLine* mutable_add_line();
  void set_allocated_add_line(::protos::AddLine* add_line);
  private:
  const ::protos::AddLine& _internal_add_line() const;
  ::protos::AddLine* _internal_mutable_add_line();
  public:
  void unsafe_arena_set_allocated_add_line(
      ::protos::AddLine* add_line);
  ::protos::AddLine* unsafe_arena_release_add_line();
  // .protos.AddArc add_arc = 4;
  bool has_add_arc() const;
  private:
  bool _internal_has_add_arc() const;

  public:
  void clear_add_arc() ;
  const ::protos::AddArc& add_arc() const;
  PROTOBUF_NODISCARD ::protos::AddArc* release_add_arc();
  ::protos::AddArc* mutable_add_arc();
  void set_allocated_add_arc(::protos::AddArc* add_arc);
  private:
  const ::protos::AddArc& _internal_add_arc() const;
  ::protos::AddArc* _internal_mutable_add_arc();
  public:
  void unsafe_arena_set_allocated_add_arc(
      ::protos::AddArc* add_arc);
  ::protos::AddArc* unsafe_arena_release_add_arc();
  // .protos.AddCircle add_circle = 5;
  bool has_add_circle() const;
  private:
  bool _internal_has_add_circle() const;

  public:
  void clear_add_circle() ;
  const ::protos::AddCircle& add_circle() const;
  PROTOBUF_NODISCARD ::protos::AddCircle* release_add_circle();
  ::protos::AddCircle* mutable_add_circle();
  void set_allocated_add_circle(::protos::AddCircle* add_circle);
  private:
  const ::protos::AddCircle& _internal_add_circle() const;
  ::protos::AddCircle* _internal_mutable_add_circle();
  public:
  void unsafe_arena_set_allocated_add_circle(
      ::protos::AddCircle* add_circle);
  ::protos::AddCircle* unsafe_arena_release_add_circle();
  // .protos.AddTriangle add_triangle = 6;
  bool has_add_triangle() const;
  private:
  bool _internal_has_add_triangle() const;

  public:
  void clear_add_triangle() ;
  const ::protos::AddTriangle& add_triangle() const;
  PROTOBUF_NODISCARD ::protos::AddTriangle* release_add_triangle();
  ::protos::AddTriangle* mutable_add_triangle();
  void set_allocated_add_triangle(::protos::AddTriangle* add_triangle);
  private:
  const ::protos::AddTriangle& _internal_add_triangle() const;
  ::protos::AddTriangle* _internal_mutable_add_triangle();
  public:
  void unsafe_arena_set_allocated_add_triangle(
      ::protos::AddTriangle* add_triangle);
  ::protos::AddTriangle* unsafe_arena_release_add_triangle();
  // .protos.AddRectangle add_rectangle = 7;
  bool has_add_rectangle() const;
  private:
  bool _internal_has_add_rectangle() const;

  public:
  void clear_add_rectangle() ;
  const ::protos::AddRectangle& add_rectangle() const;
  PROTOBUF_NODISCARD ::protos::AddRectangle* release_add_rectangle();
  ::protos::AddRectangle* mutable_add_rectangle();
  void set_allocated_add_rectangle(::protos::AddRectangle* add_rectangle);
  private:
  const ::protos::AddRectangle& _internal_add_rectangle() const;
  ::protos::AddRectangle* _internal_mutable_add_rectangle();
  public:
  void unsafe_arena_set_allocated_add_rectangle(
      ::protos::AddRectangle* add_rectangle);
  ::protos::AddRectangle* unsafe_arena_release_add_rectangle();
  // .protos.AddSector add_sector = 8;
  bool has_add_sector() const;
  private:
  bool _internal_has_add_sector() const;

  public:
  void clear_add_sector() ;
  const ::protos::AddSector& add_sector() const;
  PROTOBUF_NODISCARD ::protos::AddSector* release_add_sector();
  ::protos::AddSector* mutable_add_sector();
  void set_allocated_add_sector(::protos::AddSector* add_sector);
  private:
  const ::protos::AddSector& _internal_add_sector() const;
  ::protos::AddSector* _internal_mutable_add_sector();
  public:
  void unsafe_arena_set_allocated_add_sector(
      ::protos::AddSector* add_sector);
  ::protos::AddSector* unsafe_arena_release_add_sector();
  // .protos.AddMessage add_message = 9;
  bool has_add_message() const;
  private:
  bool _internal_has_add_message() const;

  public:
  void clear_add_message() ;
  const ::protos::AddMessage& add_message() const;
  PROTOBUF_NODISCARD ::protos::AddMessage* release_add_message();
  ::protos::AddMessage* mutable_add_message();
  void set_allocated_add_message(::protos::AddMessage* add_message);
  private:
  const ::protos::AddMessage& _internal_add_message() const;
  ::protos::AddMessage* _internal_mutable_add_message();
  public:
  void unsafe_arena_set_allocated_add_message(
      ::protos::AddMessage* add_message);
  ::protos::AddMessage* unsafe_arena_release_add_message();
  void clear_log();
  LogCase log_case() const;
  // @@protoc_insertion_point(class_scope:protos.Log)
 private:
  class _Internal;
  void set_has_add_text();
  void set_has_add_point();
  void set_has_add_line();
  void set_has_add_arc();
  void set_has_add_circle();
  void set_has_add_triangle();
  void set_has_add_rectangle();
  void set_has_add_sector();
  void set_has_add_message();

  inline bool has_log() const;
  inline void clear_has_log();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union LogUnion {
      constexpr LogUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::protos::AddText* add_text_;
      ::protos::AddPoint* add_point_;
      ::protos::AddLine* add_line_;
      ::protos::AddArc* add_arc_;
      ::protos::AddCircle* add_circle_;
      ::protos::AddTriangle* add_triangle_;
      ::protos::AddRectangle* add_rectangle_;
      ::protos::AddSector* add_sector_;
      ::protos::AddMessage* add_message_;
    } log_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class DebugClient final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.DebugClient) */ {
 public:
  inline DebugClient() : DebugClient(nullptr) {}
  ~DebugClient() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DebugClient(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugClient(const DebugClient& from);
  DebugClient(DebugClient&& from) noexcept
    : DebugClient() {
    *this = ::std::move(from);
  }

  inline DebugClient& operator=(const DebugClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugClient& operator=(DebugClient&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugClient& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugClient* internal_default_instance() {
    return reinterpret_cast<const DebugClient*>(
               &_DebugClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(DebugClient& a, DebugClient& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugClient* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugClient* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugClient>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugClient& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugClient& from) {
    DebugClient::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugClient* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.DebugClient";
  }
  protected:
  explicit DebugClient(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:protos.DebugClient)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_GoToPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Body_GoToPoint) */ {
 public:
  inline Body_GoToPoint() : Body_GoToPoint(nullptr) {}
  ~Body_GoToPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_GoToPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Body_GoToPoint(const Body_GoToPoint& from);
  Body_GoToPoint(Body_GoToPoint&& from) noexcept
    : Body_GoToPoint() {
    *this = ::std::move(from);
  }

  inline Body_GoToPoint& operator=(const Body_GoToPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_GoToPoint& operator=(Body_GoToPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_GoToPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_GoToPoint* internal_default_instance() {
    return reinterpret_cast<const Body_GoToPoint*>(
               &_Body_GoToPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(Body_GoToPoint& a, Body_GoToPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_GoToPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_GoToPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_GoToPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_GoToPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Body_GoToPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Body_GoToPoint& from) {
    Body_GoToPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Body_GoToPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_GoToPoint";
  }
  protected:
  explicit Body_GoToPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kDistanceThresholdFieldNumber = 2,
    kMaxDashPowerFieldNumber = 3,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* target_point);
  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();
  public:
  void unsafe_arena_set_allocated_target_point(
      ::protos::Vector2D* target_point);
  ::protos::Vector2D* unsafe_arena_release_target_point();
  // float distance_threshold = 2;
  void clear_distance_threshold() ;
  float distance_threshold() const;
  void set_distance_threshold(float value);

  private:
  float _internal_distance_threshold() const;
  void _internal_set_distance_threshold(float value);

  public:
  // float max_dash_power = 3;
  void clear_max_dash_power() ;
  float max_dash_power() const;
  void set_max_dash_power(float value);

  private:
  float _internal_max_dash_power() const;
  void _internal_set_max_dash_power(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_GoToPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    float distance_threshold_;
    float max_dash_power_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_SmartKick final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Body_SmartKick) */ {
 public:
  inline Body_SmartKick() : Body_SmartKick(nullptr) {}
  ~Body_SmartKick() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_SmartKick(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Body_SmartKick(const Body_SmartKick& from);
  Body_SmartKick(Body_SmartKick&& from) noexcept
    : Body_SmartKick() {
    *this = ::std::move(from);
  }

  inline Body_SmartKick& operator=(const Body_SmartKick& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_SmartKick& operator=(Body_SmartKick&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_SmartKick& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_SmartKick* internal_default_instance() {
    return reinterpret_cast<const Body_SmartKick*>(
               &_Body_SmartKick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(Body_SmartKick& a, Body_SmartKick& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_SmartKick* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_SmartKick* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_SmartKick* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_SmartKick>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Body_SmartKick& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Body_SmartKick& from) {
    Body_SmartKick::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Body_SmartKick* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_SmartKick";
  }
  protected:
  explicit Body_SmartKick(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kFirstSpeedFieldNumber = 2,
    kFirstSpeedThresholdFieldNumber = 3,
    kMaxStepsFieldNumber = 4,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* target_point);
  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();
  public:
  void unsafe_arena_set_allocated_target_point(
      ::protos::Vector2D* target_point);
  ::protos::Vector2D* unsafe_arena_release_target_point();
  // float first_speed = 2;
  void clear_first_speed() ;
  float first_speed() const;
  void set_first_speed(float value);

  private:
  float _internal_first_speed() const;
  void _internal_set_first_speed(float value);

  public:
  // float first_speed_threshold = 3;
  void clear_first_speed_threshold() ;
  float first_speed_threshold() const;
  void set_first_speed_threshold(float value);

  private:
  float _internal_first_speed_threshold() const;
  void _internal_set_first_speed_threshold(float value);

  public:
  // int32 max_steps = 4;
  void clear_max_steps() ;
  ::int32_t max_steps() const;
  void set_max_steps(::int32_t value);

  private:
  ::int32_t _internal_max_steps() const;
  void _internal_set_max_steps(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_SmartKick)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    float first_speed_;
    float first_speed_threshold_;
    ::int32_t max_steps_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Bhv_BeforeKickOff final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Bhv_BeforeKickOff) */ {
 public:
  inline Bhv_BeforeKickOff() : Bhv_BeforeKickOff(nullptr) {}
  ~Bhv_BeforeKickOff() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bhv_BeforeKickOff(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bhv_BeforeKickOff(const Bhv_BeforeKickOff& from);
  Bhv_BeforeKickOff(Bhv_BeforeKickOff&& from) noexcept
    : Bhv_BeforeKickOff() {
    *this = ::std::move(from);
  }

  inline Bhv_BeforeKickOff& operator=(const Bhv_BeforeKickOff& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bhv_BeforeKickOff& operator=(Bhv_BeforeKickOff&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bhv_BeforeKickOff& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bhv_BeforeKickOff* internal_default_instance() {
    return reinterpret_cast<const Bhv_BeforeKickOff*>(
               &_Bhv_BeforeKickOff_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(Bhv_BeforeKickOff& a, Bhv_BeforeKickOff& b) {
    a.Swap(&b);
  }
  inline void Swap(Bhv_BeforeKickOff* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bhv_BeforeKickOff* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bhv_BeforeKickOff* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bhv_BeforeKickOff>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bhv_BeforeKickOff& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Bhv_BeforeKickOff& from) {
    Bhv_BeforeKickOff::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bhv_BeforeKickOff* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Bhv_BeforeKickOff";
  }
  protected:
  explicit Bhv_BeforeKickOff(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
  };
  // .protos.Vector2D point = 1;
  bool has_point() const;
  void clear_point() ;
  const ::protos::Vector2D& point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_point();
  ::protos::Vector2D* mutable_point();
  void set_allocated_point(::protos::Vector2D* point);
  private:
  const ::protos::Vector2D& _internal_point() const;
  ::protos::Vector2D* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::protos::Vector2D* point);
  ::protos::Vector2D* unsafe_arena_release_point();
  // @@protoc_insertion_point(class_scope:protos.Bhv_BeforeKickOff)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* point_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Bhv_BodyNeckToBall final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Bhv_BodyNeckToBall) */ {
 public:
  inline Bhv_BodyNeckToBall() : Bhv_BodyNeckToBall(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bhv_BodyNeckToBall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bhv_BodyNeckToBall(const Bhv_BodyNeckToBall& from);
  Bhv_BodyNeckToBall(Bhv_BodyNeckToBall&& from) noexcept
    : Bhv_BodyNeckToBall() {
    *this = ::std::move(from);
  }

  inline Bhv_BodyNeckToBall& operator=(const Bhv_BodyNeckToBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bhv_BodyNeckToBall& operator=(Bhv_BodyNeckToBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bhv_BodyNeckToBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bhv_BodyNeckToBall* internal_default_instance() {
    return reinterpret_cast<const Bhv_BodyNeckToBall*>(
               &_Bhv_BodyNeckToBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(Bhv_BodyNeckToBall& a, Bhv_BodyNeckToBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Bhv_BodyNeckToBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bhv_BodyNeckToBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bhv_BodyNeckToBall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bhv_BodyNeckToBall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Bhv_BodyNeckToBall& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Bhv_BodyNeckToBall& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Bhv_BodyNeckToBall";
  }
  protected:
  explicit Bhv_BodyNeckToBall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Bhv_BodyNeckToBall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Bhv_BodyNeckToPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Bhv_BodyNeckToPoint) */ {
 public:
  inline Bhv_BodyNeckToPoint() : Bhv_BodyNeckToPoint(nullptr) {}
  ~Bhv_BodyNeckToPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bhv_BodyNeckToPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bhv_BodyNeckToPoint(const Bhv_BodyNeckToPoint& from);
  Bhv_BodyNeckToPoint(Bhv_BodyNeckToPoint&& from) noexcept
    : Bhv_BodyNeckToPoint() {
    *this = ::std::move(from);
  }

  inline Bhv_BodyNeckToPoint& operator=(const Bhv_BodyNeckToPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bhv_BodyNeckToPoint& operator=(Bhv_BodyNeckToPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bhv_BodyNeckToPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bhv_BodyNeckToPoint* internal_default_instance() {
    return reinterpret_cast<const Bhv_BodyNeckToPoint*>(
               &_Bhv_BodyNeckToPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(Bhv_BodyNeckToPoint& a, Bhv_BodyNeckToPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Bhv_BodyNeckToPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bhv_BodyNeckToPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bhv_BodyNeckToPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bhv_BodyNeckToPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bhv_BodyNeckToPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Bhv_BodyNeckToPoint& from) {
    Bhv_BodyNeckToPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bhv_BodyNeckToPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Bhv_BodyNeckToPoint";
  }
  protected:
  explicit Bhv_BodyNeckToPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
  };
  // .protos.Vector2D point = 1;
  bool has_point() const;
  void clear_point() ;
  const ::protos::Vector2D& point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_point();
  ::protos::Vector2D* mutable_point();
  void set_allocated_point(::protos::Vector2D* point);
  private:
  const ::protos::Vector2D& _internal_point() const;
  ::protos::Vector2D* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::protos::Vector2D* point);
  ::protos::Vector2D* unsafe_arena_release_point();
  // @@protoc_insertion_point(class_scope:protos.Bhv_BodyNeckToPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* point_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Bhv_Emergency final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Bhv_Emergency) */ {
 public:
  inline Bhv_Emergency() : Bhv_Emergency(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bhv_Emergency(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bhv_Emergency(const Bhv_Emergency& from);
  Bhv_Emergency(Bhv_Emergency&& from) noexcept
    : Bhv_Emergency() {
    *this = ::std::move(from);
  }

  inline Bhv_Emergency& operator=(const Bhv_Emergency& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bhv_Emergency& operator=(Bhv_Emergency&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bhv_Emergency& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bhv_Emergency* internal_default_instance() {
    return reinterpret_cast<const Bhv_Emergency*>(
               &_Bhv_Emergency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(Bhv_Emergency& a, Bhv_Emergency& b) {
    a.Swap(&b);
  }
  inline void Swap(Bhv_Emergency* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bhv_Emergency* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bhv_Emergency* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bhv_Emergency>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Bhv_Emergency& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Bhv_Emergency& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Bhv_Emergency";
  }
  protected:
  explicit Bhv_Emergency(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Bhv_Emergency)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Bhv_GoToPointLookBall final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Bhv_GoToPointLookBall) */ {
 public:
  inline Bhv_GoToPointLookBall() : Bhv_GoToPointLookBall(nullptr) {}
  ~Bhv_GoToPointLookBall() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bhv_GoToPointLookBall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bhv_GoToPointLookBall(const Bhv_GoToPointLookBall& from);
  Bhv_GoToPointLookBall(Bhv_GoToPointLookBall&& from) noexcept
    : Bhv_GoToPointLookBall() {
    *this = ::std::move(from);
  }

  inline Bhv_GoToPointLookBall& operator=(const Bhv_GoToPointLookBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bhv_GoToPointLookBall& operator=(Bhv_GoToPointLookBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bhv_GoToPointLookBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bhv_GoToPointLookBall* internal_default_instance() {
    return reinterpret_cast<const Bhv_GoToPointLookBall*>(
               &_Bhv_GoToPointLookBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(Bhv_GoToPointLookBall& a, Bhv_GoToPointLookBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Bhv_GoToPointLookBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bhv_GoToPointLookBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bhv_GoToPointLookBall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bhv_GoToPointLookBall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bhv_GoToPointLookBall& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Bhv_GoToPointLookBall& from) {
    Bhv_GoToPointLookBall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bhv_GoToPointLookBall* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Bhv_GoToPointLookBall";
  }
  protected:
  explicit Bhv_GoToPointLookBall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kDistanceThresholdFieldNumber = 2,
    kMaxDashPowerFieldNumber = 3,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* target_point);
  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();
  public:
  void unsafe_arena_set_allocated_target_point(
      ::protos::Vector2D* target_point);
  ::protos::Vector2D* unsafe_arena_release_target_point();
  // float distance_threshold = 2;
  void clear_distance_threshold() ;
  float distance_threshold() const;
  void set_distance_threshold(float value);

  private:
  float _internal_distance_threshold() const;
  void _internal_set_distance_threshold(float value);

  public:
  // float max_dash_power = 3;
  void clear_max_dash_power() ;
  float max_dash_power() const;
  void set_max_dash_power(float value);

  private:
  float _internal_max_dash_power() const;
  void _internal_set_max_dash_power(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Bhv_GoToPointLookBall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    float distance_threshold_;
    float max_dash_power_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Bhv_NeckBodyToBall final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Bhv_NeckBodyToBall) */ {
 public:
  inline Bhv_NeckBodyToBall() : Bhv_NeckBodyToBall(nullptr) {}
  ~Bhv_NeckBodyToBall() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bhv_NeckBodyToBall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bhv_NeckBodyToBall(const Bhv_NeckBodyToBall& from);
  Bhv_NeckBodyToBall(Bhv_NeckBodyToBall&& from) noexcept
    : Bhv_NeckBodyToBall() {
    *this = ::std::move(from);
  }

  inline Bhv_NeckBodyToBall& operator=(const Bhv_NeckBodyToBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bhv_NeckBodyToBall& operator=(Bhv_NeckBodyToBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bhv_NeckBodyToBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bhv_NeckBodyToBall* internal_default_instance() {
    return reinterpret_cast<const Bhv_NeckBodyToBall*>(
               &_Bhv_NeckBodyToBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(Bhv_NeckBodyToBall& a, Bhv_NeckBodyToBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Bhv_NeckBodyToBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bhv_NeckBodyToBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bhv_NeckBodyToBall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bhv_NeckBodyToBall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bhv_NeckBodyToBall& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Bhv_NeckBodyToBall& from) {
    Bhv_NeckBodyToBall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bhv_NeckBodyToBall* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Bhv_NeckBodyToBall";
  }
  protected:
  explicit Bhv_NeckBodyToBall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAngleBufFieldNumber = 1,
  };
  // float angle_buf = 1;
  void clear_angle_buf() ;
  float angle_buf() const;
  void set_angle_buf(float value);

  private:
  float _internal_angle_buf() const;
  void _internal_set_angle_buf(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Bhv_NeckBodyToBall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float angle_buf_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Bhv_NeckBodyToPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Bhv_NeckBodyToPoint) */ {
 public:
  inline Bhv_NeckBodyToPoint() : Bhv_NeckBodyToPoint(nullptr) {}
  ~Bhv_NeckBodyToPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bhv_NeckBodyToPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bhv_NeckBodyToPoint(const Bhv_NeckBodyToPoint& from);
  Bhv_NeckBodyToPoint(Bhv_NeckBodyToPoint&& from) noexcept
    : Bhv_NeckBodyToPoint() {
    *this = ::std::move(from);
  }

  inline Bhv_NeckBodyToPoint& operator=(const Bhv_NeckBodyToPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bhv_NeckBodyToPoint& operator=(Bhv_NeckBodyToPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bhv_NeckBodyToPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bhv_NeckBodyToPoint* internal_default_instance() {
    return reinterpret_cast<const Bhv_NeckBodyToPoint*>(
               &_Bhv_NeckBodyToPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(Bhv_NeckBodyToPoint& a, Bhv_NeckBodyToPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Bhv_NeckBodyToPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bhv_NeckBodyToPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bhv_NeckBodyToPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bhv_NeckBodyToPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bhv_NeckBodyToPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Bhv_NeckBodyToPoint& from) {
    Bhv_NeckBodyToPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bhv_NeckBodyToPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Bhv_NeckBodyToPoint";
  }
  protected:
  explicit Bhv_NeckBodyToPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
    kAngleBufFieldNumber = 2,
  };
  // .protos.Vector2D point = 1;
  bool has_point() const;
  void clear_point() ;
  const ::protos::Vector2D& point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_point();
  ::protos::Vector2D* mutable_point();
  void set_allocated_point(::protos::Vector2D* point);
  private:
  const ::protos::Vector2D& _internal_point() const;
  ::protos::Vector2D* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::protos::Vector2D* point);
  ::protos::Vector2D* unsafe_arena_release_point();
  // float angle_buf = 2;
  void clear_angle_buf() ;
  float angle_buf() const;
  void set_angle_buf(float value);

  private:
  float _internal_angle_buf() const;
  void _internal_set_angle_buf(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Bhv_NeckBodyToPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* point_;
    float angle_buf_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Bhv_ScanField final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Bhv_ScanField) */ {
 public:
  inline Bhv_ScanField() : Bhv_ScanField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bhv_ScanField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bhv_ScanField(const Bhv_ScanField& from);
  Bhv_ScanField(Bhv_ScanField&& from) noexcept
    : Bhv_ScanField() {
    *this = ::std::move(from);
  }

  inline Bhv_ScanField& operator=(const Bhv_ScanField& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bhv_ScanField& operator=(Bhv_ScanField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bhv_ScanField& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bhv_ScanField* internal_default_instance() {
    return reinterpret_cast<const Bhv_ScanField*>(
               &_Bhv_ScanField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(Bhv_ScanField& a, Bhv_ScanField& b) {
    a.Swap(&b);
  }
  inline void Swap(Bhv_ScanField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bhv_ScanField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bhv_ScanField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bhv_ScanField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Bhv_ScanField& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Bhv_ScanField& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Bhv_ScanField";
  }
  protected:
  explicit Bhv_ScanField(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Bhv_ScanField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_AdvanceBall final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Body_AdvanceBall) */ {
 public:
  inline Body_AdvanceBall() : Body_AdvanceBall(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_AdvanceBall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Body_AdvanceBall(const Body_AdvanceBall& from);
  Body_AdvanceBall(Body_AdvanceBall&& from) noexcept
    : Body_AdvanceBall() {
    *this = ::std::move(from);
  }

  inline Body_AdvanceBall& operator=(const Body_AdvanceBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_AdvanceBall& operator=(Body_AdvanceBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_AdvanceBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_AdvanceBall* internal_default_instance() {
    return reinterpret_cast<const Body_AdvanceBall*>(
               &_Body_AdvanceBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(Body_AdvanceBall& a, Body_AdvanceBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_AdvanceBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_AdvanceBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_AdvanceBall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_AdvanceBall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Body_AdvanceBall& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Body_AdvanceBall& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_AdvanceBall";
  }
  protected:
  explicit Body_AdvanceBall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Body_AdvanceBall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_ClearBall final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Body_ClearBall) */ {
 public:
  inline Body_ClearBall() : Body_ClearBall(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_ClearBall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Body_ClearBall(const Body_ClearBall& from);
  Body_ClearBall(Body_ClearBall&& from) noexcept
    : Body_ClearBall() {
    *this = ::std::move(from);
  }

  inline Body_ClearBall& operator=(const Body_ClearBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_ClearBall& operator=(Body_ClearBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_ClearBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_ClearBall* internal_default_instance() {
    return reinterpret_cast<const Body_ClearBall*>(
               &_Body_ClearBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(Body_ClearBall& a, Body_ClearBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_ClearBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_ClearBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_ClearBall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_ClearBall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Body_ClearBall& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Body_ClearBall& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_ClearBall";
  }
  protected:
  explicit Body_ClearBall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Body_ClearBall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_Dribble final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Body_Dribble) */ {
 public:
  inline Body_Dribble() : Body_Dribble(nullptr) {}
  ~Body_Dribble() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_Dribble(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Body_Dribble(const Body_Dribble& from);
  Body_Dribble(Body_Dribble&& from) noexcept
    : Body_Dribble() {
    *this = ::std::move(from);
  }

  inline Body_Dribble& operator=(const Body_Dribble& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_Dribble& operator=(Body_Dribble&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_Dribble& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_Dribble* internal_default_instance() {
    return reinterpret_cast<const Body_Dribble*>(
               &_Body_Dribble_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(Body_Dribble& a, Body_Dribble& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_Dribble* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_Dribble* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_Dribble* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_Dribble>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Body_Dribble& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Body_Dribble& from) {
    Body_Dribble::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Body_Dribble* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_Dribble";
  }
  protected:
  explicit Body_Dribble(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kDistanceThresholdFieldNumber = 2,
    kDashPowerFieldNumber = 3,
    kDashCountFieldNumber = 4,
    kDodgeFieldNumber = 5,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* target_point);
  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();
  public:
  void unsafe_arena_set_allocated_target_point(
      ::protos::Vector2D* target_point);
  ::protos::Vector2D* unsafe_arena_release_target_point();
  // float distance_threshold = 2;
  void clear_distance_threshold() ;
  float distance_threshold() const;
  void set_distance_threshold(float value);

  private:
  float _internal_distance_threshold() const;
  void _internal_set_distance_threshold(float value);

  public:
  // float dash_power = 3;
  void clear_dash_power() ;
  float dash_power() const;
  void set_dash_power(float value);

  private:
  float _internal_dash_power() const;
  void _internal_set_dash_power(float value);

  public:
  // int32 dash_count = 4;
  void clear_dash_count() ;
  ::int32_t dash_count() const;
  void set_dash_count(::int32_t value);

  private:
  ::int32_t _internal_dash_count() const;
  void _internal_set_dash_count(::int32_t value);

  public:
  // bool dodge = 5;
  void clear_dodge() ;
  bool dodge() const;
  void set_dodge(bool value);

  private:
  bool _internal_dodge() const;
  void _internal_set_dodge(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_Dribble)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    float distance_threshold_;
    float dash_power_;
    ::int32_t dash_count_;
    bool dodge_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_GoToPointDodge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Body_GoToPointDodge) */ {
 public:
  inline Body_GoToPointDodge() : Body_GoToPointDodge(nullptr) {}
  ~Body_GoToPointDodge() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_GoToPointDodge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Body_GoToPointDodge(const Body_GoToPointDodge& from);
  Body_GoToPointDodge(Body_GoToPointDodge&& from) noexcept
    : Body_GoToPointDodge() {
    *this = ::std::move(from);
  }

  inline Body_GoToPointDodge& operator=(const Body_GoToPointDodge& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_GoToPointDodge& operator=(Body_GoToPointDodge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_GoToPointDodge& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_GoToPointDodge* internal_default_instance() {
    return reinterpret_cast<const Body_GoToPointDodge*>(
               &_Body_GoToPointDodge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(Body_GoToPointDodge& a, Body_GoToPointDodge& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_GoToPointDodge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_GoToPointDodge* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_GoToPointDodge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_GoToPointDodge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Body_GoToPointDodge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Body_GoToPointDodge& from) {
    Body_GoToPointDodge::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Body_GoToPointDodge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_GoToPointDodge";
  }
  protected:
  explicit Body_GoToPointDodge(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kDashPowerFieldNumber = 2,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* target_point);
  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();
  public:
  void unsafe_arena_set_allocated_target_point(
      ::protos::Vector2D* target_point);
  ::protos::Vector2D* unsafe_arena_release_target_point();
  // float dash_power = 2;
  void clear_dash_power() ;
  float dash_power() const;
  void set_dash_power(float value);

  private:
  float _internal_dash_power() const;
  void _internal_set_dash_power(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_GoToPointDodge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    float dash_power_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_HoldBall final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Body_HoldBall) */ {
 public:
  inline Body_HoldBall() : Body_HoldBall(nullptr) {}
  ~Body_HoldBall() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_HoldBall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Body_HoldBall(const Body_HoldBall& from);
  Body_HoldBall(Body_HoldBall&& from) noexcept
    : Body_HoldBall() {
    *this = ::std::move(from);
  }

  inline Body_HoldBall& operator=(const Body_HoldBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_HoldBall& operator=(Body_HoldBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_HoldBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_HoldBall* internal_default_instance() {
    return reinterpret_cast<const Body_HoldBall*>(
               &_Body_HoldBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(Body_HoldBall& a, Body_HoldBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_HoldBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_HoldBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_HoldBall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_HoldBall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Body_HoldBall& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Body_HoldBall& from) {
    Body_HoldBall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Body_HoldBall* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_HoldBall";
  }
  protected:
  explicit Body_HoldBall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTurnTargetPointFieldNumber = 2,
    kKickTargetPointFieldNumber = 3,
    kDoTurnFieldNumber = 1,
  };
  // .protos.Vector2D turn_target_point = 2;
  bool has_turn_target_point() const;
  void clear_turn_target_point() ;
  const ::protos::Vector2D& turn_target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_turn_target_point();
  ::protos::Vector2D* mutable_turn_target_point();
  void set_allocated_turn_target_point(::protos::Vector2D* turn_target_point);
  private:
  const ::protos::Vector2D& _internal_turn_target_point() const;
  ::protos::Vector2D* _internal_mutable_turn_target_point();
  public:
  void unsafe_arena_set_allocated_turn_target_point(
      ::protos::Vector2D* turn_target_point);
  ::protos::Vector2D* unsafe_arena_release_turn_target_point();
  // .protos.Vector2D kick_target_point = 3;
  bool has_kick_target_point() const;
  void clear_kick_target_point() ;
  const ::protos::Vector2D& kick_target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_kick_target_point();
  ::protos::Vector2D* mutable_kick_target_point();
  void set_allocated_kick_target_point(::protos::Vector2D* kick_target_point);
  private:
  const ::protos::Vector2D& _internal_kick_target_point() const;
  ::protos::Vector2D* _internal_mutable_kick_target_point();
  public:
  void unsafe_arena_set_allocated_kick_target_point(
      ::protos::Vector2D* kick_target_point);
  ::protos::Vector2D* unsafe_arena_release_kick_target_point();
  // bool do_turn = 1;
  void clear_do_turn() ;
  bool do_turn() const;
  void set_do_turn(bool value);

  private:
  bool _internal_do_turn() const;
  void _internal_set_do_turn(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_HoldBall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* turn_target_point_;
    ::protos::Vector2D* kick_target_point_;
    bool do_turn_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_Intercept final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Body_Intercept) */ {
 public:
  inline Body_Intercept() : Body_Intercept(nullptr) {}
  ~Body_Intercept() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_Intercept(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Body_Intercept(const Body_Intercept& from);
  Body_Intercept(Body_Intercept&& from) noexcept
    : Body_Intercept() {
    *this = ::std::move(from);
  }

  inline Body_Intercept& operator=(const Body_Intercept& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_Intercept& operator=(Body_Intercept&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_Intercept& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_Intercept* internal_default_instance() {
    return reinterpret_cast<const Body_Intercept*>(
               &_Body_Intercept_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(Body_Intercept& a, Body_Intercept& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_Intercept* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_Intercept* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_Intercept* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_Intercept>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Body_Intercept& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Body_Intercept& from) {
    Body_Intercept::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Body_Intercept* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_Intercept";
  }
  protected:
  explicit Body_Intercept(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFacePointFieldNumber = 2,
    kSaveRecoveryFieldNumber = 1,
  };
  // .protos.Vector2D face_point = 2;
  bool has_face_point() const;
  void clear_face_point() ;
  const ::protos::Vector2D& face_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_face_point();
  ::protos::Vector2D* mutable_face_point();
  void set_allocated_face_point(::protos::Vector2D* face_point);
  private:
  const ::protos::Vector2D& _internal_face_point() const;
  ::protos::Vector2D* _internal_mutable_face_point();
  public:
  void unsafe_arena_set_allocated_face_point(
      ::protos::Vector2D* face_point);
  ::protos::Vector2D* unsafe_arena_release_face_point();
  // bool save_recovery = 1;
  void clear_save_recovery() ;
  bool save_recovery() const;
  void set_save_recovery(bool value);

  private:
  bool _internal_save_recovery() const;
  void _internal_set_save_recovery(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_Intercept)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* face_point_;
    bool save_recovery_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_KickOneStep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Body_KickOneStep) */ {
 public:
  inline Body_KickOneStep() : Body_KickOneStep(nullptr) {}
  ~Body_KickOneStep() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_KickOneStep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Body_KickOneStep(const Body_KickOneStep& from);
  Body_KickOneStep(Body_KickOneStep&& from) noexcept
    : Body_KickOneStep() {
    *this = ::std::move(from);
  }

  inline Body_KickOneStep& operator=(const Body_KickOneStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_KickOneStep& operator=(Body_KickOneStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_KickOneStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_KickOneStep* internal_default_instance() {
    return reinterpret_cast<const Body_KickOneStep*>(
               &_Body_KickOneStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(Body_KickOneStep& a, Body_KickOneStep& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_KickOneStep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_KickOneStep* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_KickOneStep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_KickOneStep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Body_KickOneStep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Body_KickOneStep& from) {
    Body_KickOneStep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Body_KickOneStep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_KickOneStep";
  }
  protected:
  explicit Body_KickOneStep(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kFirstSpeedFieldNumber = 2,
    kForceModeFieldNumber = 3,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* target_point);
  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();
  public:
  void unsafe_arena_set_allocated_target_point(
      ::protos::Vector2D* target_point);
  ::protos::Vector2D* unsafe_arena_release_target_point();
  // float first_speed = 2;
  void clear_first_speed() ;
  float first_speed() const;
  void set_first_speed(float value);

  private:
  float _internal_first_speed() const;
  void _internal_set_first_speed(float value);

  public:
  // bool force_mode = 3;
  void clear_force_mode() ;
  bool force_mode() const;
  void set_force_mode(bool value);

  private:
  bool _internal_force_mode() const;
  void _internal_set_force_mode(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_KickOneStep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    float first_speed_;
    bool force_mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_StopBall final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Body_StopBall) */ {
 public:
  inline Body_StopBall() : Body_StopBall(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_StopBall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Body_StopBall(const Body_StopBall& from);
  Body_StopBall(Body_StopBall&& from) noexcept
    : Body_StopBall() {
    *this = ::std::move(from);
  }

  inline Body_StopBall& operator=(const Body_StopBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_StopBall& operator=(Body_StopBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_StopBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_StopBall* internal_default_instance() {
    return reinterpret_cast<const Body_StopBall*>(
               &_Body_StopBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(Body_StopBall& a, Body_StopBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_StopBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_StopBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_StopBall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_StopBall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Body_StopBall& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Body_StopBall& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_StopBall";
  }
  protected:
  explicit Body_StopBall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Body_StopBall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_StopDash final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Body_StopDash) */ {
 public:
  inline Body_StopDash() : Body_StopDash(nullptr) {}
  ~Body_StopDash() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_StopDash(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Body_StopDash(const Body_StopDash& from);
  Body_StopDash(Body_StopDash&& from) noexcept
    : Body_StopDash() {
    *this = ::std::move(from);
  }

  inline Body_StopDash& operator=(const Body_StopDash& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_StopDash& operator=(Body_StopDash&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_StopDash& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_StopDash* internal_default_instance() {
    return reinterpret_cast<const Body_StopDash*>(
               &_Body_StopDash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(Body_StopDash& a, Body_StopDash& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_StopDash* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_StopDash* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_StopDash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_StopDash>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Body_StopDash& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Body_StopDash& from) {
    Body_StopDash::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Body_StopDash* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_StopDash";
  }
  protected:
  explicit Body_StopDash(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSaveRecoveryFieldNumber = 1,
  };
  // bool save_recovery = 1;
  void clear_save_recovery() ;
  bool save_recovery() const;
  void set_save_recovery(bool value);

  private:
  bool _internal_save_recovery() const;
  void _internal_set_save_recovery(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_StopDash)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool save_recovery_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_TackleToPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Body_TackleToPoint) */ {
 public:
  inline Body_TackleToPoint() : Body_TackleToPoint(nullptr) {}
  ~Body_TackleToPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_TackleToPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Body_TackleToPoint(const Body_TackleToPoint& from);
  Body_TackleToPoint(Body_TackleToPoint&& from) noexcept
    : Body_TackleToPoint() {
    *this = ::std::move(from);
  }

  inline Body_TackleToPoint& operator=(const Body_TackleToPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_TackleToPoint& operator=(Body_TackleToPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_TackleToPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_TackleToPoint* internal_default_instance() {
    return reinterpret_cast<const Body_TackleToPoint*>(
               &_Body_TackleToPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(Body_TackleToPoint& a, Body_TackleToPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_TackleToPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_TackleToPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_TackleToPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_TackleToPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Body_TackleToPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Body_TackleToPoint& from) {
    Body_TackleToPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Body_TackleToPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_TackleToPoint";
  }
  protected:
  explicit Body_TackleToPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kMinProbabilityFieldNumber = 2,
    kMinSpeedFieldNumber = 3,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* target_point);
  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();
  public:
  void unsafe_arena_set_allocated_target_point(
      ::protos::Vector2D* target_point);
  ::protos::Vector2D* unsafe_arena_release_target_point();
  // float min_probability = 2;
  void clear_min_probability() ;
  float min_probability() const;
  void set_min_probability(float value);

  private:
  float _internal_min_probability() const;
  void _internal_set_min_probability(float value);

  public:
  // float min_speed = 3;
  void clear_min_speed() ;
  float min_speed() const;
  void set_min_speed(float value);

  private:
  float _internal_min_speed() const;
  void _internal_set_min_speed(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_TackleToPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    float min_probability_;
    float min_speed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_TurnToAngle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Body_TurnToAngle) */ {
 public:
  inline Body_TurnToAngle() : Body_TurnToAngle(nullptr) {}
  ~Body_TurnToAngle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_TurnToAngle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Body_TurnToAngle(const Body_TurnToAngle& from);
  Body_TurnToAngle(Body_TurnToAngle&& from) noexcept
    : Body_TurnToAngle() {
    *this = ::std::move(from);
  }

  inline Body_TurnToAngle& operator=(const Body_TurnToAngle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_TurnToAngle& operator=(Body_TurnToAngle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_TurnToAngle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_TurnToAngle* internal_default_instance() {
    return reinterpret_cast<const Body_TurnToAngle*>(
               &_Body_TurnToAngle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(Body_TurnToAngle& a, Body_TurnToAngle& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_TurnToAngle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_TurnToAngle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_TurnToAngle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_TurnToAngle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Body_TurnToAngle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Body_TurnToAngle& from) {
    Body_TurnToAngle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Body_TurnToAngle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_TurnToAngle";
  }
  protected:
  explicit Body_TurnToAngle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAngleFieldNumber = 1,
  };
  // float angle = 1;
  void clear_angle() ;
  float angle() const;
  void set_angle(float value);

  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_TurnToAngle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float angle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_TurnToBall final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Body_TurnToBall) */ {
 public:
  inline Body_TurnToBall() : Body_TurnToBall(nullptr) {}
  ~Body_TurnToBall() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_TurnToBall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Body_TurnToBall(const Body_TurnToBall& from);
  Body_TurnToBall(Body_TurnToBall&& from) noexcept
    : Body_TurnToBall() {
    *this = ::std::move(from);
  }

  inline Body_TurnToBall& operator=(const Body_TurnToBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_TurnToBall& operator=(Body_TurnToBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_TurnToBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_TurnToBall* internal_default_instance() {
    return reinterpret_cast<const Body_TurnToBall*>(
               &_Body_TurnToBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(Body_TurnToBall& a, Body_TurnToBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_TurnToBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_TurnToBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_TurnToBall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_TurnToBall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Body_TurnToBall& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Body_TurnToBall& from) {
    Body_TurnToBall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Body_TurnToBall* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_TurnToBall";
  }
  protected:
  explicit Body_TurnToBall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCycleFieldNumber = 1,
  };
  // int32 cycle = 1;
  void clear_cycle() ;
  ::int32_t cycle() const;
  void set_cycle(::int32_t value);

  private:
  ::int32_t _internal_cycle() const;
  void _internal_set_cycle(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_TurnToBall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t cycle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_TurnToPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Body_TurnToPoint) */ {
 public:
  inline Body_TurnToPoint() : Body_TurnToPoint(nullptr) {}
  ~Body_TurnToPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_TurnToPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Body_TurnToPoint(const Body_TurnToPoint& from);
  Body_TurnToPoint(Body_TurnToPoint&& from) noexcept
    : Body_TurnToPoint() {
    *this = ::std::move(from);
  }

  inline Body_TurnToPoint& operator=(const Body_TurnToPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_TurnToPoint& operator=(Body_TurnToPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_TurnToPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_TurnToPoint* internal_default_instance() {
    return reinterpret_cast<const Body_TurnToPoint*>(
               &_Body_TurnToPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(Body_TurnToPoint& a, Body_TurnToPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_TurnToPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_TurnToPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_TurnToPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_TurnToPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Body_TurnToPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Body_TurnToPoint& from) {
    Body_TurnToPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Body_TurnToPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_TurnToPoint";
  }
  protected:
  explicit Body_TurnToPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kCycleFieldNumber = 2,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* target_point);
  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();
  public:
  void unsafe_arena_set_allocated_target_point(
      ::protos::Vector2D* target_point);
  ::protos::Vector2D* unsafe_arena_release_target_point();
  // int32 cycle = 2;
  void clear_cycle() ;
  ::int32_t cycle() const;
  void set_cycle(::int32_t value);

  private:
  ::int32_t _internal_cycle() const;
  void _internal_set_cycle(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_TurnToPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    ::int32_t cycle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Focus_MoveToPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Focus_MoveToPoint) */ {
 public:
  inline Focus_MoveToPoint() : Focus_MoveToPoint(nullptr) {}
  ~Focus_MoveToPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Focus_MoveToPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Focus_MoveToPoint(const Focus_MoveToPoint& from);
  Focus_MoveToPoint(Focus_MoveToPoint&& from) noexcept
    : Focus_MoveToPoint() {
    *this = ::std::move(from);
  }

  inline Focus_MoveToPoint& operator=(const Focus_MoveToPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Focus_MoveToPoint& operator=(Focus_MoveToPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Focus_MoveToPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Focus_MoveToPoint* internal_default_instance() {
    return reinterpret_cast<const Focus_MoveToPoint*>(
               &_Focus_MoveToPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(Focus_MoveToPoint& a, Focus_MoveToPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Focus_MoveToPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Focus_MoveToPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Focus_MoveToPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Focus_MoveToPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Focus_MoveToPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Focus_MoveToPoint& from) {
    Focus_MoveToPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Focus_MoveToPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Focus_MoveToPoint";
  }
  protected:
  explicit Focus_MoveToPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* target_point);
  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();
  public:
  void unsafe_arena_set_allocated_target_point(
      ::protos::Vector2D* target_point);
  ::protos::Vector2D* unsafe_arena_release_target_point();
  // @@protoc_insertion_point(class_scope:protos.Focus_MoveToPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Focus_Reset final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Focus_Reset) */ {
 public:
  inline Focus_Reset() : Focus_Reset(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Focus_Reset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Focus_Reset(const Focus_Reset& from);
  Focus_Reset(Focus_Reset&& from) noexcept
    : Focus_Reset() {
    *this = ::std::move(from);
  }

  inline Focus_Reset& operator=(const Focus_Reset& from) {
    CopyFrom(from);
    return *this;
  }
  inline Focus_Reset& operator=(Focus_Reset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Focus_Reset& default_instance() {
    return *internal_default_instance();
  }
  static inline const Focus_Reset* internal_default_instance() {
    return reinterpret_cast<const Focus_Reset*>(
               &_Focus_Reset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(Focus_Reset& a, Focus_Reset& b) {
    a.Swap(&b);
  }
  inline void Swap(Focus_Reset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Focus_Reset* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Focus_Reset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Focus_Reset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Focus_Reset& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Focus_Reset& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Focus_Reset";
  }
  protected:
  explicit Focus_Reset(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Focus_Reset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_ScanField final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Neck_ScanField) */ {
 public:
  inline Neck_ScanField() : Neck_ScanField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_ScanField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Neck_ScanField(const Neck_ScanField& from);
  Neck_ScanField(Neck_ScanField&& from) noexcept
    : Neck_ScanField() {
    *this = ::std::move(from);
  }

  inline Neck_ScanField& operator=(const Neck_ScanField& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_ScanField& operator=(Neck_ScanField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_ScanField& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_ScanField* internal_default_instance() {
    return reinterpret_cast<const Neck_ScanField*>(
               &_Neck_ScanField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(Neck_ScanField& a, Neck_ScanField& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_ScanField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_ScanField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_ScanField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_ScanField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Neck_ScanField& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Neck_ScanField& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_ScanField";
  }
  protected:
  explicit Neck_ScanField(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Neck_ScanField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_ScanPlayers final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Neck_ScanPlayers) */ {
 public:
  inline Neck_ScanPlayers() : Neck_ScanPlayers(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_ScanPlayers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Neck_ScanPlayers(const Neck_ScanPlayers& from);
  Neck_ScanPlayers(Neck_ScanPlayers&& from) noexcept
    : Neck_ScanPlayers() {
    *this = ::std::move(from);
  }

  inline Neck_ScanPlayers& operator=(const Neck_ScanPlayers& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_ScanPlayers& operator=(Neck_ScanPlayers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_ScanPlayers& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_ScanPlayers* internal_default_instance() {
    return reinterpret_cast<const Neck_ScanPlayers*>(
               &_Neck_ScanPlayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(Neck_ScanPlayers& a, Neck_ScanPlayers& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_ScanPlayers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_ScanPlayers* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_ScanPlayers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_ScanPlayers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Neck_ScanPlayers& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Neck_ScanPlayers& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_ScanPlayers";
  }
  protected:
  explicit Neck_ScanPlayers(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Neck_ScanPlayers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_TurnToBallAndPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Neck_TurnToBallAndPlayer) */ {
 public:
  inline Neck_TurnToBallAndPlayer() : Neck_TurnToBallAndPlayer(nullptr) {}
  ~Neck_TurnToBallAndPlayer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_TurnToBallAndPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Neck_TurnToBallAndPlayer(const Neck_TurnToBallAndPlayer& from);
  Neck_TurnToBallAndPlayer(Neck_TurnToBallAndPlayer&& from) noexcept
    : Neck_TurnToBallAndPlayer() {
    *this = ::std::move(from);
  }

  inline Neck_TurnToBallAndPlayer& operator=(const Neck_TurnToBallAndPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_TurnToBallAndPlayer& operator=(Neck_TurnToBallAndPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_TurnToBallAndPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_TurnToBallAndPlayer* internal_default_instance() {
    return reinterpret_cast<const Neck_TurnToBallAndPlayer*>(
               &_Neck_TurnToBallAndPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(Neck_TurnToBallAndPlayer& a, Neck_TurnToBallAndPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_TurnToBallAndPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_TurnToBallAndPlayer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_TurnToBallAndPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_TurnToBallAndPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Neck_TurnToBallAndPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Neck_TurnToBallAndPlayer& from) {
    Neck_TurnToBallAndPlayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Neck_TurnToBallAndPlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_TurnToBallAndPlayer";
  }
  protected:
  explicit Neck_TurnToBallAndPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSideFieldNumber = 1,
    kUniformNumberFieldNumber = 2,
    kCountThresholdFieldNumber = 3,
  };
  // .protos.Side side = 1;
  void clear_side() ;
  ::protos::Side side() const;
  void set_side(::protos::Side value);

  private:
  ::protos::Side _internal_side() const;
  void _internal_set_side(::protos::Side value);

  public:
  // int32 uniform_number = 2;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // int32 count_threshold = 3;
  void clear_count_threshold() ;
  ::int32_t count_threshold() const;
  void set_count_threshold(::int32_t value);

  private:
  ::int32_t _internal_count_threshold() const;
  void _internal_set_count_threshold(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Neck_TurnToBallAndPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int side_;
    ::int32_t uniform_number_;
    ::int32_t count_threshold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_TurnToBallOrScan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Neck_TurnToBallOrScan) */ {
 public:
  inline Neck_TurnToBallOrScan() : Neck_TurnToBallOrScan(nullptr) {}
  ~Neck_TurnToBallOrScan() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_TurnToBallOrScan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Neck_TurnToBallOrScan(const Neck_TurnToBallOrScan& from);
  Neck_TurnToBallOrScan(Neck_TurnToBallOrScan&& from) noexcept
    : Neck_TurnToBallOrScan() {
    *this = ::std::move(from);
  }

  inline Neck_TurnToBallOrScan& operator=(const Neck_TurnToBallOrScan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_TurnToBallOrScan& operator=(Neck_TurnToBallOrScan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_TurnToBallOrScan& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_TurnToBallOrScan* internal_default_instance() {
    return reinterpret_cast<const Neck_TurnToBallOrScan*>(
               &_Neck_TurnToBallOrScan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(Neck_TurnToBallOrScan& a, Neck_TurnToBallOrScan& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_TurnToBallOrScan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_TurnToBallOrScan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_TurnToBallOrScan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_TurnToBallOrScan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Neck_TurnToBallOrScan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Neck_TurnToBallOrScan& from) {
    Neck_TurnToBallOrScan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Neck_TurnToBallOrScan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_TurnToBallOrScan";
  }
  protected:
  explicit Neck_TurnToBallOrScan(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountThresholdFieldNumber = 1,
  };
  // int32 count_threshold = 1;
  void clear_count_threshold() ;
  ::int32_t count_threshold() const;
  void set_count_threshold(::int32_t value);

  private:
  ::int32_t _internal_count_threshold() const;
  void _internal_set_count_threshold(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Neck_TurnToBallOrScan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t count_threshold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_TurnToBall final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Neck_TurnToBall) */ {
 public:
  inline Neck_TurnToBall() : Neck_TurnToBall(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_TurnToBall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Neck_TurnToBall(const Neck_TurnToBall& from);
  Neck_TurnToBall(Neck_TurnToBall&& from) noexcept
    : Neck_TurnToBall() {
    *this = ::std::move(from);
  }

  inline Neck_TurnToBall& operator=(const Neck_TurnToBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_TurnToBall& operator=(Neck_TurnToBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_TurnToBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_TurnToBall* internal_default_instance() {
    return reinterpret_cast<const Neck_TurnToBall*>(
               &_Neck_TurnToBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(Neck_TurnToBall& a, Neck_TurnToBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_TurnToBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_TurnToBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_TurnToBall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_TurnToBall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Neck_TurnToBall& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Neck_TurnToBall& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_TurnToBall";
  }
  protected:
  explicit Neck_TurnToBall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Neck_TurnToBall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_TurnToGoalieOrScan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Neck_TurnToGoalieOrScan) */ {
 public:
  inline Neck_TurnToGoalieOrScan() : Neck_TurnToGoalieOrScan(nullptr) {}
  ~Neck_TurnToGoalieOrScan() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_TurnToGoalieOrScan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Neck_TurnToGoalieOrScan(const Neck_TurnToGoalieOrScan& from);
  Neck_TurnToGoalieOrScan(Neck_TurnToGoalieOrScan&& from) noexcept
    : Neck_TurnToGoalieOrScan() {
    *this = ::std::move(from);
  }

  inline Neck_TurnToGoalieOrScan& operator=(const Neck_TurnToGoalieOrScan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_TurnToGoalieOrScan& operator=(Neck_TurnToGoalieOrScan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_TurnToGoalieOrScan& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_TurnToGoalieOrScan* internal_default_instance() {
    return reinterpret_cast<const Neck_TurnToGoalieOrScan*>(
               &_Neck_TurnToGoalieOrScan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(Neck_TurnToGoalieOrScan& a, Neck_TurnToGoalieOrScan& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_TurnToGoalieOrScan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_TurnToGoalieOrScan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_TurnToGoalieOrScan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_TurnToGoalieOrScan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Neck_TurnToGoalieOrScan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Neck_TurnToGoalieOrScan& from) {
    Neck_TurnToGoalieOrScan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Neck_TurnToGoalieOrScan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_TurnToGoalieOrScan";
  }
  protected:
  explicit Neck_TurnToGoalieOrScan(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountThresholdFieldNumber = 1,
  };
  // int32 count_threshold = 1;
  void clear_count_threshold() ;
  ::int32_t count_threshold() const;
  void set_count_threshold(::int32_t value);

  private:
  ::int32_t _internal_count_threshold() const;
  void _internal_set_count_threshold(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Neck_TurnToGoalieOrScan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t count_threshold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_TurnToLowConfTeammate final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Neck_TurnToLowConfTeammate) */ {
 public:
  inline Neck_TurnToLowConfTeammate() : Neck_TurnToLowConfTeammate(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_TurnToLowConfTeammate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Neck_TurnToLowConfTeammate(const Neck_TurnToLowConfTeammate& from);
  Neck_TurnToLowConfTeammate(Neck_TurnToLowConfTeammate&& from) noexcept
    : Neck_TurnToLowConfTeammate() {
    *this = ::std::move(from);
  }

  inline Neck_TurnToLowConfTeammate& operator=(const Neck_TurnToLowConfTeammate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_TurnToLowConfTeammate& operator=(Neck_TurnToLowConfTeammate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_TurnToLowConfTeammate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_TurnToLowConfTeammate* internal_default_instance() {
    return reinterpret_cast<const Neck_TurnToLowConfTeammate*>(
               &_Neck_TurnToLowConfTeammate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(Neck_TurnToLowConfTeammate& a, Neck_TurnToLowConfTeammate& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_TurnToLowConfTeammate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_TurnToLowConfTeammate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_TurnToLowConfTeammate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_TurnToLowConfTeammate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Neck_TurnToLowConfTeammate& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Neck_TurnToLowConfTeammate& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_TurnToLowConfTeammate";
  }
  protected:
  explicit Neck_TurnToLowConfTeammate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Neck_TurnToLowConfTeammate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_TurnToPlayerOrScan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Neck_TurnToPlayerOrScan) */ {
 public:
  inline Neck_TurnToPlayerOrScan() : Neck_TurnToPlayerOrScan(nullptr) {}
  ~Neck_TurnToPlayerOrScan() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_TurnToPlayerOrScan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Neck_TurnToPlayerOrScan(const Neck_TurnToPlayerOrScan& from);
  Neck_TurnToPlayerOrScan(Neck_TurnToPlayerOrScan&& from) noexcept
    : Neck_TurnToPlayerOrScan() {
    *this = ::std::move(from);
  }

  inline Neck_TurnToPlayerOrScan& operator=(const Neck_TurnToPlayerOrScan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_TurnToPlayerOrScan& operator=(Neck_TurnToPlayerOrScan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_TurnToPlayerOrScan& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_TurnToPlayerOrScan* internal_default_instance() {
    return reinterpret_cast<const Neck_TurnToPlayerOrScan*>(
               &_Neck_TurnToPlayerOrScan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(Neck_TurnToPlayerOrScan& a, Neck_TurnToPlayerOrScan& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_TurnToPlayerOrScan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_TurnToPlayerOrScan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_TurnToPlayerOrScan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_TurnToPlayerOrScan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Neck_TurnToPlayerOrScan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Neck_TurnToPlayerOrScan& from) {
    Neck_TurnToPlayerOrScan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Neck_TurnToPlayerOrScan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_TurnToPlayerOrScan";
  }
  protected:
  explicit Neck_TurnToPlayerOrScan(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSideFieldNumber = 1,
    kUniformNumberFieldNumber = 2,
    kCountThresholdFieldNumber = 3,
  };
  // .protos.Side side = 1;
  void clear_side() ;
  ::protos::Side side() const;
  void set_side(::protos::Side value);

  private:
  ::protos::Side _internal_side() const;
  void _internal_set_side(::protos::Side value);

  public:
  // int32 uniform_number = 2;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // int32 count_threshold = 3;
  void clear_count_threshold() ;
  ::int32_t count_threshold() const;
  void set_count_threshold(::int32_t value);

  private:
  ::int32_t _internal_count_threshold() const;
  void _internal_set_count_threshold(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Neck_TurnToPlayerOrScan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int side_;
    ::int32_t uniform_number_;
    ::int32_t count_threshold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_TurnToPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Neck_TurnToPoint) */ {
 public:
  inline Neck_TurnToPoint() : Neck_TurnToPoint(nullptr) {}
  ~Neck_TurnToPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_TurnToPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Neck_TurnToPoint(const Neck_TurnToPoint& from);
  Neck_TurnToPoint(Neck_TurnToPoint&& from) noexcept
    : Neck_TurnToPoint() {
    *this = ::std::move(from);
  }

  inline Neck_TurnToPoint& operator=(const Neck_TurnToPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_TurnToPoint& operator=(Neck_TurnToPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_TurnToPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_TurnToPoint* internal_default_instance() {
    return reinterpret_cast<const Neck_TurnToPoint*>(
               &_Neck_TurnToPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(Neck_TurnToPoint& a, Neck_TurnToPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_TurnToPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_TurnToPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_TurnToPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_TurnToPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Neck_TurnToPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Neck_TurnToPoint& from) {
    Neck_TurnToPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Neck_TurnToPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_TurnToPoint";
  }
  protected:
  explicit Neck_TurnToPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* target_point);
  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();
  public:
  void unsafe_arena_set_allocated_target_point(
      ::protos::Vector2D* target_point);
  ::protos::Vector2D* unsafe_arena_release_target_point();
  // @@protoc_insertion_point(class_scope:protos.Neck_TurnToPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_TurnToRelative final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Neck_TurnToRelative) */ {
 public:
  inline Neck_TurnToRelative() : Neck_TurnToRelative(nullptr) {}
  ~Neck_TurnToRelative() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_TurnToRelative(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Neck_TurnToRelative(const Neck_TurnToRelative& from);
  Neck_TurnToRelative(Neck_TurnToRelative&& from) noexcept
    : Neck_TurnToRelative() {
    *this = ::std::move(from);
  }

  inline Neck_TurnToRelative& operator=(const Neck_TurnToRelative& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_TurnToRelative& operator=(Neck_TurnToRelative&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_TurnToRelative& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_TurnToRelative* internal_default_instance() {
    return reinterpret_cast<const Neck_TurnToRelative*>(
               &_Neck_TurnToRelative_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(Neck_TurnToRelative& a, Neck_TurnToRelative& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_TurnToRelative* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_TurnToRelative* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_TurnToRelative* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_TurnToRelative>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Neck_TurnToRelative& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Neck_TurnToRelative& from) {
    Neck_TurnToRelative::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Neck_TurnToRelative* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_TurnToRelative";
  }
  protected:
  explicit Neck_TurnToRelative(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAngleFieldNumber = 1,
  };
  // float angle = 1;
  void clear_angle() ;
  float angle() const;
  void set_angle(float value);

  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Neck_TurnToRelative)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float angle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class View_ChangeWidth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.View_ChangeWidth) */ {
 public:
  inline View_ChangeWidth() : View_ChangeWidth(nullptr) {}
  ~View_ChangeWidth() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR View_ChangeWidth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  View_ChangeWidth(const View_ChangeWidth& from);
  View_ChangeWidth(View_ChangeWidth&& from) noexcept
    : View_ChangeWidth() {
    *this = ::std::move(from);
  }

  inline View_ChangeWidth& operator=(const View_ChangeWidth& from) {
    CopyFrom(from);
    return *this;
  }
  inline View_ChangeWidth& operator=(View_ChangeWidth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const View_ChangeWidth& default_instance() {
    return *internal_default_instance();
  }
  static inline const View_ChangeWidth* internal_default_instance() {
    return reinterpret_cast<const View_ChangeWidth*>(
               &_View_ChangeWidth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(View_ChangeWidth& a, View_ChangeWidth& b) {
    a.Swap(&b);
  }
  inline void Swap(View_ChangeWidth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(View_ChangeWidth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  View_ChangeWidth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<View_ChangeWidth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const View_ChangeWidth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const View_ChangeWidth& from) {
    View_ChangeWidth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(View_ChangeWidth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.View_ChangeWidth";
  }
  protected:
  explicit View_ChangeWidth(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewWidthFieldNumber = 1,
  };
  // .protos.ViewWidth view_width = 1;
  void clear_view_width() ;
  ::protos::ViewWidth view_width() const;
  void set_view_width(::protos::ViewWidth value);

  private:
  ::protos::ViewWidth _internal_view_width() const;
  void _internal_set_view_width(::protos::ViewWidth value);

  public:
  // @@protoc_insertion_point(class_scope:protos.View_ChangeWidth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int view_width_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class View_Normal final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.View_Normal) */ {
 public:
  inline View_Normal() : View_Normal(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR View_Normal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  View_Normal(const View_Normal& from);
  View_Normal(View_Normal&& from) noexcept
    : View_Normal() {
    *this = ::std::move(from);
  }

  inline View_Normal& operator=(const View_Normal& from) {
    CopyFrom(from);
    return *this;
  }
  inline View_Normal& operator=(View_Normal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const View_Normal& default_instance() {
    return *internal_default_instance();
  }
  static inline const View_Normal* internal_default_instance() {
    return reinterpret_cast<const View_Normal*>(
               &_View_Normal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(View_Normal& a, View_Normal& b) {
    a.Swap(&b);
  }
  inline void Swap(View_Normal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(View_Normal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  View_Normal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<View_Normal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const View_Normal& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const View_Normal& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.View_Normal";
  }
  protected:
  explicit View_Normal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.View_Normal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class View_Synch final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.View_Synch) */ {
 public:
  inline View_Synch() : View_Synch(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR View_Synch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  View_Synch(const View_Synch& from);
  View_Synch(View_Synch&& from) noexcept
    : View_Synch() {
    *this = ::std::move(from);
  }

  inline View_Synch& operator=(const View_Synch& from) {
    CopyFrom(from);
    return *this;
  }
  inline View_Synch& operator=(View_Synch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const View_Synch& default_instance() {
    return *internal_default_instance();
  }
  static inline const View_Synch* internal_default_instance() {
    return reinterpret_cast<const View_Synch*>(
               &_View_Synch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(View_Synch& a, View_Synch& b) {
    a.Swap(&b);
  }
  inline void Swap(View_Synch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(View_Synch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  View_Synch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<View_Synch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const View_Synch& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const View_Synch& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.View_Synch";
  }
  protected:
  explicit View_Synch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.View_Synch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class View_Wide final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.View_Wide) */ {
 public:
  inline View_Wide() : View_Wide(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR View_Wide(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  View_Wide(const View_Wide& from);
  View_Wide(View_Wide&& from) noexcept
    : View_Wide() {
    *this = ::std::move(from);
  }

  inline View_Wide& operator=(const View_Wide& from) {
    CopyFrom(from);
    return *this;
  }
  inline View_Wide& operator=(View_Wide&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const View_Wide& default_instance() {
    return *internal_default_instance();
  }
  static inline const View_Wide* internal_default_instance() {
    return reinterpret_cast<const View_Wide*>(
               &_View_Wide_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(View_Wide& a, View_Wide& b) {
    a.Swap(&b);
  }
  inline void Swap(View_Wide* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(View_Wide* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  View_Wide* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<View_Wide>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const View_Wide& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const View_Wide& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.View_Wide";
  }
  protected:
  explicit View_Wide(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.View_Wide)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Action final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Action) */ {
 public:
  inline Action() : Action(nullptr) {}
  ~Action() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Action(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Action(const Action& from);
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action& operator=(Action&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Action& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kDash = 1,
    kTurn = 2,
    kKick = 3,
    kTackle = 4,
    kCatch = 5,
    kMove = 6,
    kTurnNeck = 7,
    kChangeView = 8,
    kSay = 9,
    kPointTo = 10,
    kPointToOf = 11,
    kAttentionTo = 12,
    kAttentionToOf = 13,
    kLog = 14,
    kDebugClient = 15,
    kBodyGoToPoint = 16,
    kBodySmartKick = 17,
    kBhvBeforeKickOff = 18,
    kBhvBodyNeckToBall = 19,
    kBhvBodyNeckToPoint = 20,
    kBhvEmergency = 21,
    kBhvGoToPointLookBall = 22,
    kBhvNeckBodyToBall = 23,
    kBhvNeckBodyToPoint = 24,
    kBhvScanField = 25,
    kBodyAdvanceBall = 26,
    kBodyClearBall = 27,
    kBodyDribble = 28,
    kBodyGoToPointDodge = 29,
    kBodyHoldBall = 30,
    kBodyIntercept = 31,
    kBodyKickOneStep = 32,
    kBodyStopBall = 33,
    kBodyStopDash = 34,
    kBodyTackleToPoint = 35,
    kBodyTurnToAngle = 36,
    kBodyTurnToBall = 37,
    kBodyTurnToPoint = 38,
    kFocusMoveToPoint = 39,
    kFocusReset = 40,
    kNeckScanField = 41,
    kNeckScanPlayers = 42,
    kNeckTurnToBallAndPlayer = 43,
    kNeckTurnToBallOrScan = 44,
    kNeckTurnToBall = 45,
    kNeckTurnToGoalieOrScan = 46,
    kNeckTurnToLowConfTeammate = 47,
    kNeckTurnToPlayerOrScan = 48,
    kNeckTurnToPoint = 49,
    kNeckTurnToRelative = 50,
    kViewChangeWidth = 51,
    kViewNormal = 52,
    kViewSynch = 53,
    kViewWide = 54,
    ACTION_NOT_SET = 0,
  };

  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }
  inline void Swap(Action* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Action& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Action& from) {
    Action::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Action";
  }
  protected:
  explicit Action(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDashFieldNumber = 1,
    kTurnFieldNumber = 2,
    kKickFieldNumber = 3,
    kTackleFieldNumber = 4,
    kCatchFieldNumber = 5,
    kMoveFieldNumber = 6,
    kTurnNeckFieldNumber = 7,
    kChangeViewFieldNumber = 8,
    kSayFieldNumber = 9,
    kPointToFieldNumber = 10,
    kPointToOfFieldNumber = 11,
    kAttentionToFieldNumber = 12,
    kAttentionToOfFieldNumber = 13,
    kLogFieldNumber = 14,
    kDebugClientFieldNumber = 15,
    kBodyGoToPointFieldNumber = 16,
    kBodySmartKickFieldNumber = 17,
    kBhvBeforeKickOffFieldNumber = 18,
    kBhvBodyNeckToBallFieldNumber = 19,
    kBhvBodyNeckToPointFieldNumber = 20,
    kBhvEmergencyFieldNumber = 21,
    kBhvGoToPointLookBallFieldNumber = 22,
    kBhvNeckBodyToBallFieldNumber = 23,
    kBhvNeckBodyToPointFieldNumber = 24,
    kBhvScanFieldFieldNumber = 25,
    kBodyAdvanceBallFieldNumber = 26,
    kBodyClearBallFieldNumber = 27,
    kBodyDribbleFieldNumber = 28,
    kBodyGoToPointDodgeFieldNumber = 29,
    kBodyHoldBallFieldNumber = 30,
    kBodyInterceptFieldNumber = 31,
    kBodyKickOneStepFieldNumber = 32,
    kBodyStopBallFieldNumber = 33,
    kBodyStopDashFieldNumber = 34,
    kBodyTackleToPointFieldNumber = 35,
    kBodyTurnToAngleFieldNumber = 36,
    kBodyTurnToBallFieldNumber = 37,
    kBodyTurnToPointFieldNumber = 38,
    kFocusMoveToPointFieldNumber = 39,
    kFocusResetFieldNumber = 40,
    kNeckScanFieldFieldNumber = 41,
    kNeckScanPlayersFieldNumber = 42,
    kNeckTurnToBallAndPlayerFieldNumber = 43,
    kNeckTurnToBallOrScanFieldNumber = 44,
    kNeckTurnToBallFieldNumber = 45,
    kNeckTurnToGoalieOrScanFieldNumber = 46,
    kNeckTurnToLowConfTeammateFieldNumber = 47,
    kNeckTurnToPlayerOrScanFieldNumber = 48,
    kNeckTurnToPointFieldNumber = 49,
    kNeckTurnToRelativeFieldNumber = 50,
    kViewChangeWidthFieldNumber = 51,
    kViewNormalFieldNumber = 52,
    kViewSynchFieldNumber = 53,
    kViewWideFieldNumber = 54,
  };
  // .protos.Dash dash = 1;
  bool has_dash() const;
  private:
  bool _internal_has_dash() const;

  public:
  void clear_dash() ;
  const ::protos::Dash& dash() const;
  PROTOBUF_NODISCARD ::protos::Dash* release_dash();
  ::protos::Dash* mutable_dash();
  void set_allocated_dash(::protos::Dash* dash);
  private:
  const ::protos::Dash& _internal_dash() const;
  ::protos::Dash* _internal_mutable_dash();
  public:
  void unsafe_arena_set_allocated_dash(
      ::protos::Dash* dash);
  ::protos::Dash* unsafe_arena_release_dash();
  // .protos.Turn turn = 2;
  bool has_turn() const;
  private:
  bool _internal_has_turn() const;

  public:
  void clear_turn() ;
  const ::protos::Turn& turn() const;
  PROTOBUF_NODISCARD ::protos::Turn* release_turn();
  ::protos::Turn* mutable_turn();
  void set_allocated_turn(::protos::Turn* turn);
  private:
  const ::protos::Turn& _internal_turn() const;
  ::protos::Turn* _internal_mutable_turn();
  public:
  void unsafe_arena_set_allocated_turn(
      ::protos::Turn* turn);
  ::protos::Turn* unsafe_arena_release_turn();
  // .protos.Kick kick = 3;
  bool has_kick() const;
  private:
  bool _internal_has_kick() const;

  public:
  void clear_kick() ;
  const ::protos::Kick& kick() const;
  PROTOBUF_NODISCARD ::protos::Kick* release_kick();
  ::protos::Kick* mutable_kick();
  void set_allocated_kick(::protos::Kick* kick);
  private:
  const ::protos::Kick& _internal_kick() const;
  ::protos::Kick* _internal_mutable_kick();
  public:
  void unsafe_arena_set_allocated_kick(
      ::protos::Kick* kick);
  ::protos::Kick* unsafe_arena_release_kick();
  // .protos.Tackle tackle = 4;
  bool has_tackle() const;
  private:
  bool _internal_has_tackle() const;

  public:
  void clear_tackle() ;
  const ::protos::Tackle& tackle() const;
  PROTOBUF_NODISCARD ::protos::Tackle* release_tackle();
  ::protos::Tackle* mutable_tackle();
  void set_allocated_tackle(::protos::Tackle* tackle);
  private:
  const ::protos::Tackle& _internal_tackle() const;
  ::protos::Tackle* _internal_mutable_tackle();
  public:
  void unsafe_arena_set_allocated_tackle(
      ::protos::Tackle* tackle);
  ::protos::Tackle* unsafe_arena_release_tackle();
  // .protos.Catch catch = 5;
  bool has_catch_() const;
  private:
  bool _internal_has_catch_() const;

  public:
  void clear_catch_() ;
  const ::protos::Catch& catch_() const;
  PROTOBUF_NODISCARD ::protos::Catch* release_catch_();
  ::protos::Catch* mutable_catch_();
  void set_allocated_catch_(::protos::Catch* catch_);
  private:
  const ::protos::Catch& _internal_catch_() const;
  ::protos::Catch* _internal_mutable_catch_();
  public:
  void unsafe_arena_set_allocated_catch_(
      ::protos::Catch* catch_);
  ::protos::Catch* unsafe_arena_release_catch_();
  // .protos.Move move = 6;
  bool has_move() const;
  private:
  bool _internal_has_move() const;

  public:
  void clear_move() ;
  const ::protos::Move& move() const;
  PROTOBUF_NODISCARD ::protos::Move* release_move();
  ::protos::Move* mutable_move();
  void set_allocated_move(::protos::Move* move);
  private:
  const ::protos::Move& _internal_move() const;
  ::protos::Move* _internal_mutable_move();
  public:
  void unsafe_arena_set_allocated_move(
      ::protos::Move* move);
  ::protos::Move* unsafe_arena_release_move();
  // .protos.TurnNeck turn_neck = 7;
  bool has_turn_neck() const;
  private:
  bool _internal_has_turn_neck() const;

  public:
  void clear_turn_neck() ;
  const ::protos::TurnNeck& turn_neck() const;
  PROTOBUF_NODISCARD ::protos::TurnNeck* release_turn_neck();
  ::protos::TurnNeck* mutable_turn_neck();
  void set_allocated_turn_neck(::protos::TurnNeck* turn_neck);
  private:
  const ::protos::TurnNeck& _internal_turn_neck() const;
  ::protos::TurnNeck* _internal_mutable_turn_neck();
  public:
  void unsafe_arena_set_allocated_turn_neck(
      ::protos::TurnNeck* turn_neck);
  ::protos::TurnNeck* unsafe_arena_release_turn_neck();
  // .protos.ChangeView change_view = 8;
  bool has_change_view() const;
  private:
  bool _internal_has_change_view() const;

  public:
  void clear_change_view() ;
  const ::protos::ChangeView& change_view() const;
  PROTOBUF_NODISCARD ::protos::ChangeView* release_change_view();
  ::protos::ChangeView* mutable_change_view();
  void set_allocated_change_view(::protos::ChangeView* change_view);
  private:
  const ::protos::ChangeView& _internal_change_view() const;
  ::protos::ChangeView* _internal_mutable_change_view();
  public:
  void unsafe_arena_set_allocated_change_view(
      ::protos::ChangeView* change_view);
  ::protos::ChangeView* unsafe_arena_release_change_view();
  // .protos.Say say = 9;
  bool has_say() const;
  private:
  bool _internal_has_say() const;

  public:
  void clear_say() ;
  const ::protos::Say& say() const;
  PROTOBUF_NODISCARD ::protos::Say* release_say();
  ::protos::Say* mutable_say();
  void set_allocated_say(::protos::Say* say);
  private:
  const ::protos::Say& _internal_say() const;
  ::protos::Say* _internal_mutable_say();
  public:
  void unsafe_arena_set_allocated_say(
      ::protos::Say* say);
  ::protos::Say* unsafe_arena_release_say();
  // .protos.PointTo point_to = 10;
  bool has_point_to() const;
  private:
  bool _internal_has_point_to() const;

  public:
  void clear_point_to() ;
  const ::protos::PointTo& point_to() const;
  PROTOBUF_NODISCARD ::protos::PointTo* release_point_to();
  ::protos::PointTo* mutable_point_to();
  void set_allocated_point_to(::protos::PointTo* point_to);
  private:
  const ::protos::PointTo& _internal_point_to() const;
  ::protos::PointTo* _internal_mutable_point_to();
  public:
  void unsafe_arena_set_allocated_point_to(
      ::protos::PointTo* point_to);
  ::protos::PointTo* unsafe_arena_release_point_to();
  // .protos.PointToOf point_to_of = 11;
  bool has_point_to_of() const;
  private:
  bool _internal_has_point_to_of() const;

  public:
  void clear_point_to_of() ;
  const ::protos::PointToOf& point_to_of() const;
  PROTOBUF_NODISCARD ::protos::PointToOf* release_point_to_of();
  ::protos::PointToOf* mutable_point_to_of();
  void set_allocated_point_to_of(::protos::PointToOf* point_to_of);
  private:
  const ::protos::PointToOf& _internal_point_to_of() const;
  ::protos::PointToOf* _internal_mutable_point_to_of();
  public:
  void unsafe_arena_set_allocated_point_to_of(
      ::protos::PointToOf* point_to_of);
  ::protos::PointToOf* unsafe_arena_release_point_to_of();
  // .protos.AttentionTo attention_to = 12;
  bool has_attention_to() const;
  private:
  bool _internal_has_attention_to() const;

  public:
  void clear_attention_to() ;
  const ::protos::AttentionTo& attention_to() const;
  PROTOBUF_NODISCARD ::protos::AttentionTo* release_attention_to();
  ::protos::AttentionTo* mutable_attention_to();
  void set_allocated_attention_to(::protos::AttentionTo* attention_to);
  private:
  const ::protos::AttentionTo& _internal_attention_to() const;
  ::protos::AttentionTo* _internal_mutable_attention_to();
  public:
  void unsafe_arena_set_allocated_attention_to(
      ::protos::AttentionTo* attention_to);
  ::protos::AttentionTo* unsafe_arena_release_attention_to();
  // .protos.AttentionToOf attention_to_of = 13;
  bool has_attention_to_of() const;
  private:
  bool _internal_has_attention_to_of() const;

  public:
  void clear_attention_to_of() ;
  const ::protos::AttentionToOf& attention_to_of() const;
  PROTOBUF_NODISCARD ::protos::AttentionToOf* release_attention_to_of();
  ::protos::AttentionToOf* mutable_attention_to_of();
  void set_allocated_attention_to_of(::protos::AttentionToOf* attention_to_of);
  private:
  const ::protos::AttentionToOf& _internal_attention_to_of() const;
  ::protos::AttentionToOf* _internal_mutable_attention_to_of();
  public:
  void unsafe_arena_set_allocated_attention_to_of(
      ::protos::AttentionToOf* attention_to_of);
  ::protos::AttentionToOf* unsafe_arena_release_attention_to_of();
  // .protos.Log log = 14;
  bool has_log() const;
  private:
  bool _internal_has_log() const;

  public:
  void clear_log() ;
  const ::protos::Log& log() const;
  PROTOBUF_NODISCARD ::protos::Log* release_log();
  ::protos::Log* mutable_log();
  void set_allocated_log(::protos::Log* log);
  private:
  const ::protos::Log& _internal_log() const;
  ::protos::Log* _internal_mutable_log();
  public:
  void unsafe_arena_set_allocated_log(
      ::protos::Log* log);
  ::protos::Log* unsafe_arena_release_log();
  // .protos.DebugClient debug_client = 15;
  bool has_debug_client() const;
  private:
  bool _internal_has_debug_client() const;

  public:
  void clear_debug_client() ;
  const ::protos::DebugClient& debug_client() const;
  PROTOBUF_NODISCARD ::protos::DebugClient* release_debug_client();
  ::protos::DebugClient* mutable_debug_client();
  void set_allocated_debug_client(::protos::DebugClient* debug_client);
  private:
  const ::protos::DebugClient& _internal_debug_client() const;
  ::protos::DebugClient* _internal_mutable_debug_client();
  public:
  void unsafe_arena_set_allocated_debug_client(
      ::protos::DebugClient* debug_client);
  ::protos::DebugClient* unsafe_arena_release_debug_client();
  // .protos.Body_GoToPoint body_go_to_point = 16;
  bool has_body_go_to_point() const;
  private:
  bool _internal_has_body_go_to_point() const;

  public:
  void clear_body_go_to_point() ;
  const ::protos::Body_GoToPoint& body_go_to_point() const;
  PROTOBUF_NODISCARD ::protos::Body_GoToPoint* release_body_go_to_point();
  ::protos::Body_GoToPoint* mutable_body_go_to_point();
  void set_allocated_body_go_to_point(::protos::Body_GoToPoint* body_go_to_point);
  private:
  const ::protos::Body_GoToPoint& _internal_body_go_to_point() const;
  ::protos::Body_GoToPoint* _internal_mutable_body_go_to_point();
  public:
  void unsafe_arena_set_allocated_body_go_to_point(
      ::protos::Body_GoToPoint* body_go_to_point);
  ::protos::Body_GoToPoint* unsafe_arena_release_body_go_to_point();
  // .protos.Body_SmartKick body_smart_kick = 17;
  bool has_body_smart_kick() const;
  private:
  bool _internal_has_body_smart_kick() const;

  public:
  void clear_body_smart_kick() ;
  const ::protos::Body_SmartKick& body_smart_kick() const;
  PROTOBUF_NODISCARD ::protos::Body_SmartKick* release_body_smart_kick();
  ::protos::Body_SmartKick* mutable_body_smart_kick();
  void set_allocated_body_smart_kick(::protos::Body_SmartKick* body_smart_kick);
  private:
  const ::protos::Body_SmartKick& _internal_body_smart_kick() const;
  ::protos::Body_SmartKick* _internal_mutable_body_smart_kick();
  public:
  void unsafe_arena_set_allocated_body_smart_kick(
      ::protos::Body_SmartKick* body_smart_kick);
  ::protos::Body_SmartKick* unsafe_arena_release_body_smart_kick();
  // .protos.Bhv_BeforeKickOff bhv_before_kick_off = 18;
  bool has_bhv_before_kick_off() const;
  private:
  bool _internal_has_bhv_before_kick_off() const;

  public:
  void clear_bhv_before_kick_off() ;
  const ::protos::Bhv_BeforeKickOff& bhv_before_kick_off() const;
  PROTOBUF_NODISCARD ::protos::Bhv_BeforeKickOff* release_bhv_before_kick_off();
  ::protos::Bhv_BeforeKickOff* mutable_bhv_before_kick_off();
  void set_allocated_bhv_before_kick_off(::protos::Bhv_BeforeKickOff* bhv_before_kick_off);
  private:
  const ::protos::Bhv_BeforeKickOff& _internal_bhv_before_kick_off() const;
  ::protos::Bhv_BeforeKickOff* _internal_mutable_bhv_before_kick_off();
  public:
  void unsafe_arena_set_allocated_bhv_before_kick_off(
      ::protos::Bhv_BeforeKickOff* bhv_before_kick_off);
  ::protos::Bhv_BeforeKickOff* unsafe_arena_release_bhv_before_kick_off();
  // .protos.Bhv_BodyNeckToBall bhv_body_neck_to_ball = 19;
  bool has_bhv_body_neck_to_ball() const;
  private:
  bool _internal_has_bhv_body_neck_to_ball() const;

  public:
  void clear_bhv_body_neck_to_ball() ;
  const ::protos::Bhv_BodyNeckToBall& bhv_body_neck_to_ball() const;
  PROTOBUF_NODISCARD ::protos::Bhv_BodyNeckToBall* release_bhv_body_neck_to_ball();
  ::protos::Bhv_BodyNeckToBall* mutable_bhv_body_neck_to_ball();
  void set_allocated_bhv_body_neck_to_ball(::protos::Bhv_BodyNeckToBall* bhv_body_neck_to_ball);
  private:
  const ::protos::Bhv_BodyNeckToBall& _internal_bhv_body_neck_to_ball() const;
  ::protos::Bhv_BodyNeckToBall* _internal_mutable_bhv_body_neck_to_ball();
  public:
  void unsafe_arena_set_allocated_bhv_body_neck_to_ball(
      ::protos::Bhv_BodyNeckToBall* bhv_body_neck_to_ball);
  ::protos::Bhv_BodyNeckToBall* unsafe_arena_release_bhv_body_neck_to_ball();
  // .protos.Bhv_BodyNeckToPoint bhv_body_neck_to_point = 20;
  bool has_bhv_body_neck_to_point() const;
  private:
  bool _internal_has_bhv_body_neck_to_point() const;

  public:
  void clear_bhv_body_neck_to_point() ;
  const ::protos::Bhv_BodyNeckToPoint& bhv_body_neck_to_point() const;
  PROTOBUF_NODISCARD ::protos::Bhv_BodyNeckToPoint* release_bhv_body_neck_to_point();
  ::protos::Bhv_BodyNeckToPoint* mutable_bhv_body_neck_to_point();
  void set_allocated_bhv_body_neck_to_point(::protos::Bhv_BodyNeckToPoint* bhv_body_neck_to_point);
  private:
  const ::protos::Bhv_BodyNeckToPoint& _internal_bhv_body_neck_to_point() const;
  ::protos::Bhv_BodyNeckToPoint* _internal_mutable_bhv_body_neck_to_point();
  public:
  void unsafe_arena_set_allocated_bhv_body_neck_to_point(
      ::protos::Bhv_BodyNeckToPoint* bhv_body_neck_to_point);
  ::protos::Bhv_BodyNeckToPoint* unsafe_arena_release_bhv_body_neck_to_point();
  // .protos.Bhv_Emergency bhv_emergency = 21;
  bool has_bhv_emergency() const;
  private:
  bool _internal_has_bhv_emergency() const;

  public:
  void clear_bhv_emergency() ;
  const ::protos::Bhv_Emergency& bhv_emergency() const;
  PROTOBUF_NODISCARD ::protos::Bhv_Emergency* release_bhv_emergency();
  ::protos::Bhv_Emergency* mutable_bhv_emergency();
  void set_allocated_bhv_emergency(::protos::Bhv_Emergency* bhv_emergency);
  private:
  const ::protos::Bhv_Emergency& _internal_bhv_emergency() const;
  ::protos::Bhv_Emergency* _internal_mutable_bhv_emergency();
  public:
  void unsafe_arena_set_allocated_bhv_emergency(
      ::protos::Bhv_Emergency* bhv_emergency);
  ::protos::Bhv_Emergency* unsafe_arena_release_bhv_emergency();
  // .protos.Bhv_GoToPointLookBall bhv_go_to_point_look_ball = 22;
  bool has_bhv_go_to_point_look_ball() const;
  private:
  bool _internal_has_bhv_go_to_point_look_ball() const;

  public:
  void clear_bhv_go_to_point_look_ball() ;
  const ::protos::Bhv_GoToPointLookBall& bhv_go_to_point_look_ball() const;
  PROTOBUF_NODISCARD ::protos::Bhv_GoToPointLookBall* release_bhv_go_to_point_look_ball();
  ::protos::Bhv_GoToPointLookBall* mutable_bhv_go_to_point_look_ball();
  void set_allocated_bhv_go_to_point_look_ball(::protos::Bhv_GoToPointLookBall* bhv_go_to_point_look_ball);
  private:
  const ::protos::Bhv_GoToPointLookBall& _internal_bhv_go_to_point_look_ball() const;
  ::protos::Bhv_GoToPointLookBall* _internal_mutable_bhv_go_to_point_look_ball();
  public:
  void unsafe_arena_set_allocated_bhv_go_to_point_look_ball(
      ::protos::Bhv_GoToPointLookBall* bhv_go_to_point_look_ball);
  ::protos::Bhv_GoToPointLookBall* unsafe_arena_release_bhv_go_to_point_look_ball();
  // .protos.Bhv_NeckBodyToBall bhv_neck_body_to_ball = 23;
  bool has_bhv_neck_body_to_ball() const;
  private:
  bool _internal_has_bhv_neck_body_to_ball() const;

  public:
  void clear_bhv_neck_body_to_ball() ;
  const ::protos::Bhv_NeckBodyToBall& bhv_neck_body_to_ball() const;
  PROTOBUF_NODISCARD ::protos::Bhv_NeckBodyToBall* release_bhv_neck_body_to_ball();
  ::protos::Bhv_NeckBodyToBall* mutable_bhv_neck_body_to_ball();
  void set_allocated_bhv_neck_body_to_ball(::protos::Bhv_NeckBodyToBall* bhv_neck_body_to_ball);
  private:
  const ::protos::Bhv_NeckBodyToBall& _internal_bhv_neck_body_to_ball() const;
  ::protos::Bhv_NeckBodyToBall* _internal_mutable_bhv_neck_body_to_ball();
  public:
  void unsafe_arena_set_allocated_bhv_neck_body_to_ball(
      ::protos::Bhv_NeckBodyToBall* bhv_neck_body_to_ball);
  ::protos::Bhv_NeckBodyToBall* unsafe_arena_release_bhv_neck_body_to_ball();
  // .protos.Bhv_NeckBodyToPoint bhv_neck_body_to_point = 24;
  bool has_bhv_neck_body_to_point() const;
  private:
  bool _internal_has_bhv_neck_body_to_point() const;

  public:
  void clear_bhv_neck_body_to_point() ;
  const ::protos::Bhv_NeckBodyToPoint& bhv_neck_body_to_point() const;
  PROTOBUF_NODISCARD ::protos::Bhv_NeckBodyToPoint* release_bhv_neck_body_to_point();
  ::protos::Bhv_NeckBodyToPoint* mutable_bhv_neck_body_to_point();
  void set_allocated_bhv_neck_body_to_point(::protos::Bhv_NeckBodyToPoint* bhv_neck_body_to_point);
  private:
  const ::protos::Bhv_NeckBodyToPoint& _internal_bhv_neck_body_to_point() const;
  ::protos::Bhv_NeckBodyToPoint* _internal_mutable_bhv_neck_body_to_point();
  public:
  void unsafe_arena_set_allocated_bhv_neck_body_to_point(
      ::protos::Bhv_NeckBodyToPoint* bhv_neck_body_to_point);
  ::protos::Bhv_NeckBodyToPoint* unsafe_arena_release_bhv_neck_body_to_point();
  // .protos.Bhv_ScanField bhv_scan_field = 25;
  bool has_bhv_scan_field() const;
  private:
  bool _internal_has_bhv_scan_field() const;

  public:
  void clear_bhv_scan_field() ;
  const ::protos::Bhv_ScanField& bhv_scan_field() const;
  PROTOBUF_NODISCARD ::protos::Bhv_ScanField* release_bhv_scan_field();
  ::protos::Bhv_ScanField* mutable_bhv_scan_field();
  void set_allocated_bhv_scan_field(::protos::Bhv_ScanField* bhv_scan_field);
  private:
  const ::protos::Bhv_ScanField& _internal_bhv_scan_field() const;
  ::protos::Bhv_ScanField* _internal_mutable_bhv_scan_field();
  public:
  void unsafe_arena_set_allocated_bhv_scan_field(
      ::protos::Bhv_ScanField* bhv_scan_field);
  ::protos::Bhv_ScanField* unsafe_arena_release_bhv_scan_field();
  // .protos.Body_AdvanceBall body_advance_ball = 26;
  bool has_body_advance_ball() const;
  private:
  bool _internal_has_body_advance_ball() const;

  public:
  void clear_body_advance_ball() ;
  const ::protos::Body_AdvanceBall& body_advance_ball() const;
  PROTOBUF_NODISCARD ::protos::Body_AdvanceBall* release_body_advance_ball();
  ::protos::Body_AdvanceBall* mutable_body_advance_ball();
  void set_allocated_body_advance_ball(::protos::Body_AdvanceBall* body_advance_ball);
  private:
  const ::protos::Body_AdvanceBall& _internal_body_advance_ball() const;
  ::protos::Body_AdvanceBall* _internal_mutable_body_advance_ball();
  public:
  void unsafe_arena_set_allocated_body_advance_ball(
      ::protos::Body_AdvanceBall* body_advance_ball);
  ::protos::Body_AdvanceBall* unsafe_arena_release_body_advance_ball();
  // .protos.Body_ClearBall body_clear_ball = 27;
  bool has_body_clear_ball() const;
  private:
  bool _internal_has_body_clear_ball() const;

  public:
  void clear_body_clear_ball() ;
  const ::protos::Body_ClearBall& body_clear_ball() const;
  PROTOBUF_NODISCARD ::protos::Body_ClearBall* release_body_clear_ball();
  ::protos::Body_ClearBall* mutable_body_clear_ball();
  void set_allocated_body_clear_ball(::protos::Body_ClearBall* body_clear_ball);
  private:
  const ::protos::Body_ClearBall& _internal_body_clear_ball() const;
  ::protos::Body_ClearBall* _internal_mutable_body_clear_ball();
  public:
  void unsafe_arena_set_allocated_body_clear_ball(
      ::protos::Body_ClearBall* body_clear_ball);
  ::protos::Body_ClearBall* unsafe_arena_release_body_clear_ball();
  // .protos.Body_Dribble body_dribble = 28;
  bool has_body_dribble() const;
  private:
  bool _internal_has_body_dribble() const;

  public:
  void clear_body_dribble() ;
  const ::protos::Body_Dribble& body_dribble() const;
  PROTOBUF_NODISCARD ::protos::Body_Dribble* release_body_dribble();
  ::protos::Body_Dribble* mutable_body_dribble();
  void set_allocated_body_dribble(::protos::Body_Dribble* body_dribble);
  private:
  const ::protos::Body_Dribble& _internal_body_dribble() const;
  ::protos::Body_Dribble* _internal_mutable_body_dribble();
  public:
  void unsafe_arena_set_allocated_body_dribble(
      ::protos::Body_Dribble* body_dribble);
  ::protos::Body_Dribble* unsafe_arena_release_body_dribble();
  // .protos.Body_GoToPointDodge body_go_to_point_dodge = 29;
  bool has_body_go_to_point_dodge() const;
  private:
  bool _internal_has_body_go_to_point_dodge() const;

  public:
  void clear_body_go_to_point_dodge() ;
  const ::protos::Body_GoToPointDodge& body_go_to_point_dodge() const;
  PROTOBUF_NODISCARD ::protos::Body_GoToPointDodge* release_body_go_to_point_dodge();
  ::protos::Body_GoToPointDodge* mutable_body_go_to_point_dodge();
  void set_allocated_body_go_to_point_dodge(::protos::Body_GoToPointDodge* body_go_to_point_dodge);
  private:
  const ::protos::Body_GoToPointDodge& _internal_body_go_to_point_dodge() const;
  ::protos::Body_GoToPointDodge* _internal_mutable_body_go_to_point_dodge();
  public:
  void unsafe_arena_set_allocated_body_go_to_point_dodge(
      ::protos::Body_GoToPointDodge* body_go_to_point_dodge);
  ::protos::Body_GoToPointDodge* unsafe_arena_release_body_go_to_point_dodge();
  // .protos.Body_HoldBall body_hold_ball = 30;
  bool has_body_hold_ball() const;
  private:
  bool _internal_has_body_hold_ball() const;

  public:
  void clear_body_hold_ball() ;
  const ::protos::Body_HoldBall& body_hold_ball() const;
  PROTOBUF_NODISCARD ::protos::Body_HoldBall* release_body_hold_ball();
  ::protos::Body_HoldBall* mutable_body_hold_ball();
  void set_allocated_body_hold_ball(::protos::Body_HoldBall* body_hold_ball);
  private:
  const ::protos::Body_HoldBall& _internal_body_hold_ball() const;
  ::protos::Body_HoldBall* _internal_mutable_body_hold_ball();
  public:
  void unsafe_arena_set_allocated_body_hold_ball(
      ::protos::Body_HoldBall* body_hold_ball);
  ::protos::Body_HoldBall* unsafe_arena_release_body_hold_ball();
  // .protos.Body_Intercept body_intercept = 31;
  bool has_body_intercept() const;
  private:
  bool _internal_has_body_intercept() const;

  public:
  void clear_body_intercept() ;
  const ::protos::Body_Intercept& body_intercept() const;
  PROTOBUF_NODISCARD ::protos::Body_Intercept* release_body_intercept();
  ::protos::Body_Intercept* mutable_body_intercept();
  void set_allocated_body_intercept(::protos::Body_Intercept* body_intercept);
  private:
  const ::protos::Body_Intercept& _internal_body_intercept() const;
  ::protos::Body_Intercept* _internal_mutable_body_intercept();
  public:
  void unsafe_arena_set_allocated_body_intercept(
      ::protos::Body_Intercept* body_intercept);
  ::protos::Body_Intercept* unsafe_arena_release_body_intercept();
  // .protos.Body_KickOneStep body_kick_one_step = 32;
  bool has_body_kick_one_step() const;
  private:
  bool _internal_has_body_kick_one_step() const;

  public:
  void clear_body_kick_one_step() ;
  const ::protos::Body_KickOneStep& body_kick_one_step() const;
  PROTOBUF_NODISCARD ::protos::Body_KickOneStep* release_body_kick_one_step();
  ::protos::Body_KickOneStep* mutable_body_kick_one_step();
  void set_allocated_body_kick_one_step(::protos::Body_KickOneStep* body_kick_one_step);
  private:
  const ::protos::Body_KickOneStep& _internal_body_kick_one_step() const;
  ::protos::Body_KickOneStep* _internal_mutable_body_kick_one_step();
  public:
  void unsafe_arena_set_allocated_body_kick_one_step(
      ::protos::Body_KickOneStep* body_kick_one_step);
  ::protos::Body_KickOneStep* unsafe_arena_release_body_kick_one_step();
  // .protos.Body_StopBall body_stop_ball = 33;
  bool has_body_stop_ball() const;
  private:
  bool _internal_has_body_stop_ball() const;

  public:
  void clear_body_stop_ball() ;
  const ::protos::Body_StopBall& body_stop_ball() const;
  PROTOBUF_NODISCARD ::protos::Body_StopBall* release_body_stop_ball();
  ::protos::Body_StopBall* mutable_body_stop_ball();
  void set_allocated_body_stop_ball(::protos::Body_StopBall* body_stop_ball);
  private:
  const ::protos::Body_StopBall& _internal_body_stop_ball() const;
  ::protos::Body_StopBall* _internal_mutable_body_stop_ball();
  public:
  void unsafe_arena_set_allocated_body_stop_ball(
      ::protos::Body_StopBall* body_stop_ball);
  ::protos::Body_StopBall* unsafe_arena_release_body_stop_ball();
  // .protos.Body_StopDash body_stop_dash = 34;
  bool has_body_stop_dash() const;
  private:
  bool _internal_has_body_stop_dash() const;

  public:
  void clear_body_stop_dash() ;
  const ::protos::Body_StopDash& body_stop_dash() const;
  PROTOBUF_NODISCARD ::protos::Body_StopDash* release_body_stop_dash();
  ::protos::Body_StopDash* mutable_body_stop_dash();
  void set_allocated_body_stop_dash(::protos::Body_StopDash* body_stop_dash);
  private:
  const ::protos::Body_StopDash& _internal_body_stop_dash() const;
  ::protos::Body_StopDash* _internal_mutable_body_stop_dash();
  public:
  void unsafe_arena_set_allocated_body_stop_dash(
      ::protos::Body_StopDash* body_stop_dash);
  ::protos::Body_StopDash* unsafe_arena_release_body_stop_dash();
  // .protos.Body_TackleToPoint body_tackle_to_point = 35;
  bool has_body_tackle_to_point() const;
  private:
  bool _internal_has_body_tackle_to_point() const;

  public:
  void clear_body_tackle_to_point() ;
  const ::protos::Body_TackleToPoint& body_tackle_to_point() const;
  PROTOBUF_NODISCARD ::protos::Body_TackleToPoint* release_body_tackle_to_point();
  ::protos::Body_TackleToPoint* mutable_body_tackle_to_point();
  void set_allocated_body_tackle_to_point(::protos::Body_TackleToPoint* body_tackle_to_point);
  private:
  const ::protos::Body_TackleToPoint& _internal_body_tackle_to_point() const;
  ::protos::Body_TackleToPoint* _internal_mutable_body_tackle_to_point();
  public:
  void unsafe_arena_set_allocated_body_tackle_to_point(
      ::protos::Body_TackleToPoint* body_tackle_to_point);
  ::protos::Body_TackleToPoint* unsafe_arena_release_body_tackle_to_point();
  // .protos.Body_TurnToAngle body_turn_to_angle = 36;
  bool has_body_turn_to_angle() const;
  private:
  bool _internal_has_body_turn_to_angle() const;

  public:
  void clear_body_turn_to_angle() ;
  const ::protos::Body_TurnToAngle& body_turn_to_angle() const;
  PROTOBUF_NODISCARD ::protos::Body_TurnToAngle* release_body_turn_to_angle();
  ::protos::Body_TurnToAngle* mutable_body_turn_to_angle();
  void set_allocated_body_turn_to_angle(::protos::Body_TurnToAngle* body_turn_to_angle);
  private:
  const ::protos::Body_TurnToAngle& _internal_body_turn_to_angle() const;
  ::protos::Body_TurnToAngle* _internal_mutable_body_turn_to_angle();
  public:
  void unsafe_arena_set_allocated_body_turn_to_angle(
      ::protos::Body_TurnToAngle* body_turn_to_angle);
  ::protos::Body_TurnToAngle* unsafe_arena_release_body_turn_to_angle();
  // .protos.Body_TurnToBall body_turn_to_ball = 37;
  bool has_body_turn_to_ball() const;
  private:
  bool _internal_has_body_turn_to_ball() const;

  public:
  void clear_body_turn_to_ball() ;
  const ::protos::Body_TurnToBall& body_turn_to_ball() const;
  PROTOBUF_NODISCARD ::protos::Body_TurnToBall* release_body_turn_to_ball();
  ::protos::Body_TurnToBall* mutable_body_turn_to_ball();
  void set_allocated_body_turn_to_ball(::protos::Body_TurnToBall* body_turn_to_ball);
  private:
  const ::protos::Body_TurnToBall& _internal_body_turn_to_ball() const;
  ::protos::Body_TurnToBall* _internal_mutable_body_turn_to_ball();
  public:
  void unsafe_arena_set_allocated_body_turn_to_ball(
      ::protos::Body_TurnToBall* body_turn_to_ball);
  ::protos::Body_TurnToBall* unsafe_arena_release_body_turn_to_ball();
  // .protos.Body_TurnToPoint body_turn_to_point = 38;
  bool has_body_turn_to_point() const;
  private:
  bool _internal_has_body_turn_to_point() const;

  public:
  void clear_body_turn_to_point() ;
  const ::protos::Body_TurnToPoint& body_turn_to_point() const;
  PROTOBUF_NODISCARD ::protos::Body_TurnToPoint* release_body_turn_to_point();
  ::protos::Body_TurnToPoint* mutable_body_turn_to_point();
  void set_allocated_body_turn_to_point(::protos::Body_TurnToPoint* body_turn_to_point);
  private:
  const ::protos::Body_TurnToPoint& _internal_body_turn_to_point() const;
  ::protos::Body_TurnToPoint* _internal_mutable_body_turn_to_point();
  public:
  void unsafe_arena_set_allocated_body_turn_to_point(
      ::protos::Body_TurnToPoint* body_turn_to_point);
  ::protos::Body_TurnToPoint* unsafe_arena_release_body_turn_to_point();
  // .protos.Focus_MoveToPoint focus_move_to_point = 39;
  bool has_focus_move_to_point() const;
  private:
  bool _internal_has_focus_move_to_point() const;

  public:
  void clear_focus_move_to_point() ;
  const ::protos::Focus_MoveToPoint& focus_move_to_point() const;
  PROTOBUF_NODISCARD ::protos::Focus_MoveToPoint* release_focus_move_to_point();
  ::protos::Focus_MoveToPoint* mutable_focus_move_to_point();
  void set_allocated_focus_move_to_point(::protos::Focus_MoveToPoint* focus_move_to_point);
  private:
  const ::protos::Focus_MoveToPoint& _internal_focus_move_to_point() const;
  ::protos::Focus_MoveToPoint* _internal_mutable_focus_move_to_point();
  public:
  void unsafe_arena_set_allocated_focus_move_to_point(
      ::protos::Focus_MoveToPoint* focus_move_to_point);
  ::protos::Focus_MoveToPoint* unsafe_arena_release_focus_move_to_point();
  // .protos.Focus_Reset focus_reset = 40;
  bool has_focus_reset() const;
  private:
  bool _internal_has_focus_reset() const;

  public:
  void clear_focus_reset() ;
  const ::protos::Focus_Reset& focus_reset() const;
  PROTOBUF_NODISCARD ::protos::Focus_Reset* release_focus_reset();
  ::protos::Focus_Reset* mutable_focus_reset();
  void set_allocated_focus_reset(::protos::Focus_Reset* focus_reset);
  private:
  const ::protos::Focus_Reset& _internal_focus_reset() const;
  ::protos::Focus_Reset* _internal_mutable_focus_reset();
  public:
  void unsafe_arena_set_allocated_focus_reset(
      ::protos::Focus_Reset* focus_reset);
  ::protos::Focus_Reset* unsafe_arena_release_focus_reset();
  // .protos.Neck_ScanField neck_scan_field = 41;
  bool has_neck_scan_field() const;
  private:
  bool _internal_has_neck_scan_field() const;

  public:
  void clear_neck_scan_field() ;
  const ::protos::Neck_ScanField& neck_scan_field() const;
  PROTOBUF_NODISCARD ::protos::Neck_ScanField* release_neck_scan_field();
  ::protos::Neck_ScanField* mutable_neck_scan_field();
  void set_allocated_neck_scan_field(::protos::Neck_ScanField* neck_scan_field);
  private:
  const ::protos::Neck_ScanField& _internal_neck_scan_field() const;
  ::protos::Neck_ScanField* _internal_mutable_neck_scan_field();
  public:
  void unsafe_arena_set_allocated_neck_scan_field(
      ::protos::Neck_ScanField* neck_scan_field);
  ::protos::Neck_ScanField* unsafe_arena_release_neck_scan_field();
  // .protos.Neck_ScanPlayers neck_scan_players = 42;
  bool has_neck_scan_players() const;
  private:
  bool _internal_has_neck_scan_players() const;

  public:
  void clear_neck_scan_players() ;
  const ::protos::Neck_ScanPlayers& neck_scan_players() const;
  PROTOBUF_NODISCARD ::protos::Neck_ScanPlayers* release_neck_scan_players();
  ::protos::Neck_ScanPlayers* mutable_neck_scan_players();
  void set_allocated_neck_scan_players(::protos::Neck_ScanPlayers* neck_scan_players);
  private:
  const ::protos::Neck_ScanPlayers& _internal_neck_scan_players() const;
  ::protos::Neck_ScanPlayers* _internal_mutable_neck_scan_players();
  public:
  void unsafe_arena_set_allocated_neck_scan_players(
      ::protos::Neck_ScanPlayers* neck_scan_players);
  ::protos::Neck_ScanPlayers* unsafe_arena_release_neck_scan_players();
  // .protos.Neck_TurnToBallAndPlayer neck_turn_to_ball_and_player = 43;
  bool has_neck_turn_to_ball_and_player() const;
  private:
  bool _internal_has_neck_turn_to_ball_and_player() const;

  public:
  void clear_neck_turn_to_ball_and_player() ;
  const ::protos::Neck_TurnToBallAndPlayer& neck_turn_to_ball_and_player() const;
  PROTOBUF_NODISCARD ::protos::Neck_TurnToBallAndPlayer* release_neck_turn_to_ball_and_player();
  ::protos::Neck_TurnToBallAndPlayer* mutable_neck_turn_to_ball_and_player();
  void set_allocated_neck_turn_to_ball_and_player(::protos::Neck_TurnToBallAndPlayer* neck_turn_to_ball_and_player);
  private:
  const ::protos::Neck_TurnToBallAndPlayer& _internal_neck_turn_to_ball_and_player() const;
  ::protos::Neck_TurnToBallAndPlayer* _internal_mutable_neck_turn_to_ball_and_player();
  public:
  void unsafe_arena_set_allocated_neck_turn_to_ball_and_player(
      ::protos::Neck_TurnToBallAndPlayer* neck_turn_to_ball_and_player);
  ::protos::Neck_TurnToBallAndPlayer* unsafe_arena_release_neck_turn_to_ball_and_player();
  // .protos.Neck_TurnToBallOrScan neck_turn_to_ball_or_scan = 44;
  bool has_neck_turn_to_ball_or_scan() const;
  private:
  bool _internal_has_neck_turn_to_ball_or_scan() const;

  public:
  void clear_neck_turn_to_ball_or_scan() ;
  const ::protos::Neck_TurnToBallOrScan& neck_turn_to_ball_or_scan() const;
  PROTOBUF_NODISCARD ::protos::Neck_TurnToBallOrScan* release_neck_turn_to_ball_or_scan();
  ::protos::Neck_TurnToBallOrScan* mutable_neck_turn_to_ball_or_scan();
  void set_allocated_neck_turn_to_ball_or_scan(::protos::Neck_TurnToBallOrScan* neck_turn_to_ball_or_scan);
  private:
  const ::protos::Neck_TurnToBallOrScan& _internal_neck_turn_to_ball_or_scan() const;
  ::protos::Neck_TurnToBallOrScan* _internal_mutable_neck_turn_to_ball_or_scan();
  public:
  void unsafe_arena_set_allocated_neck_turn_to_ball_or_scan(
      ::protos::Neck_TurnToBallOrScan* neck_turn_to_ball_or_scan);
  ::protos::Neck_TurnToBallOrScan* unsafe_arena_release_neck_turn_to_ball_or_scan();
  // .protos.Neck_TurnToBall neck_turn_to_ball = 45;
  bool has_neck_turn_to_ball() const;
  private:
  bool _internal_has_neck_turn_to_ball() const;

  public:
  void clear_neck_turn_to_ball() ;
  const ::protos::Neck_TurnToBall& neck_turn_to_ball() const;
  PROTOBUF_NODISCARD ::protos::Neck_TurnToBall* release_neck_turn_to_ball();
  ::protos::Neck_TurnToBall* mutable_neck_turn_to_ball();
  void set_allocated_neck_turn_to_ball(::protos::Neck_TurnToBall* neck_turn_to_ball);
  private:
  const ::protos::Neck_TurnToBall& _internal_neck_turn_to_ball() const;
  ::protos::Neck_TurnToBall* _internal_mutable_neck_turn_to_ball();
  public:
  void unsafe_arena_set_allocated_neck_turn_to_ball(
      ::protos::Neck_TurnToBall* neck_turn_to_ball);
  ::protos::Neck_TurnToBall* unsafe_arena_release_neck_turn_to_ball();
  // .protos.Neck_TurnToGoalieOrScan neck_turn_to_goalie_or_scan = 46;
  bool has_neck_turn_to_goalie_or_scan() const;
  private:
  bool _internal_has_neck_turn_to_goalie_or_scan() const;

  public:
  void clear_neck_turn_to_goalie_or_scan() ;
  const ::protos::Neck_TurnToGoalieOrScan& neck_turn_to_goalie_or_scan() const;
  PROTOBUF_NODISCARD ::protos::Neck_TurnToGoalieOrScan* release_neck_turn_to_goalie_or_scan();
  ::protos::Neck_TurnToGoalieOrScan* mutable_neck_turn_to_goalie_or_scan();
  void set_allocated_neck_turn_to_goalie_or_scan(::protos::Neck_TurnToGoalieOrScan* neck_turn_to_goalie_or_scan);
  private:
  const ::protos::Neck_TurnToGoalieOrScan& _internal_neck_turn_to_goalie_or_scan() const;
  ::protos::Neck_TurnToGoalieOrScan* _internal_mutable_neck_turn_to_goalie_or_scan();
  public:
  void unsafe_arena_set_allocated_neck_turn_to_goalie_or_scan(
      ::protos::Neck_TurnToGoalieOrScan* neck_turn_to_goalie_or_scan);
  ::protos::Neck_TurnToGoalieOrScan* unsafe_arena_release_neck_turn_to_goalie_or_scan();
  // .protos.Neck_TurnToLowConfTeammate neck_turn_to_low_conf_teammate = 47;
  bool has_neck_turn_to_low_conf_teammate() const;
  private:
  bool _internal_has_neck_turn_to_low_conf_teammate() const;

  public:
  void clear_neck_turn_to_low_conf_teammate() ;
  const ::protos::Neck_TurnToLowConfTeammate& neck_turn_to_low_conf_teammate() const;
  PROTOBUF_NODISCARD ::protos::Neck_TurnToLowConfTeammate* release_neck_turn_to_low_conf_teammate();
  ::protos::Neck_TurnToLowConfTeammate* mutable_neck_turn_to_low_conf_teammate();
  void set_allocated_neck_turn_to_low_conf_teammate(::protos::Neck_TurnToLowConfTeammate* neck_turn_to_low_conf_teammate);
  private:
  const ::protos::Neck_TurnToLowConfTeammate& _internal_neck_turn_to_low_conf_teammate() const;
  ::protos::Neck_TurnToLowConfTeammate* _internal_mutable_neck_turn_to_low_conf_teammate();
  public:
  void unsafe_arena_set_allocated_neck_turn_to_low_conf_teammate(
      ::protos::Neck_TurnToLowConfTeammate* neck_turn_to_low_conf_teammate);
  ::protos::Neck_TurnToLowConfTeammate* unsafe_arena_release_neck_turn_to_low_conf_teammate();
  // .protos.Neck_TurnToPlayerOrScan neck_turn_to_player_or_scan = 48;
  bool has_neck_turn_to_player_or_scan() const;
  private:
  bool _internal_has_neck_turn_to_player_or_scan() const;

  public:
  void clear_neck_turn_to_player_or_scan() ;
  const ::protos::Neck_TurnToPlayerOrScan& neck_turn_to_player_or_scan() const;
  PROTOBUF_NODISCARD ::protos::Neck_TurnToPlayerOrScan* release_neck_turn_to_player_or_scan();
  ::protos::Neck_TurnToPlayerOrScan* mutable_neck_turn_to_player_or_scan();
  void set_allocated_neck_turn_to_player_or_scan(::protos::Neck_TurnToPlayerOrScan* neck_turn_to_player_or_scan);
  private:
  const ::protos::Neck_TurnToPlayerOrScan& _internal_neck_turn_to_player_or_scan() const;
  ::protos::Neck_TurnToPlayerOrScan* _internal_mutable_neck_turn_to_player_or_scan();
  public:
  void unsafe_arena_set_allocated_neck_turn_to_player_or_scan(
      ::protos::Neck_TurnToPlayerOrScan* neck_turn_to_player_or_scan);
  ::protos::Neck_TurnToPlayerOrScan* unsafe_arena_release_neck_turn_to_player_or_scan();
  // .protos.Neck_TurnToPoint neck_turn_to_point = 49;
  bool has_neck_turn_to_point() const;
  private:
  bool _internal_has_neck_turn_to_point() const;

  public:
  void clear_neck_turn_to_point() ;
  const ::protos::Neck_TurnToPoint& neck_turn_to_point() const;
  PROTOBUF_NODISCARD ::protos::Neck_TurnToPoint* release_neck_turn_to_point();
  ::protos::Neck_TurnToPoint* mutable_neck_turn_to_point();
  void set_allocated_neck_turn_to_point(::protos::Neck_TurnToPoint* neck_turn_to_point);
  private:
  const ::protos::Neck_TurnToPoint& _internal_neck_turn_to_point() const;
  ::protos::Neck_TurnToPoint* _internal_mutable_neck_turn_to_point();
  public:
  void unsafe_arena_set_allocated_neck_turn_to_point(
      ::protos::Neck_TurnToPoint* neck_turn_to_point);
  ::protos::Neck_TurnToPoint* unsafe_arena_release_neck_turn_to_point();
  // .protos.Neck_TurnToRelative neck_turn_to_relative = 50;
  bool has_neck_turn_to_relative() const;
  private:
  bool _internal_has_neck_turn_to_relative() const;

  public:
  void clear_neck_turn_to_relative() ;
  const ::protos::Neck_TurnToRelative& neck_turn_to_relative() const;
  PROTOBUF_NODISCARD ::protos::Neck_TurnToRelative* release_neck_turn_to_relative();
  ::protos::Neck_TurnToRelative* mutable_neck_turn_to_relative();
  void set_allocated_neck_turn_to_relative(::protos::Neck_TurnToRelative* neck_turn_to_relative);
  private:
  const ::protos::Neck_TurnToRelative& _internal_neck_turn_to_relative() const;
  ::protos::Neck_TurnToRelative* _internal_mutable_neck_turn_to_relative();
  public:
  void unsafe_arena_set_allocated_neck_turn_to_relative(
      ::protos::Neck_TurnToRelative* neck_turn_to_relative);
  ::protos::Neck_TurnToRelative* unsafe_arena_release_neck_turn_to_relative();
  // .protos.View_ChangeWidth view_change_width = 51;
  bool has_view_change_width() const;
  private:
  bool _internal_has_view_change_width() const;

  public:
  void clear_view_change_width() ;
  const ::protos::View_ChangeWidth& view_change_width() const;
  PROTOBUF_NODISCARD ::protos::View_ChangeWidth* release_view_change_width();
  ::protos::View_ChangeWidth* mutable_view_change_width();
  void set_allocated_view_change_width(::protos::View_ChangeWidth* view_change_width);
  private:
  const ::protos::View_ChangeWidth& _internal_view_change_width() const;
  ::protos::View_ChangeWidth* _internal_mutable_view_change_width();
  public:
  void unsafe_arena_set_allocated_view_change_width(
      ::protos::View_ChangeWidth* view_change_width);
  ::protos::View_ChangeWidth* unsafe_arena_release_view_change_width();
  // .protos.View_Normal view_normal = 52;
  bool has_view_normal() const;
  private:
  bool _internal_has_view_normal() const;

  public:
  void clear_view_normal() ;
  const ::protos::View_Normal& view_normal() const;
  PROTOBUF_NODISCARD ::protos::View_Normal* release_view_normal();
  ::protos::View_Normal* mutable_view_normal();
  void set_allocated_view_normal(::protos::View_Normal* view_normal);
  private:
  const ::protos::View_Normal& _internal_view_normal() const;
  ::protos::View_Normal* _internal_mutable_view_normal();
  public:
  void unsafe_arena_set_allocated_view_normal(
      ::protos::View_Normal* view_normal);
  ::protos::View_Normal* unsafe_arena_release_view_normal();
  // .protos.View_Synch view_synch = 53;
  bool has_view_synch() const;
  private:
  bool _internal_has_view_synch() const;

  public:
  void clear_view_synch() ;
  const ::protos::View_Synch& view_synch() const;
  PROTOBUF_NODISCARD ::protos::View_Synch* release_view_synch();
  ::protos::View_Synch* mutable_view_synch();
  void set_allocated_view_synch(::protos::View_Synch* view_synch);
  private:
  const ::protos::View_Synch& _internal_view_synch() const;
  ::protos::View_Synch* _internal_mutable_view_synch();
  public:
  void unsafe_arena_set_allocated_view_synch(
      ::protos::View_Synch* view_synch);
  ::protos::View_Synch* unsafe_arena_release_view_synch();
  // .protos.View_Wide view_wide = 54;
  bool has_view_wide() const;
  private:
  bool _internal_has_view_wide() const;

  public:
  void clear_view_wide() ;
  const ::protos::View_Wide& view_wide() const;
  PROTOBUF_NODISCARD ::protos::View_Wide* release_view_wide();
  ::protos::View_Wide* mutable_view_wide();
  void set_allocated_view_wide(::protos::View_Wide* view_wide);
  private:
  const ::protos::View_Wide& _internal_view_wide() const;
  ::protos::View_Wide* _internal_mutable_view_wide();
  public:
  void unsafe_arena_set_allocated_view_wide(
      ::protos::View_Wide* view_wide);
  ::protos::View_Wide* unsafe_arena_release_view_wide();
  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:protos.Action)
 private:
  class _Internal;
  void set_has_dash();
  void set_has_turn();
  void set_has_kick();
  void set_has_tackle();
  void set_has_catch_();
  void set_has_move();
  void set_has_turn_neck();
  void set_has_change_view();
  void set_has_say();
  void set_has_point_to();
  void set_has_point_to_of();
  void set_has_attention_to();
  void set_has_attention_to_of();
  void set_has_log();
  void set_has_debug_client();
  void set_has_body_go_to_point();
  void set_has_body_smart_kick();
  void set_has_bhv_before_kick_off();
  void set_has_bhv_body_neck_to_ball();
  void set_has_bhv_body_neck_to_point();
  void set_has_bhv_emergency();
  void set_has_bhv_go_to_point_look_ball();
  void set_has_bhv_neck_body_to_ball();
  void set_has_bhv_neck_body_to_point();
  void set_has_bhv_scan_field();
  void set_has_body_advance_ball();
  void set_has_body_clear_ball();
  void set_has_body_dribble();
  void set_has_body_go_to_point_dodge();
  void set_has_body_hold_ball();
  void set_has_body_intercept();
  void set_has_body_kick_one_step();
  void set_has_body_stop_ball();
  void set_has_body_stop_dash();
  void set_has_body_tackle_to_point();
  void set_has_body_turn_to_angle();
  void set_has_body_turn_to_ball();
  void set_has_body_turn_to_point();
  void set_has_focus_move_to_point();
  void set_has_focus_reset();
  void set_has_neck_scan_field();
  void set_has_neck_scan_players();
  void set_has_neck_turn_to_ball_and_player();
  void set_has_neck_turn_to_ball_or_scan();
  void set_has_neck_turn_to_ball();
  void set_has_neck_turn_to_goalie_or_scan();
  void set_has_neck_turn_to_low_conf_teammate();
  void set_has_neck_turn_to_player_or_scan();
  void set_has_neck_turn_to_point();
  void set_has_neck_turn_to_relative();
  void set_has_view_change_width();
  void set_has_view_normal();
  void set_has_view_synch();
  void set_has_view_wide();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::protos::Dash* dash_;
      ::protos::Turn* turn_;
      ::protos::Kick* kick_;
      ::protos::Tackle* tackle_;
      ::protos::Catch* catch__;
      ::protos::Move* move_;
      ::protos::TurnNeck* turn_neck_;
      ::protos::ChangeView* change_view_;
      ::protos::Say* say_;
      ::protos::PointTo* point_to_;
      ::protos::PointToOf* point_to_of_;
      ::protos::AttentionTo* attention_to_;
      ::protos::AttentionToOf* attention_to_of_;
      ::protos::Log* log_;
      ::protos::DebugClient* debug_client_;
      ::protos::Body_GoToPoint* body_go_to_point_;
      ::protos::Body_SmartKick* body_smart_kick_;
      ::protos::Bhv_BeforeKickOff* bhv_before_kick_off_;
      ::protos::Bhv_BodyNeckToBall* bhv_body_neck_to_ball_;
      ::protos::Bhv_BodyNeckToPoint* bhv_body_neck_to_point_;
      ::protos::Bhv_Emergency* bhv_emergency_;
      ::protos::Bhv_GoToPointLookBall* bhv_go_to_point_look_ball_;
      ::protos::Bhv_NeckBodyToBall* bhv_neck_body_to_ball_;
      ::protos::Bhv_NeckBodyToPoint* bhv_neck_body_to_point_;
      ::protos::Bhv_ScanField* bhv_scan_field_;
      ::protos::Body_AdvanceBall* body_advance_ball_;
      ::protos::Body_ClearBall* body_clear_ball_;
      ::protos::Body_Dribble* body_dribble_;
      ::protos::Body_GoToPointDodge* body_go_to_point_dodge_;
      ::protos::Body_HoldBall* body_hold_ball_;
      ::protos::Body_Intercept* body_intercept_;
      ::protos::Body_KickOneStep* body_kick_one_step_;
      ::protos::Body_StopBall* body_stop_ball_;
      ::protos::Body_StopDash* body_stop_dash_;
      ::protos::Body_TackleToPoint* body_tackle_to_point_;
      ::protos::Body_TurnToAngle* body_turn_to_angle_;
      ::protos::Body_TurnToBall* body_turn_to_ball_;
      ::protos::Body_TurnToPoint* body_turn_to_point_;
      ::protos::Focus_MoveToPoint* focus_move_to_point_;
      ::protos::Focus_Reset* focus_reset_;
      ::protos::Neck_ScanField* neck_scan_field_;
      ::protos::Neck_ScanPlayers* neck_scan_players_;
      ::protos::Neck_TurnToBallAndPlayer* neck_turn_to_ball_and_player_;
      ::protos::Neck_TurnToBallOrScan* neck_turn_to_ball_or_scan_;
      ::protos::Neck_TurnToBall* neck_turn_to_ball_;
      ::protos::Neck_TurnToGoalieOrScan* neck_turn_to_goalie_or_scan_;
      ::protos::Neck_TurnToLowConfTeammate* neck_turn_to_low_conf_teammate_;
      ::protos::Neck_TurnToPlayerOrScan* neck_turn_to_player_or_scan_;
      ::protos::Neck_TurnToPoint* neck_turn_to_point_;
      ::protos::Neck_TurnToRelative* neck_turn_to_relative_;
      ::protos::View_ChangeWidth* view_change_width_;
      ::protos::View_Normal* view_normal_;
      ::protos::View_Synch* view_synch_;
      ::protos::View_Wide* view_wide_;
    } action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Actions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.Actions) */ {
 public:
  inline Actions() : Actions(nullptr) {}
  ~Actions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Actions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Actions(const Actions& from);
  Actions(Actions&& from) noexcept
    : Actions() {
    *this = ::std::move(from);
  }

  inline Actions& operator=(const Actions& from) {
    CopyFrom(from);
    return *this;
  }
  inline Actions& operator=(Actions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Actions& default_instance() {
    return *internal_default_instance();
  }
  static inline const Actions* internal_default_instance() {
    return reinterpret_cast<const Actions*>(
               &_Actions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(Actions& a, Actions& b) {
    a.Swap(&b);
  }
  inline void Swap(Actions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Actions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Actions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Actions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Actions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Actions& from) {
    Actions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Actions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Actions";
  }
  protected:
  explicit Actions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 1,
  };
  // repeated .protos.Action actions = 1;
  int actions_size() const;
  private:
  int _internal_actions_size() const;

  public:
  void clear_actions() ;
  ::protos::Action* mutable_actions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Action >*
      mutable_actions();
  private:
  const ::protos::Action& _internal_actions(int index) const;
  ::protos::Action* _internal_add_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Action>& _internal_actions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Action>* _internal_mutable_actions();
  public:
  const ::protos::Action& actions(int index) const;
  ::protos::Action* add_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Action >&
      actions() const;
  // @@protoc_insertion_point(class_scope:protos.Actions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Action > actions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vector2D

// float x = 1;
inline void Vector2D::clear_x() {
  _impl_.x_ = 0;
}
inline float Vector2D::x() const {
  // @@protoc_insertion_point(field_get:protos.Vector2D.x)
  return _internal_x();
}
inline void Vector2D::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:protos.Vector2D.x)
}
inline float Vector2D::_internal_x() const {
  return _impl_.x_;
}
inline void Vector2D::_internal_set_x(float value) {
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void Vector2D::clear_y() {
  _impl_.y_ = 0;
}
inline float Vector2D::y() const {
  // @@protoc_insertion_point(field_get:protos.Vector2D.y)
  return _internal_y();
}
inline void Vector2D::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:protos.Vector2D.y)
}
inline float Vector2D::_internal_y() const {
  return _impl_.y_;
}
inline void Vector2D::_internal_set_y(float value) {
  ;
  _impl_.y_ = value;
}

// float dist = 3;
inline void Vector2D::clear_dist() {
  _impl_.dist_ = 0;
}
inline float Vector2D::dist() const {
  // @@protoc_insertion_point(field_get:protos.Vector2D.dist)
  return _internal_dist();
}
inline void Vector2D::set_dist(float value) {
  _internal_set_dist(value);
  // @@protoc_insertion_point(field_set:protos.Vector2D.dist)
}
inline float Vector2D::_internal_dist() const {
  return _impl_.dist_;
}
inline void Vector2D::_internal_set_dist(float value) {
  ;
  _impl_.dist_ = value;
}

// float angle = 4;
inline void Vector2D::clear_angle() {
  _impl_.angle_ = 0;
}
inline float Vector2D::angle() const {
  // @@protoc_insertion_point(field_get:protos.Vector2D.angle)
  return _internal_angle();
}
inline void Vector2D::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:protos.Vector2D.angle)
}
inline float Vector2D::_internal_angle() const {
  return _impl_.angle_;
}
inline void Vector2D::_internal_set_angle(float value) {
  ;
  _impl_.angle_ = value;
}

// -------------------------------------------------------------------

// Ball

// .protos.Vector2D position = 1;
inline bool Ball::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Ball::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Ball::_internal_position() const {
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::position() const {
  // @@protoc_insertion_point(field_get:protos.Ball.position)
  return _internal_position();
}
inline void Ball::unsafe_arena_set_allocated_position(
    ::protos::Vector2D* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.position)
}
inline ::protos::Vector2D* Ball::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protos.Ball.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* Ball::mutable_position() {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.Ball.position)
  return _msg;
}
inline void Ball::set_allocated_position(::protos::Vector2D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.position)
}

// .protos.Vector2D relative_position = 2;
inline bool Ball::has_relative_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.relative_position_ != nullptr);
  return value;
}
inline void Ball::clear_relative_position() {
  if (_impl_.relative_position_ != nullptr) _impl_.relative_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& Ball::_internal_relative_position() const {
  const ::protos::Vector2D* p = _impl_.relative_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::relative_position() const {
  // @@protoc_insertion_point(field_get:protos.Ball.relative_position)
  return _internal_relative_position();
}
inline void Ball::unsafe_arena_set_allocated_relative_position(
    ::protos::Vector2D* relative_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relative_position_);
  }
  _impl_.relative_position_ = relative_position;
  if (relative_position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.relative_position)
}
inline ::protos::Vector2D* Ball::release_relative_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.relative_position_;
  _impl_.relative_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_relative_position() {
  // @@protoc_insertion_point(field_release:protos.Ball.relative_position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.relative_position_;
  _impl_.relative_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_relative_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.relative_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.relative_position_ = p;
  }
  return _impl_.relative_position_;
}
inline ::protos::Vector2D* Ball::mutable_relative_position() {
  ::protos::Vector2D* _msg = _internal_mutable_relative_position();
  // @@protoc_insertion_point(field_mutable:protos.Ball.relative_position)
  return _msg;
}
inline void Ball::set_allocated_relative_position(::protos::Vector2D* relative_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.relative_position_;
  }
  if (relative_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(relative_position);
    if (message_arena != submessage_arena) {
      relative_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relative_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.relative_position_ = relative_position;
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.relative_position)
}

// .protos.Vector2D seen_position = 3;
inline bool Ball::has_seen_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_position_ != nullptr);
  return value;
}
inline void Ball::clear_seen_position() {
  if (_impl_.seen_position_ != nullptr) _impl_.seen_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& Ball::_internal_seen_position() const {
  const ::protos::Vector2D* p = _impl_.seen_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::seen_position() const {
  // @@protoc_insertion_point(field_get:protos.Ball.seen_position)
  return _internal_seen_position();
}
inline void Ball::unsafe_arena_set_allocated_seen_position(
    ::protos::Vector2D* seen_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.seen_position_);
  }
  _impl_.seen_position_ = seen_position;
  if (seen_position) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.seen_position)
}
inline ::protos::Vector2D* Ball::release_seen_position() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_seen_position() {
  // @@protoc_insertion_point(field_release:protos.Ball.seen_position)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_seen_position() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.seen_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.seen_position_ = p;
  }
  return _impl_.seen_position_;
}
inline ::protos::Vector2D* Ball::mutable_seen_position() {
  ::protos::Vector2D* _msg = _internal_mutable_seen_position();
  // @@protoc_insertion_point(field_mutable:protos.Ball.seen_position)
  return _msg;
}
inline void Ball::set_allocated_seen_position(::protos::Vector2D* seen_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.seen_position_;
  }
  if (seen_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seen_position);
    if (message_arena != submessage_arena) {
      seen_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seen_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.seen_position_ = seen_position;
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.seen_position)
}

// .protos.Vector2D heard_position = 4;
inline bool Ball::has_heard_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heard_position_ != nullptr);
  return value;
}
inline void Ball::clear_heard_position() {
  if (_impl_.heard_position_ != nullptr) _impl_.heard_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::protos::Vector2D& Ball::_internal_heard_position() const {
  const ::protos::Vector2D* p = _impl_.heard_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::heard_position() const {
  // @@protoc_insertion_point(field_get:protos.Ball.heard_position)
  return _internal_heard_position();
}
inline void Ball::unsafe_arena_set_allocated_heard_position(
    ::protos::Vector2D* heard_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.heard_position_);
  }
  _impl_.heard_position_ = heard_position;
  if (heard_position) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.heard_position)
}
inline ::protos::Vector2D* Ball::release_heard_position() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* temp = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_heard_position() {
  // @@protoc_insertion_point(field_release:protos.Ball.heard_position)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* temp = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_heard_position() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.heard_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.heard_position_ = p;
  }
  return _impl_.heard_position_;
}
inline ::protos::Vector2D* Ball::mutable_heard_position() {
  ::protos::Vector2D* _msg = _internal_mutable_heard_position();
  // @@protoc_insertion_point(field_mutable:protos.Ball.heard_position)
  return _msg;
}
inline void Ball::set_allocated_heard_position(::protos::Vector2D* heard_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.heard_position_;
  }
  if (heard_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(heard_position);
    if (message_arena != submessage_arena) {
      heard_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heard_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.heard_position_ = heard_position;
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.heard_position)
}

// .protos.Vector2D velocity = 5;
inline bool Ball::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void Ball::clear_velocity() {
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::protos::Vector2D& Ball::_internal_velocity() const {
  const ::protos::Vector2D* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::velocity() const {
  // @@protoc_insertion_point(field_get:protos.Ball.velocity)
  return _internal_velocity();
}
inline void Ball::unsafe_arena_set_allocated_velocity(
    ::protos::Vector2D* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.velocity)
}
inline ::protos::Vector2D* Ball::release_velocity() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:protos.Ball.velocity)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_velocity() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::protos::Vector2D* Ball::mutable_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Ball.velocity)
  return _msg;
}
inline void Ball::set_allocated_velocity(::protos::Vector2D* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.velocity)
}

// .protos.Vector2D seen_velocity = 6;
inline bool Ball::has_seen_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_velocity_ != nullptr);
  return value;
}
inline void Ball::clear_seen_velocity() {
  if (_impl_.seen_velocity_ != nullptr) _impl_.seen_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::protos::Vector2D& Ball::_internal_seen_velocity() const {
  const ::protos::Vector2D* p = _impl_.seen_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::seen_velocity() const {
  // @@protoc_insertion_point(field_get:protos.Ball.seen_velocity)
  return _internal_seen_velocity();
}
inline void Ball::unsafe_arena_set_allocated_seen_velocity(
    ::protos::Vector2D* seen_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.seen_velocity_);
  }
  _impl_.seen_velocity_ = seen_velocity;
  if (seen_velocity) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.seen_velocity)
}
inline ::protos::Vector2D* Ball::release_seen_velocity() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::protos::Vector2D* temp = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_seen_velocity() {
  // @@protoc_insertion_point(field_release:protos.Ball.seen_velocity)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::protos::Vector2D* temp = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_seen_velocity() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.seen_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.seen_velocity_ = p;
  }
  return _impl_.seen_velocity_;
}
inline ::protos::Vector2D* Ball::mutable_seen_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_seen_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Ball.seen_velocity)
  return _msg;
}
inline void Ball::set_allocated_seen_velocity(::protos::Vector2D* seen_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.seen_velocity_;
  }
  if (seen_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seen_velocity);
    if (message_arena != submessage_arena) {
      seen_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seen_velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.seen_velocity_ = seen_velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.seen_velocity)
}

// .protos.Vector2D heard_velocity = 7;
inline bool Ball::has_heard_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heard_velocity_ != nullptr);
  return value;
}
inline void Ball::clear_heard_velocity() {
  if (_impl_.heard_velocity_ != nullptr) _impl_.heard_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::protos::Vector2D& Ball::_internal_heard_velocity() const {
  const ::protos::Vector2D* p = _impl_.heard_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::heard_velocity() const {
  // @@protoc_insertion_point(field_get:protos.Ball.heard_velocity)
  return _internal_heard_velocity();
}
inline void Ball::unsafe_arena_set_allocated_heard_velocity(
    ::protos::Vector2D* heard_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.heard_velocity_);
  }
  _impl_.heard_velocity_ = heard_velocity;
  if (heard_velocity) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.heard_velocity)
}
inline ::protos::Vector2D* Ball::release_heard_velocity() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::protos::Vector2D* temp = _impl_.heard_velocity_;
  _impl_.heard_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_heard_velocity() {
  // @@protoc_insertion_point(field_release:protos.Ball.heard_velocity)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::protos::Vector2D* temp = _impl_.heard_velocity_;
  _impl_.heard_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_heard_velocity() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.heard_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.heard_velocity_ = p;
  }
  return _impl_.heard_velocity_;
}
inline ::protos::Vector2D* Ball::mutable_heard_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_heard_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Ball.heard_velocity)
  return _msg;
}
inline void Ball::set_allocated_heard_velocity(::protos::Vector2D* heard_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.heard_velocity_;
  }
  if (heard_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(heard_velocity);
    if (message_arena != submessage_arena) {
      heard_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heard_velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.heard_velocity_ = heard_velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.heard_velocity)
}

// int32 pos_count = 8;
inline void Ball::clear_pos_count() {
  _impl_.pos_count_ = 0;
}
inline ::int32_t Ball::pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.pos_count)
  return _internal_pos_count();
}
inline void Ball::set_pos_count(::int32_t value) {
  _internal_set_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.pos_count)
}
inline ::int32_t Ball::_internal_pos_count() const {
  return _impl_.pos_count_;
}
inline void Ball::_internal_set_pos_count(::int32_t value) {
  ;
  _impl_.pos_count_ = value;
}

// int32 seen_pos_count = 9;
inline void Ball::clear_seen_pos_count() {
  _impl_.seen_pos_count_ = 0;
}
inline ::int32_t Ball::seen_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.seen_pos_count)
  return _internal_seen_pos_count();
}
inline void Ball::set_seen_pos_count(::int32_t value) {
  _internal_set_seen_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.seen_pos_count)
}
inline ::int32_t Ball::_internal_seen_pos_count() const {
  return _impl_.seen_pos_count_;
}
inline void Ball::_internal_set_seen_pos_count(::int32_t value) {
  ;
  _impl_.seen_pos_count_ = value;
}

// int32 heard_pos_count = 10;
inline void Ball::clear_heard_pos_count() {
  _impl_.heard_pos_count_ = 0;
}
inline ::int32_t Ball::heard_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.heard_pos_count)
  return _internal_heard_pos_count();
}
inline void Ball::set_heard_pos_count(::int32_t value) {
  _internal_set_heard_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.heard_pos_count)
}
inline ::int32_t Ball::_internal_heard_pos_count() const {
  return _impl_.heard_pos_count_;
}
inline void Ball::_internal_set_heard_pos_count(::int32_t value) {
  ;
  _impl_.heard_pos_count_ = value;
}

// int32 vel_count = 11;
inline void Ball::clear_vel_count() {
  _impl_.vel_count_ = 0;
}
inline ::int32_t Ball::vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.vel_count)
  return _internal_vel_count();
}
inline void Ball::set_vel_count(::int32_t value) {
  _internal_set_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.vel_count)
}
inline ::int32_t Ball::_internal_vel_count() const {
  return _impl_.vel_count_;
}
inline void Ball::_internal_set_vel_count(::int32_t value) {
  ;
  _impl_.vel_count_ = value;
}

// int32 seen_vel_count = 12;
inline void Ball::clear_seen_vel_count() {
  _impl_.seen_vel_count_ = 0;
}
inline ::int32_t Ball::seen_vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.seen_vel_count)
  return _internal_seen_vel_count();
}
inline void Ball::set_seen_vel_count(::int32_t value) {
  _internal_set_seen_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.seen_vel_count)
}
inline ::int32_t Ball::_internal_seen_vel_count() const {
  return _impl_.seen_vel_count_;
}
inline void Ball::_internal_set_seen_vel_count(::int32_t value) {
  ;
  _impl_.seen_vel_count_ = value;
}

// int32 heard_vel_count = 13;
inline void Ball::clear_heard_vel_count() {
  _impl_.heard_vel_count_ = 0;
}
inline ::int32_t Ball::heard_vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.heard_vel_count)
  return _internal_heard_vel_count();
}
inline void Ball::set_heard_vel_count(::int32_t value) {
  _internal_set_heard_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.heard_vel_count)
}
inline ::int32_t Ball::_internal_heard_vel_count() const {
  return _impl_.heard_vel_count_;
}
inline void Ball::_internal_set_heard_vel_count(::int32_t value) {
  ;
  _impl_.heard_vel_count_ = value;
}

// int32 lost_count = 14;
inline void Ball::clear_lost_count() {
  _impl_.lost_count_ = 0;
}
inline ::int32_t Ball::lost_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.lost_count)
  return _internal_lost_count();
}
inline void Ball::set_lost_count(::int32_t value) {
  _internal_set_lost_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.lost_count)
}
inline ::int32_t Ball::_internal_lost_count() const {
  return _impl_.lost_count_;
}
inline void Ball::_internal_set_lost_count(::int32_t value) {
  ;
  _impl_.lost_count_ = value;
}

// int32 ghost_count = 15;
inline void Ball::clear_ghost_count() {
  _impl_.ghost_count_ = 0;
}
inline ::int32_t Ball::ghost_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.ghost_count)
  return _internal_ghost_count();
}
inline void Ball::set_ghost_count(::int32_t value) {
  _internal_set_ghost_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.ghost_count)
}
inline ::int32_t Ball::_internal_ghost_count() const {
  return _impl_.ghost_count_;
}
inline void Ball::_internal_set_ghost_count(::int32_t value) {
  ;
  _impl_.ghost_count_ = value;
}

// float dist_from_self = 16;
inline void Ball::clear_dist_from_self() {
  _impl_.dist_from_self_ = 0;
}
inline float Ball::dist_from_self() const {
  // @@protoc_insertion_point(field_get:protos.Ball.dist_from_self)
  return _internal_dist_from_self();
}
inline void Ball::set_dist_from_self(float value) {
  _internal_set_dist_from_self(value);
  // @@protoc_insertion_point(field_set:protos.Ball.dist_from_self)
}
inline float Ball::_internal_dist_from_self() const {
  return _impl_.dist_from_self_;
}
inline void Ball::_internal_set_dist_from_self(float value) {
  ;
  _impl_.dist_from_self_ = value;
}

// float angle_from_self = 17;
inline void Ball::clear_angle_from_self() {
  _impl_.angle_from_self_ = 0;
}
inline float Ball::angle_from_self() const {
  // @@protoc_insertion_point(field_get:protos.Ball.angle_from_self)
  return _internal_angle_from_self();
}
inline void Ball::set_angle_from_self(float value) {
  _internal_set_angle_from_self(value);
  // @@protoc_insertion_point(field_set:protos.Ball.angle_from_self)
}
inline float Ball::_internal_angle_from_self() const {
  return _impl_.angle_from_self_;
}
inline void Ball::_internal_set_angle_from_self(float value) {
  ;
  _impl_.angle_from_self_ = value;
}

// -------------------------------------------------------------------

// Player

// .protos.Vector2D position = 1;
inline bool Player::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Player::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Player::_internal_position() const {
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Player::position() const {
  // @@protoc_insertion_point(field_get:protos.Player.position)
  return _internal_position();
}
inline void Player::unsafe_arena_set_allocated_position(
    ::protos::Vector2D* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Player.position)
}
inline ::protos::Vector2D* Player::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Player::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protos.Player.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Player::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* Player::mutable_position() {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.Player.position)
  return _msg;
}
inline void Player::set_allocated_position(::protos::Vector2D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protos.Player.position)
}

// .protos.Vector2D seen_position = 2;
inline bool Player::has_seen_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_position_ != nullptr);
  return value;
}
inline void Player::clear_seen_position() {
  if (_impl_.seen_position_ != nullptr) _impl_.seen_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& Player::_internal_seen_position() const {
  const ::protos::Vector2D* p = _impl_.seen_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Player::seen_position() const {
  // @@protoc_insertion_point(field_get:protos.Player.seen_position)
  return _internal_seen_position();
}
inline void Player::unsafe_arena_set_allocated_seen_position(
    ::protos::Vector2D* seen_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.seen_position_);
  }
  _impl_.seen_position_ = seen_position;
  if (seen_position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Player.seen_position)
}
inline ::protos::Vector2D* Player::release_seen_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Player::unsafe_arena_release_seen_position() {
  // @@protoc_insertion_point(field_release:protos.Player.seen_position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Player::_internal_mutable_seen_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.seen_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.seen_position_ = p;
  }
  return _impl_.seen_position_;
}
inline ::protos::Vector2D* Player::mutable_seen_position() {
  ::protos::Vector2D* _msg = _internal_mutable_seen_position();
  // @@protoc_insertion_point(field_mutable:protos.Player.seen_position)
  return _msg;
}
inline void Player::set_allocated_seen_position(::protos::Vector2D* seen_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.seen_position_;
  }
  if (seen_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seen_position);
    if (message_arena != submessage_arena) {
      seen_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seen_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.seen_position_ = seen_position;
  // @@protoc_insertion_point(field_set_allocated:protos.Player.seen_position)
}

// .protos.Vector2D heard_position = 3;
inline bool Player::has_heard_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heard_position_ != nullptr);
  return value;
}
inline void Player::clear_heard_position() {
  if (_impl_.heard_position_ != nullptr) _impl_.heard_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& Player::_internal_heard_position() const {
  const ::protos::Vector2D* p = _impl_.heard_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Player::heard_position() const {
  // @@protoc_insertion_point(field_get:protos.Player.heard_position)
  return _internal_heard_position();
}
inline void Player::unsafe_arena_set_allocated_heard_position(
    ::protos::Vector2D* heard_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.heard_position_);
  }
  _impl_.heard_position_ = heard_position;
  if (heard_position) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Player.heard_position)
}
inline ::protos::Vector2D* Player::release_heard_position() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Player::unsafe_arena_release_heard_position() {
  // @@protoc_insertion_point(field_release:protos.Player.heard_position)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Player::_internal_mutable_heard_position() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.heard_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.heard_position_ = p;
  }
  return _impl_.heard_position_;
}
inline ::protos::Vector2D* Player::mutable_heard_position() {
  ::protos::Vector2D* _msg = _internal_mutable_heard_position();
  // @@protoc_insertion_point(field_mutable:protos.Player.heard_position)
  return _msg;
}
inline void Player::set_allocated_heard_position(::protos::Vector2D* heard_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.heard_position_;
  }
  if (heard_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(heard_position);
    if (message_arena != submessage_arena) {
      heard_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heard_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.heard_position_ = heard_position;
  // @@protoc_insertion_point(field_set_allocated:protos.Player.heard_position)
}

// .protos.Vector2D velocity = 4;
inline bool Player::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void Player::clear_velocity() {
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::protos::Vector2D& Player::_internal_velocity() const {
  const ::protos::Vector2D* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Player::velocity() const {
  // @@protoc_insertion_point(field_get:protos.Player.velocity)
  return _internal_velocity();
}
inline void Player::unsafe_arena_set_allocated_velocity(
    ::protos::Vector2D* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Player.velocity)
}
inline ::protos::Vector2D* Player::release_velocity() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Player::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:protos.Player.velocity)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Player::_internal_mutable_velocity() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::protos::Vector2D* Player::mutable_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Player.velocity)
  return _msg;
}
inline void Player::set_allocated_velocity(::protos::Vector2D* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.Player.velocity)
}

// .protos.Vector2D seen_velocity = 5;
inline bool Player::has_seen_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_velocity_ != nullptr);
  return value;
}
inline void Player::clear_seen_velocity() {
  if (_impl_.seen_velocity_ != nullptr) _impl_.seen_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::protos::Vector2D& Player::_internal_seen_velocity() const {
  const ::protos::Vector2D* p = _impl_.seen_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Player::seen_velocity() const {
  // @@protoc_insertion_point(field_get:protos.Player.seen_velocity)
  return _internal_seen_velocity();
}
inline void Player::unsafe_arena_set_allocated_seen_velocity(
    ::protos::Vector2D* seen_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.seen_velocity_);
  }
  _impl_.seen_velocity_ = seen_velocity;
  if (seen_velocity) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Player.seen_velocity)
}
inline ::protos::Vector2D* Player::release_seen_velocity() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* temp = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Player::unsafe_arena_release_seen_velocity() {
  // @@protoc_insertion_point(field_release:protos.Player.seen_velocity)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* temp = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Player::_internal_mutable_seen_velocity() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.seen_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.seen_velocity_ = p;
  }
  return _impl_.seen_velocity_;
}
inline ::protos::Vector2D* Player::mutable_seen_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_seen_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Player.seen_velocity)
  return _msg;
}
inline void Player::set_allocated_seen_velocity(::protos::Vector2D* seen_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.seen_velocity_;
  }
  if (seen_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seen_velocity);
    if (message_arena != submessage_arena) {
      seen_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seen_velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.seen_velocity_ = seen_velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.Player.seen_velocity)
}

// int32 pos_count = 6;
inline void Player::clear_pos_count() {
  _impl_.pos_count_ = 0;
}
inline ::int32_t Player::pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.pos_count)
  return _internal_pos_count();
}
inline void Player::set_pos_count(::int32_t value) {
  _internal_set_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.pos_count)
}
inline ::int32_t Player::_internal_pos_count() const {
  return _impl_.pos_count_;
}
inline void Player::_internal_set_pos_count(::int32_t value) {
  ;
  _impl_.pos_count_ = value;
}

// int32 seen_pos_count = 7;
inline void Player::clear_seen_pos_count() {
  _impl_.seen_pos_count_ = 0;
}
inline ::int32_t Player::seen_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.seen_pos_count)
  return _internal_seen_pos_count();
}
inline void Player::set_seen_pos_count(::int32_t value) {
  _internal_set_seen_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.seen_pos_count)
}
inline ::int32_t Player::_internal_seen_pos_count() const {
  return _impl_.seen_pos_count_;
}
inline void Player::_internal_set_seen_pos_count(::int32_t value) {
  ;
  _impl_.seen_pos_count_ = value;
}

// int32 heard_pos_count = 8;
inline void Player::clear_heard_pos_count() {
  _impl_.heard_pos_count_ = 0;
}
inline ::int32_t Player::heard_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.heard_pos_count)
  return _internal_heard_pos_count();
}
inline void Player::set_heard_pos_count(::int32_t value) {
  _internal_set_heard_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.heard_pos_count)
}
inline ::int32_t Player::_internal_heard_pos_count() const {
  return _impl_.heard_pos_count_;
}
inline void Player::_internal_set_heard_pos_count(::int32_t value) {
  ;
  _impl_.heard_pos_count_ = value;
}

// int32 vel_count = 9;
inline void Player::clear_vel_count() {
  _impl_.vel_count_ = 0;
}
inline ::int32_t Player::vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.vel_count)
  return _internal_vel_count();
}
inline void Player::set_vel_count(::int32_t value) {
  _internal_set_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.vel_count)
}
inline ::int32_t Player::_internal_vel_count() const {
  return _impl_.vel_count_;
}
inline void Player::_internal_set_vel_count(::int32_t value) {
  ;
  _impl_.vel_count_ = value;
}

// int32 seen_vel_count = 10;
inline void Player::clear_seen_vel_count() {
  _impl_.seen_vel_count_ = 0;
}
inline ::int32_t Player::seen_vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.seen_vel_count)
  return _internal_seen_vel_count();
}
inline void Player::set_seen_vel_count(::int32_t value) {
  _internal_set_seen_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.seen_vel_count)
}
inline ::int32_t Player::_internal_seen_vel_count() const {
  return _impl_.seen_vel_count_;
}
inline void Player::_internal_set_seen_vel_count(::int32_t value) {
  ;
  _impl_.seen_vel_count_ = value;
}

// int32 ghost_count = 11;
inline void Player::clear_ghost_count() {
  _impl_.ghost_count_ = 0;
}
inline ::int32_t Player::ghost_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.ghost_count)
  return _internal_ghost_count();
}
inline void Player::set_ghost_count(::int32_t value) {
  _internal_set_ghost_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.ghost_count)
}
inline ::int32_t Player::_internal_ghost_count() const {
  return _impl_.ghost_count_;
}
inline void Player::_internal_set_ghost_count(::int32_t value) {
  ;
  _impl_.ghost_count_ = value;
}

// float dist_from_self = 12;
inline void Player::clear_dist_from_self() {
  _impl_.dist_from_self_ = 0;
}
inline float Player::dist_from_self() const {
  // @@protoc_insertion_point(field_get:protos.Player.dist_from_self)
  return _internal_dist_from_self();
}
inline void Player::set_dist_from_self(float value) {
  _internal_set_dist_from_self(value);
  // @@protoc_insertion_point(field_set:protos.Player.dist_from_self)
}
inline float Player::_internal_dist_from_self() const {
  return _impl_.dist_from_self_;
}
inline void Player::_internal_set_dist_from_self(float value) {
  ;
  _impl_.dist_from_self_ = value;
}

// float angle_from_self = 13;
inline void Player::clear_angle_from_self() {
  _impl_.angle_from_self_ = 0;
}
inline float Player::angle_from_self() const {
  // @@protoc_insertion_point(field_get:protos.Player.angle_from_self)
  return _internal_angle_from_self();
}
inline void Player::set_angle_from_self(float value) {
  _internal_set_angle_from_self(value);
  // @@protoc_insertion_point(field_set:protos.Player.angle_from_self)
}
inline float Player::_internal_angle_from_self() const {
  return _impl_.angle_from_self_;
}
inline void Player::_internal_set_angle_from_self(float value) {
  ;
  _impl_.angle_from_self_ = value;
}

// int32 id = 14;
inline void Player::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t Player::id() const {
  // @@protoc_insertion_point(field_get:protos.Player.id)
  return _internal_id();
}
inline void Player::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:protos.Player.id)
}
inline ::int32_t Player::_internal_id() const {
  return _impl_.id_;
}
inline void Player::_internal_set_id(::int32_t value) {
  ;
  _impl_.id_ = value;
}

// .protos.Side side = 15;
inline void Player::clear_side() {
  _impl_.side_ = 0;
}
inline ::protos::Side Player::side() const {
  // @@protoc_insertion_point(field_get:protos.Player.side)
  return _internal_side();
}
inline void Player::set_side(::protos::Side value) {
   _internal_set_side(value);
  // @@protoc_insertion_point(field_set:protos.Player.side)
}
inline ::protos::Side Player::_internal_side() const {
  return static_cast<::protos::Side>(_impl_.side_);
}
inline void Player::_internal_set_side(::protos::Side value) {
  ;
  _impl_.side_ = value;
}

// int32 uniform_number = 16;
inline void Player::clear_uniform_number() {
  _impl_.uniform_number_ = 0;
}
inline ::int32_t Player::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.Player.uniform_number)
  return _internal_uniform_number();
}
inline void Player::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.Player.uniform_number)
}
inline ::int32_t Player::_internal_uniform_number() const {
  return _impl_.uniform_number_;
}
inline void Player::_internal_set_uniform_number(::int32_t value) {
  ;
  _impl_.uniform_number_ = value;
}

// int32 uniform_number_count = 17;
inline void Player::clear_uniform_number_count() {
  _impl_.uniform_number_count_ = 0;
}
inline ::int32_t Player::uniform_number_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.uniform_number_count)
  return _internal_uniform_number_count();
}
inline void Player::set_uniform_number_count(::int32_t value) {
  _internal_set_uniform_number_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.uniform_number_count)
}
inline ::int32_t Player::_internal_uniform_number_count() const {
  return _impl_.uniform_number_count_;
}
inline void Player::_internal_set_uniform_number_count(::int32_t value) {
  ;
  _impl_.uniform_number_count_ = value;
}

// bool is_goalie = 18;
inline void Player::clear_is_goalie() {
  _impl_.is_goalie_ = false;
}
inline bool Player::is_goalie() const {
  // @@protoc_insertion_point(field_get:protos.Player.is_goalie)
  return _internal_is_goalie();
}
inline void Player::set_is_goalie(bool value) {
  _internal_set_is_goalie(value);
  // @@protoc_insertion_point(field_set:protos.Player.is_goalie)
}
inline bool Player::_internal_is_goalie() const {
  return _impl_.is_goalie_;
}
inline void Player::_internal_set_is_goalie(bool value) {
  ;
  _impl_.is_goalie_ = value;
}

// float body_direction = 19;
inline void Player::clear_body_direction() {
  _impl_.body_direction_ = 0;
}
inline float Player::body_direction() const {
  // @@protoc_insertion_point(field_get:protos.Player.body_direction)
  return _internal_body_direction();
}
inline void Player::set_body_direction(float value) {
  _internal_set_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.Player.body_direction)
}
inline float Player::_internal_body_direction() const {
  return _impl_.body_direction_;
}
inline void Player::_internal_set_body_direction(float value) {
  ;
  _impl_.body_direction_ = value;
}

// int32 body_direction_count = 20;
inline void Player::clear_body_direction_count() {
  _impl_.body_direction_count_ = 0;
}
inline ::int32_t Player::body_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.body_direction_count)
  return _internal_body_direction_count();
}
inline void Player::set_body_direction_count(::int32_t value) {
  _internal_set_body_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.body_direction_count)
}
inline ::int32_t Player::_internal_body_direction_count() const {
  return _impl_.body_direction_count_;
}
inline void Player::_internal_set_body_direction_count(::int32_t value) {
  ;
  _impl_.body_direction_count_ = value;
}

// float face_direction = 21;
inline void Player::clear_face_direction() {
  _impl_.face_direction_ = 0;
}
inline float Player::face_direction() const {
  // @@protoc_insertion_point(field_get:protos.Player.face_direction)
  return _internal_face_direction();
}
inline void Player::set_face_direction(float value) {
  _internal_set_face_direction(value);
  // @@protoc_insertion_point(field_set:protos.Player.face_direction)
}
inline float Player::_internal_face_direction() const {
  return _impl_.face_direction_;
}
inline void Player::_internal_set_face_direction(float value) {
  ;
  _impl_.face_direction_ = value;
}

// int32 face_direction_count = 22;
inline void Player::clear_face_direction_count() {
  _impl_.face_direction_count_ = 0;
}
inline ::int32_t Player::face_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.face_direction_count)
  return _internal_face_direction_count();
}
inline void Player::set_face_direction_count(::int32_t value) {
  _internal_set_face_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.face_direction_count)
}
inline ::int32_t Player::_internal_face_direction_count() const {
  return _impl_.face_direction_count_;
}
inline void Player::_internal_set_face_direction_count(::int32_t value) {
  ;
  _impl_.face_direction_count_ = value;
}

// float point_to_direction = 23;
inline void Player::clear_point_to_direction() {
  _impl_.point_to_direction_ = 0;
}
inline float Player::point_to_direction() const {
  // @@protoc_insertion_point(field_get:protos.Player.point_to_direction)
  return _internal_point_to_direction();
}
inline void Player::set_point_to_direction(float value) {
  _internal_set_point_to_direction(value);
  // @@protoc_insertion_point(field_set:protos.Player.point_to_direction)
}
inline float Player::_internal_point_to_direction() const {
  return _impl_.point_to_direction_;
}
inline void Player::_internal_set_point_to_direction(float value) {
  ;
  _impl_.point_to_direction_ = value;
}

// int32 point_to_direction_count = 24;
inline void Player::clear_point_to_direction_count() {
  _impl_.point_to_direction_count_ = 0;
}
inline ::int32_t Player::point_to_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.point_to_direction_count)
  return _internal_point_to_direction_count();
}
inline void Player::set_point_to_direction_count(::int32_t value) {
  _internal_set_point_to_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.point_to_direction_count)
}
inline ::int32_t Player::_internal_point_to_direction_count() const {
  return _impl_.point_to_direction_count_;
}
inline void Player::_internal_set_point_to_direction_count(::int32_t value) {
  ;
  _impl_.point_to_direction_count_ = value;
}

// bool is_kicking = 25;
inline void Player::clear_is_kicking() {
  _impl_.is_kicking_ = false;
}
inline bool Player::is_kicking() const {
  // @@protoc_insertion_point(field_get:protos.Player.is_kicking)
  return _internal_is_kicking();
}
inline void Player::set_is_kicking(bool value) {
  _internal_set_is_kicking(value);
  // @@protoc_insertion_point(field_set:protos.Player.is_kicking)
}
inline bool Player::_internal_is_kicking() const {
  return _impl_.is_kicking_;
}
inline void Player::_internal_set_is_kicking(bool value) {
  ;
  _impl_.is_kicking_ = value;
}

// float dist_from_ball = 26;
inline void Player::clear_dist_from_ball() {
  _impl_.dist_from_ball_ = 0;
}
inline float Player::dist_from_ball() const {
  // @@protoc_insertion_point(field_get:protos.Player.dist_from_ball)
  return _internal_dist_from_ball();
}
inline void Player::set_dist_from_ball(float value) {
  _internal_set_dist_from_ball(value);
  // @@protoc_insertion_point(field_set:protos.Player.dist_from_ball)
}
inline float Player::_internal_dist_from_ball() const {
  return _impl_.dist_from_ball_;
}
inline void Player::_internal_set_dist_from_ball(float value) {
  ;
  _impl_.dist_from_ball_ = value;
}

// float angle_from_ball = 27;
inline void Player::clear_angle_from_ball() {
  _impl_.angle_from_ball_ = 0;
}
inline float Player::angle_from_ball() const {
  // @@protoc_insertion_point(field_get:protos.Player.angle_from_ball)
  return _internal_angle_from_ball();
}
inline void Player::set_angle_from_ball(float value) {
  _internal_set_angle_from_ball(value);
  // @@protoc_insertion_point(field_set:protos.Player.angle_from_ball)
}
inline float Player::_internal_angle_from_ball() const {
  return _impl_.angle_from_ball_;
}
inline void Player::_internal_set_angle_from_ball(float value) {
  ;
  _impl_.angle_from_ball_ = value;
}

// int32 ball_reach_steps = 28;
inline void Player::clear_ball_reach_steps() {
  _impl_.ball_reach_steps_ = 0;
}
inline ::int32_t Player::ball_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.Player.ball_reach_steps)
  return _internal_ball_reach_steps();
}
inline void Player::set_ball_reach_steps(::int32_t value) {
  _internal_set_ball_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.Player.ball_reach_steps)
}
inline ::int32_t Player::_internal_ball_reach_steps() const {
  return _impl_.ball_reach_steps_;
}
inline void Player::_internal_set_ball_reach_steps(::int32_t value) {
  ;
  _impl_.ball_reach_steps_ = value;
}

// bool is_tackling = 29;
inline void Player::clear_is_tackling() {
  _impl_.is_tackling_ = false;
}
inline bool Player::is_tackling() const {
  // @@protoc_insertion_point(field_get:protos.Player.is_tackling)
  return _internal_is_tackling();
}
inline void Player::set_is_tackling(bool value) {
  _internal_set_is_tackling(value);
  // @@protoc_insertion_point(field_set:protos.Player.is_tackling)
}
inline bool Player::_internal_is_tackling() const {
  return _impl_.is_tackling_;
}
inline void Player::_internal_set_is_tackling(bool value) {
  ;
  _impl_.is_tackling_ = value;
}

// -------------------------------------------------------------------

// Self

// .protos.Vector2D position = 1;
inline bool Self::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Self::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Self::_internal_position() const {
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Self::position() const {
  // @@protoc_insertion_point(field_get:protos.Self.position)
  return _internal_position();
}
inline void Self::unsafe_arena_set_allocated_position(
    ::protos::Vector2D* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Self.position)
}
inline ::protos::Vector2D* Self::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Self::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protos.Self.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Self::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* Self::mutable_position() {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.Self.position)
  return _msg;
}
inline void Self::set_allocated_position(::protos::Vector2D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protos.Self.position)
}

// .protos.Vector2D seen_position = 2;
inline bool Self::has_seen_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_position_ != nullptr);
  return value;
}
inline void Self::clear_seen_position() {
  if (_impl_.seen_position_ != nullptr) _impl_.seen_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& Self::_internal_seen_position() const {
  const ::protos::Vector2D* p = _impl_.seen_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Self::seen_position() const {
  // @@protoc_insertion_point(field_get:protos.Self.seen_position)
  return _internal_seen_position();
}
inline void Self::unsafe_arena_set_allocated_seen_position(
    ::protos::Vector2D* seen_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.seen_position_);
  }
  _impl_.seen_position_ = seen_position;
  if (seen_position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Self.seen_position)
}
inline ::protos::Vector2D* Self::release_seen_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Self::unsafe_arena_release_seen_position() {
  // @@protoc_insertion_point(field_release:protos.Self.seen_position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Self::_internal_mutable_seen_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.seen_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.seen_position_ = p;
  }
  return _impl_.seen_position_;
}
inline ::protos::Vector2D* Self::mutable_seen_position() {
  ::protos::Vector2D* _msg = _internal_mutable_seen_position();
  // @@protoc_insertion_point(field_mutable:protos.Self.seen_position)
  return _msg;
}
inline void Self::set_allocated_seen_position(::protos::Vector2D* seen_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.seen_position_;
  }
  if (seen_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seen_position);
    if (message_arena != submessage_arena) {
      seen_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seen_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.seen_position_ = seen_position;
  // @@protoc_insertion_point(field_set_allocated:protos.Self.seen_position)
}

// .protos.Vector2D heard_position = 3;
inline bool Self::has_heard_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heard_position_ != nullptr);
  return value;
}
inline void Self::clear_heard_position() {
  if (_impl_.heard_position_ != nullptr) _impl_.heard_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& Self::_internal_heard_position() const {
  const ::protos::Vector2D* p = _impl_.heard_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Self::heard_position() const {
  // @@protoc_insertion_point(field_get:protos.Self.heard_position)
  return _internal_heard_position();
}
inline void Self::unsafe_arena_set_allocated_heard_position(
    ::protos::Vector2D* heard_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.heard_position_);
  }
  _impl_.heard_position_ = heard_position;
  if (heard_position) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Self.heard_position)
}
inline ::protos::Vector2D* Self::release_heard_position() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Self::unsafe_arena_release_heard_position() {
  // @@protoc_insertion_point(field_release:protos.Self.heard_position)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Self::_internal_mutable_heard_position() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.heard_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.heard_position_ = p;
  }
  return _impl_.heard_position_;
}
inline ::protos::Vector2D* Self::mutable_heard_position() {
  ::protos::Vector2D* _msg = _internal_mutable_heard_position();
  // @@protoc_insertion_point(field_mutable:protos.Self.heard_position)
  return _msg;
}
inline void Self::set_allocated_heard_position(::protos::Vector2D* heard_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.heard_position_;
  }
  if (heard_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(heard_position);
    if (message_arena != submessage_arena) {
      heard_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heard_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.heard_position_ = heard_position;
  // @@protoc_insertion_point(field_set_allocated:protos.Self.heard_position)
}

// .protos.Vector2D velocity = 4;
inline bool Self::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void Self::clear_velocity() {
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::protos::Vector2D& Self::_internal_velocity() const {
  const ::protos::Vector2D* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Self::velocity() const {
  // @@protoc_insertion_point(field_get:protos.Self.velocity)
  return _internal_velocity();
}
inline void Self::unsafe_arena_set_allocated_velocity(
    ::protos::Vector2D* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Self.velocity)
}
inline ::protos::Vector2D* Self::release_velocity() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Self::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:protos.Self.velocity)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Self::_internal_mutable_velocity() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::protos::Vector2D* Self::mutable_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Self.velocity)
  return _msg;
}
inline void Self::set_allocated_velocity(::protos::Vector2D* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.Self.velocity)
}

// .protos.Vector2D seen_velocity = 5;
inline bool Self::has_seen_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_velocity_ != nullptr);
  return value;
}
inline void Self::clear_seen_velocity() {
  if (_impl_.seen_velocity_ != nullptr) _impl_.seen_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::protos::Vector2D& Self::_internal_seen_velocity() const {
  const ::protos::Vector2D* p = _impl_.seen_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Self::seen_velocity() const {
  // @@protoc_insertion_point(field_get:protos.Self.seen_velocity)
  return _internal_seen_velocity();
}
inline void Self::unsafe_arena_set_allocated_seen_velocity(
    ::protos::Vector2D* seen_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.seen_velocity_);
  }
  _impl_.seen_velocity_ = seen_velocity;
  if (seen_velocity) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Self.seen_velocity)
}
inline ::protos::Vector2D* Self::release_seen_velocity() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* temp = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Self::unsafe_arena_release_seen_velocity() {
  // @@protoc_insertion_point(field_release:protos.Self.seen_velocity)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* temp = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Self::_internal_mutable_seen_velocity() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.seen_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.seen_velocity_ = p;
  }
  return _impl_.seen_velocity_;
}
inline ::protos::Vector2D* Self::mutable_seen_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_seen_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Self.seen_velocity)
  return _msg;
}
inline void Self::set_allocated_seen_velocity(::protos::Vector2D* seen_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.seen_velocity_;
  }
  if (seen_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seen_velocity);
    if (message_arena != submessage_arena) {
      seen_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seen_velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.seen_velocity_ = seen_velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.Self.seen_velocity)
}

// int32 pos_count = 6;
inline void Self::clear_pos_count() {
  _impl_.pos_count_ = 0;
}
inline ::int32_t Self::pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.pos_count)
  return _internal_pos_count();
}
inline void Self::set_pos_count(::int32_t value) {
  _internal_set_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.pos_count)
}
inline ::int32_t Self::_internal_pos_count() const {
  return _impl_.pos_count_;
}
inline void Self::_internal_set_pos_count(::int32_t value) {
  ;
  _impl_.pos_count_ = value;
}

// int32 seen_pos_count = 7;
inline void Self::clear_seen_pos_count() {
  _impl_.seen_pos_count_ = 0;
}
inline ::int32_t Self::seen_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.seen_pos_count)
  return _internal_seen_pos_count();
}
inline void Self::set_seen_pos_count(::int32_t value) {
  _internal_set_seen_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.seen_pos_count)
}
inline ::int32_t Self::_internal_seen_pos_count() const {
  return _impl_.seen_pos_count_;
}
inline void Self::_internal_set_seen_pos_count(::int32_t value) {
  ;
  _impl_.seen_pos_count_ = value;
}

// int32 heard_pos_count = 8;
inline void Self::clear_heard_pos_count() {
  _impl_.heard_pos_count_ = 0;
}
inline ::int32_t Self::heard_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.heard_pos_count)
  return _internal_heard_pos_count();
}
inline void Self::set_heard_pos_count(::int32_t value) {
  _internal_set_heard_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.heard_pos_count)
}
inline ::int32_t Self::_internal_heard_pos_count() const {
  return _impl_.heard_pos_count_;
}
inline void Self::_internal_set_heard_pos_count(::int32_t value) {
  ;
  _impl_.heard_pos_count_ = value;
}

// int32 vel_count = 9;
inline void Self::clear_vel_count() {
  _impl_.vel_count_ = 0;
}
inline ::int32_t Self::vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.vel_count)
  return _internal_vel_count();
}
inline void Self::set_vel_count(::int32_t value) {
  _internal_set_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.vel_count)
}
inline ::int32_t Self::_internal_vel_count() const {
  return _impl_.vel_count_;
}
inline void Self::_internal_set_vel_count(::int32_t value) {
  ;
  _impl_.vel_count_ = value;
}

// int32 seen_vel_count = 10;
inline void Self::clear_seen_vel_count() {
  _impl_.seen_vel_count_ = 0;
}
inline ::int32_t Self::seen_vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.seen_vel_count)
  return _internal_seen_vel_count();
}
inline void Self::set_seen_vel_count(::int32_t value) {
  _internal_set_seen_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.seen_vel_count)
}
inline ::int32_t Self::_internal_seen_vel_count() const {
  return _impl_.seen_vel_count_;
}
inline void Self::_internal_set_seen_vel_count(::int32_t value) {
  ;
  _impl_.seen_vel_count_ = value;
}

// int32 ghost_count = 11;
inline void Self::clear_ghost_count() {
  _impl_.ghost_count_ = 0;
}
inline ::int32_t Self::ghost_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.ghost_count)
  return _internal_ghost_count();
}
inline void Self::set_ghost_count(::int32_t value) {
  _internal_set_ghost_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.ghost_count)
}
inline ::int32_t Self::_internal_ghost_count() const {
  return _impl_.ghost_count_;
}
inline void Self::_internal_set_ghost_count(::int32_t value) {
  ;
  _impl_.ghost_count_ = value;
}

// int32 id = 12;
inline void Self::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t Self::id() const {
  // @@protoc_insertion_point(field_get:protos.Self.id)
  return _internal_id();
}
inline void Self::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:protos.Self.id)
}
inline ::int32_t Self::_internal_id() const {
  return _impl_.id_;
}
inline void Self::_internal_set_id(::int32_t value) {
  ;
  _impl_.id_ = value;
}

// .protos.Side side = 13;
inline void Self::clear_side() {
  _impl_.side_ = 0;
}
inline ::protos::Side Self::side() const {
  // @@protoc_insertion_point(field_get:protos.Self.side)
  return _internal_side();
}
inline void Self::set_side(::protos::Side value) {
   _internal_set_side(value);
  // @@protoc_insertion_point(field_set:protos.Self.side)
}
inline ::protos::Side Self::_internal_side() const {
  return static_cast<::protos::Side>(_impl_.side_);
}
inline void Self::_internal_set_side(::protos::Side value) {
  ;
  _impl_.side_ = value;
}

// int32 uniform_number = 14;
inline void Self::clear_uniform_number() {
  _impl_.uniform_number_ = 0;
}
inline ::int32_t Self::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.Self.uniform_number)
  return _internal_uniform_number();
}
inline void Self::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.Self.uniform_number)
}
inline ::int32_t Self::_internal_uniform_number() const {
  return _impl_.uniform_number_;
}
inline void Self::_internal_set_uniform_number(::int32_t value) {
  ;
  _impl_.uniform_number_ = value;
}

// int32 uniform_number_count = 15;
inline void Self::clear_uniform_number_count() {
  _impl_.uniform_number_count_ = 0;
}
inline ::int32_t Self::uniform_number_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.uniform_number_count)
  return _internal_uniform_number_count();
}
inline void Self::set_uniform_number_count(::int32_t value) {
  _internal_set_uniform_number_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.uniform_number_count)
}
inline ::int32_t Self::_internal_uniform_number_count() const {
  return _impl_.uniform_number_count_;
}
inline void Self::_internal_set_uniform_number_count(::int32_t value) {
  ;
  _impl_.uniform_number_count_ = value;
}

// bool is_goalie = 16;
inline void Self::clear_is_goalie() {
  _impl_.is_goalie_ = false;
}
inline bool Self::is_goalie() const {
  // @@protoc_insertion_point(field_get:protos.Self.is_goalie)
  return _internal_is_goalie();
}
inline void Self::set_is_goalie(bool value) {
  _internal_set_is_goalie(value);
  // @@protoc_insertion_point(field_set:protos.Self.is_goalie)
}
inline bool Self::_internal_is_goalie() const {
  return _impl_.is_goalie_;
}
inline void Self::_internal_set_is_goalie(bool value) {
  ;
  _impl_.is_goalie_ = value;
}

// float body_direction = 17;
inline void Self::clear_body_direction() {
  _impl_.body_direction_ = 0;
}
inline float Self::body_direction() const {
  // @@protoc_insertion_point(field_get:protos.Self.body_direction)
  return _internal_body_direction();
}
inline void Self::set_body_direction(float value) {
  _internal_set_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.Self.body_direction)
}
inline float Self::_internal_body_direction() const {
  return _impl_.body_direction_;
}
inline void Self::_internal_set_body_direction(float value) {
  ;
  _impl_.body_direction_ = value;
}

// int32 body_direction_count = 18;
inline void Self::clear_body_direction_count() {
  _impl_.body_direction_count_ = 0;
}
inline ::int32_t Self::body_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.body_direction_count)
  return _internal_body_direction_count();
}
inline void Self::set_body_direction_count(::int32_t value) {
  _internal_set_body_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.body_direction_count)
}
inline ::int32_t Self::_internal_body_direction_count() const {
  return _impl_.body_direction_count_;
}
inline void Self::_internal_set_body_direction_count(::int32_t value) {
  ;
  _impl_.body_direction_count_ = value;
}

// float face_direction = 19;
inline void Self::clear_face_direction() {
  _impl_.face_direction_ = 0;
}
inline float Self::face_direction() const {
  // @@protoc_insertion_point(field_get:protos.Self.face_direction)
  return _internal_face_direction();
}
inline void Self::set_face_direction(float value) {
  _internal_set_face_direction(value);
  // @@protoc_insertion_point(field_set:protos.Self.face_direction)
}
inline float Self::_internal_face_direction() const {
  return _impl_.face_direction_;
}
inline void Self::_internal_set_face_direction(float value) {
  ;
  _impl_.face_direction_ = value;
}

// int32 face_direction_count = 20;
inline void Self::clear_face_direction_count() {
  _impl_.face_direction_count_ = 0;
}
inline ::int32_t Self::face_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.face_direction_count)
  return _internal_face_direction_count();
}
inline void Self::set_face_direction_count(::int32_t value) {
  _internal_set_face_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.face_direction_count)
}
inline ::int32_t Self::_internal_face_direction_count() const {
  return _impl_.face_direction_count_;
}
inline void Self::_internal_set_face_direction_count(::int32_t value) {
  ;
  _impl_.face_direction_count_ = value;
}

// float point_to_direction = 21;
inline void Self::clear_point_to_direction() {
  _impl_.point_to_direction_ = 0;
}
inline float Self::point_to_direction() const {
  // @@protoc_insertion_point(field_get:protos.Self.point_to_direction)
  return _internal_point_to_direction();
}
inline void Self::set_point_to_direction(float value) {
  _internal_set_point_to_direction(value);
  // @@protoc_insertion_point(field_set:protos.Self.point_to_direction)
}
inline float Self::_internal_point_to_direction() const {
  return _impl_.point_to_direction_;
}
inline void Self::_internal_set_point_to_direction(float value) {
  ;
  _impl_.point_to_direction_ = value;
}

// int32 point_to_direction_count = 22;
inline void Self::clear_point_to_direction_count() {
  _impl_.point_to_direction_count_ = 0;
}
inline ::int32_t Self::point_to_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.point_to_direction_count)
  return _internal_point_to_direction_count();
}
inline void Self::set_point_to_direction_count(::int32_t value) {
  _internal_set_point_to_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.point_to_direction_count)
}
inline ::int32_t Self::_internal_point_to_direction_count() const {
  return _impl_.point_to_direction_count_;
}
inline void Self::_internal_set_point_to_direction_count(::int32_t value) {
  ;
  _impl_.point_to_direction_count_ = value;
}

// bool is_kicking = 23;
inline void Self::clear_is_kicking() {
  _impl_.is_kicking_ = false;
}
inline bool Self::is_kicking() const {
  // @@protoc_insertion_point(field_get:protos.Self.is_kicking)
  return _internal_is_kicking();
}
inline void Self::set_is_kicking(bool value) {
  _internal_set_is_kicking(value);
  // @@protoc_insertion_point(field_set:protos.Self.is_kicking)
}
inline bool Self::_internal_is_kicking() const {
  return _impl_.is_kicking_;
}
inline void Self::_internal_set_is_kicking(bool value) {
  ;
  _impl_.is_kicking_ = value;
}

// float dist_from_ball = 24;
inline void Self::clear_dist_from_ball() {
  _impl_.dist_from_ball_ = 0;
}
inline float Self::dist_from_ball() const {
  // @@protoc_insertion_point(field_get:protos.Self.dist_from_ball)
  return _internal_dist_from_ball();
}
inline void Self::set_dist_from_ball(float value) {
  _internal_set_dist_from_ball(value);
  // @@protoc_insertion_point(field_set:protos.Self.dist_from_ball)
}
inline float Self::_internal_dist_from_ball() const {
  return _impl_.dist_from_ball_;
}
inline void Self::_internal_set_dist_from_ball(float value) {
  ;
  _impl_.dist_from_ball_ = value;
}

// float angle_from_ball = 25;
inline void Self::clear_angle_from_ball() {
  _impl_.angle_from_ball_ = 0;
}
inline float Self::angle_from_ball() const {
  // @@protoc_insertion_point(field_get:protos.Self.angle_from_ball)
  return _internal_angle_from_ball();
}
inline void Self::set_angle_from_ball(float value) {
  _internal_set_angle_from_ball(value);
  // @@protoc_insertion_point(field_set:protos.Self.angle_from_ball)
}
inline float Self::_internal_angle_from_ball() const {
  return _impl_.angle_from_ball_;
}
inline void Self::_internal_set_angle_from_ball(float value) {
  ;
  _impl_.angle_from_ball_ = value;
}

// int32 ball_reach_steps = 26;
inline void Self::clear_ball_reach_steps() {
  _impl_.ball_reach_steps_ = 0;
}
inline ::int32_t Self::ball_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.Self.ball_reach_steps)
  return _internal_ball_reach_steps();
}
inline void Self::set_ball_reach_steps(::int32_t value) {
  _internal_set_ball_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.Self.ball_reach_steps)
}
inline ::int32_t Self::_internal_ball_reach_steps() const {
  return _impl_.ball_reach_steps_;
}
inline void Self::_internal_set_ball_reach_steps(::int32_t value) {
  ;
  _impl_.ball_reach_steps_ = value;
}

// bool is_tackling = 27;
inline void Self::clear_is_tackling() {
  _impl_.is_tackling_ = false;
}
inline bool Self::is_tackling() const {
  // @@protoc_insertion_point(field_get:protos.Self.is_tackling)
  return _internal_is_tackling();
}
inline void Self::set_is_tackling(bool value) {
  _internal_set_is_tackling(value);
  // @@protoc_insertion_point(field_set:protos.Self.is_tackling)
}
inline bool Self::_internal_is_tackling() const {
  return _impl_.is_tackling_;
}
inline void Self::_internal_set_is_tackling(bool value) {
  ;
  _impl_.is_tackling_ = value;
}

// float relative_neck_direction = 28;
inline void Self::clear_relative_neck_direction() {
  _impl_.relative_neck_direction_ = 0;
}
inline float Self::relative_neck_direction() const {
  // @@protoc_insertion_point(field_get:protos.Self.relative_neck_direction)
  return _internal_relative_neck_direction();
}
inline void Self::set_relative_neck_direction(float value) {
  _internal_set_relative_neck_direction(value);
  // @@protoc_insertion_point(field_set:protos.Self.relative_neck_direction)
}
inline float Self::_internal_relative_neck_direction() const {
  return _impl_.relative_neck_direction_;
}
inline void Self::_internal_set_relative_neck_direction(float value) {
  ;
  _impl_.relative_neck_direction_ = value;
}

// float stamina = 29;
inline void Self::clear_stamina() {
  _impl_.stamina_ = 0;
}
inline float Self::stamina() const {
  // @@protoc_insertion_point(field_get:protos.Self.stamina)
  return _internal_stamina();
}
inline void Self::set_stamina(float value) {
  _internal_set_stamina(value);
  // @@protoc_insertion_point(field_set:protos.Self.stamina)
}
inline float Self::_internal_stamina() const {
  return _impl_.stamina_;
}
inline void Self::_internal_set_stamina(float value) {
  ;
  _impl_.stamina_ = value;
}

// bool is_kickable = 30;
inline void Self::clear_is_kickable() {
  _impl_.is_kickable_ = false;
}
inline bool Self::is_kickable() const {
  // @@protoc_insertion_point(field_get:protos.Self.is_kickable)
  return _internal_is_kickable();
}
inline void Self::set_is_kickable(bool value) {
  _internal_set_is_kickable(value);
  // @@protoc_insertion_point(field_set:protos.Self.is_kickable)
}
inline bool Self::_internal_is_kickable() const {
  return _impl_.is_kickable_;
}
inline void Self::_internal_set_is_kickable(bool value) {
  ;
  _impl_.is_kickable_ = value;
}

// float catch_probability = 31;
inline void Self::clear_catch_probability() {
  _impl_.catch_probability_ = 0;
}
inline float Self::catch_probability() const {
  // @@protoc_insertion_point(field_get:protos.Self.catch_probability)
  return _internal_catch_probability();
}
inline void Self::set_catch_probability(float value) {
  _internal_set_catch_probability(value);
  // @@protoc_insertion_point(field_set:protos.Self.catch_probability)
}
inline float Self::_internal_catch_probability() const {
  return _impl_.catch_probability_;
}
inline void Self::_internal_set_catch_probability(float value) {
  ;
  _impl_.catch_probability_ = value;
}

// float tackle_probability = 32;
inline void Self::clear_tackle_probability() {
  _impl_.tackle_probability_ = 0;
}
inline float Self::tackle_probability() const {
  // @@protoc_insertion_point(field_get:protos.Self.tackle_probability)
  return _internal_tackle_probability();
}
inline void Self::set_tackle_probability(float value) {
  _internal_set_tackle_probability(value);
  // @@protoc_insertion_point(field_set:protos.Self.tackle_probability)
}
inline float Self::_internal_tackle_probability() const {
  return _impl_.tackle_probability_;
}
inline void Self::_internal_set_tackle_probability(float value) {
  ;
  _impl_.tackle_probability_ = value;
}

// float foul_probability = 33;
inline void Self::clear_foul_probability() {
  _impl_.foul_probability_ = 0;
}
inline float Self::foul_probability() const {
  // @@protoc_insertion_point(field_get:protos.Self.foul_probability)
  return _internal_foul_probability();
}
inline void Self::set_foul_probability(float value) {
  _internal_set_foul_probability(value);
  // @@protoc_insertion_point(field_set:protos.Self.foul_probability)
}
inline float Self::_internal_foul_probability() const {
  return _impl_.foul_probability_;
}
inline void Self::_internal_set_foul_probability(float value) {
  ;
  _impl_.foul_probability_ = value;
}

// .protos.ViewWidth view_width = 34;
inline void Self::clear_view_width() {
  _impl_.view_width_ = 0;
}
inline ::protos::ViewWidth Self::view_width() const {
  // @@protoc_insertion_point(field_get:protos.Self.view_width)
  return _internal_view_width();
}
inline void Self::set_view_width(::protos::ViewWidth value) {
   _internal_set_view_width(value);
  // @@protoc_insertion_point(field_set:protos.Self.view_width)
}
inline ::protos::ViewWidth Self::_internal_view_width() const {
  return static_cast<::protos::ViewWidth>(_impl_.view_width_);
}
inline void Self::_internal_set_view_width(::protos::ViewWidth value) {
  ;
  _impl_.view_width_ = value;
}

// -------------------------------------------------------------------

// InterceptInfo

// .protos.InterceptActionType action_type = 1;
inline void InterceptInfo::clear_action_type() {
  _impl_.action_type_ = 0;
}
inline ::protos::InterceptActionType InterceptInfo::action_type() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.action_type)
  return _internal_action_type();
}
inline void InterceptInfo::set_action_type(::protos::InterceptActionType value) {
   _internal_set_action_type(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.action_type)
}
inline ::protos::InterceptActionType InterceptInfo::_internal_action_type() const {
  return static_cast<::protos::InterceptActionType>(_impl_.action_type_);
}
inline void InterceptInfo::_internal_set_action_type(::protos::InterceptActionType value) {
  ;
  _impl_.action_type_ = value;
}

// int32 turn_steps = 2;
inline void InterceptInfo::clear_turn_steps() {
  _impl_.turn_steps_ = 0;
}
inline ::int32_t InterceptInfo::turn_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.turn_steps)
  return _internal_turn_steps();
}
inline void InterceptInfo::set_turn_steps(::int32_t value) {
  _internal_set_turn_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.turn_steps)
}
inline ::int32_t InterceptInfo::_internal_turn_steps() const {
  return _impl_.turn_steps_;
}
inline void InterceptInfo::_internal_set_turn_steps(::int32_t value) {
  ;
  _impl_.turn_steps_ = value;
}

// float turn_angle = 3;
inline void InterceptInfo::clear_turn_angle() {
  _impl_.turn_angle_ = 0;
}
inline float InterceptInfo::turn_angle() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.turn_angle)
  return _internal_turn_angle();
}
inline void InterceptInfo::set_turn_angle(float value) {
  _internal_set_turn_angle(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.turn_angle)
}
inline float InterceptInfo::_internal_turn_angle() const {
  return _impl_.turn_angle_;
}
inline void InterceptInfo::_internal_set_turn_angle(float value) {
  ;
  _impl_.turn_angle_ = value;
}

// int32 dash_steps = 4;
inline void InterceptInfo::clear_dash_steps() {
  _impl_.dash_steps_ = 0;
}
inline ::int32_t InterceptInfo::dash_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.dash_steps)
  return _internal_dash_steps();
}
inline void InterceptInfo::set_dash_steps(::int32_t value) {
  _internal_set_dash_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.dash_steps)
}
inline ::int32_t InterceptInfo::_internal_dash_steps() const {
  return _impl_.dash_steps_;
}
inline void InterceptInfo::_internal_set_dash_steps(::int32_t value) {
  ;
  _impl_.dash_steps_ = value;
}

// float dash_power = 5;
inline void InterceptInfo::clear_dash_power() {
  _impl_.dash_power_ = 0;
}
inline float InterceptInfo::dash_power() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.dash_power)
  return _internal_dash_power();
}
inline void InterceptInfo::set_dash_power(float value) {
  _internal_set_dash_power(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.dash_power)
}
inline float InterceptInfo::_internal_dash_power() const {
  return _impl_.dash_power_;
}
inline void InterceptInfo::_internal_set_dash_power(float value) {
  ;
  _impl_.dash_power_ = value;
}

// float dash_dir = 6;
inline void InterceptInfo::clear_dash_dir() {
  _impl_.dash_dir_ = 0;
}
inline float InterceptInfo::dash_dir() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.dash_dir)
  return _internal_dash_dir();
}
inline void InterceptInfo::set_dash_dir(float value) {
  _internal_set_dash_dir(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.dash_dir)
}
inline float InterceptInfo::_internal_dash_dir() const {
  return _impl_.dash_dir_;
}
inline void InterceptInfo::_internal_set_dash_dir(float value) {
  ;
  _impl_.dash_dir_ = value;
}

// .protos.Vector2D final_self_position = 7;
inline bool InterceptInfo::has_final_self_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.final_self_position_ != nullptr);
  return value;
}
inline void InterceptInfo::clear_final_self_position() {
  if (_impl_.final_self_position_ != nullptr) _impl_.final_self_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& InterceptInfo::_internal_final_self_position() const {
  const ::protos::Vector2D* p = _impl_.final_self_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& InterceptInfo::final_self_position() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.final_self_position)
  return _internal_final_self_position();
}
inline void InterceptInfo::unsafe_arena_set_allocated_final_self_position(
    ::protos::Vector2D* final_self_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.final_self_position_);
  }
  _impl_.final_self_position_ = final_self_position;
  if (final_self_position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.InterceptInfo.final_self_position)
}
inline ::protos::Vector2D* InterceptInfo::release_final_self_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.final_self_position_;
  _impl_.final_self_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* InterceptInfo::unsafe_arena_release_final_self_position() {
  // @@protoc_insertion_point(field_release:protos.InterceptInfo.final_self_position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.final_self_position_;
  _impl_.final_self_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* InterceptInfo::_internal_mutable_final_self_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.final_self_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.final_self_position_ = p;
  }
  return _impl_.final_self_position_;
}
inline ::protos::Vector2D* InterceptInfo::mutable_final_self_position() {
  ::protos::Vector2D* _msg = _internal_mutable_final_self_position();
  // @@protoc_insertion_point(field_mutable:protos.InterceptInfo.final_self_position)
  return _msg;
}
inline void InterceptInfo::set_allocated_final_self_position(::protos::Vector2D* final_self_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.final_self_position_;
  }
  if (final_self_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(final_self_position);
    if (message_arena != submessage_arena) {
      final_self_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, final_self_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.final_self_position_ = final_self_position;
  // @@protoc_insertion_point(field_set_allocated:protos.InterceptInfo.final_self_position)
}

// float final_ball_dist = 8;
inline void InterceptInfo::clear_final_ball_dist() {
  _impl_.final_ball_dist_ = 0;
}
inline float InterceptInfo::final_ball_dist() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.final_ball_dist)
  return _internal_final_ball_dist();
}
inline void InterceptInfo::set_final_ball_dist(float value) {
  _internal_set_final_ball_dist(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.final_ball_dist)
}
inline float InterceptInfo::_internal_final_ball_dist() const {
  return _impl_.final_ball_dist_;
}
inline void InterceptInfo::_internal_set_final_ball_dist(float value) {
  ;
  _impl_.final_ball_dist_ = value;
}

// float final_stamina = 9;
inline void InterceptInfo::clear_final_stamina() {
  _impl_.final_stamina_ = 0;
}
inline float InterceptInfo::final_stamina() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.final_stamina)
  return _internal_final_stamina();
}
inline void InterceptInfo::set_final_stamina(float value) {
  _internal_set_final_stamina(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.final_stamina)
}
inline float InterceptInfo::_internal_final_stamina() const {
  return _impl_.final_stamina_;
}
inline void InterceptInfo::_internal_set_final_stamina(float value) {
  ;
  _impl_.final_stamina_ = value;
}

// float value = 10;
inline void InterceptInfo::clear_value() {
  _impl_.value_ = 0;
}
inline float InterceptInfo::value() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.value)
  return _internal_value();
}
inline void InterceptInfo::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.value)
}
inline float InterceptInfo::_internal_value() const {
  return _impl_.value_;
}
inline void InterceptInfo::_internal_set_value(float value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// InterceptTable

// int32 self_reach_steps = 1;
inline void InterceptTable::clear_self_reach_steps() {
  _impl_.self_reach_steps_ = 0;
}
inline ::int32_t InterceptTable::self_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.self_reach_steps)
  return _internal_self_reach_steps();
}
inline void InterceptTable::set_self_reach_steps(::int32_t value) {
  _internal_set_self_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.self_reach_steps)
}
inline ::int32_t InterceptTable::_internal_self_reach_steps() const {
  return _impl_.self_reach_steps_;
}
inline void InterceptTable::_internal_set_self_reach_steps(::int32_t value) {
  ;
  _impl_.self_reach_steps_ = value;
}

// int32 first_teammate_reach_steps = 2;
inline void InterceptTable::clear_first_teammate_reach_steps() {
  _impl_.first_teammate_reach_steps_ = 0;
}
inline ::int32_t InterceptTable::first_teammate_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.first_teammate_reach_steps)
  return _internal_first_teammate_reach_steps();
}
inline void InterceptTable::set_first_teammate_reach_steps(::int32_t value) {
  _internal_set_first_teammate_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.first_teammate_reach_steps)
}
inline ::int32_t InterceptTable::_internal_first_teammate_reach_steps() const {
  return _impl_.first_teammate_reach_steps_;
}
inline void InterceptTable::_internal_set_first_teammate_reach_steps(::int32_t value) {
  ;
  _impl_.first_teammate_reach_steps_ = value;
}

// int32 second_teammate_reach_steps = 3;
inline void InterceptTable::clear_second_teammate_reach_steps() {
  _impl_.second_teammate_reach_steps_ = 0;
}
inline ::int32_t InterceptTable::second_teammate_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.second_teammate_reach_steps)
  return _internal_second_teammate_reach_steps();
}
inline void InterceptTable::set_second_teammate_reach_steps(::int32_t value) {
  _internal_set_second_teammate_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.second_teammate_reach_steps)
}
inline ::int32_t InterceptTable::_internal_second_teammate_reach_steps() const {
  return _impl_.second_teammate_reach_steps_;
}
inline void InterceptTable::_internal_set_second_teammate_reach_steps(::int32_t value) {
  ;
  _impl_.second_teammate_reach_steps_ = value;
}

// int32 first_opponent_reach_steps = 4;
inline void InterceptTable::clear_first_opponent_reach_steps() {
  _impl_.first_opponent_reach_steps_ = 0;
}
inline ::int32_t InterceptTable::first_opponent_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.first_opponent_reach_steps)
  return _internal_first_opponent_reach_steps();
}
inline void InterceptTable::set_first_opponent_reach_steps(::int32_t value) {
  _internal_set_first_opponent_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.first_opponent_reach_steps)
}
inline ::int32_t InterceptTable::_internal_first_opponent_reach_steps() const {
  return _impl_.first_opponent_reach_steps_;
}
inline void InterceptTable::_internal_set_first_opponent_reach_steps(::int32_t value) {
  ;
  _impl_.first_opponent_reach_steps_ = value;
}

// int32 second_opponent_reach_steps = 5;
inline void InterceptTable::clear_second_opponent_reach_steps() {
  _impl_.second_opponent_reach_steps_ = 0;
}
inline ::int32_t InterceptTable::second_opponent_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.second_opponent_reach_steps)
  return _internal_second_opponent_reach_steps();
}
inline void InterceptTable::set_second_opponent_reach_steps(::int32_t value) {
  _internal_set_second_opponent_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.second_opponent_reach_steps)
}
inline ::int32_t InterceptTable::_internal_second_opponent_reach_steps() const {
  return _impl_.second_opponent_reach_steps_;
}
inline void InterceptTable::_internal_set_second_opponent_reach_steps(::int32_t value) {
  ;
  _impl_.second_opponent_reach_steps_ = value;
}

// int32 first_teammate_id = 6;
inline void InterceptTable::clear_first_teammate_id() {
  _impl_.first_teammate_id_ = 0;
}
inline ::int32_t InterceptTable::first_teammate_id() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.first_teammate_id)
  return _internal_first_teammate_id();
}
inline void InterceptTable::set_first_teammate_id(::int32_t value) {
  _internal_set_first_teammate_id(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.first_teammate_id)
}
inline ::int32_t InterceptTable::_internal_first_teammate_id() const {
  return _impl_.first_teammate_id_;
}
inline void InterceptTable::_internal_set_first_teammate_id(::int32_t value) {
  ;
  _impl_.first_teammate_id_ = value;
}

// int32 second_teammate_id = 7;
inline void InterceptTable::clear_second_teammate_id() {
  _impl_.second_teammate_id_ = 0;
}
inline ::int32_t InterceptTable::second_teammate_id() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.second_teammate_id)
  return _internal_second_teammate_id();
}
inline void InterceptTable::set_second_teammate_id(::int32_t value) {
  _internal_set_second_teammate_id(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.second_teammate_id)
}
inline ::int32_t InterceptTable::_internal_second_teammate_id() const {
  return _impl_.second_teammate_id_;
}
inline void InterceptTable::_internal_set_second_teammate_id(::int32_t value) {
  ;
  _impl_.second_teammate_id_ = value;
}

// int32 first_opponent_id = 8;
inline void InterceptTable::clear_first_opponent_id() {
  _impl_.first_opponent_id_ = 0;
}
inline ::int32_t InterceptTable::first_opponent_id() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.first_opponent_id)
  return _internal_first_opponent_id();
}
inline void InterceptTable::set_first_opponent_id(::int32_t value) {
  _internal_set_first_opponent_id(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.first_opponent_id)
}
inline ::int32_t InterceptTable::_internal_first_opponent_id() const {
  return _impl_.first_opponent_id_;
}
inline void InterceptTable::_internal_set_first_opponent_id(::int32_t value) {
  ;
  _impl_.first_opponent_id_ = value;
}

// int32 second_opponent_id = 9;
inline void InterceptTable::clear_second_opponent_id() {
  _impl_.second_opponent_id_ = 0;
}
inline ::int32_t InterceptTable::second_opponent_id() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.second_opponent_id)
  return _internal_second_opponent_id();
}
inline void InterceptTable::set_second_opponent_id(::int32_t value) {
  _internal_set_second_opponent_id(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.second_opponent_id)
}
inline ::int32_t InterceptTable::_internal_second_opponent_id() const {
  return _impl_.second_opponent_id_;
}
inline void InterceptTable::_internal_set_second_opponent_id(::int32_t value) {
  ;
  _impl_.second_opponent_id_ = value;
}

// repeated .protos.InterceptInfo self_intercept_info = 10;
inline int InterceptTable::_internal_self_intercept_info_size() const {
  return _impl_.self_intercept_info_.size();
}
inline int InterceptTable::self_intercept_info_size() const {
  return _internal_self_intercept_info_size();
}
inline void InterceptTable::clear_self_intercept_info() {
  _internal_mutable_self_intercept_info()->Clear();
}
inline ::protos::InterceptInfo* InterceptTable::mutable_self_intercept_info(int index) {
  // @@protoc_insertion_point(field_mutable:protos.InterceptTable.self_intercept_info)
  return _internal_mutable_self_intercept_info()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::InterceptInfo >*
InterceptTable::mutable_self_intercept_info() {
  // @@protoc_insertion_point(field_mutable_list:protos.InterceptTable.self_intercept_info)
  return _internal_mutable_self_intercept_info();
}
inline const ::protos::InterceptInfo& InterceptTable::_internal_self_intercept_info(int index) const {
  return _internal_self_intercept_info().Get(index);
}
inline const ::protos::InterceptInfo& InterceptTable::self_intercept_info(int index) const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.self_intercept_info)
  return _internal_self_intercept_info(index);
}
inline ::protos::InterceptInfo* InterceptTable::_internal_add_self_intercept_info() {
  return _internal_mutable_self_intercept_info()->Add();
}
inline ::protos::InterceptInfo* InterceptTable::add_self_intercept_info() {
  ::protos::InterceptInfo* _add = _internal_add_self_intercept_info();
  // @@protoc_insertion_point(field_add:protos.InterceptTable.self_intercept_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::InterceptInfo >&
InterceptTable::self_intercept_info() const {
  // @@protoc_insertion_point(field_list:protos.InterceptTable.self_intercept_info)
  return _internal_self_intercept_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::InterceptInfo>&
InterceptTable::_internal_self_intercept_info() const {
  return _impl_.self_intercept_info_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::InterceptInfo>*
InterceptTable::_internal_mutable_self_intercept_info() {
  return &_impl_.self_intercept_info_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WorldModel

// .protos.InterceptTable intercept_table = 1;
inline bool WorldModel::has_intercept_table() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.intercept_table_ != nullptr);
  return value;
}
inline void WorldModel::clear_intercept_table() {
  if (_impl_.intercept_table_ != nullptr) _impl_.intercept_table_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::InterceptTable& WorldModel::_internal_intercept_table() const {
  const ::protos::InterceptTable* p = _impl_.intercept_table_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::InterceptTable&>(
      ::protos::_InterceptTable_default_instance_);
}
inline const ::protos::InterceptTable& WorldModel::intercept_table() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.intercept_table)
  return _internal_intercept_table();
}
inline void WorldModel::unsafe_arena_set_allocated_intercept_table(
    ::protos::InterceptTable* intercept_table) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.intercept_table_);
  }
  _impl_.intercept_table_ = intercept_table;
  if (intercept_table) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.WorldModel.intercept_table)
}
inline ::protos::InterceptTable* WorldModel::release_intercept_table() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::InterceptTable* temp = _impl_.intercept_table_;
  _impl_.intercept_table_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::InterceptTable* WorldModel::unsafe_arena_release_intercept_table() {
  // @@protoc_insertion_point(field_release:protos.WorldModel.intercept_table)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::InterceptTable* temp = _impl_.intercept_table_;
  _impl_.intercept_table_ = nullptr;
  return temp;
}
inline ::protos::InterceptTable* WorldModel::_internal_mutable_intercept_table() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.intercept_table_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::InterceptTable>(GetArenaForAllocation());
    _impl_.intercept_table_ = p;
  }
  return _impl_.intercept_table_;
}
inline ::protos::InterceptTable* WorldModel::mutable_intercept_table() {
  ::protos::InterceptTable* _msg = _internal_mutable_intercept_table();
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.intercept_table)
  return _msg;
}
inline void WorldModel::set_allocated_intercept_table(::protos::InterceptTable* intercept_table) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.intercept_table_;
  }
  if (intercept_table) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(intercept_table);
    if (message_arena != submessage_arena) {
      intercept_table = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intercept_table, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.intercept_table_ = intercept_table;
  // @@protoc_insertion_point(field_set_allocated:protos.WorldModel.intercept_table)
}

// string our_team_name = 2;
inline void WorldModel::clear_our_team_name() {
  _impl_.our_team_name_.ClearToEmpty();
}
inline const std::string& WorldModel::our_team_name() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.our_team_name)
  return _internal_our_team_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldModel::set_our_team_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.our_team_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.WorldModel.our_team_name)
}
inline std::string* WorldModel::mutable_our_team_name() {
  std::string* _s = _internal_mutable_our_team_name();
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.our_team_name)
  return _s;
}
inline const std::string& WorldModel::_internal_our_team_name() const {
  return _impl_.our_team_name_.Get();
}
inline void WorldModel::_internal_set_our_team_name(const std::string& value) {
  ;


  _impl_.our_team_name_.Set(value, GetArenaForAllocation());
}
inline std::string* WorldModel::_internal_mutable_our_team_name() {
  ;
  return _impl_.our_team_name_.Mutable( GetArenaForAllocation());
}
inline std::string* WorldModel::release_our_team_name() {
  // @@protoc_insertion_point(field_release:protos.WorldModel.our_team_name)
  return _impl_.our_team_name_.Release();
}
inline void WorldModel::set_allocated_our_team_name(std::string* value) {
  _impl_.our_team_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.our_team_name_.IsDefault()) {
          _impl_.our_team_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.WorldModel.our_team_name)
}

// string their_team_name = 3;
inline void WorldModel::clear_their_team_name() {
  _impl_.their_team_name_.ClearToEmpty();
}
inline const std::string& WorldModel::their_team_name() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.their_team_name)
  return _internal_their_team_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldModel::set_their_team_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.their_team_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.WorldModel.their_team_name)
}
inline std::string* WorldModel::mutable_their_team_name() {
  std::string* _s = _internal_mutable_their_team_name();
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.their_team_name)
  return _s;
}
inline const std::string& WorldModel::_internal_their_team_name() const {
  return _impl_.their_team_name_.Get();
}
inline void WorldModel::_internal_set_their_team_name(const std::string& value) {
  ;


  _impl_.their_team_name_.Set(value, GetArenaForAllocation());
}
inline std::string* WorldModel::_internal_mutable_their_team_name() {
  ;
  return _impl_.their_team_name_.Mutable( GetArenaForAllocation());
}
inline std::string* WorldModel::release_their_team_name() {
  // @@protoc_insertion_point(field_release:protos.WorldModel.their_team_name)
  return _impl_.their_team_name_.Release();
}
inline void WorldModel::set_allocated_their_team_name(std::string* value) {
  _impl_.their_team_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.their_team_name_.IsDefault()) {
          _impl_.their_team_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.WorldModel.their_team_name)
}

// .protos.Side our_side = 4;
inline void WorldModel::clear_our_side() {
  _impl_.our_side_ = 0;
}
inline ::protos::Side WorldModel::our_side() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.our_side)
  return _internal_our_side();
}
inline void WorldModel::set_our_side(::protos::Side value) {
   _internal_set_our_side(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.our_side)
}
inline ::protos::Side WorldModel::_internal_our_side() const {
  return static_cast<::protos::Side>(_impl_.our_side_);
}
inline void WorldModel::_internal_set_our_side(::protos::Side value) {
  ;
  _impl_.our_side_ = value;
}

// int32 last_set_play_start_time = 5;
inline void WorldModel::clear_last_set_play_start_time() {
  _impl_.last_set_play_start_time_ = 0;
}
inline ::int32_t WorldModel::last_set_play_start_time() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.last_set_play_start_time)
  return _internal_last_set_play_start_time();
}
inline void WorldModel::set_last_set_play_start_time(::int32_t value) {
  _internal_set_last_set_play_start_time(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.last_set_play_start_time)
}
inline ::int32_t WorldModel::_internal_last_set_play_start_time() const {
  return _impl_.last_set_play_start_time_;
}
inline void WorldModel::_internal_set_last_set_play_start_time(::int32_t value) {
  ;
  _impl_.last_set_play_start_time_ = value;
}

// .protos.Self self = 6;
inline bool WorldModel::has_self() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.self_ != nullptr);
  return value;
}
inline void WorldModel::clear_self() {
  if (_impl_.self_ != nullptr) _impl_.self_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Self& WorldModel::_internal_self() const {
  const ::protos::Self* p = _impl_.self_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Self&>(
      ::protos::_Self_default_instance_);
}
inline const ::protos::Self& WorldModel::self() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.self)
  return _internal_self();
}
inline void WorldModel::unsafe_arena_set_allocated_self(
    ::protos::Self* self) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.self_);
  }
  _impl_.self_ = self;
  if (self) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.WorldModel.self)
}
inline ::protos::Self* WorldModel::release_self() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Self* temp = _impl_.self_;
  _impl_.self_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Self* WorldModel::unsafe_arena_release_self() {
  // @@protoc_insertion_point(field_release:protos.WorldModel.self)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Self* temp = _impl_.self_;
  _impl_.self_ = nullptr;
  return temp;
}
inline ::protos::Self* WorldModel::_internal_mutable_self() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.self_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Self>(GetArenaForAllocation());
    _impl_.self_ = p;
  }
  return _impl_.self_;
}
inline ::protos::Self* WorldModel::mutable_self() {
  ::protos::Self* _msg = _internal_mutable_self();
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.self)
  return _msg;
}
inline void WorldModel::set_allocated_self(::protos::Self* self) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.self_;
  }
  if (self) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(self);
    if (message_arena != submessage_arena) {
      self = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, self, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.self_ = self;
  // @@protoc_insertion_point(field_set_allocated:protos.WorldModel.self)
}

// .protos.Ball ball = 7;
inline bool WorldModel::has_ball() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_ != nullptr);
  return value;
}
inline void WorldModel::clear_ball() {
  if (_impl_.ball_ != nullptr) _impl_.ball_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Ball& WorldModel::_internal_ball() const {
  const ::protos::Ball* p = _impl_.ball_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Ball&>(
      ::protos::_Ball_default_instance_);
}
inline const ::protos::Ball& WorldModel::ball() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.ball)
  return _internal_ball();
}
inline void WorldModel::unsafe_arena_set_allocated_ball(
    ::protos::Ball* ball) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ball_);
  }
  _impl_.ball_ = ball;
  if (ball) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.WorldModel.ball)
}
inline ::protos::Ball* WorldModel::release_ball() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Ball* temp = _impl_.ball_;
  _impl_.ball_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Ball* WorldModel::unsafe_arena_release_ball() {
  // @@protoc_insertion_point(field_release:protos.WorldModel.ball)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Ball* temp = _impl_.ball_;
  _impl_.ball_ = nullptr;
  return temp;
}
inline ::protos::Ball* WorldModel::_internal_mutable_ball() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.ball_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Ball>(GetArenaForAllocation());
    _impl_.ball_ = p;
  }
  return _impl_.ball_;
}
inline ::protos::Ball* WorldModel::mutable_ball() {
  ::protos::Ball* _msg = _internal_mutable_ball();
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.ball)
  return _msg;
}
inline void WorldModel::set_allocated_ball(::protos::Ball* ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ball_;
  }
  if (ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball);
    if (message_arena != submessage_arena) {
      ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ball_ = ball;
  // @@protoc_insertion_point(field_set_allocated:protos.WorldModel.ball)
}

// repeated .protos.Player teammates = 8;
inline int WorldModel::_internal_teammates_size() const {
  return _impl_.teammates_.size();
}
inline int WorldModel::teammates_size() const {
  return _internal_teammates_size();
}
inline void WorldModel::clear_teammates() {
  _internal_mutable_teammates()->Clear();
}
inline ::protos::Player* WorldModel::mutable_teammates(int index) {
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.teammates)
  return _internal_mutable_teammates()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >*
WorldModel::mutable_teammates() {
  // @@protoc_insertion_point(field_mutable_list:protos.WorldModel.teammates)
  return _internal_mutable_teammates();
}
inline const ::protos::Player& WorldModel::_internal_teammates(int index) const {
  return _internal_teammates().Get(index);
}
inline const ::protos::Player& WorldModel::teammates(int index) const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.teammates)
  return _internal_teammates(index);
}
inline ::protos::Player* WorldModel::_internal_add_teammates() {
  return _internal_mutable_teammates()->Add();
}
inline ::protos::Player* WorldModel::add_teammates() {
  ::protos::Player* _add = _internal_add_teammates();
  // @@protoc_insertion_point(field_add:protos.WorldModel.teammates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >&
WorldModel::teammates() const {
  // @@protoc_insertion_point(field_list:protos.WorldModel.teammates)
  return _internal_teammates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>&
WorldModel::_internal_teammates() const {
  return _impl_.teammates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>*
WorldModel::_internal_mutable_teammates() {
  return &_impl_.teammates_;
}

// repeated .protos.Player opponents = 9;
inline int WorldModel::_internal_opponents_size() const {
  return _impl_.opponents_.size();
}
inline int WorldModel::opponents_size() const {
  return _internal_opponents_size();
}
inline void WorldModel::clear_opponents() {
  _internal_mutable_opponents()->Clear();
}
inline ::protos::Player* WorldModel::mutable_opponents(int index) {
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.opponents)
  return _internal_mutable_opponents()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >*
WorldModel::mutable_opponents() {
  // @@protoc_insertion_point(field_mutable_list:protos.WorldModel.opponents)
  return _internal_mutable_opponents();
}
inline const ::protos::Player& WorldModel::_internal_opponents(int index) const {
  return _internal_opponents().Get(index);
}
inline const ::protos::Player& WorldModel::opponents(int index) const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.opponents)
  return _internal_opponents(index);
}
inline ::protos::Player* WorldModel::_internal_add_opponents() {
  return _internal_mutable_opponents()->Add();
}
inline ::protos::Player* WorldModel::add_opponents() {
  ::protos::Player* _add = _internal_add_opponents();
  // @@protoc_insertion_point(field_add:protos.WorldModel.opponents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >&
WorldModel::opponents() const {
  // @@protoc_insertion_point(field_list:protos.WorldModel.opponents)
  return _internal_opponents();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>&
WorldModel::_internal_opponents() const {
  return _impl_.opponents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>*
WorldModel::_internal_mutable_opponents() {
  return &_impl_.opponents_;
}

// repeated .protos.Player unknowns = 10;
inline int WorldModel::_internal_unknowns_size() const {
  return _impl_.unknowns_.size();
}
inline int WorldModel::unknowns_size() const {
  return _internal_unknowns_size();
}
inline void WorldModel::clear_unknowns() {
  _internal_mutable_unknowns()->Clear();
}
inline ::protos::Player* WorldModel::mutable_unknowns(int index) {
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.unknowns)
  return _internal_mutable_unknowns()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >*
WorldModel::mutable_unknowns() {
  // @@protoc_insertion_point(field_mutable_list:protos.WorldModel.unknowns)
  return _internal_mutable_unknowns();
}
inline const ::protos::Player& WorldModel::_internal_unknowns(int index) const {
  return _internal_unknowns().Get(index);
}
inline const ::protos::Player& WorldModel::unknowns(int index) const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.unknowns)
  return _internal_unknowns(index);
}
inline ::protos::Player* WorldModel::_internal_add_unknowns() {
  return _internal_mutable_unknowns()->Add();
}
inline ::protos::Player* WorldModel::add_unknowns() {
  ::protos::Player* _add = _internal_add_unknowns();
  // @@protoc_insertion_point(field_add:protos.WorldModel.unknowns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Player >&
WorldModel::unknowns() const {
  // @@protoc_insertion_point(field_list:protos.WorldModel.unknowns)
  return _internal_unknowns();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>&
WorldModel::_internal_unknowns() const {
  return _impl_.unknowns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Player>*
WorldModel::_internal_mutable_unknowns() {
  return &_impl_.unknowns_;
}

// map<int32, .protos.Player> our_players_dict = 11;
inline int WorldModel::_internal_our_players_dict_size() const {
  return _impl_.our_players_dict_.size();
}
inline int WorldModel::our_players_dict_size() const {
  return _internal_our_players_dict_size();
}
inline void WorldModel::clear_our_players_dict() {
  _impl_.our_players_dict_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >&
WorldModel::_internal_our_players_dict() const {
  return _impl_.our_players_dict_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >&
WorldModel::our_players_dict() const {
  // @@protoc_insertion_point(field_map:protos.WorldModel.our_players_dict)
  return _internal_our_players_dict();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >*
WorldModel::_internal_mutable_our_players_dict() {
  return _impl_.our_players_dict_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >*
WorldModel::mutable_our_players_dict() {
  // @@protoc_insertion_point(field_mutable_map:protos.WorldModel.our_players_dict)
  return _internal_mutable_our_players_dict();
}

// map<int32, .protos.Player> their_players_dict = 12;
inline int WorldModel::_internal_their_players_dict_size() const {
  return _impl_.their_players_dict_.size();
}
inline int WorldModel::their_players_dict_size() const {
  return _internal_their_players_dict_size();
}
inline void WorldModel::clear_their_players_dict() {
  _impl_.their_players_dict_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >&
WorldModel::_internal_their_players_dict() const {
  return _impl_.their_players_dict_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >&
WorldModel::their_players_dict() const {
  // @@protoc_insertion_point(field_map:protos.WorldModel.their_players_dict)
  return _internal_their_players_dict();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >*
WorldModel::_internal_mutable_their_players_dict() {
  return _impl_.their_players_dict_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::protos::Player >*
WorldModel::mutable_their_players_dict() {
  // @@protoc_insertion_point(field_mutable_map:protos.WorldModel.their_players_dict)
  return _internal_mutable_their_players_dict();
}

// int32 our_goalie_uniform_number = 13;
inline void WorldModel::clear_our_goalie_uniform_number() {
  _impl_.our_goalie_uniform_number_ = 0;
}
inline ::int32_t WorldModel::our_goalie_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.our_goalie_uniform_number)
  return _internal_our_goalie_uniform_number();
}
inline void WorldModel::set_our_goalie_uniform_number(::int32_t value) {
  _internal_set_our_goalie_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.our_goalie_uniform_number)
}
inline ::int32_t WorldModel::_internal_our_goalie_uniform_number() const {
  return _impl_.our_goalie_uniform_number_;
}
inline void WorldModel::_internal_set_our_goalie_uniform_number(::int32_t value) {
  ;
  _impl_.our_goalie_uniform_number_ = value;
}

// int32 their_goalie_uniform_number = 14;
inline void WorldModel::clear_their_goalie_uniform_number() {
  _impl_.their_goalie_uniform_number_ = 0;
}
inline ::int32_t WorldModel::their_goalie_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.their_goalie_uniform_number)
  return _internal_their_goalie_uniform_number();
}
inline void WorldModel::set_their_goalie_uniform_number(::int32_t value) {
  _internal_set_their_goalie_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.their_goalie_uniform_number)
}
inline ::int32_t WorldModel::_internal_their_goalie_uniform_number() const {
  return _impl_.their_goalie_uniform_number_;
}
inline void WorldModel::_internal_set_their_goalie_uniform_number(::int32_t value) {
  ;
  _impl_.their_goalie_uniform_number_ = value;
}

// float offside_line_x = 15;
inline void WorldModel::clear_offside_line_x() {
  _impl_.offside_line_x_ = 0;
}
inline float WorldModel::offside_line_x() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.offside_line_x)
  return _internal_offside_line_x();
}
inline void WorldModel::set_offside_line_x(float value) {
  _internal_set_offside_line_x(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.offside_line_x)
}
inline float WorldModel::_internal_offside_line_x() const {
  return _impl_.offside_line_x_;
}
inline void WorldModel::_internal_set_offside_line_x(float value) {
  ;
  _impl_.offside_line_x_ = value;
}

// int32 ofside_line_x_count = 16;
inline void WorldModel::clear_ofside_line_x_count() {
  _impl_.ofside_line_x_count_ = 0;
}
inline ::int32_t WorldModel::ofside_line_x_count() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.ofside_line_x_count)
  return _internal_ofside_line_x_count();
}
inline void WorldModel::set_ofside_line_x_count(::int32_t value) {
  _internal_set_ofside_line_x_count(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.ofside_line_x_count)
}
inline ::int32_t WorldModel::_internal_ofside_line_x_count() const {
  return _impl_.ofside_line_x_count_;
}
inline void WorldModel::_internal_set_ofside_line_x_count(::int32_t value) {
  ;
  _impl_.ofside_line_x_count_ = value;
}

// int32 kickable_teammate_id = 17;
inline void WorldModel::clear_kickable_teammate_id() {
  _impl_.kickable_teammate_id_ = 0;
}
inline ::int32_t WorldModel::kickable_teammate_id() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.kickable_teammate_id)
  return _internal_kickable_teammate_id();
}
inline void WorldModel::set_kickable_teammate_id(::int32_t value) {
  _internal_set_kickable_teammate_id(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.kickable_teammate_id)
}
inline ::int32_t WorldModel::_internal_kickable_teammate_id() const {
  return _impl_.kickable_teammate_id_;
}
inline void WorldModel::_internal_set_kickable_teammate_id(::int32_t value) {
  ;
  _impl_.kickable_teammate_id_ = value;
}

// int32 kickable_opponent_id = 18;
inline void WorldModel::clear_kickable_opponent_id() {
  _impl_.kickable_opponent_id_ = 0;
}
inline ::int32_t WorldModel::kickable_opponent_id() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.kickable_opponent_id)
  return _internal_kickable_opponent_id();
}
inline void WorldModel::set_kickable_opponent_id(::int32_t value) {
  _internal_set_kickable_opponent_id(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.kickable_opponent_id)
}
inline ::int32_t WorldModel::_internal_kickable_opponent_id() const {
  return _impl_.kickable_opponent_id_;
}
inline void WorldModel::_internal_set_kickable_opponent_id(::int32_t value) {
  ;
  _impl_.kickable_opponent_id_ = value;
}

// .protos.Side last_kick_side = 19;
inline void WorldModel::clear_last_kick_side() {
  _impl_.last_kick_side_ = 0;
}
inline ::protos::Side WorldModel::last_kick_side() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.last_kick_side)
  return _internal_last_kick_side();
}
inline void WorldModel::set_last_kick_side(::protos::Side value) {
   _internal_set_last_kick_side(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.last_kick_side)
}
inline ::protos::Side WorldModel::_internal_last_kick_side() const {
  return static_cast<::protos::Side>(_impl_.last_kick_side_);
}
inline void WorldModel::_internal_set_last_kick_side(::protos::Side value) {
  ;
  _impl_.last_kick_side_ = value;
}

// int32 last_kicker_uniform_number = 20;
inline void WorldModel::clear_last_kicker_uniform_number() {
  _impl_.last_kicker_uniform_number_ = 0;
}
inline ::int32_t WorldModel::last_kicker_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.last_kicker_uniform_number)
  return _internal_last_kicker_uniform_number();
}
inline void WorldModel::set_last_kicker_uniform_number(::int32_t value) {
  _internal_set_last_kicker_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.last_kicker_uniform_number)
}
inline ::int32_t WorldModel::_internal_last_kicker_uniform_number() const {
  return _impl_.last_kicker_uniform_number_;
}
inline void WorldModel::_internal_set_last_kicker_uniform_number(::int32_t value) {
  ;
  _impl_.last_kicker_uniform_number_ = value;
}

// int32 cycle = 21;
inline void WorldModel::clear_cycle() {
  _impl_.cycle_ = 0;
}
inline ::int32_t WorldModel::cycle() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.cycle)
  return _internal_cycle();
}
inline void WorldModel::set_cycle(::int32_t value) {
  _internal_set_cycle(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.cycle)
}
inline ::int32_t WorldModel::_internal_cycle() const {
  return _impl_.cycle_;
}
inline void WorldModel::_internal_set_cycle(::int32_t value) {
  ;
  _impl_.cycle_ = value;
}

// .protos.GameModeType game_mode_type = 22;
inline void WorldModel::clear_game_mode_type() {
  _impl_.game_mode_type_ = 0;
}
inline ::protos::GameModeType WorldModel::game_mode_type() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.game_mode_type)
  return _internal_game_mode_type();
}
inline void WorldModel::set_game_mode_type(::protos::GameModeType value) {
   _internal_set_game_mode_type(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.game_mode_type)
}
inline ::protos::GameModeType WorldModel::_internal_game_mode_type() const {
  return static_cast<::protos::GameModeType>(_impl_.game_mode_type_);
}
inline void WorldModel::_internal_set_game_mode_type(::protos::GameModeType value) {
  ;
  _impl_.game_mode_type_ = value;
}

// int32 left_team_score = 23;
inline void WorldModel::clear_left_team_score() {
  _impl_.left_team_score_ = 0;
}
inline ::int32_t WorldModel::left_team_score() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.left_team_score)
  return _internal_left_team_score();
}
inline void WorldModel::set_left_team_score(::int32_t value) {
  _internal_set_left_team_score(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.left_team_score)
}
inline ::int32_t WorldModel::_internal_left_team_score() const {
  return _impl_.left_team_score_;
}
inline void WorldModel::_internal_set_left_team_score(::int32_t value) {
  ;
  _impl_.left_team_score_ = value;
}

// int32 right_team_score = 24;
inline void WorldModel::clear_right_team_score() {
  _impl_.right_team_score_ = 0;
}
inline ::int32_t WorldModel::right_team_score() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.right_team_score)
  return _internal_right_team_score();
}
inline void WorldModel::set_right_team_score(::int32_t value) {
  _internal_set_right_team_score(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.right_team_score)
}
inline ::int32_t WorldModel::_internal_right_team_score() const {
  return _impl_.right_team_score_;
}
inline void WorldModel::_internal_set_right_team_score(::int32_t value) {
  ;
  _impl_.right_team_score_ = value;
}

// bool is_our_set_play = 25;
inline void WorldModel::clear_is_our_set_play() {
  _impl_.is_our_set_play_ = false;
}
inline bool WorldModel::is_our_set_play() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.is_our_set_play)
  return _internal_is_our_set_play();
}
inline void WorldModel::set_is_our_set_play(bool value) {
  _internal_set_is_our_set_play(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.is_our_set_play)
}
inline bool WorldModel::_internal_is_our_set_play() const {
  return _impl_.is_our_set_play_;
}
inline void WorldModel::_internal_set_is_our_set_play(bool value) {
  ;
  _impl_.is_our_set_play_ = value;
}

// bool is_their_set_play = 26;
inline void WorldModel::clear_is_their_set_play() {
  _impl_.is_their_set_play_ = false;
}
inline bool WorldModel::is_their_set_play() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.is_their_set_play)
  return _internal_is_their_set_play();
}
inline void WorldModel::set_is_their_set_play(bool value) {
  _internal_set_is_their_set_play(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.is_their_set_play)
}
inline bool WorldModel::_internal_is_their_set_play() const {
  return _impl_.is_their_set_play_;
}
inline void WorldModel::_internal_set_is_their_set_play(bool value) {
  ;
  _impl_.is_their_set_play_ = value;
}

// int32 stoped_cycle = 27;
inline void WorldModel::clear_stoped_cycle() {
  _impl_.stoped_cycle_ = 0;
}
inline ::int32_t WorldModel::stoped_cycle() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.stoped_cycle)
  return _internal_stoped_cycle();
}
inline void WorldModel::set_stoped_cycle(::int32_t value) {
  _internal_set_stoped_cycle(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.stoped_cycle)
}
inline ::int32_t WorldModel::_internal_stoped_cycle() const {
  return _impl_.stoped_cycle_;
}
inline void WorldModel::_internal_set_stoped_cycle(::int32_t value) {
  ;
  _impl_.stoped_cycle_ = value;
}

// int32 our_team_score = 28;
inline void WorldModel::clear_our_team_score() {
  _impl_.our_team_score_ = 0;
}
inline ::int32_t WorldModel::our_team_score() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.our_team_score)
  return _internal_our_team_score();
}
inline void WorldModel::set_our_team_score(::int32_t value) {
  _internal_set_our_team_score(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.our_team_score)
}
inline ::int32_t WorldModel::_internal_our_team_score() const {
  return _impl_.our_team_score_;
}
inline void WorldModel::_internal_set_our_team_score(::int32_t value) {
  ;
  _impl_.our_team_score_ = value;
}

// int32 their_team_score = 29;
inline void WorldModel::clear_their_team_score() {
  _impl_.their_team_score_ = 0;
}
inline ::int32_t WorldModel::their_team_score() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.their_team_score)
  return _internal_their_team_score();
}
inline void WorldModel::set_their_team_score(::int32_t value) {
  _internal_set_their_team_score(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.their_team_score)
}
inline ::int32_t WorldModel::_internal_their_team_score() const {
  return _impl_.their_team_score_;
}
inline void WorldModel::_internal_set_their_team_score(::int32_t value) {
  ;
  _impl_.their_team_score_ = value;
}

// -------------------------------------------------------------------

// State

// .protos.WorldModel world_model = 1;
inline bool State::has_world_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.world_model_ != nullptr);
  return value;
}
inline void State::clear_world_model() {
  if (_impl_.world_model_ != nullptr) _impl_.world_model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::WorldModel& State::_internal_world_model() const {
  const ::protos::WorldModel* p = _impl_.world_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::WorldModel&>(
      ::protos::_WorldModel_default_instance_);
}
inline const ::protos::WorldModel& State::world_model() const {
  // @@protoc_insertion_point(field_get:protos.State.world_model)
  return _internal_world_model();
}
inline void State::unsafe_arena_set_allocated_world_model(
    ::protos::WorldModel* world_model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.world_model_);
  }
  _impl_.world_model_ = world_model;
  if (world_model) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.State.world_model)
}
inline ::protos::WorldModel* State::release_world_model() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::WorldModel* temp = _impl_.world_model_;
  _impl_.world_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::WorldModel* State::unsafe_arena_release_world_model() {
  // @@protoc_insertion_point(field_release:protos.State.world_model)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::WorldModel* temp = _impl_.world_model_;
  _impl_.world_model_ = nullptr;
  return temp;
}
inline ::protos::WorldModel* State::_internal_mutable_world_model() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.world_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::WorldModel>(GetArenaForAllocation());
    _impl_.world_model_ = p;
  }
  return _impl_.world_model_;
}
inline ::protos::WorldModel* State::mutable_world_model() {
  ::protos::WorldModel* _msg = _internal_mutable_world_model();
  // @@protoc_insertion_point(field_mutable:protos.State.world_model)
  return _msg;
}
inline void State::set_allocated_world_model(::protos::WorldModel* world_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.world_model_;
  }
  if (world_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(world_model);
    if (message_arena != submessage_arena) {
      world_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, world_model, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.world_model_ = world_model;
  // @@protoc_insertion_point(field_set_allocated:protos.State.world_model)
}

// .protos.WorldModel full_world_model = 2;
inline bool State::has_full_world_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.full_world_model_ != nullptr);
  return value;
}
inline void State::clear_full_world_model() {
  if (_impl_.full_world_model_ != nullptr) _impl_.full_world_model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::WorldModel& State::_internal_full_world_model() const {
  const ::protos::WorldModel* p = _impl_.full_world_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::WorldModel&>(
      ::protos::_WorldModel_default_instance_);
}
inline const ::protos::WorldModel& State::full_world_model() const {
  // @@protoc_insertion_point(field_get:protos.State.full_world_model)
  return _internal_full_world_model();
}
inline void State::unsafe_arena_set_allocated_full_world_model(
    ::protos::WorldModel* full_world_model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.full_world_model_);
  }
  _impl_.full_world_model_ = full_world_model;
  if (full_world_model) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.State.full_world_model)
}
inline ::protos::WorldModel* State::release_full_world_model() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::WorldModel* temp = _impl_.full_world_model_;
  _impl_.full_world_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::WorldModel* State::unsafe_arena_release_full_world_model() {
  // @@protoc_insertion_point(field_release:protos.State.full_world_model)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::WorldModel* temp = _impl_.full_world_model_;
  _impl_.full_world_model_ = nullptr;
  return temp;
}
inline ::protos::WorldModel* State::_internal_mutable_full_world_model() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.full_world_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::WorldModel>(GetArenaForAllocation());
    _impl_.full_world_model_ = p;
  }
  return _impl_.full_world_model_;
}
inline ::protos::WorldModel* State::mutable_full_world_model() {
  ::protos::WorldModel* _msg = _internal_mutable_full_world_model();
  // @@protoc_insertion_point(field_mutable:protos.State.full_world_model)
  return _msg;
}
inline void State::set_allocated_full_world_model(::protos::WorldModel* full_world_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.full_world_model_;
  }
  if (full_world_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(full_world_model);
    if (message_arena != submessage_arena) {
      full_world_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, full_world_model, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.full_world_model_ = full_world_model;
  // @@protoc_insertion_point(field_set_allocated:protos.State.full_world_model)
}

// -------------------------------------------------------------------

// Dash

// float power = 1;
inline void Dash::clear_power() {
  _impl_.power_ = 0;
}
inline float Dash::power() const {
  // @@protoc_insertion_point(field_get:protos.Dash.power)
  return _internal_power();
}
inline void Dash::set_power(float value) {
  _internal_set_power(value);
  // @@protoc_insertion_point(field_set:protos.Dash.power)
}
inline float Dash::_internal_power() const {
  return _impl_.power_;
}
inline void Dash::_internal_set_power(float value) {
  ;
  _impl_.power_ = value;
}

// float relative_direction = 2;
inline void Dash::clear_relative_direction() {
  _impl_.relative_direction_ = 0;
}
inline float Dash::relative_direction() const {
  // @@protoc_insertion_point(field_get:protos.Dash.relative_direction)
  return _internal_relative_direction();
}
inline void Dash::set_relative_direction(float value) {
  _internal_set_relative_direction(value);
  // @@protoc_insertion_point(field_set:protos.Dash.relative_direction)
}
inline float Dash::_internal_relative_direction() const {
  return _impl_.relative_direction_;
}
inline void Dash::_internal_set_relative_direction(float value) {
  ;
  _impl_.relative_direction_ = value;
}

// -------------------------------------------------------------------

// Turn

// float relative_direction = 1;
inline void Turn::clear_relative_direction() {
  _impl_.relative_direction_ = 0;
}
inline float Turn::relative_direction() const {
  // @@protoc_insertion_point(field_get:protos.Turn.relative_direction)
  return _internal_relative_direction();
}
inline void Turn::set_relative_direction(float value) {
  _internal_set_relative_direction(value);
  // @@protoc_insertion_point(field_set:protos.Turn.relative_direction)
}
inline float Turn::_internal_relative_direction() const {
  return _impl_.relative_direction_;
}
inline void Turn::_internal_set_relative_direction(float value) {
  ;
  _impl_.relative_direction_ = value;
}

// -------------------------------------------------------------------

// Kick

// float power = 1;
inline void Kick::clear_power() {
  _impl_.power_ = 0;
}
inline float Kick::power() const {
  // @@protoc_insertion_point(field_get:protos.Kick.power)
  return _internal_power();
}
inline void Kick::set_power(float value) {
  _internal_set_power(value);
  // @@protoc_insertion_point(field_set:protos.Kick.power)
}
inline float Kick::_internal_power() const {
  return _impl_.power_;
}
inline void Kick::_internal_set_power(float value) {
  ;
  _impl_.power_ = value;
}

// float relative_direction = 2;
inline void Kick::clear_relative_direction() {
  _impl_.relative_direction_ = 0;
}
inline float Kick::relative_direction() const {
  // @@protoc_insertion_point(field_get:protos.Kick.relative_direction)
  return _internal_relative_direction();
}
inline void Kick::set_relative_direction(float value) {
  _internal_set_relative_direction(value);
  // @@protoc_insertion_point(field_set:protos.Kick.relative_direction)
}
inline float Kick::_internal_relative_direction() const {
  return _impl_.relative_direction_;
}
inline void Kick::_internal_set_relative_direction(float value) {
  ;
  _impl_.relative_direction_ = value;
}

// -------------------------------------------------------------------

// Tackle

// float power_or_dir = 1;
inline void Tackle::clear_power_or_dir() {
  _impl_.power_or_dir_ = 0;
}
inline float Tackle::power_or_dir() const {
  // @@protoc_insertion_point(field_get:protos.Tackle.power_or_dir)
  return _internal_power_or_dir();
}
inline void Tackle::set_power_or_dir(float value) {
  _internal_set_power_or_dir(value);
  // @@protoc_insertion_point(field_set:protos.Tackle.power_or_dir)
}
inline float Tackle::_internal_power_or_dir() const {
  return _impl_.power_or_dir_;
}
inline void Tackle::_internal_set_power_or_dir(float value) {
  ;
  _impl_.power_or_dir_ = value;
}

// bool foul = 2;
inline void Tackle::clear_foul() {
  _impl_.foul_ = false;
}
inline bool Tackle::foul() const {
  // @@protoc_insertion_point(field_get:protos.Tackle.foul)
  return _internal_foul();
}
inline void Tackle::set_foul(bool value) {
  _internal_set_foul(value);
  // @@protoc_insertion_point(field_set:protos.Tackle.foul)
}
inline bool Tackle::_internal_foul() const {
  return _impl_.foul_;
}
inline void Tackle::_internal_set_foul(bool value) {
  ;
  _impl_.foul_ = value;
}

// -------------------------------------------------------------------

// Catch

// -------------------------------------------------------------------

// Move

// float x = 1;
inline void Move::clear_x() {
  _impl_.x_ = 0;
}
inline float Move::x() const {
  // @@protoc_insertion_point(field_get:protos.Move.x)
  return _internal_x();
}
inline void Move::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:protos.Move.x)
}
inline float Move::_internal_x() const {
  return _impl_.x_;
}
inline void Move::_internal_set_x(float value) {
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void Move::clear_y() {
  _impl_.y_ = 0;
}
inline float Move::y() const {
  // @@protoc_insertion_point(field_get:protos.Move.y)
  return _internal_y();
}
inline void Move::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:protos.Move.y)
}
inline float Move::_internal_y() const {
  return _impl_.y_;
}
inline void Move::_internal_set_y(float value) {
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// TurnNeck

// float moment = 1;
inline void TurnNeck::clear_moment() {
  _impl_.moment_ = 0;
}
inline float TurnNeck::moment() const {
  // @@protoc_insertion_point(field_get:protos.TurnNeck.moment)
  return _internal_moment();
}
inline void TurnNeck::set_moment(float value) {
  _internal_set_moment(value);
  // @@protoc_insertion_point(field_set:protos.TurnNeck.moment)
}
inline float TurnNeck::_internal_moment() const {
  return _impl_.moment_;
}
inline void TurnNeck::_internal_set_moment(float value) {
  ;
  _impl_.moment_ = value;
}

// -------------------------------------------------------------------

// ChangeView

// .protos.ViewWidth view_width = 1;
inline void ChangeView::clear_view_width() {
  _impl_.view_width_ = 0;
}
inline ::protos::ViewWidth ChangeView::view_width() const {
  // @@protoc_insertion_point(field_get:protos.ChangeView.view_width)
  return _internal_view_width();
}
inline void ChangeView::set_view_width(::protos::ViewWidth value) {
   _internal_set_view_width(value);
  // @@protoc_insertion_point(field_set:protos.ChangeView.view_width)
}
inline ::protos::ViewWidth ChangeView::_internal_view_width() const {
  return static_cast<::protos::ViewWidth>(_impl_.view_width_);
}
inline void ChangeView::_internal_set_view_width(::protos::ViewWidth value) {
  ;
  _impl_.view_width_ = value;
}

// -------------------------------------------------------------------

// BallMessage

// .protos.Vector2D ball_position = 1;
inline bool BallMessage::has_ball_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_position_ != nullptr);
  return value;
}
inline void BallMessage::clear_ball_position() {
  if (_impl_.ball_position_ != nullptr) _impl_.ball_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& BallMessage::_internal_ball_position() const {
  const ::protos::Vector2D* p = _impl_.ball_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& BallMessage::ball_position() const {
  // @@protoc_insertion_point(field_get:protos.BallMessage.ball_position)
  return _internal_ball_position();
}
inline void BallMessage::unsafe_arena_set_allocated_ball_position(
    ::protos::Vector2D* ball_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ball_position_);
  }
  _impl_.ball_position_ = ball_position;
  if (ball_position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.BallMessage.ball_position)
}
inline ::protos::Vector2D* BallMessage::release_ball_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.ball_position_;
  _impl_.ball_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* BallMessage::unsafe_arena_release_ball_position() {
  // @@protoc_insertion_point(field_release:protos.BallMessage.ball_position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.ball_position_;
  _impl_.ball_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* BallMessage::_internal_mutable_ball_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ball_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.ball_position_ = p;
  }
  return _impl_.ball_position_;
}
inline ::protos::Vector2D* BallMessage::mutable_ball_position() {
  ::protos::Vector2D* _msg = _internal_mutable_ball_position();
  // @@protoc_insertion_point(field_mutable:protos.BallMessage.ball_position)
  return _msg;
}
inline void BallMessage::set_allocated_ball_position(::protos::Vector2D* ball_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ball_position_;
  }
  if (ball_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball_position);
    if (message_arena != submessage_arena) {
      ball_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ball_position_ = ball_position;
  // @@protoc_insertion_point(field_set_allocated:protos.BallMessage.ball_position)
}

// .protos.Vector2D ball_velocity = 2;
inline bool BallMessage::has_ball_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_velocity_ != nullptr);
  return value;
}
inline void BallMessage::clear_ball_velocity() {
  if (_impl_.ball_velocity_ != nullptr) _impl_.ball_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& BallMessage::_internal_ball_velocity() const {
  const ::protos::Vector2D* p = _impl_.ball_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& BallMessage::ball_velocity() const {
  // @@protoc_insertion_point(field_get:protos.BallMessage.ball_velocity)
  return _internal_ball_velocity();
}
inline void BallMessage::unsafe_arena_set_allocated_ball_velocity(
    ::protos::Vector2D* ball_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ball_velocity_);
  }
  _impl_.ball_velocity_ = ball_velocity;
  if (ball_velocity) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.BallMessage.ball_velocity)
}
inline ::protos::Vector2D* BallMessage::release_ball_velocity() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.ball_velocity_;
  _impl_.ball_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* BallMessage::unsafe_arena_release_ball_velocity() {
  // @@protoc_insertion_point(field_release:protos.BallMessage.ball_velocity)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.ball_velocity_;
  _impl_.ball_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* BallMessage::_internal_mutable_ball_velocity() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ball_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.ball_velocity_ = p;
  }
  return _impl_.ball_velocity_;
}
inline ::protos::Vector2D* BallMessage::mutable_ball_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_ball_velocity();
  // @@protoc_insertion_point(field_mutable:protos.BallMessage.ball_velocity)
  return _msg;
}
inline void BallMessage::set_allocated_ball_velocity(::protos::Vector2D* ball_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ball_velocity_;
  }
  if (ball_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball_velocity);
    if (message_arena != submessage_arena) {
      ball_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ball_velocity_ = ball_velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.BallMessage.ball_velocity)
}

// -------------------------------------------------------------------

// PassMessage

// int32 receiver_uniform_number = 1;
inline void PassMessage::clear_receiver_uniform_number() {
  _impl_.receiver_uniform_number_ = 0;
}
inline ::int32_t PassMessage::receiver_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.PassMessage.receiver_uniform_number)
  return _internal_receiver_uniform_number();
}
inline void PassMessage::set_receiver_uniform_number(::int32_t value) {
  _internal_set_receiver_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.PassMessage.receiver_uniform_number)
}
inline ::int32_t PassMessage::_internal_receiver_uniform_number() const {
  return _impl_.receiver_uniform_number_;
}
inline void PassMessage::_internal_set_receiver_uniform_number(::int32_t value) {
  ;
  _impl_.receiver_uniform_number_ = value;
}

// .protos.Vector2D receiver_point = 2;
inline bool PassMessage::has_receiver_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.receiver_point_ != nullptr);
  return value;
}
inline void PassMessage::clear_receiver_point() {
  if (_impl_.receiver_point_ != nullptr) _impl_.receiver_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& PassMessage::_internal_receiver_point() const {
  const ::protos::Vector2D* p = _impl_.receiver_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& PassMessage::receiver_point() const {
  // @@protoc_insertion_point(field_get:protos.PassMessage.receiver_point)
  return _internal_receiver_point();
}
inline void PassMessage::unsafe_arena_set_allocated_receiver_point(
    ::protos::Vector2D* receiver_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.receiver_point_);
  }
  _impl_.receiver_point_ = receiver_point;
  if (receiver_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PassMessage.receiver_point)
}
inline ::protos::Vector2D* PassMessage::release_receiver_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.receiver_point_;
  _impl_.receiver_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* PassMessage::unsafe_arena_release_receiver_point() {
  // @@protoc_insertion_point(field_release:protos.PassMessage.receiver_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.receiver_point_;
  _impl_.receiver_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* PassMessage::_internal_mutable_receiver_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.receiver_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.receiver_point_ = p;
  }
  return _impl_.receiver_point_;
}
inline ::protos::Vector2D* PassMessage::mutable_receiver_point() {
  ::protos::Vector2D* _msg = _internal_mutable_receiver_point();
  // @@protoc_insertion_point(field_mutable:protos.PassMessage.receiver_point)
  return _msg;
}
inline void PassMessage::set_allocated_receiver_point(::protos::Vector2D* receiver_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.receiver_point_;
  }
  if (receiver_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(receiver_point);
    if (message_arena != submessage_arena) {
      receiver_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, receiver_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.receiver_point_ = receiver_point;
  // @@protoc_insertion_point(field_set_allocated:protos.PassMessage.receiver_point)
}

// .protos.Vector2D ball_position = 3;
inline bool PassMessage::has_ball_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_position_ != nullptr);
  return value;
}
inline void PassMessage::clear_ball_position() {
  if (_impl_.ball_position_ != nullptr) _impl_.ball_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& PassMessage::_internal_ball_position() const {
  const ::protos::Vector2D* p = _impl_.ball_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& PassMessage::ball_position() const {
  // @@protoc_insertion_point(field_get:protos.PassMessage.ball_position)
  return _internal_ball_position();
}
inline void PassMessage::unsafe_arena_set_allocated_ball_position(
    ::protos::Vector2D* ball_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ball_position_);
  }
  _impl_.ball_position_ = ball_position;
  if (ball_position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PassMessage.ball_position)
}
inline ::protos::Vector2D* PassMessage::release_ball_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.ball_position_;
  _impl_.ball_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* PassMessage::unsafe_arena_release_ball_position() {
  // @@protoc_insertion_point(field_release:protos.PassMessage.ball_position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.ball_position_;
  _impl_.ball_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* PassMessage::_internal_mutable_ball_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ball_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.ball_position_ = p;
  }
  return _impl_.ball_position_;
}
inline ::protos::Vector2D* PassMessage::mutable_ball_position() {
  ::protos::Vector2D* _msg = _internal_mutable_ball_position();
  // @@protoc_insertion_point(field_mutable:protos.PassMessage.ball_position)
  return _msg;
}
inline void PassMessage::set_allocated_ball_position(::protos::Vector2D* ball_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ball_position_;
  }
  if (ball_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball_position);
    if (message_arena != submessage_arena) {
      ball_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ball_position_ = ball_position;
  // @@protoc_insertion_point(field_set_allocated:protos.PassMessage.ball_position)
}

// .protos.Vector2D ball_velocity = 4;
inline bool PassMessage::has_ball_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_velocity_ != nullptr);
  return value;
}
inline void PassMessage::clear_ball_velocity() {
  if (_impl_.ball_velocity_ != nullptr) _impl_.ball_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& PassMessage::_internal_ball_velocity() const {
  const ::protos::Vector2D* p = _impl_.ball_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& PassMessage::ball_velocity() const {
  // @@protoc_insertion_point(field_get:protos.PassMessage.ball_velocity)
  return _internal_ball_velocity();
}
inline void PassMessage::unsafe_arena_set_allocated_ball_velocity(
    ::protos::Vector2D* ball_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ball_velocity_);
  }
  _impl_.ball_velocity_ = ball_velocity;
  if (ball_velocity) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PassMessage.ball_velocity)
}
inline ::protos::Vector2D* PassMessage::release_ball_velocity() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.ball_velocity_;
  _impl_.ball_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* PassMessage::unsafe_arena_release_ball_velocity() {
  // @@protoc_insertion_point(field_release:protos.PassMessage.ball_velocity)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.ball_velocity_;
  _impl_.ball_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* PassMessage::_internal_mutable_ball_velocity() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.ball_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.ball_velocity_ = p;
  }
  return _impl_.ball_velocity_;
}
inline ::protos::Vector2D* PassMessage::mutable_ball_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_ball_velocity();
  // @@protoc_insertion_point(field_mutable:protos.PassMessage.ball_velocity)
  return _msg;
}
inline void PassMessage::set_allocated_ball_velocity(::protos::Vector2D* ball_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ball_velocity_;
  }
  if (ball_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball_velocity);
    if (message_arena != submessage_arena) {
      ball_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ball_velocity_ = ball_velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.PassMessage.ball_velocity)
}

// -------------------------------------------------------------------

// InterceptMessage

// bool our = 1;
inline void InterceptMessage::clear_our() {
  _impl_.our_ = false;
}
inline bool InterceptMessage::our() const {
  // @@protoc_insertion_point(field_get:protos.InterceptMessage.our)
  return _internal_our();
}
inline void InterceptMessage::set_our(bool value) {
  _internal_set_our(value);
  // @@protoc_insertion_point(field_set:protos.InterceptMessage.our)
}
inline bool InterceptMessage::_internal_our() const {
  return _impl_.our_;
}
inline void InterceptMessage::_internal_set_our(bool value) {
  ;
  _impl_.our_ = value;
}

// int32 uniform_number = 2;
inline void InterceptMessage::clear_uniform_number() {
  _impl_.uniform_number_ = 0;
}
inline ::int32_t InterceptMessage::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.InterceptMessage.uniform_number)
  return _internal_uniform_number();
}
inline void InterceptMessage::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.InterceptMessage.uniform_number)
}
inline ::int32_t InterceptMessage::_internal_uniform_number() const {
  return _impl_.uniform_number_;
}
inline void InterceptMessage::_internal_set_uniform_number(::int32_t value) {
  ;
  _impl_.uniform_number_ = value;
}

// int32 cycle = 3;
inline void InterceptMessage::clear_cycle() {
  _impl_.cycle_ = 0;
}
inline ::int32_t InterceptMessage::cycle() const {
  // @@protoc_insertion_point(field_get:protos.InterceptMessage.cycle)
  return _internal_cycle();
}
inline void InterceptMessage::set_cycle(::int32_t value) {
  _internal_set_cycle(value);
  // @@protoc_insertion_point(field_set:protos.InterceptMessage.cycle)
}
inline ::int32_t InterceptMessage::_internal_cycle() const {
  return _impl_.cycle_;
}
inline void InterceptMessage::_internal_set_cycle(::int32_t value) {
  ;
  _impl_.cycle_ = value;
}

// -------------------------------------------------------------------

// GoalieMessage

// int32 goalie_uniform_number = 1;
inline void GoalieMessage::clear_goalie_uniform_number() {
  _impl_.goalie_uniform_number_ = 0;
}
inline ::int32_t GoalieMessage::goalie_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.GoalieMessage.goalie_uniform_number)
  return _internal_goalie_uniform_number();
}
inline void GoalieMessage::set_goalie_uniform_number(::int32_t value) {
  _internal_set_goalie_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.GoalieMessage.goalie_uniform_number)
}
inline ::int32_t GoalieMessage::_internal_goalie_uniform_number() const {
  return _impl_.goalie_uniform_number_;
}
inline void GoalieMessage::_internal_set_goalie_uniform_number(::int32_t value) {
  ;
  _impl_.goalie_uniform_number_ = value;
}

// .protos.Vector2D goalie_position = 2;
inline bool GoalieMessage::has_goalie_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.goalie_position_ != nullptr);
  return value;
}
inline void GoalieMessage::clear_goalie_position() {
  if (_impl_.goalie_position_ != nullptr) _impl_.goalie_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& GoalieMessage::_internal_goalie_position() const {
  const ::protos::Vector2D* p = _impl_.goalie_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& GoalieMessage::goalie_position() const {
  // @@protoc_insertion_point(field_get:protos.GoalieMessage.goalie_position)
  return _internal_goalie_position();
}
inline void GoalieMessage::unsafe_arena_set_allocated_goalie_position(
    ::protos::Vector2D* goalie_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.goalie_position_);
  }
  _impl_.goalie_position_ = goalie_position;
  if (goalie_position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.GoalieMessage.goalie_position)
}
inline ::protos::Vector2D* GoalieMessage::release_goalie_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.goalie_position_;
  _impl_.goalie_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* GoalieMessage::unsafe_arena_release_goalie_position() {
  // @@protoc_insertion_point(field_release:protos.GoalieMessage.goalie_position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.goalie_position_;
  _impl_.goalie_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* GoalieMessage::_internal_mutable_goalie_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.goalie_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.goalie_position_ = p;
  }
  return _impl_.goalie_position_;
}
inline ::protos::Vector2D* GoalieMessage::mutable_goalie_position() {
  ::protos::Vector2D* _msg = _internal_mutable_goalie_position();
  // @@protoc_insertion_point(field_mutable:protos.GoalieMessage.goalie_position)
  return _msg;
}
inline void GoalieMessage::set_allocated_goalie_position(::protos::Vector2D* goalie_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.goalie_position_;
  }
  if (goalie_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(goalie_position);
    if (message_arena != submessage_arena) {
      goalie_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, goalie_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.goalie_position_ = goalie_position;
  // @@protoc_insertion_point(field_set_allocated:protos.GoalieMessage.goalie_position)
}

// float goalie_body_direction = 3;
inline void GoalieMessage::clear_goalie_body_direction() {
  _impl_.goalie_body_direction_ = 0;
}
inline float GoalieMessage::goalie_body_direction() const {
  // @@protoc_insertion_point(field_get:protos.GoalieMessage.goalie_body_direction)
  return _internal_goalie_body_direction();
}
inline void GoalieMessage::set_goalie_body_direction(float value) {
  _internal_set_goalie_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.GoalieMessage.goalie_body_direction)
}
inline float GoalieMessage::_internal_goalie_body_direction() const {
  return _impl_.goalie_body_direction_;
}
inline void GoalieMessage::_internal_set_goalie_body_direction(float value) {
  ;
  _impl_.goalie_body_direction_ = value;
}

// -------------------------------------------------------------------

// GoalieAndPlayerMessage

// int32 goalie_uniform_number = 1;
inline void GoalieAndPlayerMessage::clear_goalie_uniform_number() {
  _impl_.goalie_uniform_number_ = 0;
}
inline ::int32_t GoalieAndPlayerMessage::goalie_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.GoalieAndPlayerMessage.goalie_uniform_number)
  return _internal_goalie_uniform_number();
}
inline void GoalieAndPlayerMessage::set_goalie_uniform_number(::int32_t value) {
  _internal_set_goalie_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.GoalieAndPlayerMessage.goalie_uniform_number)
}
inline ::int32_t GoalieAndPlayerMessage::_internal_goalie_uniform_number() const {
  return _impl_.goalie_uniform_number_;
}
inline void GoalieAndPlayerMessage::_internal_set_goalie_uniform_number(::int32_t value) {
  ;
  _impl_.goalie_uniform_number_ = value;
}

// .protos.Vector2D goalie_position = 2;
inline bool GoalieAndPlayerMessage::has_goalie_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.goalie_position_ != nullptr);
  return value;
}
inline void GoalieAndPlayerMessage::clear_goalie_position() {
  if (_impl_.goalie_position_ != nullptr) _impl_.goalie_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& GoalieAndPlayerMessage::_internal_goalie_position() const {
  const ::protos::Vector2D* p = _impl_.goalie_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& GoalieAndPlayerMessage::goalie_position() const {
  // @@protoc_insertion_point(field_get:protos.GoalieAndPlayerMessage.goalie_position)
  return _internal_goalie_position();
}
inline void GoalieAndPlayerMessage::unsafe_arena_set_allocated_goalie_position(
    ::protos::Vector2D* goalie_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.goalie_position_);
  }
  _impl_.goalie_position_ = goalie_position;
  if (goalie_position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.GoalieAndPlayerMessage.goalie_position)
}
inline ::protos::Vector2D* GoalieAndPlayerMessage::release_goalie_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.goalie_position_;
  _impl_.goalie_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* GoalieAndPlayerMessage::unsafe_arena_release_goalie_position() {
  // @@protoc_insertion_point(field_release:protos.GoalieAndPlayerMessage.goalie_position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.goalie_position_;
  _impl_.goalie_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* GoalieAndPlayerMessage::_internal_mutable_goalie_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.goalie_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.goalie_position_ = p;
  }
  return _impl_.goalie_position_;
}
inline ::protos::Vector2D* GoalieAndPlayerMessage::mutable_goalie_position() {
  ::protos::Vector2D* _msg = _internal_mutable_goalie_position();
  // @@protoc_insertion_point(field_mutable:protos.GoalieAndPlayerMessage.goalie_position)
  return _msg;
}
inline void GoalieAndPlayerMessage::set_allocated_goalie_position(::protos::Vector2D* goalie_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.goalie_position_;
  }
  if (goalie_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(goalie_position);
    if (message_arena != submessage_arena) {
      goalie_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, goalie_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.goalie_position_ = goalie_position;
  // @@protoc_insertion_point(field_set_allocated:protos.GoalieAndPlayerMessage.goalie_position)
}

// float goalie_body_direction = 3;
inline void GoalieAndPlayerMessage::clear_goalie_body_direction() {
  _impl_.goalie_body_direction_ = 0;
}
inline float GoalieAndPlayerMessage::goalie_body_direction() const {
  // @@protoc_insertion_point(field_get:protos.GoalieAndPlayerMessage.goalie_body_direction)
  return _internal_goalie_body_direction();
}
inline void GoalieAndPlayerMessage::set_goalie_body_direction(float value) {
  _internal_set_goalie_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.GoalieAndPlayerMessage.goalie_body_direction)
}
inline float GoalieAndPlayerMessage::_internal_goalie_body_direction() const {
  return _impl_.goalie_body_direction_;
}
inline void GoalieAndPlayerMessage::_internal_set_goalie_body_direction(float value) {
  ;
  _impl_.goalie_body_direction_ = value;
}

// int32 player_uniform_number = 4;
inline void GoalieAndPlayerMessage::clear_player_uniform_number() {
  _impl_.player_uniform_number_ = 0;
}
inline ::int32_t GoalieAndPlayerMessage::player_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.GoalieAndPlayerMessage.player_uniform_number)
  return _internal_player_uniform_number();
}
inline void GoalieAndPlayerMessage::set_player_uniform_number(::int32_t value) {
  _internal_set_player_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.GoalieAndPlayerMessage.player_uniform_number)
}
inline ::int32_t GoalieAndPlayerMessage::_internal_player_uniform_number() const {
  return _impl_.player_uniform_number_;
}
inline void GoalieAndPlayerMessage::_internal_set_player_uniform_number(::int32_t value) {
  ;
  _impl_.player_uniform_number_ = value;
}

// .protos.Vector2D player_position = 5;
inline bool GoalieAndPlayerMessage::has_player_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_position_ != nullptr);
  return value;
}
inline void GoalieAndPlayerMessage::clear_player_position() {
  if (_impl_.player_position_ != nullptr) _impl_.player_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& GoalieAndPlayerMessage::_internal_player_position() const {
  const ::protos::Vector2D* p = _impl_.player_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& GoalieAndPlayerMessage::player_position() const {
  // @@protoc_insertion_point(field_get:protos.GoalieAndPlayerMessage.player_position)
  return _internal_player_position();
}
inline void GoalieAndPlayerMessage::unsafe_arena_set_allocated_player_position(
    ::protos::Vector2D* player_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_position_);
  }
  _impl_.player_position_ = player_position;
  if (player_position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.GoalieAndPlayerMessage.player_position)
}
inline ::protos::Vector2D* GoalieAndPlayerMessage::release_player_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.player_position_;
  _impl_.player_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* GoalieAndPlayerMessage::unsafe_arena_release_player_position() {
  // @@protoc_insertion_point(field_release:protos.GoalieAndPlayerMessage.player_position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.player_position_;
  _impl_.player_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* GoalieAndPlayerMessage::_internal_mutable_player_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.player_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.player_position_ = p;
  }
  return _impl_.player_position_;
}
inline ::protos::Vector2D* GoalieAndPlayerMessage::mutable_player_position() {
  ::protos::Vector2D* _msg = _internal_mutable_player_position();
  // @@protoc_insertion_point(field_mutable:protos.GoalieAndPlayerMessage.player_position)
  return _msg;
}
inline void GoalieAndPlayerMessage::set_allocated_player_position(::protos::Vector2D* player_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_position_;
  }
  if (player_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player_position);
    if (message_arena != submessage_arena) {
      player_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.player_position_ = player_position;
  // @@protoc_insertion_point(field_set_allocated:protos.GoalieAndPlayerMessage.player_position)
}

// -------------------------------------------------------------------

// OffsideLineMessage

// float offside_line_x = 1;
inline void OffsideLineMessage::clear_offside_line_x() {
  _impl_.offside_line_x_ = 0;
}
inline float OffsideLineMessage::offside_line_x() const {
  // @@protoc_insertion_point(field_get:protos.OffsideLineMessage.offside_line_x)
  return _internal_offside_line_x();
}
inline void OffsideLineMessage::set_offside_line_x(float value) {
  _internal_set_offside_line_x(value);
  // @@protoc_insertion_point(field_set:protos.OffsideLineMessage.offside_line_x)
}
inline float OffsideLineMessage::_internal_offside_line_x() const {
  return _impl_.offside_line_x_;
}
inline void OffsideLineMessage::_internal_set_offside_line_x(float value) {
  ;
  _impl_.offside_line_x_ = value;
}

// -------------------------------------------------------------------

// DefenseLineMessage

// float defense_line_x = 1;
inline void DefenseLineMessage::clear_defense_line_x() {
  _impl_.defense_line_x_ = 0;
}
inline float DefenseLineMessage::defense_line_x() const {
  // @@protoc_insertion_point(field_get:protos.DefenseLineMessage.defense_line_x)
  return _internal_defense_line_x();
}
inline void DefenseLineMessage::set_defense_line_x(float value) {
  _internal_set_defense_line_x(value);
  // @@protoc_insertion_point(field_set:protos.DefenseLineMessage.defense_line_x)
}
inline float DefenseLineMessage::_internal_defense_line_x() const {
  return _impl_.defense_line_x_;
}
inline void DefenseLineMessage::_internal_set_defense_line_x(float value) {
  ;
  _impl_.defense_line_x_ = value;
}

// -------------------------------------------------------------------

// WaitRequestMessage

// -------------------------------------------------------------------

// SetplayMessage

// int32 wait_step = 1;
inline void SetplayMessage::clear_wait_step() {
  _impl_.wait_step_ = 0;
}
inline ::int32_t SetplayMessage::wait_step() const {
  // @@protoc_insertion_point(field_get:protos.SetplayMessage.wait_step)
  return _internal_wait_step();
}
inline void SetplayMessage::set_wait_step(::int32_t value) {
  _internal_set_wait_step(value);
  // @@protoc_insertion_point(field_set:protos.SetplayMessage.wait_step)
}
inline ::int32_t SetplayMessage::_internal_wait_step() const {
  return _impl_.wait_step_;
}
inline void SetplayMessage::_internal_set_wait_step(::int32_t value) {
  ;
  _impl_.wait_step_ = value;
}

// -------------------------------------------------------------------

// PassRequestMessage

// .protos.Vector2D target_point = 1;
inline bool PassRequestMessage::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void PassRequestMessage::clear_target_point() {
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& PassRequestMessage::_internal_target_point() const {
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& PassRequestMessage::target_point() const {
  // @@protoc_insertion_point(field_get:protos.PassRequestMessage.target_point)
  return _internal_target_point();
}
inline void PassRequestMessage::unsafe_arena_set_allocated_target_point(
    ::protos::Vector2D* target_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = target_point;
  if (target_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PassRequestMessage.target_point)
}
inline ::protos::Vector2D* PassRequestMessage::release_target_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* PassRequestMessage::unsafe_arena_release_target_point() {
  // @@protoc_insertion_point(field_release:protos.PassRequestMessage.target_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* PassRequestMessage::_internal_mutable_target_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.target_point_ = p;
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* PassRequestMessage::mutable_target_point() {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.PassRequestMessage.target_point)
  return _msg;
}
inline void PassRequestMessage::set_allocated_target_point(::protos::Vector2D* target_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_point_;
  }
  if (target_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_point);
    if (message_arena != submessage_arena) {
      target_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_point_ = target_point;
  // @@protoc_insertion_point(field_set_allocated:protos.PassRequestMessage.target_point)
}

// -------------------------------------------------------------------

// StaminaMessage

// float stamina = 1;
inline void StaminaMessage::clear_stamina() {
  _impl_.stamina_ = 0;
}
inline float StaminaMessage::stamina() const {
  // @@protoc_insertion_point(field_get:protos.StaminaMessage.stamina)
  return _internal_stamina();
}
inline void StaminaMessage::set_stamina(float value) {
  _internal_set_stamina(value);
  // @@protoc_insertion_point(field_set:protos.StaminaMessage.stamina)
}
inline float StaminaMessage::_internal_stamina() const {
  return _impl_.stamina_;
}
inline void StaminaMessage::_internal_set_stamina(float value) {
  ;
  _impl_.stamina_ = value;
}

// -------------------------------------------------------------------

// RecoveryMessage

// float recovery = 1;
inline void RecoveryMessage::clear_recovery() {
  _impl_.recovery_ = 0;
}
inline float RecoveryMessage::recovery() const {
  // @@protoc_insertion_point(field_get:protos.RecoveryMessage.recovery)
  return _internal_recovery();
}
inline void RecoveryMessage::set_recovery(float value) {
  _internal_set_recovery(value);
  // @@protoc_insertion_point(field_set:protos.RecoveryMessage.recovery)
}
inline float RecoveryMessage::_internal_recovery() const {
  return _impl_.recovery_;
}
inline void RecoveryMessage::_internal_set_recovery(float value) {
  ;
  _impl_.recovery_ = value;
}

// -------------------------------------------------------------------

// StaminaCapacityMessage

// float stamina_capacity = 1;
inline void StaminaCapacityMessage::clear_stamina_capacity() {
  _impl_.stamina_capacity_ = 0;
}
inline float StaminaCapacityMessage::stamina_capacity() const {
  // @@protoc_insertion_point(field_get:protos.StaminaCapacityMessage.stamina_capacity)
  return _internal_stamina_capacity();
}
inline void StaminaCapacityMessage::set_stamina_capacity(float value) {
  _internal_set_stamina_capacity(value);
  // @@protoc_insertion_point(field_set:protos.StaminaCapacityMessage.stamina_capacity)
}
inline float StaminaCapacityMessage::_internal_stamina_capacity() const {
  return _impl_.stamina_capacity_;
}
inline void StaminaCapacityMessage::_internal_set_stamina_capacity(float value) {
  ;
  _impl_.stamina_capacity_ = value;
}

// -------------------------------------------------------------------

// DribbleMessage

// .protos.Vector2D target_point = 1;
inline bool DribbleMessage::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void DribbleMessage::clear_target_point() {
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& DribbleMessage::_internal_target_point() const {
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& DribbleMessage::target_point() const {
  // @@protoc_insertion_point(field_get:protos.DribbleMessage.target_point)
  return _internal_target_point();
}
inline void DribbleMessage::unsafe_arena_set_allocated_target_point(
    ::protos::Vector2D* target_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = target_point;
  if (target_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.DribbleMessage.target_point)
}
inline ::protos::Vector2D* DribbleMessage::release_target_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* DribbleMessage::unsafe_arena_release_target_point() {
  // @@protoc_insertion_point(field_release:protos.DribbleMessage.target_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* DribbleMessage::_internal_mutable_target_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.target_point_ = p;
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* DribbleMessage::mutable_target_point() {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.DribbleMessage.target_point)
  return _msg;
}
inline void DribbleMessage::set_allocated_target_point(::protos::Vector2D* target_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_point_;
  }
  if (target_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_point);
    if (message_arena != submessage_arena) {
      target_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_point_ = target_point;
  // @@protoc_insertion_point(field_set_allocated:protos.DribbleMessage.target_point)
}

// int32 queue_count = 2;
inline void DribbleMessage::clear_queue_count() {
  _impl_.queue_count_ = 0;
}
inline ::int32_t DribbleMessage::queue_count() const {
  // @@protoc_insertion_point(field_get:protos.DribbleMessage.queue_count)
  return _internal_queue_count();
}
inline void DribbleMessage::set_queue_count(::int32_t value) {
  _internal_set_queue_count(value);
  // @@protoc_insertion_point(field_set:protos.DribbleMessage.queue_count)
}
inline ::int32_t DribbleMessage::_internal_queue_count() const {
  return _impl_.queue_count_;
}
inline void DribbleMessage::_internal_set_queue_count(::int32_t value) {
  ;
  _impl_.queue_count_ = value;
}

// -------------------------------------------------------------------

// BallGoalieMessage

// .protos.Vector2D ball_position = 1;
inline bool BallGoalieMessage::has_ball_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_position_ != nullptr);
  return value;
}
inline void BallGoalieMessage::clear_ball_position() {
  if (_impl_.ball_position_ != nullptr) _impl_.ball_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& BallGoalieMessage::_internal_ball_position() const {
  const ::protos::Vector2D* p = _impl_.ball_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& BallGoalieMessage::ball_position() const {
  // @@protoc_insertion_point(field_get:protos.BallGoalieMessage.ball_position)
  return _internal_ball_position();
}
inline void BallGoalieMessage::unsafe_arena_set_allocated_ball_position(
    ::protos::Vector2D* ball_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ball_position_);
  }
  _impl_.ball_position_ = ball_position;
  if (ball_position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.BallGoalieMessage.ball_position)
}
inline ::protos::Vector2D* BallGoalieMessage::release_ball_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.ball_position_;
  _impl_.ball_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* BallGoalieMessage::unsafe_arena_release_ball_position() {
  // @@protoc_insertion_point(field_release:protos.BallGoalieMessage.ball_position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.ball_position_;
  _impl_.ball_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* BallGoalieMessage::_internal_mutable_ball_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ball_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.ball_position_ = p;
  }
  return _impl_.ball_position_;
}
inline ::protos::Vector2D* BallGoalieMessage::mutable_ball_position() {
  ::protos::Vector2D* _msg = _internal_mutable_ball_position();
  // @@protoc_insertion_point(field_mutable:protos.BallGoalieMessage.ball_position)
  return _msg;
}
inline void BallGoalieMessage::set_allocated_ball_position(::protos::Vector2D* ball_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ball_position_;
  }
  if (ball_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball_position);
    if (message_arena != submessage_arena) {
      ball_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ball_position_ = ball_position;
  // @@protoc_insertion_point(field_set_allocated:protos.BallGoalieMessage.ball_position)
}

// .protos.Vector2D ball_velocity = 2;
inline bool BallGoalieMessage::has_ball_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_velocity_ != nullptr);
  return value;
}
inline void BallGoalieMessage::clear_ball_velocity() {
  if (_impl_.ball_velocity_ != nullptr) _impl_.ball_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& BallGoalieMessage::_internal_ball_velocity() const {
  const ::protos::Vector2D* p = _impl_.ball_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& BallGoalieMessage::ball_velocity() const {
  // @@protoc_insertion_point(field_get:protos.BallGoalieMessage.ball_velocity)
  return _internal_ball_velocity();
}
inline void BallGoalieMessage::unsafe_arena_set_allocated_ball_velocity(
    ::protos::Vector2D* ball_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ball_velocity_);
  }
  _impl_.ball_velocity_ = ball_velocity;
  if (ball_velocity) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.BallGoalieMessage.ball_velocity)
}
inline ::protos::Vector2D* BallGoalieMessage::release_ball_velocity() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.ball_velocity_;
  _impl_.ball_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* BallGoalieMessage::unsafe_arena_release_ball_velocity() {
  // @@protoc_insertion_point(field_release:protos.BallGoalieMessage.ball_velocity)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.ball_velocity_;
  _impl_.ball_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* BallGoalieMessage::_internal_mutable_ball_velocity() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ball_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.ball_velocity_ = p;
  }
  return _impl_.ball_velocity_;
}
inline ::protos::Vector2D* BallGoalieMessage::mutable_ball_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_ball_velocity();
  // @@protoc_insertion_point(field_mutable:protos.BallGoalieMessage.ball_velocity)
  return _msg;
}
inline void BallGoalieMessage::set_allocated_ball_velocity(::protos::Vector2D* ball_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ball_velocity_;
  }
  if (ball_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball_velocity);
    if (message_arena != submessage_arena) {
      ball_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ball_velocity_ = ball_velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.BallGoalieMessage.ball_velocity)
}

// .protos.Vector2D goalie_position = 3;
inline bool BallGoalieMessage::has_goalie_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.goalie_position_ != nullptr);
  return value;
}
inline void BallGoalieMessage::clear_goalie_position() {
  if (_impl_.goalie_position_ != nullptr) _impl_.goalie_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& BallGoalieMessage::_internal_goalie_position() const {
  const ::protos::Vector2D* p = _impl_.goalie_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& BallGoalieMessage::goalie_position() const {
  // @@protoc_insertion_point(field_get:protos.BallGoalieMessage.goalie_position)
  return _internal_goalie_position();
}
inline void BallGoalieMessage::unsafe_arena_set_allocated_goalie_position(
    ::protos::Vector2D* goalie_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.goalie_position_);
  }
  _impl_.goalie_position_ = goalie_position;
  if (goalie_position) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.BallGoalieMessage.goalie_position)
}
inline ::protos::Vector2D* BallGoalieMessage::release_goalie_position() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.goalie_position_;
  _impl_.goalie_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* BallGoalieMessage::unsafe_arena_release_goalie_position() {
  // @@protoc_insertion_point(field_release:protos.BallGoalieMessage.goalie_position)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.goalie_position_;
  _impl_.goalie_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* BallGoalieMessage::_internal_mutable_goalie_position() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.goalie_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.goalie_position_ = p;
  }
  return _impl_.goalie_position_;
}
inline ::protos::Vector2D* BallGoalieMessage::mutable_goalie_position() {
  ::protos::Vector2D* _msg = _internal_mutable_goalie_position();
  // @@protoc_insertion_point(field_mutable:protos.BallGoalieMessage.goalie_position)
  return _msg;
}
inline void BallGoalieMessage::set_allocated_goalie_position(::protos::Vector2D* goalie_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.goalie_position_;
  }
  if (goalie_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(goalie_position);
    if (message_arena != submessage_arena) {
      goalie_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, goalie_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.goalie_position_ = goalie_position;
  // @@protoc_insertion_point(field_set_allocated:protos.BallGoalieMessage.goalie_position)
}

// float goalie_body_direction = 4;
inline void BallGoalieMessage::clear_goalie_body_direction() {
  _impl_.goalie_body_direction_ = 0;
}
inline float BallGoalieMessage::goalie_body_direction() const {
  // @@protoc_insertion_point(field_get:protos.BallGoalieMessage.goalie_body_direction)
  return _internal_goalie_body_direction();
}
inline void BallGoalieMessage::set_goalie_body_direction(float value) {
  _internal_set_goalie_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.BallGoalieMessage.goalie_body_direction)
}
inline float BallGoalieMessage::_internal_goalie_body_direction() const {
  return _impl_.goalie_body_direction_;
}
inline void BallGoalieMessage::_internal_set_goalie_body_direction(float value) {
  ;
  _impl_.goalie_body_direction_ = value;
}

// -------------------------------------------------------------------

// OnePlayerMessage

// int32 uniform_number = 1;
inline void OnePlayerMessage::clear_uniform_number() {
  _impl_.uniform_number_ = 0;
}
inline ::int32_t OnePlayerMessage::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.OnePlayerMessage.uniform_number)
  return _internal_uniform_number();
}
inline void OnePlayerMessage::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.OnePlayerMessage.uniform_number)
}
inline ::int32_t OnePlayerMessage::_internal_uniform_number() const {
  return _impl_.uniform_number_;
}
inline void OnePlayerMessage::_internal_set_uniform_number(::int32_t value) {
  ;
  _impl_.uniform_number_ = value;
}

// .protos.Vector2D position = 2;
inline bool OnePlayerMessage::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void OnePlayerMessage::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& OnePlayerMessage::_internal_position() const {
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& OnePlayerMessage::position() const {
  // @@protoc_insertion_point(field_get:protos.OnePlayerMessage.position)
  return _internal_position();
}
inline void OnePlayerMessage::unsafe_arena_set_allocated_position(
    ::protos::Vector2D* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.OnePlayerMessage.position)
}
inline ::protos::Vector2D* OnePlayerMessage::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* OnePlayerMessage::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protos.OnePlayerMessage.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* OnePlayerMessage::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* OnePlayerMessage::mutable_position() {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.OnePlayerMessage.position)
  return _msg;
}
inline void OnePlayerMessage::set_allocated_position(::protos::Vector2D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protos.OnePlayerMessage.position)
}

// -------------------------------------------------------------------

// TwoPlayerMessage

// int32 first_uniform_number = 1;
inline void TwoPlayerMessage::clear_first_uniform_number() {
  _impl_.first_uniform_number_ = 0;
}
inline ::int32_t TwoPlayerMessage::first_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.TwoPlayerMessage.first_uniform_number)
  return _internal_first_uniform_number();
}
inline void TwoPlayerMessage::set_first_uniform_number(::int32_t value) {
  _internal_set_first_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.TwoPlayerMessage.first_uniform_number)
}
inline ::int32_t TwoPlayerMessage::_internal_first_uniform_number() const {
  return _impl_.first_uniform_number_;
}
inline void TwoPlayerMessage::_internal_set_first_uniform_number(::int32_t value) {
  ;
  _impl_.first_uniform_number_ = value;
}

// .protos.Vector2D first_position = 2;
inline bool TwoPlayerMessage::has_first_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.first_position_ != nullptr);
  return value;
}
inline void TwoPlayerMessage::clear_first_position() {
  if (_impl_.first_position_ != nullptr) _impl_.first_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& TwoPlayerMessage::_internal_first_position() const {
  const ::protos::Vector2D* p = _impl_.first_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& TwoPlayerMessage::first_position() const {
  // @@protoc_insertion_point(field_get:protos.TwoPlayerMessage.first_position)
  return _internal_first_position();
}
inline void TwoPlayerMessage::unsafe_arena_set_allocated_first_position(
    ::protos::Vector2D* first_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.first_position_);
  }
  _impl_.first_position_ = first_position;
  if (first_position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.TwoPlayerMessage.first_position)
}
inline ::protos::Vector2D* TwoPlayerMessage::release_first_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.first_position_;
  _impl_.first_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* TwoPlayerMessage::unsafe_arena_release_first_position() {
  // @@protoc_insertion_point(field_release:protos.TwoPlayerMessage.first_position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.first_position_;
  _impl_.first_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* TwoPlayerMessage::_internal_mutable_first_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.first_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.first_position_ = p;
  }
  return _impl_.first_position_;
}
inline ::protos::Vector2D* TwoPlayerMessage::mutable_first_position() {
  ::protos::Vector2D* _msg = _internal_mutable_first_position();
  // @@protoc_insertion_point(field_mutable:protos.TwoPlayerMessage.first_position)
  return _msg;
}
inline void TwoPlayerMessage::set_allocated_first_position(::protos::Vector2D* first_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.first_position_;
  }
  if (first_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(first_position);
    if (message_arena != submessage_arena) {
      first_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, first_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.first_position_ = first_position;
  // @@protoc_insertion_point(field_set_allocated:protos.TwoPlayerMessage.first_position)
}

// int32 second_uniform_number = 3;
inline void TwoPlayerMessage::clear_second_uniform_number() {
  _impl_.second_uniform_number_ = 0;
}
inline ::int32_t TwoPlayerMessage::second_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.TwoPlayerMessage.second_uniform_number)
  return _internal_second_uniform_number();
}
inline void TwoPlayerMessage::set_second_uniform_number(::int32_t value) {
  _internal_set_second_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.TwoPlayerMessage.second_uniform_number)
}
inline ::int32_t TwoPlayerMessage::_internal_second_uniform_number() const {
  return _impl_.second_uniform_number_;
}
inline void TwoPlayerMessage::_internal_set_second_uniform_number(::int32_t value) {
  ;
  _impl_.second_uniform_number_ = value;
}

// .protos.Vector2D second_position = 4;
inline bool TwoPlayerMessage::has_second_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.second_position_ != nullptr);
  return value;
}
inline void TwoPlayerMessage::clear_second_position() {
  if (_impl_.second_position_ != nullptr) _impl_.second_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& TwoPlayerMessage::_internal_second_position() const {
  const ::protos::Vector2D* p = _impl_.second_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& TwoPlayerMessage::second_position() const {
  // @@protoc_insertion_point(field_get:protos.TwoPlayerMessage.second_position)
  return _internal_second_position();
}
inline void TwoPlayerMessage::unsafe_arena_set_allocated_second_position(
    ::protos::Vector2D* second_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.second_position_);
  }
  _impl_.second_position_ = second_position;
  if (second_position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.TwoPlayerMessage.second_position)
}
inline ::protos::Vector2D* TwoPlayerMessage::release_second_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.second_position_;
  _impl_.second_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* TwoPlayerMessage::unsafe_arena_release_second_position() {
  // @@protoc_insertion_point(field_release:protos.TwoPlayerMessage.second_position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.second_position_;
  _impl_.second_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* TwoPlayerMessage::_internal_mutable_second_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.second_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.second_position_ = p;
  }
  return _impl_.second_position_;
}
inline ::protos::Vector2D* TwoPlayerMessage::mutable_second_position() {
  ::protos::Vector2D* _msg = _internal_mutable_second_position();
  // @@protoc_insertion_point(field_mutable:protos.TwoPlayerMessage.second_position)
  return _msg;
}
inline void TwoPlayerMessage::set_allocated_second_position(::protos::Vector2D* second_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.second_position_;
  }
  if (second_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(second_position);
    if (message_arena != submessage_arena) {
      second_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, second_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.second_position_ = second_position;
  // @@protoc_insertion_point(field_set_allocated:protos.TwoPlayerMessage.second_position)
}

// -------------------------------------------------------------------

// ThreePlayerMessage

// int32 first_uniform_number = 1;
inline void ThreePlayerMessage::clear_first_uniform_number() {
  _impl_.first_uniform_number_ = 0;
}
inline ::int32_t ThreePlayerMessage::first_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.ThreePlayerMessage.first_uniform_number)
  return _internal_first_uniform_number();
}
inline void ThreePlayerMessage::set_first_uniform_number(::int32_t value) {
  _internal_set_first_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.ThreePlayerMessage.first_uniform_number)
}
inline ::int32_t ThreePlayerMessage::_internal_first_uniform_number() const {
  return _impl_.first_uniform_number_;
}
inline void ThreePlayerMessage::_internal_set_first_uniform_number(::int32_t value) {
  ;
  _impl_.first_uniform_number_ = value;
}

// .protos.Vector2D first_position = 2;
inline bool ThreePlayerMessage::has_first_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.first_position_ != nullptr);
  return value;
}
inline void ThreePlayerMessage::clear_first_position() {
  if (_impl_.first_position_ != nullptr) _impl_.first_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& ThreePlayerMessage::_internal_first_position() const {
  const ::protos::Vector2D* p = _impl_.first_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& ThreePlayerMessage::first_position() const {
  // @@protoc_insertion_point(field_get:protos.ThreePlayerMessage.first_position)
  return _internal_first_position();
}
inline void ThreePlayerMessage::unsafe_arena_set_allocated_first_position(
    ::protos::Vector2D* first_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.first_position_);
  }
  _impl_.first_position_ = first_position;
  if (first_position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.ThreePlayerMessage.first_position)
}
inline ::protos::Vector2D* ThreePlayerMessage::release_first_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.first_position_;
  _impl_.first_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* ThreePlayerMessage::unsafe_arena_release_first_position() {
  // @@protoc_insertion_point(field_release:protos.ThreePlayerMessage.first_position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.first_position_;
  _impl_.first_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* ThreePlayerMessage::_internal_mutable_first_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.first_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.first_position_ = p;
  }
  return _impl_.first_position_;
}
inline ::protos::Vector2D* ThreePlayerMessage::mutable_first_position() {
  ::protos::Vector2D* _msg = _internal_mutable_first_position();
  // @@protoc_insertion_point(field_mutable:protos.ThreePlayerMessage.first_position)
  return _msg;
}
inline void ThreePlayerMessage::set_allocated_first_position(::protos::Vector2D* first_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.first_position_;
  }
  if (first_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(first_position);
    if (message_arena != submessage_arena) {
      first_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, first_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.first_position_ = first_position;
  // @@protoc_insertion_point(field_set_allocated:protos.ThreePlayerMessage.first_position)
}

// int32 second_uniform_number = 3;
inline void ThreePlayerMessage::clear_second_uniform_number() {
  _impl_.second_uniform_number_ = 0;
}
inline ::int32_t ThreePlayerMessage::second_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.ThreePlayerMessage.second_uniform_number)
  return _internal_second_uniform_number();
}
inline void ThreePlayerMessage::set_second_uniform_number(::int32_t value) {
  _internal_set_second_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.ThreePlayerMessage.second_uniform_number)
}
inline ::int32_t ThreePlayerMessage::_internal_second_uniform_number() const {
  return _impl_.second_uniform_number_;
}
inline void ThreePlayerMessage::_internal_set_second_uniform_number(::int32_t value) {
  ;
  _impl_.second_uniform_number_ = value;
}

// .protos.Vector2D second_position = 4;
inline bool ThreePlayerMessage::has_second_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.second_position_ != nullptr);
  return value;
}
inline void ThreePlayerMessage::clear_second_position() {
  if (_impl_.second_position_ != nullptr) _impl_.second_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& ThreePlayerMessage::_internal_second_position() const {
  const ::protos::Vector2D* p = _impl_.second_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& ThreePlayerMessage::second_position() const {
  // @@protoc_insertion_point(field_get:protos.ThreePlayerMessage.second_position)
  return _internal_second_position();
}
inline void ThreePlayerMessage::unsafe_arena_set_allocated_second_position(
    ::protos::Vector2D* second_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.second_position_);
  }
  _impl_.second_position_ = second_position;
  if (second_position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.ThreePlayerMessage.second_position)
}
inline ::protos::Vector2D* ThreePlayerMessage::release_second_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.second_position_;
  _impl_.second_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* ThreePlayerMessage::unsafe_arena_release_second_position() {
  // @@protoc_insertion_point(field_release:protos.ThreePlayerMessage.second_position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.second_position_;
  _impl_.second_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* ThreePlayerMessage::_internal_mutable_second_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.second_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.second_position_ = p;
  }
  return _impl_.second_position_;
}
inline ::protos::Vector2D* ThreePlayerMessage::mutable_second_position() {
  ::protos::Vector2D* _msg = _internal_mutable_second_position();
  // @@protoc_insertion_point(field_mutable:protos.ThreePlayerMessage.second_position)
  return _msg;
}
inline void ThreePlayerMessage::set_allocated_second_position(::protos::Vector2D* second_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.second_position_;
  }
  if (second_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(second_position);
    if (message_arena != submessage_arena) {
      second_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, second_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.second_position_ = second_position;
  // @@protoc_insertion_point(field_set_allocated:protos.ThreePlayerMessage.second_position)
}

// int32 third_uniform_number = 5;
inline void ThreePlayerMessage::clear_third_uniform_number() {
  _impl_.third_uniform_number_ = 0;
}
inline ::int32_t ThreePlayerMessage::third_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.ThreePlayerMessage.third_uniform_number)
  return _internal_third_uniform_number();
}
inline void ThreePlayerMessage::set_third_uniform_number(::int32_t value) {
  _internal_set_third_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.ThreePlayerMessage.third_uniform_number)
}
inline ::int32_t ThreePlayerMessage::_internal_third_uniform_number() const {
  return _impl_.third_uniform_number_;
}
inline void ThreePlayerMessage::_internal_set_third_uniform_number(::int32_t value) {
  ;
  _impl_.third_uniform_number_ = value;
}

// .protos.Vector2D third_position = 6;
inline bool ThreePlayerMessage::has_third_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.third_position_ != nullptr);
  return value;
}
inline void ThreePlayerMessage::clear_third_position() {
  if (_impl_.third_position_ != nullptr) _impl_.third_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& ThreePlayerMessage::_internal_third_position() const {
  const ::protos::Vector2D* p = _impl_.third_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& ThreePlayerMessage::third_position() const {
  // @@protoc_insertion_point(field_get:protos.ThreePlayerMessage.third_position)
  return _internal_third_position();
}
inline void ThreePlayerMessage::unsafe_arena_set_allocated_third_position(
    ::protos::Vector2D* third_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.third_position_);
  }
  _impl_.third_position_ = third_position;
  if (third_position) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.ThreePlayerMessage.third_position)
}
inline ::protos::Vector2D* ThreePlayerMessage::release_third_position() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.third_position_;
  _impl_.third_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* ThreePlayerMessage::unsafe_arena_release_third_position() {
  // @@protoc_insertion_point(field_release:protos.ThreePlayerMessage.third_position)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.third_position_;
  _impl_.third_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* ThreePlayerMessage::_internal_mutable_third_position() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.third_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.third_position_ = p;
  }
  return _impl_.third_position_;
}
inline ::protos::Vector2D* ThreePlayerMessage::mutable_third_position() {
  ::protos::Vector2D* _msg = _internal_mutable_third_position();
  // @@protoc_insertion_point(field_mutable:protos.ThreePlayerMessage.third_position)
  return _msg;
}
inline void ThreePlayerMessage::set_allocated_third_position(::protos::Vector2D* third_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.third_position_;
  }
  if (third_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(third_position);
    if (message_arena != submessage_arena) {
      third_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, third_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.third_position_ = third_position;
  // @@protoc_insertion_point(field_set_allocated:protos.ThreePlayerMessage.third_position)
}

// -------------------------------------------------------------------

// SelfMessage

// .protos.Vector2D self_position = 1;
inline bool SelfMessage::has_self_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.self_position_ != nullptr);
  return value;
}
inline void SelfMessage::clear_self_position() {
  if (_impl_.self_position_ != nullptr) _impl_.self_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& SelfMessage::_internal_self_position() const {
  const ::protos::Vector2D* p = _impl_.self_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& SelfMessage::self_position() const {
  // @@protoc_insertion_point(field_get:protos.SelfMessage.self_position)
  return _internal_self_position();
}
inline void SelfMessage::unsafe_arena_set_allocated_self_position(
    ::protos::Vector2D* self_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.self_position_);
  }
  _impl_.self_position_ = self_position;
  if (self_position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.SelfMessage.self_position)
}
inline ::protos::Vector2D* SelfMessage::release_self_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.self_position_;
  _impl_.self_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* SelfMessage::unsafe_arena_release_self_position() {
  // @@protoc_insertion_point(field_release:protos.SelfMessage.self_position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.self_position_;
  _impl_.self_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* SelfMessage::_internal_mutable_self_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.self_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.self_position_ = p;
  }
  return _impl_.self_position_;
}
inline ::protos::Vector2D* SelfMessage::mutable_self_position() {
  ::protos::Vector2D* _msg = _internal_mutable_self_position();
  // @@protoc_insertion_point(field_mutable:protos.SelfMessage.self_position)
  return _msg;
}
inline void SelfMessage::set_allocated_self_position(::protos::Vector2D* self_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.self_position_;
  }
  if (self_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(self_position);
    if (message_arena != submessage_arena) {
      self_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, self_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.self_position_ = self_position;
  // @@protoc_insertion_point(field_set_allocated:protos.SelfMessage.self_position)
}

// float self_body_direction = 2;
inline void SelfMessage::clear_self_body_direction() {
  _impl_.self_body_direction_ = 0;
}
inline float SelfMessage::self_body_direction() const {
  // @@protoc_insertion_point(field_get:protos.SelfMessage.self_body_direction)
  return _internal_self_body_direction();
}
inline void SelfMessage::set_self_body_direction(float value) {
  _internal_set_self_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.SelfMessage.self_body_direction)
}
inline float SelfMessage::_internal_self_body_direction() const {
  return _impl_.self_body_direction_;
}
inline void SelfMessage::_internal_set_self_body_direction(float value) {
  ;
  _impl_.self_body_direction_ = value;
}

// float self_stamina = 3;
inline void SelfMessage::clear_self_stamina() {
  _impl_.self_stamina_ = 0;
}
inline float SelfMessage::self_stamina() const {
  // @@protoc_insertion_point(field_get:protos.SelfMessage.self_stamina)
  return _internal_self_stamina();
}
inline void SelfMessage::set_self_stamina(float value) {
  _internal_set_self_stamina(value);
  // @@protoc_insertion_point(field_set:protos.SelfMessage.self_stamina)
}
inline float SelfMessage::_internal_self_stamina() const {
  return _impl_.self_stamina_;
}
inline void SelfMessage::_internal_set_self_stamina(float value) {
  ;
  _impl_.self_stamina_ = value;
}

// -------------------------------------------------------------------

// TeammateMessage

// int32 uniform_number = 1;
inline void TeammateMessage::clear_uniform_number() {
  _impl_.uniform_number_ = 0;
}
inline ::int32_t TeammateMessage::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.TeammateMessage.uniform_number)
  return _internal_uniform_number();
}
inline void TeammateMessage::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.TeammateMessage.uniform_number)
}
inline ::int32_t TeammateMessage::_internal_uniform_number() const {
  return _impl_.uniform_number_;
}
inline void TeammateMessage::_internal_set_uniform_number(::int32_t value) {
  ;
  _impl_.uniform_number_ = value;
}

// .protos.Vector2D position = 2;
inline bool TeammateMessage::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void TeammateMessage::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& TeammateMessage::_internal_position() const {
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& TeammateMessage::position() const {
  // @@protoc_insertion_point(field_get:protos.TeammateMessage.position)
  return _internal_position();
}
inline void TeammateMessage::unsafe_arena_set_allocated_position(
    ::protos::Vector2D* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.TeammateMessage.position)
}
inline ::protos::Vector2D* TeammateMessage::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* TeammateMessage::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protos.TeammateMessage.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* TeammateMessage::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* TeammateMessage::mutable_position() {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.TeammateMessage.position)
  return _msg;
}
inline void TeammateMessage::set_allocated_position(::protos::Vector2D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protos.TeammateMessage.position)
}

// float body_direction = 3;
inline void TeammateMessage::clear_body_direction() {
  _impl_.body_direction_ = 0;
}
inline float TeammateMessage::body_direction() const {
  // @@protoc_insertion_point(field_get:protos.TeammateMessage.body_direction)
  return _internal_body_direction();
}
inline void TeammateMessage::set_body_direction(float value) {
  _internal_set_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.TeammateMessage.body_direction)
}
inline float TeammateMessage::_internal_body_direction() const {
  return _impl_.body_direction_;
}
inline void TeammateMessage::_internal_set_body_direction(float value) {
  ;
  _impl_.body_direction_ = value;
}

// -------------------------------------------------------------------

// OpponentMessage

// int32 uniform_number = 1;
inline void OpponentMessage::clear_uniform_number() {
  _impl_.uniform_number_ = 0;
}
inline ::int32_t OpponentMessage::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.OpponentMessage.uniform_number)
  return _internal_uniform_number();
}
inline void OpponentMessage::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.OpponentMessage.uniform_number)
}
inline ::int32_t OpponentMessage::_internal_uniform_number() const {
  return _impl_.uniform_number_;
}
inline void OpponentMessage::_internal_set_uniform_number(::int32_t value) {
  ;
  _impl_.uniform_number_ = value;
}

// .protos.Vector2D position = 2;
inline bool OpponentMessage::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void OpponentMessage::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& OpponentMessage::_internal_position() const {
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& OpponentMessage::position() const {
  // @@protoc_insertion_point(field_get:protos.OpponentMessage.position)
  return _internal_position();
}
inline void OpponentMessage::unsafe_arena_set_allocated_position(
    ::protos::Vector2D* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.OpponentMessage.position)
}
inline ::protos::Vector2D* OpponentMessage::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* OpponentMessage::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protos.OpponentMessage.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* OpponentMessage::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* OpponentMessage::mutable_position() {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.OpponentMessage.position)
  return _msg;
}
inline void OpponentMessage::set_allocated_position(::protos::Vector2D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protos.OpponentMessage.position)
}

// float body_direction = 3;
inline void OpponentMessage::clear_body_direction() {
  _impl_.body_direction_ = 0;
}
inline float OpponentMessage::body_direction() const {
  // @@protoc_insertion_point(field_get:protos.OpponentMessage.body_direction)
  return _internal_body_direction();
}
inline void OpponentMessage::set_body_direction(float value) {
  _internal_set_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.OpponentMessage.body_direction)
}
inline float OpponentMessage::_internal_body_direction() const {
  return _impl_.body_direction_;
}
inline void OpponentMessage::_internal_set_body_direction(float value) {
  ;
  _impl_.body_direction_ = value;
}

// -------------------------------------------------------------------

// BallPlayerMessage

// .protos.Vector2D ball_position = 1;
inline bool BallPlayerMessage::has_ball_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_position_ != nullptr);
  return value;
}
inline void BallPlayerMessage::clear_ball_position() {
  if (_impl_.ball_position_ != nullptr) _impl_.ball_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& BallPlayerMessage::_internal_ball_position() const {
  const ::protos::Vector2D* p = _impl_.ball_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& BallPlayerMessage::ball_position() const {
  // @@protoc_insertion_point(field_get:protos.BallPlayerMessage.ball_position)
  return _internal_ball_position();
}
inline void BallPlayerMessage::unsafe_arena_set_allocated_ball_position(
    ::protos::Vector2D* ball_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ball_position_);
  }
  _impl_.ball_position_ = ball_position;
  if (ball_position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.BallPlayerMessage.ball_position)
}
inline ::protos::Vector2D* BallPlayerMessage::release_ball_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.ball_position_;
  _impl_.ball_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* BallPlayerMessage::unsafe_arena_release_ball_position() {
  // @@protoc_insertion_point(field_release:protos.BallPlayerMessage.ball_position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.ball_position_;
  _impl_.ball_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* BallPlayerMessage::_internal_mutable_ball_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ball_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.ball_position_ = p;
  }
  return _impl_.ball_position_;
}
inline ::protos::Vector2D* BallPlayerMessage::mutable_ball_position() {
  ::protos::Vector2D* _msg = _internal_mutable_ball_position();
  // @@protoc_insertion_point(field_mutable:protos.BallPlayerMessage.ball_position)
  return _msg;
}
inline void BallPlayerMessage::set_allocated_ball_position(::protos::Vector2D* ball_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ball_position_;
  }
  if (ball_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball_position);
    if (message_arena != submessage_arena) {
      ball_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ball_position_ = ball_position;
  // @@protoc_insertion_point(field_set_allocated:protos.BallPlayerMessage.ball_position)
}

// .protos.Vector2D ball_velocity = 2;
inline bool BallPlayerMessage::has_ball_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_velocity_ != nullptr);
  return value;
}
inline void BallPlayerMessage::clear_ball_velocity() {
  if (_impl_.ball_velocity_ != nullptr) _impl_.ball_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& BallPlayerMessage::_internal_ball_velocity() const {
  const ::protos::Vector2D* p = _impl_.ball_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& BallPlayerMessage::ball_velocity() const {
  // @@protoc_insertion_point(field_get:protos.BallPlayerMessage.ball_velocity)
  return _internal_ball_velocity();
}
inline void BallPlayerMessage::unsafe_arena_set_allocated_ball_velocity(
    ::protos::Vector2D* ball_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ball_velocity_);
  }
  _impl_.ball_velocity_ = ball_velocity;
  if (ball_velocity) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.BallPlayerMessage.ball_velocity)
}
inline ::protos::Vector2D* BallPlayerMessage::release_ball_velocity() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.ball_velocity_;
  _impl_.ball_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* BallPlayerMessage::unsafe_arena_release_ball_velocity() {
  // @@protoc_insertion_point(field_release:protos.BallPlayerMessage.ball_velocity)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.ball_velocity_;
  _impl_.ball_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* BallPlayerMessage::_internal_mutable_ball_velocity() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ball_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.ball_velocity_ = p;
  }
  return _impl_.ball_velocity_;
}
inline ::protos::Vector2D* BallPlayerMessage::mutable_ball_velocity() {
  ::protos::Vector2D* _msg = _internal_mutable_ball_velocity();
  // @@protoc_insertion_point(field_mutable:protos.BallPlayerMessage.ball_velocity)
  return _msg;
}
inline void BallPlayerMessage::set_allocated_ball_velocity(::protos::Vector2D* ball_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ball_velocity_;
  }
  if (ball_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball_velocity);
    if (message_arena != submessage_arena) {
      ball_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ball_velocity_ = ball_velocity;
  // @@protoc_insertion_point(field_set_allocated:protos.BallPlayerMessage.ball_velocity)
}

// int32 uniform_number = 3;
inline void BallPlayerMessage::clear_uniform_number() {
  _impl_.uniform_number_ = 0;
}
inline ::int32_t BallPlayerMessage::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.BallPlayerMessage.uniform_number)
  return _internal_uniform_number();
}
inline void BallPlayerMessage::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.BallPlayerMessage.uniform_number)
}
inline ::int32_t BallPlayerMessage::_internal_uniform_number() const {
  return _impl_.uniform_number_;
}
inline void BallPlayerMessage::_internal_set_uniform_number(::int32_t value) {
  ;
  _impl_.uniform_number_ = value;
}

// .protos.Vector2D player_position = 4;
inline bool BallPlayerMessage::has_player_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_position_ != nullptr);
  return value;
}
inline void BallPlayerMessage::clear_player_position() {
  if (_impl_.player_position_ != nullptr) _impl_.player_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& BallPlayerMessage::_internal_player_position() const {
  const ::protos::Vector2D* p = _impl_.player_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& BallPlayerMessage::player_position() const {
  // @@protoc_insertion_point(field_get:protos.BallPlayerMessage.player_position)
  return _internal_player_position();
}
inline void BallPlayerMessage::unsafe_arena_set_allocated_player_position(
    ::protos::Vector2D* player_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_position_);
  }
  _impl_.player_position_ = player_position;
  if (player_position) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.BallPlayerMessage.player_position)
}
inline ::protos::Vector2D* BallPlayerMessage::release_player_position() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.player_position_;
  _impl_.player_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* BallPlayerMessage::unsafe_arena_release_player_position() {
  // @@protoc_insertion_point(field_release:protos.BallPlayerMessage.player_position)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.player_position_;
  _impl_.player_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* BallPlayerMessage::_internal_mutable_player_position() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.player_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.player_position_ = p;
  }
  return _impl_.player_position_;
}
inline ::protos::Vector2D* BallPlayerMessage::mutable_player_position() {
  ::protos::Vector2D* _msg = _internal_mutable_player_position();
  // @@protoc_insertion_point(field_mutable:protos.BallPlayerMessage.player_position)
  return _msg;
}
inline void BallPlayerMessage::set_allocated_player_position(::protos::Vector2D* player_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_position_;
  }
  if (player_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player_position);
    if (message_arena != submessage_arena) {
      player_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.player_position_ = player_position;
  // @@protoc_insertion_point(field_set_allocated:protos.BallPlayerMessage.player_position)
}

// float body_direction = 5;
inline void BallPlayerMessage::clear_body_direction() {
  _impl_.body_direction_ = 0;
}
inline float BallPlayerMessage::body_direction() const {
  // @@protoc_insertion_point(field_get:protos.BallPlayerMessage.body_direction)
  return _internal_body_direction();
}
inline void BallPlayerMessage::set_body_direction(float value) {
  _internal_set_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.BallPlayerMessage.body_direction)
}
inline float BallPlayerMessage::_internal_body_direction() const {
  return _impl_.body_direction_;
}
inline void BallPlayerMessage::_internal_set_body_direction(float value) {
  ;
  _impl_.body_direction_ = value;
}

// -------------------------------------------------------------------

// Say

// .protos.BallMessage ball_message = 1;
inline bool Say::has_ball_message() const {
  return message_case() == kBallMessage;
}
inline bool Say::_internal_has_ball_message() const {
  return message_case() == kBallMessage;
}
inline void Say::set_has_ball_message() {
  _impl_._oneof_case_[0] = kBallMessage;
}
inline void Say::clear_ball_message() {
  if (message_case() == kBallMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.ball_message_;
    }
    clear_has_message();
  }
}
inline ::protos::BallMessage* Say::release_ball_message() {
  // @@protoc_insertion_point(field_release:protos.Say.ball_message)
  if (message_case() == kBallMessage) {
    clear_has_message();
    ::protos::BallMessage* temp = _impl_.message_.ball_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.ball_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::BallMessage& Say::_internal_ball_message() const {
  return message_case() == kBallMessage
      ? *_impl_.message_.ball_message_
      : reinterpret_cast<::protos::BallMessage&>(::protos::_BallMessage_default_instance_);
}
inline const ::protos::BallMessage& Say::ball_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.ball_message)
  return _internal_ball_message();
}
inline ::protos::BallMessage* Say::unsafe_arena_release_ball_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.ball_message)
  if (message_case() == kBallMessage) {
    clear_has_message();
    ::protos::BallMessage* temp = _impl_.message_.ball_message_;
    _impl_.message_.ball_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_ball_message(::protos::BallMessage* ball_message) {
  clear_message();
  if (ball_message) {
    set_has_ball_message();
    _impl_.message_.ball_message_ = ball_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.ball_message)
}
inline ::protos::BallMessage* Say::_internal_mutable_ball_message() {
  if (message_case() != kBallMessage) {
    clear_message();
    set_has_ball_message();
    _impl_.message_.ball_message_ = CreateMaybeMessage< ::protos::BallMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.ball_message_;
}
inline ::protos::BallMessage* Say::mutable_ball_message() {
  ::protos::BallMessage* _msg = _internal_mutable_ball_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.ball_message)
  return _msg;
}

// .protos.PassMessage pass_message = 2;
inline bool Say::has_pass_message() const {
  return message_case() == kPassMessage;
}
inline bool Say::_internal_has_pass_message() const {
  return message_case() == kPassMessage;
}
inline void Say::set_has_pass_message() {
  _impl_._oneof_case_[0] = kPassMessage;
}
inline void Say::clear_pass_message() {
  if (message_case() == kPassMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.pass_message_;
    }
    clear_has_message();
  }
}
inline ::protos::PassMessage* Say::release_pass_message() {
  // @@protoc_insertion_point(field_release:protos.Say.pass_message)
  if (message_case() == kPassMessage) {
    clear_has_message();
    ::protos::PassMessage* temp = _impl_.message_.pass_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.pass_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::PassMessage& Say::_internal_pass_message() const {
  return message_case() == kPassMessage
      ? *_impl_.message_.pass_message_
      : reinterpret_cast<::protos::PassMessage&>(::protos::_PassMessage_default_instance_);
}
inline const ::protos::PassMessage& Say::pass_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.pass_message)
  return _internal_pass_message();
}
inline ::protos::PassMessage* Say::unsafe_arena_release_pass_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.pass_message)
  if (message_case() == kPassMessage) {
    clear_has_message();
    ::protos::PassMessage* temp = _impl_.message_.pass_message_;
    _impl_.message_.pass_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_pass_message(::protos::PassMessage* pass_message) {
  clear_message();
  if (pass_message) {
    set_has_pass_message();
    _impl_.message_.pass_message_ = pass_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.pass_message)
}
inline ::protos::PassMessage* Say::_internal_mutable_pass_message() {
  if (message_case() != kPassMessage) {
    clear_message();
    set_has_pass_message();
    _impl_.message_.pass_message_ = CreateMaybeMessage< ::protos::PassMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.pass_message_;
}
inline ::protos::PassMessage* Say::mutable_pass_message() {
  ::protos::PassMessage* _msg = _internal_mutable_pass_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.pass_message)
  return _msg;
}

// .protos.InterceptMessage intercept_message = 3;
inline bool Say::has_intercept_message() const {
  return message_case() == kInterceptMessage;
}
inline bool Say::_internal_has_intercept_message() const {
  return message_case() == kInterceptMessage;
}
inline void Say::set_has_intercept_message() {
  _impl_._oneof_case_[0] = kInterceptMessage;
}
inline void Say::clear_intercept_message() {
  if (message_case() == kInterceptMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.intercept_message_;
    }
    clear_has_message();
  }
}
inline ::protos::InterceptMessage* Say::release_intercept_message() {
  // @@protoc_insertion_point(field_release:protos.Say.intercept_message)
  if (message_case() == kInterceptMessage) {
    clear_has_message();
    ::protos::InterceptMessage* temp = _impl_.message_.intercept_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.intercept_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::InterceptMessage& Say::_internal_intercept_message() const {
  return message_case() == kInterceptMessage
      ? *_impl_.message_.intercept_message_
      : reinterpret_cast<::protos::InterceptMessage&>(::protos::_InterceptMessage_default_instance_);
}
inline const ::protos::InterceptMessage& Say::intercept_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.intercept_message)
  return _internal_intercept_message();
}
inline ::protos::InterceptMessage* Say::unsafe_arena_release_intercept_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.intercept_message)
  if (message_case() == kInterceptMessage) {
    clear_has_message();
    ::protos::InterceptMessage* temp = _impl_.message_.intercept_message_;
    _impl_.message_.intercept_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_intercept_message(::protos::InterceptMessage* intercept_message) {
  clear_message();
  if (intercept_message) {
    set_has_intercept_message();
    _impl_.message_.intercept_message_ = intercept_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.intercept_message)
}
inline ::protos::InterceptMessage* Say::_internal_mutable_intercept_message() {
  if (message_case() != kInterceptMessage) {
    clear_message();
    set_has_intercept_message();
    _impl_.message_.intercept_message_ = CreateMaybeMessage< ::protos::InterceptMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.intercept_message_;
}
inline ::protos::InterceptMessage* Say::mutable_intercept_message() {
  ::protos::InterceptMessage* _msg = _internal_mutable_intercept_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.intercept_message)
  return _msg;
}

// .protos.GoalieMessage goalie_message = 4;
inline bool Say::has_goalie_message() const {
  return message_case() == kGoalieMessage;
}
inline bool Say::_internal_has_goalie_message() const {
  return message_case() == kGoalieMessage;
}
inline void Say::set_has_goalie_message() {
  _impl_._oneof_case_[0] = kGoalieMessage;
}
inline void Say::clear_goalie_message() {
  if (message_case() == kGoalieMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.goalie_message_;
    }
    clear_has_message();
  }
}
inline ::protos::GoalieMessage* Say::release_goalie_message() {
  // @@protoc_insertion_point(field_release:protos.Say.goalie_message)
  if (message_case() == kGoalieMessage) {
    clear_has_message();
    ::protos::GoalieMessage* temp = _impl_.message_.goalie_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.goalie_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::GoalieMessage& Say::_internal_goalie_message() const {
  return message_case() == kGoalieMessage
      ? *_impl_.message_.goalie_message_
      : reinterpret_cast<::protos::GoalieMessage&>(::protos::_GoalieMessage_default_instance_);
}
inline const ::protos::GoalieMessage& Say::goalie_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.goalie_message)
  return _internal_goalie_message();
}
inline ::protos::GoalieMessage* Say::unsafe_arena_release_goalie_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.goalie_message)
  if (message_case() == kGoalieMessage) {
    clear_has_message();
    ::protos::GoalieMessage* temp = _impl_.message_.goalie_message_;
    _impl_.message_.goalie_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_goalie_message(::protos::GoalieMessage* goalie_message) {
  clear_message();
  if (goalie_message) {
    set_has_goalie_message();
    _impl_.message_.goalie_message_ = goalie_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.goalie_message)
}
inline ::protos::GoalieMessage* Say::_internal_mutable_goalie_message() {
  if (message_case() != kGoalieMessage) {
    clear_message();
    set_has_goalie_message();
    _impl_.message_.goalie_message_ = CreateMaybeMessage< ::protos::GoalieMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.goalie_message_;
}
inline ::protos::GoalieMessage* Say::mutable_goalie_message() {
  ::protos::GoalieMessage* _msg = _internal_mutable_goalie_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.goalie_message)
  return _msg;
}

// .protos.GoalieAndPlayerMessage goalie_and_player_message = 5;
inline bool Say::has_goalie_and_player_message() const {
  return message_case() == kGoalieAndPlayerMessage;
}
inline bool Say::_internal_has_goalie_and_player_message() const {
  return message_case() == kGoalieAndPlayerMessage;
}
inline void Say::set_has_goalie_and_player_message() {
  _impl_._oneof_case_[0] = kGoalieAndPlayerMessage;
}
inline void Say::clear_goalie_and_player_message() {
  if (message_case() == kGoalieAndPlayerMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.goalie_and_player_message_;
    }
    clear_has_message();
  }
}
inline ::protos::GoalieAndPlayerMessage* Say::release_goalie_and_player_message() {
  // @@protoc_insertion_point(field_release:protos.Say.goalie_and_player_message)
  if (message_case() == kGoalieAndPlayerMessage) {
    clear_has_message();
    ::protos::GoalieAndPlayerMessage* temp = _impl_.message_.goalie_and_player_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.goalie_and_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::GoalieAndPlayerMessage& Say::_internal_goalie_and_player_message() const {
  return message_case() == kGoalieAndPlayerMessage
      ? *_impl_.message_.goalie_and_player_message_
      : reinterpret_cast<::protos::GoalieAndPlayerMessage&>(::protos::_GoalieAndPlayerMessage_default_instance_);
}
inline const ::protos::GoalieAndPlayerMessage& Say::goalie_and_player_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.goalie_and_player_message)
  return _internal_goalie_and_player_message();
}
inline ::protos::GoalieAndPlayerMessage* Say::unsafe_arena_release_goalie_and_player_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.goalie_and_player_message)
  if (message_case() == kGoalieAndPlayerMessage) {
    clear_has_message();
    ::protos::GoalieAndPlayerMessage* temp = _impl_.message_.goalie_and_player_message_;
    _impl_.message_.goalie_and_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_goalie_and_player_message(::protos::GoalieAndPlayerMessage* goalie_and_player_message) {
  clear_message();
  if (goalie_and_player_message) {
    set_has_goalie_and_player_message();
    _impl_.message_.goalie_and_player_message_ = goalie_and_player_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.goalie_and_player_message)
}
inline ::protos::GoalieAndPlayerMessage* Say::_internal_mutable_goalie_and_player_message() {
  if (message_case() != kGoalieAndPlayerMessage) {
    clear_message();
    set_has_goalie_and_player_message();
    _impl_.message_.goalie_and_player_message_ = CreateMaybeMessage< ::protos::GoalieAndPlayerMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.goalie_and_player_message_;
}
inline ::protos::GoalieAndPlayerMessage* Say::mutable_goalie_and_player_message() {
  ::protos::GoalieAndPlayerMessage* _msg = _internal_mutable_goalie_and_player_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.goalie_and_player_message)
  return _msg;
}

// .protos.OffsideLineMessage offside_line_message = 6;
inline bool Say::has_offside_line_message() const {
  return message_case() == kOffsideLineMessage;
}
inline bool Say::_internal_has_offside_line_message() const {
  return message_case() == kOffsideLineMessage;
}
inline void Say::set_has_offside_line_message() {
  _impl_._oneof_case_[0] = kOffsideLineMessage;
}
inline void Say::clear_offside_line_message() {
  if (message_case() == kOffsideLineMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.offside_line_message_;
    }
    clear_has_message();
  }
}
inline ::protos::OffsideLineMessage* Say::release_offside_line_message() {
  // @@protoc_insertion_point(field_release:protos.Say.offside_line_message)
  if (message_case() == kOffsideLineMessage) {
    clear_has_message();
    ::protos::OffsideLineMessage* temp = _impl_.message_.offside_line_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.offside_line_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::OffsideLineMessage& Say::_internal_offside_line_message() const {
  return message_case() == kOffsideLineMessage
      ? *_impl_.message_.offside_line_message_
      : reinterpret_cast<::protos::OffsideLineMessage&>(::protos::_OffsideLineMessage_default_instance_);
}
inline const ::protos::OffsideLineMessage& Say::offside_line_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.offside_line_message)
  return _internal_offside_line_message();
}
inline ::protos::OffsideLineMessage* Say::unsafe_arena_release_offside_line_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.offside_line_message)
  if (message_case() == kOffsideLineMessage) {
    clear_has_message();
    ::protos::OffsideLineMessage* temp = _impl_.message_.offside_line_message_;
    _impl_.message_.offside_line_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_offside_line_message(::protos::OffsideLineMessage* offside_line_message) {
  clear_message();
  if (offside_line_message) {
    set_has_offside_line_message();
    _impl_.message_.offside_line_message_ = offside_line_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.offside_line_message)
}
inline ::protos::OffsideLineMessage* Say::_internal_mutable_offside_line_message() {
  if (message_case() != kOffsideLineMessage) {
    clear_message();
    set_has_offside_line_message();
    _impl_.message_.offside_line_message_ = CreateMaybeMessage< ::protos::OffsideLineMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.offside_line_message_;
}
inline ::protos::OffsideLineMessage* Say::mutable_offside_line_message() {
  ::protos::OffsideLineMessage* _msg = _internal_mutable_offside_line_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.offside_line_message)
  return _msg;
}

// .protos.DefenseLineMessage defense_line_message = 7;
inline bool Say::has_defense_line_message() const {
  return message_case() == kDefenseLineMessage;
}
inline bool Say::_internal_has_defense_line_message() const {
  return message_case() == kDefenseLineMessage;
}
inline void Say::set_has_defense_line_message() {
  _impl_._oneof_case_[0] = kDefenseLineMessage;
}
inline void Say::clear_defense_line_message() {
  if (message_case() == kDefenseLineMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.defense_line_message_;
    }
    clear_has_message();
  }
}
inline ::protos::DefenseLineMessage* Say::release_defense_line_message() {
  // @@protoc_insertion_point(field_release:protos.Say.defense_line_message)
  if (message_case() == kDefenseLineMessage) {
    clear_has_message();
    ::protos::DefenseLineMessage* temp = _impl_.message_.defense_line_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.defense_line_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::DefenseLineMessage& Say::_internal_defense_line_message() const {
  return message_case() == kDefenseLineMessage
      ? *_impl_.message_.defense_line_message_
      : reinterpret_cast<::protos::DefenseLineMessage&>(::protos::_DefenseLineMessage_default_instance_);
}
inline const ::protos::DefenseLineMessage& Say::defense_line_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.defense_line_message)
  return _internal_defense_line_message();
}
inline ::protos::DefenseLineMessage* Say::unsafe_arena_release_defense_line_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.defense_line_message)
  if (message_case() == kDefenseLineMessage) {
    clear_has_message();
    ::protos::DefenseLineMessage* temp = _impl_.message_.defense_line_message_;
    _impl_.message_.defense_line_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_defense_line_message(::protos::DefenseLineMessage* defense_line_message) {
  clear_message();
  if (defense_line_message) {
    set_has_defense_line_message();
    _impl_.message_.defense_line_message_ = defense_line_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.defense_line_message)
}
inline ::protos::DefenseLineMessage* Say::_internal_mutable_defense_line_message() {
  if (message_case() != kDefenseLineMessage) {
    clear_message();
    set_has_defense_line_message();
    _impl_.message_.defense_line_message_ = CreateMaybeMessage< ::protos::DefenseLineMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.defense_line_message_;
}
inline ::protos::DefenseLineMessage* Say::mutable_defense_line_message() {
  ::protos::DefenseLineMessage* _msg = _internal_mutable_defense_line_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.defense_line_message)
  return _msg;
}

// .protos.WaitRequestMessage wait_request_message = 8;
inline bool Say::has_wait_request_message() const {
  return message_case() == kWaitRequestMessage;
}
inline bool Say::_internal_has_wait_request_message() const {
  return message_case() == kWaitRequestMessage;
}
inline void Say::set_has_wait_request_message() {
  _impl_._oneof_case_[0] = kWaitRequestMessage;
}
inline void Say::clear_wait_request_message() {
  if (message_case() == kWaitRequestMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.wait_request_message_;
    }
    clear_has_message();
  }
}
inline ::protos::WaitRequestMessage* Say::release_wait_request_message() {
  // @@protoc_insertion_point(field_release:protos.Say.wait_request_message)
  if (message_case() == kWaitRequestMessage) {
    clear_has_message();
    ::protos::WaitRequestMessage* temp = _impl_.message_.wait_request_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.wait_request_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::WaitRequestMessage& Say::_internal_wait_request_message() const {
  return message_case() == kWaitRequestMessage
      ? *_impl_.message_.wait_request_message_
      : reinterpret_cast<::protos::WaitRequestMessage&>(::protos::_WaitRequestMessage_default_instance_);
}
inline const ::protos::WaitRequestMessage& Say::wait_request_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.wait_request_message)
  return _internal_wait_request_message();
}
inline ::protos::WaitRequestMessage* Say::unsafe_arena_release_wait_request_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.wait_request_message)
  if (message_case() == kWaitRequestMessage) {
    clear_has_message();
    ::protos::WaitRequestMessage* temp = _impl_.message_.wait_request_message_;
    _impl_.message_.wait_request_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_wait_request_message(::protos::WaitRequestMessage* wait_request_message) {
  clear_message();
  if (wait_request_message) {
    set_has_wait_request_message();
    _impl_.message_.wait_request_message_ = wait_request_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.wait_request_message)
}
inline ::protos::WaitRequestMessage* Say::_internal_mutable_wait_request_message() {
  if (message_case() != kWaitRequestMessage) {
    clear_message();
    set_has_wait_request_message();
    _impl_.message_.wait_request_message_ = CreateMaybeMessage< ::protos::WaitRequestMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.wait_request_message_;
}
inline ::protos::WaitRequestMessage* Say::mutable_wait_request_message() {
  ::protos::WaitRequestMessage* _msg = _internal_mutable_wait_request_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.wait_request_message)
  return _msg;
}

// .protos.SetplayMessage setplay_message = 9;
inline bool Say::has_setplay_message() const {
  return message_case() == kSetplayMessage;
}
inline bool Say::_internal_has_setplay_message() const {
  return message_case() == kSetplayMessage;
}
inline void Say::set_has_setplay_message() {
  _impl_._oneof_case_[0] = kSetplayMessage;
}
inline void Say::clear_setplay_message() {
  if (message_case() == kSetplayMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.setplay_message_;
    }
    clear_has_message();
  }
}
inline ::protos::SetplayMessage* Say::release_setplay_message() {
  // @@protoc_insertion_point(field_release:protos.Say.setplay_message)
  if (message_case() == kSetplayMessage) {
    clear_has_message();
    ::protos::SetplayMessage* temp = _impl_.message_.setplay_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.setplay_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::SetplayMessage& Say::_internal_setplay_message() const {
  return message_case() == kSetplayMessage
      ? *_impl_.message_.setplay_message_
      : reinterpret_cast<::protos::SetplayMessage&>(::protos::_SetplayMessage_default_instance_);
}
inline const ::protos::SetplayMessage& Say::setplay_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.setplay_message)
  return _internal_setplay_message();
}
inline ::protos::SetplayMessage* Say::unsafe_arena_release_setplay_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.setplay_message)
  if (message_case() == kSetplayMessage) {
    clear_has_message();
    ::protos::SetplayMessage* temp = _impl_.message_.setplay_message_;
    _impl_.message_.setplay_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_setplay_message(::protos::SetplayMessage* setplay_message) {
  clear_message();
  if (setplay_message) {
    set_has_setplay_message();
    _impl_.message_.setplay_message_ = setplay_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.setplay_message)
}
inline ::protos::SetplayMessage* Say::_internal_mutable_setplay_message() {
  if (message_case() != kSetplayMessage) {
    clear_message();
    set_has_setplay_message();
    _impl_.message_.setplay_message_ = CreateMaybeMessage< ::protos::SetplayMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.setplay_message_;
}
inline ::protos::SetplayMessage* Say::mutable_setplay_message() {
  ::protos::SetplayMessage* _msg = _internal_mutable_setplay_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.setplay_message)
  return _msg;
}

// .protos.PassRequestMessage pass_request_message = 10;
inline bool Say::has_pass_request_message() const {
  return message_case() == kPassRequestMessage;
}
inline bool Say::_internal_has_pass_request_message() const {
  return message_case() == kPassRequestMessage;
}
inline void Say::set_has_pass_request_message() {
  _impl_._oneof_case_[0] = kPassRequestMessage;
}
inline void Say::clear_pass_request_message() {
  if (message_case() == kPassRequestMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.pass_request_message_;
    }
    clear_has_message();
  }
}
inline ::protos::PassRequestMessage* Say::release_pass_request_message() {
  // @@protoc_insertion_point(field_release:protos.Say.pass_request_message)
  if (message_case() == kPassRequestMessage) {
    clear_has_message();
    ::protos::PassRequestMessage* temp = _impl_.message_.pass_request_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.pass_request_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::PassRequestMessage& Say::_internal_pass_request_message() const {
  return message_case() == kPassRequestMessage
      ? *_impl_.message_.pass_request_message_
      : reinterpret_cast<::protos::PassRequestMessage&>(::protos::_PassRequestMessage_default_instance_);
}
inline const ::protos::PassRequestMessage& Say::pass_request_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.pass_request_message)
  return _internal_pass_request_message();
}
inline ::protos::PassRequestMessage* Say::unsafe_arena_release_pass_request_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.pass_request_message)
  if (message_case() == kPassRequestMessage) {
    clear_has_message();
    ::protos::PassRequestMessage* temp = _impl_.message_.pass_request_message_;
    _impl_.message_.pass_request_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_pass_request_message(::protos::PassRequestMessage* pass_request_message) {
  clear_message();
  if (pass_request_message) {
    set_has_pass_request_message();
    _impl_.message_.pass_request_message_ = pass_request_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.pass_request_message)
}
inline ::protos::PassRequestMessage* Say::_internal_mutable_pass_request_message() {
  if (message_case() != kPassRequestMessage) {
    clear_message();
    set_has_pass_request_message();
    _impl_.message_.pass_request_message_ = CreateMaybeMessage< ::protos::PassRequestMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.pass_request_message_;
}
inline ::protos::PassRequestMessage* Say::mutable_pass_request_message() {
  ::protos::PassRequestMessage* _msg = _internal_mutable_pass_request_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.pass_request_message)
  return _msg;
}

// .protos.StaminaMessage stamina_message = 11;
inline bool Say::has_stamina_message() const {
  return message_case() == kStaminaMessage;
}
inline bool Say::_internal_has_stamina_message() const {
  return message_case() == kStaminaMessage;
}
inline void Say::set_has_stamina_message() {
  _impl_._oneof_case_[0] = kStaminaMessage;
}
inline void Say::clear_stamina_message() {
  if (message_case() == kStaminaMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.stamina_message_;
    }
    clear_has_message();
  }
}
inline ::protos::StaminaMessage* Say::release_stamina_message() {
  // @@protoc_insertion_point(field_release:protos.Say.stamina_message)
  if (message_case() == kStaminaMessage) {
    clear_has_message();
    ::protos::StaminaMessage* temp = _impl_.message_.stamina_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.stamina_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::StaminaMessage& Say::_internal_stamina_message() const {
  return message_case() == kStaminaMessage
      ? *_impl_.message_.stamina_message_
      : reinterpret_cast<::protos::StaminaMessage&>(::protos::_StaminaMessage_default_instance_);
}
inline const ::protos::StaminaMessage& Say::stamina_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.stamina_message)
  return _internal_stamina_message();
}
inline ::protos::StaminaMessage* Say::unsafe_arena_release_stamina_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.stamina_message)
  if (message_case() == kStaminaMessage) {
    clear_has_message();
    ::protos::StaminaMessage* temp = _impl_.message_.stamina_message_;
    _impl_.message_.stamina_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_stamina_message(::protos::StaminaMessage* stamina_message) {
  clear_message();
  if (stamina_message) {
    set_has_stamina_message();
    _impl_.message_.stamina_message_ = stamina_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.stamina_message)
}
inline ::protos::StaminaMessage* Say::_internal_mutable_stamina_message() {
  if (message_case() != kStaminaMessage) {
    clear_message();
    set_has_stamina_message();
    _impl_.message_.stamina_message_ = CreateMaybeMessage< ::protos::StaminaMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.stamina_message_;
}
inline ::protos::StaminaMessage* Say::mutable_stamina_message() {
  ::protos::StaminaMessage* _msg = _internal_mutable_stamina_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.stamina_message)
  return _msg;
}

// .protos.RecoveryMessage recovery_message = 12;
inline bool Say::has_recovery_message() const {
  return message_case() == kRecoveryMessage;
}
inline bool Say::_internal_has_recovery_message() const {
  return message_case() == kRecoveryMessage;
}
inline void Say::set_has_recovery_message() {
  _impl_._oneof_case_[0] = kRecoveryMessage;
}
inline void Say::clear_recovery_message() {
  if (message_case() == kRecoveryMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.recovery_message_;
    }
    clear_has_message();
  }
}
inline ::protos::RecoveryMessage* Say::release_recovery_message() {
  // @@protoc_insertion_point(field_release:protos.Say.recovery_message)
  if (message_case() == kRecoveryMessage) {
    clear_has_message();
    ::protos::RecoveryMessage* temp = _impl_.message_.recovery_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.recovery_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::RecoveryMessage& Say::_internal_recovery_message() const {
  return message_case() == kRecoveryMessage
      ? *_impl_.message_.recovery_message_
      : reinterpret_cast<::protos::RecoveryMessage&>(::protos::_RecoveryMessage_default_instance_);
}
inline const ::protos::RecoveryMessage& Say::recovery_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.recovery_message)
  return _internal_recovery_message();
}
inline ::protos::RecoveryMessage* Say::unsafe_arena_release_recovery_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.recovery_message)
  if (message_case() == kRecoveryMessage) {
    clear_has_message();
    ::protos::RecoveryMessage* temp = _impl_.message_.recovery_message_;
    _impl_.message_.recovery_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_recovery_message(::protos::RecoveryMessage* recovery_message) {
  clear_message();
  if (recovery_message) {
    set_has_recovery_message();
    _impl_.message_.recovery_message_ = recovery_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.recovery_message)
}
inline ::protos::RecoveryMessage* Say::_internal_mutable_recovery_message() {
  if (message_case() != kRecoveryMessage) {
    clear_message();
    set_has_recovery_message();
    _impl_.message_.recovery_message_ = CreateMaybeMessage< ::protos::RecoveryMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.recovery_message_;
}
inline ::protos::RecoveryMessage* Say::mutable_recovery_message() {
  ::protos::RecoveryMessage* _msg = _internal_mutable_recovery_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.recovery_message)
  return _msg;
}

// .protos.StaminaCapacityMessage stamina_capacity_message = 13;
inline bool Say::has_stamina_capacity_message() const {
  return message_case() == kStaminaCapacityMessage;
}
inline bool Say::_internal_has_stamina_capacity_message() const {
  return message_case() == kStaminaCapacityMessage;
}
inline void Say::set_has_stamina_capacity_message() {
  _impl_._oneof_case_[0] = kStaminaCapacityMessage;
}
inline void Say::clear_stamina_capacity_message() {
  if (message_case() == kStaminaCapacityMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.stamina_capacity_message_;
    }
    clear_has_message();
  }
}
inline ::protos::StaminaCapacityMessage* Say::release_stamina_capacity_message() {
  // @@protoc_insertion_point(field_release:protos.Say.stamina_capacity_message)
  if (message_case() == kStaminaCapacityMessage) {
    clear_has_message();
    ::protos::StaminaCapacityMessage* temp = _impl_.message_.stamina_capacity_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.stamina_capacity_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::StaminaCapacityMessage& Say::_internal_stamina_capacity_message() const {
  return message_case() == kStaminaCapacityMessage
      ? *_impl_.message_.stamina_capacity_message_
      : reinterpret_cast<::protos::StaminaCapacityMessage&>(::protos::_StaminaCapacityMessage_default_instance_);
}
inline const ::protos::StaminaCapacityMessage& Say::stamina_capacity_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.stamina_capacity_message)
  return _internal_stamina_capacity_message();
}
inline ::protos::StaminaCapacityMessage* Say::unsafe_arena_release_stamina_capacity_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.stamina_capacity_message)
  if (message_case() == kStaminaCapacityMessage) {
    clear_has_message();
    ::protos::StaminaCapacityMessage* temp = _impl_.message_.stamina_capacity_message_;
    _impl_.message_.stamina_capacity_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_stamina_capacity_message(::protos::StaminaCapacityMessage* stamina_capacity_message) {
  clear_message();
  if (stamina_capacity_message) {
    set_has_stamina_capacity_message();
    _impl_.message_.stamina_capacity_message_ = stamina_capacity_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.stamina_capacity_message)
}
inline ::protos::StaminaCapacityMessage* Say::_internal_mutable_stamina_capacity_message() {
  if (message_case() != kStaminaCapacityMessage) {
    clear_message();
    set_has_stamina_capacity_message();
    _impl_.message_.stamina_capacity_message_ = CreateMaybeMessage< ::protos::StaminaCapacityMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.stamina_capacity_message_;
}
inline ::protos::StaminaCapacityMessage* Say::mutable_stamina_capacity_message() {
  ::protos::StaminaCapacityMessage* _msg = _internal_mutable_stamina_capacity_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.stamina_capacity_message)
  return _msg;
}

// .protos.DribbleMessage dribble_message = 14;
inline bool Say::has_dribble_message() const {
  return message_case() == kDribbleMessage;
}
inline bool Say::_internal_has_dribble_message() const {
  return message_case() == kDribbleMessage;
}
inline void Say::set_has_dribble_message() {
  _impl_._oneof_case_[0] = kDribbleMessage;
}
inline void Say::clear_dribble_message() {
  if (message_case() == kDribbleMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.dribble_message_;
    }
    clear_has_message();
  }
}
inline ::protos::DribbleMessage* Say::release_dribble_message() {
  // @@protoc_insertion_point(field_release:protos.Say.dribble_message)
  if (message_case() == kDribbleMessage) {
    clear_has_message();
    ::protos::DribbleMessage* temp = _impl_.message_.dribble_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.dribble_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::DribbleMessage& Say::_internal_dribble_message() const {
  return message_case() == kDribbleMessage
      ? *_impl_.message_.dribble_message_
      : reinterpret_cast<::protos::DribbleMessage&>(::protos::_DribbleMessage_default_instance_);
}
inline const ::protos::DribbleMessage& Say::dribble_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.dribble_message)
  return _internal_dribble_message();
}
inline ::protos::DribbleMessage* Say::unsafe_arena_release_dribble_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.dribble_message)
  if (message_case() == kDribbleMessage) {
    clear_has_message();
    ::protos::DribbleMessage* temp = _impl_.message_.dribble_message_;
    _impl_.message_.dribble_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_dribble_message(::protos::DribbleMessage* dribble_message) {
  clear_message();
  if (dribble_message) {
    set_has_dribble_message();
    _impl_.message_.dribble_message_ = dribble_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.dribble_message)
}
inline ::protos::DribbleMessage* Say::_internal_mutable_dribble_message() {
  if (message_case() != kDribbleMessage) {
    clear_message();
    set_has_dribble_message();
    _impl_.message_.dribble_message_ = CreateMaybeMessage< ::protos::DribbleMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.dribble_message_;
}
inline ::protos::DribbleMessage* Say::mutable_dribble_message() {
  ::protos::DribbleMessage* _msg = _internal_mutable_dribble_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.dribble_message)
  return _msg;
}

// .protos.BallGoalieMessage ball_goalie_message = 15;
inline bool Say::has_ball_goalie_message() const {
  return message_case() == kBallGoalieMessage;
}
inline bool Say::_internal_has_ball_goalie_message() const {
  return message_case() == kBallGoalieMessage;
}
inline void Say::set_has_ball_goalie_message() {
  _impl_._oneof_case_[0] = kBallGoalieMessage;
}
inline void Say::clear_ball_goalie_message() {
  if (message_case() == kBallGoalieMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.ball_goalie_message_;
    }
    clear_has_message();
  }
}
inline ::protos::BallGoalieMessage* Say::release_ball_goalie_message() {
  // @@protoc_insertion_point(field_release:protos.Say.ball_goalie_message)
  if (message_case() == kBallGoalieMessage) {
    clear_has_message();
    ::protos::BallGoalieMessage* temp = _impl_.message_.ball_goalie_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.ball_goalie_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::BallGoalieMessage& Say::_internal_ball_goalie_message() const {
  return message_case() == kBallGoalieMessage
      ? *_impl_.message_.ball_goalie_message_
      : reinterpret_cast<::protos::BallGoalieMessage&>(::protos::_BallGoalieMessage_default_instance_);
}
inline const ::protos::BallGoalieMessage& Say::ball_goalie_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.ball_goalie_message)
  return _internal_ball_goalie_message();
}
inline ::protos::BallGoalieMessage* Say::unsafe_arena_release_ball_goalie_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.ball_goalie_message)
  if (message_case() == kBallGoalieMessage) {
    clear_has_message();
    ::protos::BallGoalieMessage* temp = _impl_.message_.ball_goalie_message_;
    _impl_.message_.ball_goalie_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_ball_goalie_message(::protos::BallGoalieMessage* ball_goalie_message) {
  clear_message();
  if (ball_goalie_message) {
    set_has_ball_goalie_message();
    _impl_.message_.ball_goalie_message_ = ball_goalie_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.ball_goalie_message)
}
inline ::protos::BallGoalieMessage* Say::_internal_mutable_ball_goalie_message() {
  if (message_case() != kBallGoalieMessage) {
    clear_message();
    set_has_ball_goalie_message();
    _impl_.message_.ball_goalie_message_ = CreateMaybeMessage< ::protos::BallGoalieMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.ball_goalie_message_;
}
inline ::protos::BallGoalieMessage* Say::mutable_ball_goalie_message() {
  ::protos::BallGoalieMessage* _msg = _internal_mutable_ball_goalie_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.ball_goalie_message)
  return _msg;
}

// .protos.OnePlayerMessage one_player_message = 16;
inline bool Say::has_one_player_message() const {
  return message_case() == kOnePlayerMessage;
}
inline bool Say::_internal_has_one_player_message() const {
  return message_case() == kOnePlayerMessage;
}
inline void Say::set_has_one_player_message() {
  _impl_._oneof_case_[0] = kOnePlayerMessage;
}
inline void Say::clear_one_player_message() {
  if (message_case() == kOnePlayerMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.one_player_message_;
    }
    clear_has_message();
  }
}
inline ::protos::OnePlayerMessage* Say::release_one_player_message() {
  // @@protoc_insertion_point(field_release:protos.Say.one_player_message)
  if (message_case() == kOnePlayerMessage) {
    clear_has_message();
    ::protos::OnePlayerMessage* temp = _impl_.message_.one_player_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.one_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::OnePlayerMessage& Say::_internal_one_player_message() const {
  return message_case() == kOnePlayerMessage
      ? *_impl_.message_.one_player_message_
      : reinterpret_cast<::protos::OnePlayerMessage&>(::protos::_OnePlayerMessage_default_instance_);
}
inline const ::protos::OnePlayerMessage& Say::one_player_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.one_player_message)
  return _internal_one_player_message();
}
inline ::protos::OnePlayerMessage* Say::unsafe_arena_release_one_player_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.one_player_message)
  if (message_case() == kOnePlayerMessage) {
    clear_has_message();
    ::protos::OnePlayerMessage* temp = _impl_.message_.one_player_message_;
    _impl_.message_.one_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_one_player_message(::protos::OnePlayerMessage* one_player_message) {
  clear_message();
  if (one_player_message) {
    set_has_one_player_message();
    _impl_.message_.one_player_message_ = one_player_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.one_player_message)
}
inline ::protos::OnePlayerMessage* Say::_internal_mutable_one_player_message() {
  if (message_case() != kOnePlayerMessage) {
    clear_message();
    set_has_one_player_message();
    _impl_.message_.one_player_message_ = CreateMaybeMessage< ::protos::OnePlayerMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.one_player_message_;
}
inline ::protos::OnePlayerMessage* Say::mutable_one_player_message() {
  ::protos::OnePlayerMessage* _msg = _internal_mutable_one_player_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.one_player_message)
  return _msg;
}

// .protos.TwoPlayerMessage two_player_message = 17;
inline bool Say::has_two_player_message() const {
  return message_case() == kTwoPlayerMessage;
}
inline bool Say::_internal_has_two_player_message() const {
  return message_case() == kTwoPlayerMessage;
}
inline void Say::set_has_two_player_message() {
  _impl_._oneof_case_[0] = kTwoPlayerMessage;
}
inline void Say::clear_two_player_message() {
  if (message_case() == kTwoPlayerMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.two_player_message_;
    }
    clear_has_message();
  }
}
inline ::protos::TwoPlayerMessage* Say::release_two_player_message() {
  // @@protoc_insertion_point(field_release:protos.Say.two_player_message)
  if (message_case() == kTwoPlayerMessage) {
    clear_has_message();
    ::protos::TwoPlayerMessage* temp = _impl_.message_.two_player_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.two_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::TwoPlayerMessage& Say::_internal_two_player_message() const {
  return message_case() == kTwoPlayerMessage
      ? *_impl_.message_.two_player_message_
      : reinterpret_cast<::protos::TwoPlayerMessage&>(::protos::_TwoPlayerMessage_default_instance_);
}
inline const ::protos::TwoPlayerMessage& Say::two_player_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.two_player_message)
  return _internal_two_player_message();
}
inline ::protos::TwoPlayerMessage* Say::unsafe_arena_release_two_player_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.two_player_message)
  if (message_case() == kTwoPlayerMessage) {
    clear_has_message();
    ::protos::TwoPlayerMessage* temp = _impl_.message_.two_player_message_;
    _impl_.message_.two_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_two_player_message(::protos::TwoPlayerMessage* two_player_message) {
  clear_message();
  if (two_player_message) {
    set_has_two_player_message();
    _impl_.message_.two_player_message_ = two_player_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.two_player_message)
}
inline ::protos::TwoPlayerMessage* Say::_internal_mutable_two_player_message() {
  if (message_case() != kTwoPlayerMessage) {
    clear_message();
    set_has_two_player_message();
    _impl_.message_.two_player_message_ = CreateMaybeMessage< ::protos::TwoPlayerMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.two_player_message_;
}
inline ::protos::TwoPlayerMessage* Say::mutable_two_player_message() {
  ::protos::TwoPlayerMessage* _msg = _internal_mutable_two_player_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.two_player_message)
  return _msg;
}

// .protos.ThreePlayerMessage three_player_message = 18;
inline bool Say::has_three_player_message() const {
  return message_case() == kThreePlayerMessage;
}
inline bool Say::_internal_has_three_player_message() const {
  return message_case() == kThreePlayerMessage;
}
inline void Say::set_has_three_player_message() {
  _impl_._oneof_case_[0] = kThreePlayerMessage;
}
inline void Say::clear_three_player_message() {
  if (message_case() == kThreePlayerMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.three_player_message_;
    }
    clear_has_message();
  }
}
inline ::protos::ThreePlayerMessage* Say::release_three_player_message() {
  // @@protoc_insertion_point(field_release:protos.Say.three_player_message)
  if (message_case() == kThreePlayerMessage) {
    clear_has_message();
    ::protos::ThreePlayerMessage* temp = _impl_.message_.three_player_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.three_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::ThreePlayerMessage& Say::_internal_three_player_message() const {
  return message_case() == kThreePlayerMessage
      ? *_impl_.message_.three_player_message_
      : reinterpret_cast<::protos::ThreePlayerMessage&>(::protos::_ThreePlayerMessage_default_instance_);
}
inline const ::protos::ThreePlayerMessage& Say::three_player_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.three_player_message)
  return _internal_three_player_message();
}
inline ::protos::ThreePlayerMessage* Say::unsafe_arena_release_three_player_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.three_player_message)
  if (message_case() == kThreePlayerMessage) {
    clear_has_message();
    ::protos::ThreePlayerMessage* temp = _impl_.message_.three_player_message_;
    _impl_.message_.three_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_three_player_message(::protos::ThreePlayerMessage* three_player_message) {
  clear_message();
  if (three_player_message) {
    set_has_three_player_message();
    _impl_.message_.three_player_message_ = three_player_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.three_player_message)
}
inline ::protos::ThreePlayerMessage* Say::_internal_mutable_three_player_message() {
  if (message_case() != kThreePlayerMessage) {
    clear_message();
    set_has_three_player_message();
    _impl_.message_.three_player_message_ = CreateMaybeMessage< ::protos::ThreePlayerMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.three_player_message_;
}
inline ::protos::ThreePlayerMessage* Say::mutable_three_player_message() {
  ::protos::ThreePlayerMessage* _msg = _internal_mutable_three_player_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.three_player_message)
  return _msg;
}

// .protos.SelfMessage self_message = 19;
inline bool Say::has_self_message() const {
  return message_case() == kSelfMessage;
}
inline bool Say::_internal_has_self_message() const {
  return message_case() == kSelfMessage;
}
inline void Say::set_has_self_message() {
  _impl_._oneof_case_[0] = kSelfMessage;
}
inline void Say::clear_self_message() {
  if (message_case() == kSelfMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.self_message_;
    }
    clear_has_message();
  }
}
inline ::protos::SelfMessage* Say::release_self_message() {
  // @@protoc_insertion_point(field_release:protos.Say.self_message)
  if (message_case() == kSelfMessage) {
    clear_has_message();
    ::protos::SelfMessage* temp = _impl_.message_.self_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.self_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::SelfMessage& Say::_internal_self_message() const {
  return message_case() == kSelfMessage
      ? *_impl_.message_.self_message_
      : reinterpret_cast<::protos::SelfMessage&>(::protos::_SelfMessage_default_instance_);
}
inline const ::protos::SelfMessage& Say::self_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.self_message)
  return _internal_self_message();
}
inline ::protos::SelfMessage* Say::unsafe_arena_release_self_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.self_message)
  if (message_case() == kSelfMessage) {
    clear_has_message();
    ::protos::SelfMessage* temp = _impl_.message_.self_message_;
    _impl_.message_.self_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_self_message(::protos::SelfMessage* self_message) {
  clear_message();
  if (self_message) {
    set_has_self_message();
    _impl_.message_.self_message_ = self_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.self_message)
}
inline ::protos::SelfMessage* Say::_internal_mutable_self_message() {
  if (message_case() != kSelfMessage) {
    clear_message();
    set_has_self_message();
    _impl_.message_.self_message_ = CreateMaybeMessage< ::protos::SelfMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.self_message_;
}
inline ::protos::SelfMessage* Say::mutable_self_message() {
  ::protos::SelfMessage* _msg = _internal_mutable_self_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.self_message)
  return _msg;
}

// .protos.TeammateMessage teammate_message = 20;
inline bool Say::has_teammate_message() const {
  return message_case() == kTeammateMessage;
}
inline bool Say::_internal_has_teammate_message() const {
  return message_case() == kTeammateMessage;
}
inline void Say::set_has_teammate_message() {
  _impl_._oneof_case_[0] = kTeammateMessage;
}
inline void Say::clear_teammate_message() {
  if (message_case() == kTeammateMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.teammate_message_;
    }
    clear_has_message();
  }
}
inline ::protos::TeammateMessage* Say::release_teammate_message() {
  // @@protoc_insertion_point(field_release:protos.Say.teammate_message)
  if (message_case() == kTeammateMessage) {
    clear_has_message();
    ::protos::TeammateMessage* temp = _impl_.message_.teammate_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.teammate_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::TeammateMessage& Say::_internal_teammate_message() const {
  return message_case() == kTeammateMessage
      ? *_impl_.message_.teammate_message_
      : reinterpret_cast<::protos::TeammateMessage&>(::protos::_TeammateMessage_default_instance_);
}
inline const ::protos::TeammateMessage& Say::teammate_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.teammate_message)
  return _internal_teammate_message();
}
inline ::protos::TeammateMessage* Say::unsafe_arena_release_teammate_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.teammate_message)
  if (message_case() == kTeammateMessage) {
    clear_has_message();
    ::protos::TeammateMessage* temp = _impl_.message_.teammate_message_;
    _impl_.message_.teammate_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_teammate_message(::protos::TeammateMessage* teammate_message) {
  clear_message();
  if (teammate_message) {
    set_has_teammate_message();
    _impl_.message_.teammate_message_ = teammate_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.teammate_message)
}
inline ::protos::TeammateMessage* Say::_internal_mutable_teammate_message() {
  if (message_case() != kTeammateMessage) {
    clear_message();
    set_has_teammate_message();
    _impl_.message_.teammate_message_ = CreateMaybeMessage< ::protos::TeammateMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.teammate_message_;
}
inline ::protos::TeammateMessage* Say::mutable_teammate_message() {
  ::protos::TeammateMessage* _msg = _internal_mutable_teammate_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.teammate_message)
  return _msg;
}

// .protos.OpponentMessage opponent_message = 21;
inline bool Say::has_opponent_message() const {
  return message_case() == kOpponentMessage;
}
inline bool Say::_internal_has_opponent_message() const {
  return message_case() == kOpponentMessage;
}
inline void Say::set_has_opponent_message() {
  _impl_._oneof_case_[0] = kOpponentMessage;
}
inline void Say::clear_opponent_message() {
  if (message_case() == kOpponentMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.opponent_message_;
    }
    clear_has_message();
  }
}
inline ::protos::OpponentMessage* Say::release_opponent_message() {
  // @@protoc_insertion_point(field_release:protos.Say.opponent_message)
  if (message_case() == kOpponentMessage) {
    clear_has_message();
    ::protos::OpponentMessage* temp = _impl_.message_.opponent_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.opponent_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::OpponentMessage& Say::_internal_opponent_message() const {
  return message_case() == kOpponentMessage
      ? *_impl_.message_.opponent_message_
      : reinterpret_cast<::protos::OpponentMessage&>(::protos::_OpponentMessage_default_instance_);
}
inline const ::protos::OpponentMessage& Say::opponent_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.opponent_message)
  return _internal_opponent_message();
}
inline ::protos::OpponentMessage* Say::unsafe_arena_release_opponent_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.opponent_message)
  if (message_case() == kOpponentMessage) {
    clear_has_message();
    ::protos::OpponentMessage* temp = _impl_.message_.opponent_message_;
    _impl_.message_.opponent_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_opponent_message(::protos::OpponentMessage* opponent_message) {
  clear_message();
  if (opponent_message) {
    set_has_opponent_message();
    _impl_.message_.opponent_message_ = opponent_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.opponent_message)
}
inline ::protos::OpponentMessage* Say::_internal_mutable_opponent_message() {
  if (message_case() != kOpponentMessage) {
    clear_message();
    set_has_opponent_message();
    _impl_.message_.opponent_message_ = CreateMaybeMessage< ::protos::OpponentMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.opponent_message_;
}
inline ::protos::OpponentMessage* Say::mutable_opponent_message() {
  ::protos::OpponentMessage* _msg = _internal_mutable_opponent_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.opponent_message)
  return _msg;
}

// .protos.BallPlayerMessage ball_player_message = 22;
inline bool Say::has_ball_player_message() const {
  return message_case() == kBallPlayerMessage;
}
inline bool Say::_internal_has_ball_player_message() const {
  return message_case() == kBallPlayerMessage;
}
inline void Say::set_has_ball_player_message() {
  _impl_._oneof_case_[0] = kBallPlayerMessage;
}
inline void Say::clear_ball_player_message() {
  if (message_case() == kBallPlayerMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.ball_player_message_;
    }
    clear_has_message();
  }
}
inline ::protos::BallPlayerMessage* Say::release_ball_player_message() {
  // @@protoc_insertion_point(field_release:protos.Say.ball_player_message)
  if (message_case() == kBallPlayerMessage) {
    clear_has_message();
    ::protos::BallPlayerMessage* temp = _impl_.message_.ball_player_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.ball_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::BallPlayerMessage& Say::_internal_ball_player_message() const {
  return message_case() == kBallPlayerMessage
      ? *_impl_.message_.ball_player_message_
      : reinterpret_cast<::protos::BallPlayerMessage&>(::protos::_BallPlayerMessage_default_instance_);
}
inline const ::protos::BallPlayerMessage& Say::ball_player_message() const {
  // @@protoc_insertion_point(field_get:protos.Say.ball_player_message)
  return _internal_ball_player_message();
}
inline ::protos::BallPlayerMessage* Say::unsafe_arena_release_ball_player_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.ball_player_message)
  if (message_case() == kBallPlayerMessage) {
    clear_has_message();
    ::protos::BallPlayerMessage* temp = _impl_.message_.ball_player_message_;
    _impl_.message_.ball_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_ball_player_message(::protos::BallPlayerMessage* ball_player_message) {
  clear_message();
  if (ball_player_message) {
    set_has_ball_player_message();
    _impl_.message_.ball_player_message_ = ball_player_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.ball_player_message)
}
inline ::protos::BallPlayerMessage* Say::_internal_mutable_ball_player_message() {
  if (message_case() != kBallPlayerMessage) {
    clear_message();
    set_has_ball_player_message();
    _impl_.message_.ball_player_message_ = CreateMaybeMessage< ::protos::BallPlayerMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.ball_player_message_;
}
inline ::protos::BallPlayerMessage* Say::mutable_ball_player_message() {
  ::protos::BallPlayerMessage* _msg = _internal_mutable_ball_player_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.ball_player_message)
  return _msg;
}

inline bool Say::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void Say::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline Say::MessageCase Say::message_case() const {
  return Say::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PointTo

// float x = 1;
inline void PointTo::clear_x() {
  _impl_.x_ = 0;
}
inline float PointTo::x() const {
  // @@protoc_insertion_point(field_get:protos.PointTo.x)
  return _internal_x();
}
inline void PointTo::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:protos.PointTo.x)
}
inline float PointTo::_internal_x() const {
  return _impl_.x_;
}
inline void PointTo::_internal_set_x(float value) {
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void PointTo::clear_y() {
  _impl_.y_ = 0;
}
inline float PointTo::y() const {
  // @@protoc_insertion_point(field_get:protos.PointTo.y)
  return _internal_y();
}
inline void PointTo::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:protos.PointTo.y)
}
inline float PointTo::_internal_y() const {
  return _impl_.y_;
}
inline void PointTo::_internal_set_y(float value) {
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// PointToOf

// -------------------------------------------------------------------

// AttentionTo

// .protos.Side side = 1;
inline void AttentionTo::clear_side() {
  _impl_.side_ = 0;
}
inline ::protos::Side AttentionTo::side() const {
  // @@protoc_insertion_point(field_get:protos.AttentionTo.side)
  return _internal_side();
}
inline void AttentionTo::set_side(::protos::Side value) {
   _internal_set_side(value);
  // @@protoc_insertion_point(field_set:protos.AttentionTo.side)
}
inline ::protos::Side AttentionTo::_internal_side() const {
  return static_cast<::protos::Side>(_impl_.side_);
}
inline void AttentionTo::_internal_set_side(::protos::Side value) {
  ;
  _impl_.side_ = value;
}

// int32 unum = 2;
inline void AttentionTo::clear_unum() {
  _impl_.unum_ = 0;
}
inline ::int32_t AttentionTo::unum() const {
  // @@protoc_insertion_point(field_get:protos.AttentionTo.unum)
  return _internal_unum();
}
inline void AttentionTo::set_unum(::int32_t value) {
  _internal_set_unum(value);
  // @@protoc_insertion_point(field_set:protos.AttentionTo.unum)
}
inline ::int32_t AttentionTo::_internal_unum() const {
  return _impl_.unum_;
}
inline void AttentionTo::_internal_set_unum(::int32_t value) {
  ;
  _impl_.unum_ = value;
}

// -------------------------------------------------------------------

// AttentionToOf

// -------------------------------------------------------------------

// AddText

// .protos.LoggerLevel level = 1;
inline void AddText::clear_level() {
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddText::level() const {
  // @@protoc_insertion_point(field_get:protos.AddText.level)
  return _internal_level();
}
inline void AddText::set_level(::protos::LoggerLevel value) {
   _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddText.level)
}
inline ::protos::LoggerLevel AddText::_internal_level() const {
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddText::_internal_set_level(::protos::LoggerLevel value) {
  ;
  _impl_.level_ = value;
}

// string message = 2;
inline void AddText::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& AddText::message() const {
  // @@protoc_insertion_point(field_get:protos.AddText.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddText::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.AddText.message)
}
inline std::string* AddText::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:protos.AddText.message)
  return _s;
}
inline const std::string& AddText::_internal_message() const {
  return _impl_.message_.Get();
}
inline void AddText::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* AddText::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* AddText::release_message() {
  // @@protoc_insertion_point(field_release:protos.AddText.message)
  return _impl_.message_.Release();
}
inline void AddText::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddText.message)
}

// -------------------------------------------------------------------

// AddPoint

// .protos.LoggerLevel level = 1;
inline void AddPoint::clear_level() {
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddPoint::level() const {
  // @@protoc_insertion_point(field_get:protos.AddPoint.level)
  return _internal_level();
}
inline void AddPoint::set_level(::protos::LoggerLevel value) {
   _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddPoint.level)
}
inline ::protos::LoggerLevel AddPoint::_internal_level() const {
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddPoint::_internal_set_level(::protos::LoggerLevel value) {
  ;
  _impl_.level_ = value;
}

// .protos.Vector2D point = 2;
inline bool AddPoint::has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline void AddPoint::clear_point() {
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& AddPoint::_internal_point() const {
  const ::protos::Vector2D* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddPoint::point() const {
  // @@protoc_insertion_point(field_get:protos.AddPoint.point)
  return _internal_point();
}
inline void AddPoint::unsafe_arena_set_allocated_point(
    ::protos::Vector2D* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddPoint.point)
}
inline ::protos::Vector2D* AddPoint::release_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* AddPoint::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:protos.AddPoint.point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddPoint::_internal_mutable_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::protos::Vector2D* AddPoint::mutable_point() {
  ::protos::Vector2D* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:protos.AddPoint.point)
  return _msg;
}
inline void AddPoint::set_allocated_point(::protos::Vector2D* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:protos.AddPoint.point)
}

// string color = 3;
inline void AddPoint::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AddPoint::color() const {
  // @@protoc_insertion_point(field_get:protos.AddPoint.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddPoint::set_color(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.AddPoint.color)
}
inline std::string* AddPoint::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:protos.AddPoint.color)
  return _s;
}
inline const std::string& AddPoint::_internal_color() const {
  return _impl_.color_.Get();
}
inline void AddPoint::_internal_set_color(const std::string& value) {
  ;


  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* AddPoint::_internal_mutable_color() {
  ;
  return _impl_.color_.Mutable( GetArenaForAllocation());
}
inline std::string* AddPoint::release_color() {
  // @@protoc_insertion_point(field_release:protos.AddPoint.color)
  return _impl_.color_.Release();
}
inline void AddPoint::set_allocated_color(std::string* value) {
  _impl_.color_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_.IsDefault()) {
          _impl_.color_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddPoint.color)
}

// -------------------------------------------------------------------

// AddLine

// .protos.LoggerLevel level = 1;
inline void AddLine::clear_level() {
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddLine::level() const {
  // @@protoc_insertion_point(field_get:protos.AddLine.level)
  return _internal_level();
}
inline void AddLine::set_level(::protos::LoggerLevel value) {
   _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddLine.level)
}
inline ::protos::LoggerLevel AddLine::_internal_level() const {
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddLine::_internal_set_level(::protos::LoggerLevel value) {
  ;
  _impl_.level_ = value;
}

// .protos.Vector2D start = 2;
inline bool AddLine::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_ != nullptr);
  return value;
}
inline void AddLine::clear_start() {
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& AddLine::_internal_start() const {
  const ::protos::Vector2D* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddLine::start() const {
  // @@protoc_insertion_point(field_get:protos.AddLine.start)
  return _internal_start();
}
inline void AddLine::unsafe_arena_set_allocated_start(
    ::protos::Vector2D* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = start;
  if (start) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddLine.start)
}
inline ::protos::Vector2D* AddLine::release_start() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.start_;
  _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* AddLine::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:protos.AddLine.start)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddLine::_internal_mutable_start() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.start_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.start_ = p;
  }
  return _impl_.start_;
}
inline ::protos::Vector2D* AddLine::mutable_start() {
  ::protos::Vector2D* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:protos.AddLine.start)
  return _msg;
}
inline void AddLine::set_allocated_start(::protos::Vector2D* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.start_;
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(start);
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.start_ = start;
  // @@protoc_insertion_point(field_set_allocated:protos.AddLine.start)
}

// .protos.Vector2D end = 3;
inline bool AddLine::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_ != nullptr);
  return value;
}
inline void AddLine::clear_end() {
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& AddLine::_internal_end() const {
  const ::protos::Vector2D* p = _impl_.end_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddLine::end() const {
  // @@protoc_insertion_point(field_get:protos.AddLine.end)
  return _internal_end();
}
inline void AddLine::unsafe_arena_set_allocated_end(
    ::protos::Vector2D* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_);
  }
  _impl_.end_ = end;
  if (end) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddLine.end)
}
inline ::protos::Vector2D* AddLine::release_end() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.end_;
  _impl_.end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* AddLine::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:protos.AddLine.end)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.end_;
  _impl_.end_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddLine::_internal_mutable_end() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.end_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.end_ = p;
  }
  return _impl_.end_;
}
inline ::protos::Vector2D* AddLine::mutable_end() {
  ::protos::Vector2D* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:protos.AddLine.end)
  return _msg;
}
inline void AddLine::set_allocated_end(::protos::Vector2D* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.end_ = end;
  // @@protoc_insertion_point(field_set_allocated:protos.AddLine.end)
}

// string color = 4;
inline void AddLine::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AddLine::color() const {
  // @@protoc_insertion_point(field_get:protos.AddLine.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddLine::set_color(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.AddLine.color)
}
inline std::string* AddLine::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:protos.AddLine.color)
  return _s;
}
inline const std::string& AddLine::_internal_color() const {
  return _impl_.color_.Get();
}
inline void AddLine::_internal_set_color(const std::string& value) {
  ;


  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* AddLine::_internal_mutable_color() {
  ;
  return _impl_.color_.Mutable( GetArenaForAllocation());
}
inline std::string* AddLine::release_color() {
  // @@protoc_insertion_point(field_release:protos.AddLine.color)
  return _impl_.color_.Release();
}
inline void AddLine::set_allocated_color(std::string* value) {
  _impl_.color_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_.IsDefault()) {
          _impl_.color_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddLine.color)
}

// -------------------------------------------------------------------

// AddArc

// .protos.LoggerLevel level = 1;
inline void AddArc::clear_level() {
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddArc::level() const {
  // @@protoc_insertion_point(field_get:protos.AddArc.level)
  return _internal_level();
}
inline void AddArc::set_level(::protos::LoggerLevel value) {
   _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddArc.level)
}
inline ::protos::LoggerLevel AddArc::_internal_level() const {
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddArc::_internal_set_level(::protos::LoggerLevel value) {
  ;
  _impl_.level_ = value;
}

// .protos.Vector2D center = 2;
inline bool AddArc::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline void AddArc::clear_center() {
  if (_impl_.center_ != nullptr) _impl_.center_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& AddArc::_internal_center() const {
  const ::protos::Vector2D* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddArc::center() const {
  // @@protoc_insertion_point(field_get:protos.AddArc.center)
  return _internal_center();
}
inline void AddArc::unsafe_arena_set_allocated_center(
    ::protos::Vector2D* center) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = center;
  if (center) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddArc.center)
}
inline ::protos::Vector2D* AddArc::release_center() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* AddArc::unsafe_arena_release_center() {
  // @@protoc_insertion_point(field_release:protos.AddArc.center)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddArc::_internal_mutable_center() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.center_ = p;
  }
  return _impl_.center_;
}
inline ::protos::Vector2D* AddArc::mutable_center() {
  ::protos::Vector2D* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:protos.AddArc.center)
  return _msg;
}
inline void AddArc::set_allocated_center(::protos::Vector2D* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(center);
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.center_ = center;
  // @@protoc_insertion_point(field_set_allocated:protos.AddArc.center)
}

// float radius = 3;
inline void AddArc::clear_radius() {
  _impl_.radius_ = 0;
}
inline float AddArc::radius() const {
  // @@protoc_insertion_point(field_get:protos.AddArc.radius)
  return _internal_radius();
}
inline void AddArc::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:protos.AddArc.radius)
}
inline float AddArc::_internal_radius() const {
  return _impl_.radius_;
}
inline void AddArc::_internal_set_radius(float value) {
  ;
  _impl_.radius_ = value;
}

// float start_angle = 4;
inline void AddArc::clear_start_angle() {
  _impl_.start_angle_ = 0;
}
inline float AddArc::start_angle() const {
  // @@protoc_insertion_point(field_get:protos.AddArc.start_angle)
  return _internal_start_angle();
}
inline void AddArc::set_start_angle(float value) {
  _internal_set_start_angle(value);
  // @@protoc_insertion_point(field_set:protos.AddArc.start_angle)
}
inline float AddArc::_internal_start_angle() const {
  return _impl_.start_angle_;
}
inline void AddArc::_internal_set_start_angle(float value) {
  ;
  _impl_.start_angle_ = value;
}

// float span_angel = 5;
inline void AddArc::clear_span_angel() {
  _impl_.span_angel_ = 0;
}
inline float AddArc::span_angel() const {
  // @@protoc_insertion_point(field_get:protos.AddArc.span_angel)
  return _internal_span_angel();
}
inline void AddArc::set_span_angel(float value) {
  _internal_set_span_angel(value);
  // @@protoc_insertion_point(field_set:protos.AddArc.span_angel)
}
inline float AddArc::_internal_span_angel() const {
  return _impl_.span_angel_;
}
inline void AddArc::_internal_set_span_angel(float value) {
  ;
  _impl_.span_angel_ = value;
}

// string color = 6;
inline void AddArc::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AddArc::color() const {
  // @@protoc_insertion_point(field_get:protos.AddArc.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddArc::set_color(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.AddArc.color)
}
inline std::string* AddArc::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:protos.AddArc.color)
  return _s;
}
inline const std::string& AddArc::_internal_color() const {
  return _impl_.color_.Get();
}
inline void AddArc::_internal_set_color(const std::string& value) {
  ;


  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* AddArc::_internal_mutable_color() {
  ;
  return _impl_.color_.Mutable( GetArenaForAllocation());
}
inline std::string* AddArc::release_color() {
  // @@protoc_insertion_point(field_release:protos.AddArc.color)
  return _impl_.color_.Release();
}
inline void AddArc::set_allocated_color(std::string* value) {
  _impl_.color_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_.IsDefault()) {
          _impl_.color_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddArc.color)
}

// -------------------------------------------------------------------

// AddCircle

// .protos.LoggerLevel level = 1;
inline void AddCircle::clear_level() {
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddCircle::level() const {
  // @@protoc_insertion_point(field_get:protos.AddCircle.level)
  return _internal_level();
}
inline void AddCircle::set_level(::protos::LoggerLevel value) {
   _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddCircle.level)
}
inline ::protos::LoggerLevel AddCircle::_internal_level() const {
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddCircle::_internal_set_level(::protos::LoggerLevel value) {
  ;
  _impl_.level_ = value;
}

// .protos.Vector2D center = 2;
inline bool AddCircle::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline void AddCircle::clear_center() {
  if (_impl_.center_ != nullptr) _impl_.center_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& AddCircle::_internal_center() const {
  const ::protos::Vector2D* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddCircle::center() const {
  // @@protoc_insertion_point(field_get:protos.AddCircle.center)
  return _internal_center();
}
inline void AddCircle::unsafe_arena_set_allocated_center(
    ::protos::Vector2D* center) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = center;
  if (center) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddCircle.center)
}
inline ::protos::Vector2D* AddCircle::release_center() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* AddCircle::unsafe_arena_release_center() {
  // @@protoc_insertion_point(field_release:protos.AddCircle.center)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddCircle::_internal_mutable_center() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.center_ = p;
  }
  return _impl_.center_;
}
inline ::protos::Vector2D* AddCircle::mutable_center() {
  ::protos::Vector2D* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:protos.AddCircle.center)
  return _msg;
}
inline void AddCircle::set_allocated_center(::protos::Vector2D* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(center);
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.center_ = center;
  // @@protoc_insertion_point(field_set_allocated:protos.AddCircle.center)
}

// float radius = 3;
inline void AddCircle::clear_radius() {
  _impl_.radius_ = 0;
}
inline float AddCircle::radius() const {
  // @@protoc_insertion_point(field_get:protos.AddCircle.radius)
  return _internal_radius();
}
inline void AddCircle::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:protos.AddCircle.radius)
}
inline float AddCircle::_internal_radius() const {
  return _impl_.radius_;
}
inline void AddCircle::_internal_set_radius(float value) {
  ;
  _impl_.radius_ = value;
}

// string color = 4;
inline void AddCircle::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AddCircle::color() const {
  // @@protoc_insertion_point(field_get:protos.AddCircle.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddCircle::set_color(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.AddCircle.color)
}
inline std::string* AddCircle::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:protos.AddCircle.color)
  return _s;
}
inline const std::string& AddCircle::_internal_color() const {
  return _impl_.color_.Get();
}
inline void AddCircle::_internal_set_color(const std::string& value) {
  ;


  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* AddCircle::_internal_mutable_color() {
  ;
  return _impl_.color_.Mutable( GetArenaForAllocation());
}
inline std::string* AddCircle::release_color() {
  // @@protoc_insertion_point(field_release:protos.AddCircle.color)
  return _impl_.color_.Release();
}
inline void AddCircle::set_allocated_color(std::string* value) {
  _impl_.color_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_.IsDefault()) {
          _impl_.color_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddCircle.color)
}

// bool fill = 5;
inline void AddCircle::clear_fill() {
  _impl_.fill_ = false;
}
inline bool AddCircle::fill() const {
  // @@protoc_insertion_point(field_get:protos.AddCircle.fill)
  return _internal_fill();
}
inline void AddCircle::set_fill(bool value) {
  _internal_set_fill(value);
  // @@protoc_insertion_point(field_set:protos.AddCircle.fill)
}
inline bool AddCircle::_internal_fill() const {
  return _impl_.fill_;
}
inline void AddCircle::_internal_set_fill(bool value) {
  ;
  _impl_.fill_ = value;
}

// -------------------------------------------------------------------

// AddTriangle

// .protos.LoggerLevel level = 1;
inline void AddTriangle::clear_level() {
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddTriangle::level() const {
  // @@protoc_insertion_point(field_get:protos.AddTriangle.level)
  return _internal_level();
}
inline void AddTriangle::set_level(::protos::LoggerLevel value) {
   _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddTriangle.level)
}
inline ::protos::LoggerLevel AddTriangle::_internal_level() const {
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddTriangle::_internal_set_level(::protos::LoggerLevel value) {
  ;
  _impl_.level_ = value;
}

// .protos.Vector2D point1 = 2;
inline bool AddTriangle::has_point1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point1_ != nullptr);
  return value;
}
inline void AddTriangle::clear_point1() {
  if (_impl_.point1_ != nullptr) _impl_.point1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& AddTriangle::_internal_point1() const {
  const ::protos::Vector2D* p = _impl_.point1_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddTriangle::point1() const {
  // @@protoc_insertion_point(field_get:protos.AddTriangle.point1)
  return _internal_point1();
}
inline void AddTriangle::unsafe_arena_set_allocated_point1(
    ::protos::Vector2D* point1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point1_);
  }
  _impl_.point1_ = point1;
  if (point1) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddTriangle.point1)
}
inline ::protos::Vector2D* AddTriangle::release_point1() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.point1_;
  _impl_.point1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* AddTriangle::unsafe_arena_release_point1() {
  // @@protoc_insertion_point(field_release:protos.AddTriangle.point1)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.point1_;
  _impl_.point1_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddTriangle::_internal_mutable_point1() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point1_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.point1_ = p;
  }
  return _impl_.point1_;
}
inline ::protos::Vector2D* AddTriangle::mutable_point1() {
  ::protos::Vector2D* _msg = _internal_mutable_point1();
  // @@protoc_insertion_point(field_mutable:protos.AddTriangle.point1)
  return _msg;
}
inline void AddTriangle::set_allocated_point1(::protos::Vector2D* point1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.point1_;
  }
  if (point1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point1);
    if (message_arena != submessage_arena) {
      point1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.point1_ = point1;
  // @@protoc_insertion_point(field_set_allocated:protos.AddTriangle.point1)
}

// .protos.Vector2D point2 = 3;
inline bool AddTriangle::has_point2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point2_ != nullptr);
  return value;
}
inline void AddTriangle::clear_point2() {
  if (_impl_.point2_ != nullptr) _impl_.point2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& AddTriangle::_internal_point2() const {
  const ::protos::Vector2D* p = _impl_.point2_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddTriangle::point2() const {
  // @@protoc_insertion_point(field_get:protos.AddTriangle.point2)
  return _internal_point2();
}
inline void AddTriangle::unsafe_arena_set_allocated_point2(
    ::protos::Vector2D* point2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point2_);
  }
  _impl_.point2_ = point2;
  if (point2) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddTriangle.point2)
}
inline ::protos::Vector2D* AddTriangle::release_point2() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.point2_;
  _impl_.point2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* AddTriangle::unsafe_arena_release_point2() {
  // @@protoc_insertion_point(field_release:protos.AddTriangle.point2)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.point2_;
  _impl_.point2_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddTriangle::_internal_mutable_point2() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.point2_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.point2_ = p;
  }
  return _impl_.point2_;
}
inline ::protos::Vector2D* AddTriangle::mutable_point2() {
  ::protos::Vector2D* _msg = _internal_mutable_point2();
  // @@protoc_insertion_point(field_mutable:protos.AddTriangle.point2)
  return _msg;
}
inline void AddTriangle::set_allocated_point2(::protos::Vector2D* point2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.point2_;
  }
  if (point2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point2);
    if (message_arena != submessage_arena) {
      point2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point2, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.point2_ = point2;
  // @@protoc_insertion_point(field_set_allocated:protos.AddTriangle.point2)
}

// .protos.Vector2D point3 = 4;
inline bool AddTriangle::has_point3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point3_ != nullptr);
  return value;
}
inline void AddTriangle::clear_point3() {
  if (_impl_.point3_ != nullptr) _impl_.point3_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& AddTriangle::_internal_point3() const {
  const ::protos::Vector2D* p = _impl_.point3_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddTriangle::point3() const {
  // @@protoc_insertion_point(field_get:protos.AddTriangle.point3)
  return _internal_point3();
}
inline void AddTriangle::unsafe_arena_set_allocated_point3(
    ::protos::Vector2D* point3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point3_);
  }
  _impl_.point3_ = point3;
  if (point3) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddTriangle.point3)
}
inline ::protos::Vector2D* AddTriangle::release_point3() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.point3_;
  _impl_.point3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* AddTriangle::unsafe_arena_release_point3() {
  // @@protoc_insertion_point(field_release:protos.AddTriangle.point3)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.point3_;
  _impl_.point3_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddTriangle::_internal_mutable_point3() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.point3_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.point3_ = p;
  }
  return _impl_.point3_;
}
inline ::protos::Vector2D* AddTriangle::mutable_point3() {
  ::protos::Vector2D* _msg = _internal_mutable_point3();
  // @@protoc_insertion_point(field_mutable:protos.AddTriangle.point3)
  return _msg;
}
inline void AddTriangle::set_allocated_point3(::protos::Vector2D* point3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.point3_;
  }
  if (point3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point3);
    if (message_arena != submessage_arena) {
      point3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point3, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.point3_ = point3;
  // @@protoc_insertion_point(field_set_allocated:protos.AddTriangle.point3)
}

// string color = 5;
inline void AddTriangle::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AddTriangle::color() const {
  // @@protoc_insertion_point(field_get:protos.AddTriangle.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddTriangle::set_color(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.AddTriangle.color)
}
inline std::string* AddTriangle::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:protos.AddTriangle.color)
  return _s;
}
inline const std::string& AddTriangle::_internal_color() const {
  return _impl_.color_.Get();
}
inline void AddTriangle::_internal_set_color(const std::string& value) {
  ;


  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* AddTriangle::_internal_mutable_color() {
  ;
  return _impl_.color_.Mutable( GetArenaForAllocation());
}
inline std::string* AddTriangle::release_color() {
  // @@protoc_insertion_point(field_release:protos.AddTriangle.color)
  return _impl_.color_.Release();
}
inline void AddTriangle::set_allocated_color(std::string* value) {
  _impl_.color_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_.IsDefault()) {
          _impl_.color_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddTriangle.color)
}

// bool fill = 6;
inline void AddTriangle::clear_fill() {
  _impl_.fill_ = false;
}
inline bool AddTriangle::fill() const {
  // @@protoc_insertion_point(field_get:protos.AddTriangle.fill)
  return _internal_fill();
}
inline void AddTriangle::set_fill(bool value) {
  _internal_set_fill(value);
  // @@protoc_insertion_point(field_set:protos.AddTriangle.fill)
}
inline bool AddTriangle::_internal_fill() const {
  return _impl_.fill_;
}
inline void AddTriangle::_internal_set_fill(bool value) {
  ;
  _impl_.fill_ = value;
}

// -------------------------------------------------------------------

// AddRectangle

// .protos.LoggerLevel level = 1;
inline void AddRectangle::clear_level() {
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddRectangle::level() const {
  // @@protoc_insertion_point(field_get:protos.AddRectangle.level)
  return _internal_level();
}
inline void AddRectangle::set_level(::protos::LoggerLevel value) {
   _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddRectangle.level)
}
inline ::protos::LoggerLevel AddRectangle::_internal_level() const {
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddRectangle::_internal_set_level(::protos::LoggerLevel value) {
  ;
  _impl_.level_ = value;
}

// float left = 2;
inline void AddRectangle::clear_left() {
  _impl_.left_ = 0;
}
inline float AddRectangle::left() const {
  // @@protoc_insertion_point(field_get:protos.AddRectangle.left)
  return _internal_left();
}
inline void AddRectangle::set_left(float value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:protos.AddRectangle.left)
}
inline float AddRectangle::_internal_left() const {
  return _impl_.left_;
}
inline void AddRectangle::_internal_set_left(float value) {
  ;
  _impl_.left_ = value;
}

// float top = 3;
inline void AddRectangle::clear_top() {
  _impl_.top_ = 0;
}
inline float AddRectangle::top() const {
  // @@protoc_insertion_point(field_get:protos.AddRectangle.top)
  return _internal_top();
}
inline void AddRectangle::set_top(float value) {
  _internal_set_top(value);
  // @@protoc_insertion_point(field_set:protos.AddRectangle.top)
}
inline float AddRectangle::_internal_top() const {
  return _impl_.top_;
}
inline void AddRectangle::_internal_set_top(float value) {
  ;
  _impl_.top_ = value;
}

// float length = 4;
inline void AddRectangle::clear_length() {
  _impl_.length_ = 0;
}
inline float AddRectangle::length() const {
  // @@protoc_insertion_point(field_get:protos.AddRectangle.length)
  return _internal_length();
}
inline void AddRectangle::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:protos.AddRectangle.length)
}
inline float AddRectangle::_internal_length() const {
  return _impl_.length_;
}
inline void AddRectangle::_internal_set_length(float value) {
  ;
  _impl_.length_ = value;
}

// float width = 5;
inline void AddRectangle::clear_width() {
  _impl_.width_ = 0;
}
inline float AddRectangle::width() const {
  // @@protoc_insertion_point(field_get:protos.AddRectangle.width)
  return _internal_width();
}
inline void AddRectangle::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:protos.AddRectangle.width)
}
inline float AddRectangle::_internal_width() const {
  return _impl_.width_;
}
inline void AddRectangle::_internal_set_width(float value) {
  ;
  _impl_.width_ = value;
}

// string color = 6;
inline void AddRectangle::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AddRectangle::color() const {
  // @@protoc_insertion_point(field_get:protos.AddRectangle.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddRectangle::set_color(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.AddRectangle.color)
}
inline std::string* AddRectangle::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:protos.AddRectangle.color)
  return _s;
}
inline const std::string& AddRectangle::_internal_color() const {
  return _impl_.color_.Get();
}
inline void AddRectangle::_internal_set_color(const std::string& value) {
  ;


  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* AddRectangle::_internal_mutable_color() {
  ;
  return _impl_.color_.Mutable( GetArenaForAllocation());
}
inline std::string* AddRectangle::release_color() {
  // @@protoc_insertion_point(field_release:protos.AddRectangle.color)
  return _impl_.color_.Release();
}
inline void AddRectangle::set_allocated_color(std::string* value) {
  _impl_.color_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_.IsDefault()) {
          _impl_.color_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddRectangle.color)
}

// bool fill = 7;
inline void AddRectangle::clear_fill() {
  _impl_.fill_ = false;
}
inline bool AddRectangle::fill() const {
  // @@protoc_insertion_point(field_get:protos.AddRectangle.fill)
  return _internal_fill();
}
inline void AddRectangle::set_fill(bool value) {
  _internal_set_fill(value);
  // @@protoc_insertion_point(field_set:protos.AddRectangle.fill)
}
inline bool AddRectangle::_internal_fill() const {
  return _impl_.fill_;
}
inline void AddRectangle::_internal_set_fill(bool value) {
  ;
  _impl_.fill_ = value;
}

// -------------------------------------------------------------------

// AddSector

// .protos.LoggerLevel level = 1;
inline void AddSector::clear_level() {
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddSector::level() const {
  // @@protoc_insertion_point(field_get:protos.AddSector.level)
  return _internal_level();
}
inline void AddSector::set_level(::protos::LoggerLevel value) {
   _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddSector.level)
}
inline ::protos::LoggerLevel AddSector::_internal_level() const {
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddSector::_internal_set_level(::protos::LoggerLevel value) {
  ;
  _impl_.level_ = value;
}

// .protos.Vector2D center = 2;
inline bool AddSector::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline void AddSector::clear_center() {
  if (_impl_.center_ != nullptr) _impl_.center_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& AddSector::_internal_center() const {
  const ::protos::Vector2D* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddSector::center() const {
  // @@protoc_insertion_point(field_get:protos.AddSector.center)
  return _internal_center();
}
inline void AddSector::unsafe_arena_set_allocated_center(
    ::protos::Vector2D* center) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = center;
  if (center) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddSector.center)
}
inline ::protos::Vector2D* AddSector::release_center() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* AddSector::unsafe_arena_release_center() {
  // @@protoc_insertion_point(field_release:protos.AddSector.center)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddSector::_internal_mutable_center() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.center_ = p;
  }
  return _impl_.center_;
}
inline ::protos::Vector2D* AddSector::mutable_center() {
  ::protos::Vector2D* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:protos.AddSector.center)
  return _msg;
}
inline void AddSector::set_allocated_center(::protos::Vector2D* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(center);
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.center_ = center;
  // @@protoc_insertion_point(field_set_allocated:protos.AddSector.center)
}

// float min_radius = 3;
inline void AddSector::clear_min_radius() {
  _impl_.min_radius_ = 0;
}
inline float AddSector::min_radius() const {
  // @@protoc_insertion_point(field_get:protos.AddSector.min_radius)
  return _internal_min_radius();
}
inline void AddSector::set_min_radius(float value) {
  _internal_set_min_radius(value);
  // @@protoc_insertion_point(field_set:protos.AddSector.min_radius)
}
inline float AddSector::_internal_min_radius() const {
  return _impl_.min_radius_;
}
inline void AddSector::_internal_set_min_radius(float value) {
  ;
  _impl_.min_radius_ = value;
}

// float max_radius = 4;
inline void AddSector::clear_max_radius() {
  _impl_.max_radius_ = 0;
}
inline float AddSector::max_radius() const {
  // @@protoc_insertion_point(field_get:protos.AddSector.max_radius)
  return _internal_max_radius();
}
inline void AddSector::set_max_radius(float value) {
  _internal_set_max_radius(value);
  // @@protoc_insertion_point(field_set:protos.AddSector.max_radius)
}
inline float AddSector::_internal_max_radius() const {
  return _impl_.max_radius_;
}
inline void AddSector::_internal_set_max_radius(float value) {
  ;
  _impl_.max_radius_ = value;
}

// float start_angle = 5;
inline void AddSector::clear_start_angle() {
  _impl_.start_angle_ = 0;
}
inline float AddSector::start_angle() const {
  // @@protoc_insertion_point(field_get:protos.AddSector.start_angle)
  return _internal_start_angle();
}
inline void AddSector::set_start_angle(float value) {
  _internal_set_start_angle(value);
  // @@protoc_insertion_point(field_set:protos.AddSector.start_angle)
}
inline float AddSector::_internal_start_angle() const {
  return _impl_.start_angle_;
}
inline void AddSector::_internal_set_start_angle(float value) {
  ;
  _impl_.start_angle_ = value;
}

// float span_angel = 6;
inline void AddSector::clear_span_angel() {
  _impl_.span_angel_ = 0;
}
inline float AddSector::span_angel() const {
  // @@protoc_insertion_point(field_get:protos.AddSector.span_angel)
  return _internal_span_angel();
}
inline void AddSector::set_span_angel(float value) {
  _internal_set_span_angel(value);
  // @@protoc_insertion_point(field_set:protos.AddSector.span_angel)
}
inline float AddSector::_internal_span_angel() const {
  return _impl_.span_angel_;
}
inline void AddSector::_internal_set_span_angel(float value) {
  ;
  _impl_.span_angel_ = value;
}

// string color = 7;
inline void AddSector::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AddSector::color() const {
  // @@protoc_insertion_point(field_get:protos.AddSector.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddSector::set_color(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.AddSector.color)
}
inline std::string* AddSector::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:protos.AddSector.color)
  return _s;
}
inline const std::string& AddSector::_internal_color() const {
  return _impl_.color_.Get();
}
inline void AddSector::_internal_set_color(const std::string& value) {
  ;


  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* AddSector::_internal_mutable_color() {
  ;
  return _impl_.color_.Mutable( GetArenaForAllocation());
}
inline std::string* AddSector::release_color() {
  // @@protoc_insertion_point(field_release:protos.AddSector.color)
  return _impl_.color_.Release();
}
inline void AddSector::set_allocated_color(std::string* value) {
  _impl_.color_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_.IsDefault()) {
          _impl_.color_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddSector.color)
}

// bool fill = 8;
inline void AddSector::clear_fill() {
  _impl_.fill_ = false;
}
inline bool AddSector::fill() const {
  // @@protoc_insertion_point(field_get:protos.AddSector.fill)
  return _internal_fill();
}
inline void AddSector::set_fill(bool value) {
  _internal_set_fill(value);
  // @@protoc_insertion_point(field_set:protos.AddSector.fill)
}
inline bool AddSector::_internal_fill() const {
  return _impl_.fill_;
}
inline void AddSector::_internal_set_fill(bool value) {
  ;
  _impl_.fill_ = value;
}

// -------------------------------------------------------------------

// AddMessage

// .protos.LoggerLevel level = 1;
inline void AddMessage::clear_level() {
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddMessage::level() const {
  // @@protoc_insertion_point(field_get:protos.AddMessage.level)
  return _internal_level();
}
inline void AddMessage::set_level(::protos::LoggerLevel value) {
   _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddMessage.level)
}
inline ::protos::LoggerLevel AddMessage::_internal_level() const {
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddMessage::_internal_set_level(::protos::LoggerLevel value) {
  ;
  _impl_.level_ = value;
}

// .protos.Vector2D position = 2;
inline bool AddMessage::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void AddMessage::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& AddMessage::_internal_position() const {
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddMessage::position() const {
  // @@protoc_insertion_point(field_get:protos.AddMessage.position)
  return _internal_position();
}
inline void AddMessage::unsafe_arena_set_allocated_position(
    ::protos::Vector2D* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddMessage.position)
}
inline ::protos::Vector2D* AddMessage::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* AddMessage::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protos.AddMessage.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddMessage::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* AddMessage::mutable_position() {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.AddMessage.position)
  return _msg;
}
inline void AddMessage::set_allocated_position(::protos::Vector2D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protos.AddMessage.position)
}

// string message = 3;
inline void AddMessage::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& AddMessage::message() const {
  // @@protoc_insertion_point(field_get:protos.AddMessage.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddMessage::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.AddMessage.message)
}
inline std::string* AddMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:protos.AddMessage.message)
  return _s;
}
inline const std::string& AddMessage::_internal_message() const {
  return _impl_.message_.Get();
}
inline void AddMessage::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* AddMessage::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* AddMessage::release_message() {
  // @@protoc_insertion_point(field_release:protos.AddMessage.message)
  return _impl_.message_.Release();
}
inline void AddMessage::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddMessage.message)
}

// string color = 4;
inline void AddMessage::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AddMessage::color() const {
  // @@protoc_insertion_point(field_get:protos.AddMessage.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddMessage::set_color(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.AddMessage.color)
}
inline std::string* AddMessage::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:protos.AddMessage.color)
  return _s;
}
inline const std::string& AddMessage::_internal_color() const {
  return _impl_.color_.Get();
}
inline void AddMessage::_internal_set_color(const std::string& value) {
  ;


  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* AddMessage::_internal_mutable_color() {
  ;
  return _impl_.color_.Mutable( GetArenaForAllocation());
}
inline std::string* AddMessage::release_color() {
  // @@protoc_insertion_point(field_release:protos.AddMessage.color)
  return _impl_.color_.Release();
}
inline void AddMessage::set_allocated_color(std::string* value) {
  _impl_.color_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_.IsDefault()) {
          _impl_.color_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddMessage.color)
}

// -------------------------------------------------------------------

// Log

// .protos.AddText add_text = 1;
inline bool Log::has_add_text() const {
  return log_case() == kAddText;
}
inline bool Log::_internal_has_add_text() const {
  return log_case() == kAddText;
}
inline void Log::set_has_add_text() {
  _impl_._oneof_case_[0] = kAddText;
}
inline void Log::clear_add_text() {
  if (log_case() == kAddText) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.log_.add_text_;
    }
    clear_has_log();
  }
}
inline ::protos::AddText* Log::release_add_text() {
  // @@protoc_insertion_point(field_release:protos.Log.add_text)
  if (log_case() == kAddText) {
    clear_has_log();
    ::protos::AddText* temp = _impl_.log_.add_text_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddText& Log::_internal_add_text() const {
  return log_case() == kAddText
      ? *_impl_.log_.add_text_
      : reinterpret_cast<::protos::AddText&>(::protos::_AddText_default_instance_);
}
inline const ::protos::AddText& Log::add_text() const {
  // @@protoc_insertion_point(field_get:protos.Log.add_text)
  return _internal_add_text();
}
inline ::protos::AddText* Log::unsafe_arena_release_add_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_text)
  if (log_case() == kAddText) {
    clear_has_log();
    ::protos::AddText* temp = _impl_.log_.add_text_;
    _impl_.log_.add_text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_text(::protos::AddText* add_text) {
  clear_log();
  if (add_text) {
    set_has_add_text();
    _impl_.log_.add_text_ = add_text;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_text)
}
inline ::protos::AddText* Log::_internal_mutable_add_text() {
  if (log_case() != kAddText) {
    clear_log();
    set_has_add_text();
    _impl_.log_.add_text_ = CreateMaybeMessage< ::protos::AddText >(GetArenaForAllocation());
  }
  return _impl_.log_.add_text_;
}
inline ::protos::AddText* Log::mutable_add_text() {
  ::protos::AddText* _msg = _internal_mutable_add_text();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_text)
  return _msg;
}

// .protos.AddPoint add_point = 2;
inline bool Log::has_add_point() const {
  return log_case() == kAddPoint;
}
inline bool Log::_internal_has_add_point() const {
  return log_case() == kAddPoint;
}
inline void Log::set_has_add_point() {
  _impl_._oneof_case_[0] = kAddPoint;
}
inline void Log::clear_add_point() {
  if (log_case() == kAddPoint) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.log_.add_point_;
    }
    clear_has_log();
  }
}
inline ::protos::AddPoint* Log::release_add_point() {
  // @@protoc_insertion_point(field_release:protos.Log.add_point)
  if (log_case() == kAddPoint) {
    clear_has_log();
    ::protos::AddPoint* temp = _impl_.log_.add_point_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddPoint& Log::_internal_add_point() const {
  return log_case() == kAddPoint
      ? *_impl_.log_.add_point_
      : reinterpret_cast<::protos::AddPoint&>(::protos::_AddPoint_default_instance_);
}
inline const ::protos::AddPoint& Log::add_point() const {
  // @@protoc_insertion_point(field_get:protos.Log.add_point)
  return _internal_add_point();
}
inline ::protos::AddPoint* Log::unsafe_arena_release_add_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_point)
  if (log_case() == kAddPoint) {
    clear_has_log();
    ::protos::AddPoint* temp = _impl_.log_.add_point_;
    _impl_.log_.add_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_point(::protos::AddPoint* add_point) {
  clear_log();
  if (add_point) {
    set_has_add_point();
    _impl_.log_.add_point_ = add_point;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_point)
}
inline ::protos::AddPoint* Log::_internal_mutable_add_point() {
  if (log_case() != kAddPoint) {
    clear_log();
    set_has_add_point();
    _impl_.log_.add_point_ = CreateMaybeMessage< ::protos::AddPoint >(GetArenaForAllocation());
  }
  return _impl_.log_.add_point_;
}
inline ::protos::AddPoint* Log::mutable_add_point() {
  ::protos::AddPoint* _msg = _internal_mutable_add_point();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_point)
  return _msg;
}

// .protos.AddLine add_line = 3;
inline bool Log::has_add_line() const {
  return log_case() == kAddLine;
}
inline bool Log::_internal_has_add_line() const {
  return log_case() == kAddLine;
}
inline void Log::set_has_add_line() {
  _impl_._oneof_case_[0] = kAddLine;
}
inline void Log::clear_add_line() {
  if (log_case() == kAddLine) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.log_.add_line_;
    }
    clear_has_log();
  }
}
inline ::protos::AddLine* Log::release_add_line() {
  // @@protoc_insertion_point(field_release:protos.Log.add_line)
  if (log_case() == kAddLine) {
    clear_has_log();
    ::protos::AddLine* temp = _impl_.log_.add_line_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddLine& Log::_internal_add_line() const {
  return log_case() == kAddLine
      ? *_impl_.log_.add_line_
      : reinterpret_cast<::protos::AddLine&>(::protos::_AddLine_default_instance_);
}
inline const ::protos::AddLine& Log::add_line() const {
  // @@protoc_insertion_point(field_get:protos.Log.add_line)
  return _internal_add_line();
}
inline ::protos::AddLine* Log::unsafe_arena_release_add_line() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_line)
  if (log_case() == kAddLine) {
    clear_has_log();
    ::protos::AddLine* temp = _impl_.log_.add_line_;
    _impl_.log_.add_line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_line(::protos::AddLine* add_line) {
  clear_log();
  if (add_line) {
    set_has_add_line();
    _impl_.log_.add_line_ = add_line;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_line)
}
inline ::protos::AddLine* Log::_internal_mutable_add_line() {
  if (log_case() != kAddLine) {
    clear_log();
    set_has_add_line();
    _impl_.log_.add_line_ = CreateMaybeMessage< ::protos::AddLine >(GetArenaForAllocation());
  }
  return _impl_.log_.add_line_;
}
inline ::protos::AddLine* Log::mutable_add_line() {
  ::protos::AddLine* _msg = _internal_mutable_add_line();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_line)
  return _msg;
}

// .protos.AddArc add_arc = 4;
inline bool Log::has_add_arc() const {
  return log_case() == kAddArc;
}
inline bool Log::_internal_has_add_arc() const {
  return log_case() == kAddArc;
}
inline void Log::set_has_add_arc() {
  _impl_._oneof_case_[0] = kAddArc;
}
inline void Log::clear_add_arc() {
  if (log_case() == kAddArc) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.log_.add_arc_;
    }
    clear_has_log();
  }
}
inline ::protos::AddArc* Log::release_add_arc() {
  // @@protoc_insertion_point(field_release:protos.Log.add_arc)
  if (log_case() == kAddArc) {
    clear_has_log();
    ::protos::AddArc* temp = _impl_.log_.add_arc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_arc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddArc& Log::_internal_add_arc() const {
  return log_case() == kAddArc
      ? *_impl_.log_.add_arc_
      : reinterpret_cast<::protos::AddArc&>(::protos::_AddArc_default_instance_);
}
inline const ::protos::AddArc& Log::add_arc() const {
  // @@protoc_insertion_point(field_get:protos.Log.add_arc)
  return _internal_add_arc();
}
inline ::protos::AddArc* Log::unsafe_arena_release_add_arc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_arc)
  if (log_case() == kAddArc) {
    clear_has_log();
    ::protos::AddArc* temp = _impl_.log_.add_arc_;
    _impl_.log_.add_arc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_arc(::protos::AddArc* add_arc) {
  clear_log();
  if (add_arc) {
    set_has_add_arc();
    _impl_.log_.add_arc_ = add_arc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_arc)
}
inline ::protos::AddArc* Log::_internal_mutable_add_arc() {
  if (log_case() != kAddArc) {
    clear_log();
    set_has_add_arc();
    _impl_.log_.add_arc_ = CreateMaybeMessage< ::protos::AddArc >(GetArenaForAllocation());
  }
  return _impl_.log_.add_arc_;
}
inline ::protos::AddArc* Log::mutable_add_arc() {
  ::protos::AddArc* _msg = _internal_mutable_add_arc();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_arc)
  return _msg;
}

// .protos.AddCircle add_circle = 5;
inline bool Log::has_add_circle() const {
  return log_case() == kAddCircle;
}
inline bool Log::_internal_has_add_circle() const {
  return log_case() == kAddCircle;
}
inline void Log::set_has_add_circle() {
  _impl_._oneof_case_[0] = kAddCircle;
}
inline void Log::clear_add_circle() {
  if (log_case() == kAddCircle) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.log_.add_circle_;
    }
    clear_has_log();
  }
}
inline ::protos::AddCircle* Log::release_add_circle() {
  // @@protoc_insertion_point(field_release:protos.Log.add_circle)
  if (log_case() == kAddCircle) {
    clear_has_log();
    ::protos::AddCircle* temp = _impl_.log_.add_circle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddCircle& Log::_internal_add_circle() const {
  return log_case() == kAddCircle
      ? *_impl_.log_.add_circle_
      : reinterpret_cast<::protos::AddCircle&>(::protos::_AddCircle_default_instance_);
}
inline const ::protos::AddCircle& Log::add_circle() const {
  // @@protoc_insertion_point(field_get:protos.Log.add_circle)
  return _internal_add_circle();
}
inline ::protos::AddCircle* Log::unsafe_arena_release_add_circle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_circle)
  if (log_case() == kAddCircle) {
    clear_has_log();
    ::protos::AddCircle* temp = _impl_.log_.add_circle_;
    _impl_.log_.add_circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_circle(::protos::AddCircle* add_circle) {
  clear_log();
  if (add_circle) {
    set_has_add_circle();
    _impl_.log_.add_circle_ = add_circle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_circle)
}
inline ::protos::AddCircle* Log::_internal_mutable_add_circle() {
  if (log_case() != kAddCircle) {
    clear_log();
    set_has_add_circle();
    _impl_.log_.add_circle_ = CreateMaybeMessage< ::protos::AddCircle >(GetArenaForAllocation());
  }
  return _impl_.log_.add_circle_;
}
inline ::protos::AddCircle* Log::mutable_add_circle() {
  ::protos::AddCircle* _msg = _internal_mutable_add_circle();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_circle)
  return _msg;
}

// .protos.AddTriangle add_triangle = 6;
inline bool Log::has_add_triangle() const {
  return log_case() == kAddTriangle;
}
inline bool Log::_internal_has_add_triangle() const {
  return log_case() == kAddTriangle;
}
inline void Log::set_has_add_triangle() {
  _impl_._oneof_case_[0] = kAddTriangle;
}
inline void Log::clear_add_triangle() {
  if (log_case() == kAddTriangle) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.log_.add_triangle_;
    }
    clear_has_log();
  }
}
inline ::protos::AddTriangle* Log::release_add_triangle() {
  // @@protoc_insertion_point(field_release:protos.Log.add_triangle)
  if (log_case() == kAddTriangle) {
    clear_has_log();
    ::protos::AddTriangle* temp = _impl_.log_.add_triangle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_triangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddTriangle& Log::_internal_add_triangle() const {
  return log_case() == kAddTriangle
      ? *_impl_.log_.add_triangle_
      : reinterpret_cast<::protos::AddTriangle&>(::protos::_AddTriangle_default_instance_);
}
inline const ::protos::AddTriangle& Log::add_triangle() const {
  // @@protoc_insertion_point(field_get:protos.Log.add_triangle)
  return _internal_add_triangle();
}
inline ::protos::AddTriangle* Log::unsafe_arena_release_add_triangle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_triangle)
  if (log_case() == kAddTriangle) {
    clear_has_log();
    ::protos::AddTriangle* temp = _impl_.log_.add_triangle_;
    _impl_.log_.add_triangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_triangle(::protos::AddTriangle* add_triangle) {
  clear_log();
  if (add_triangle) {
    set_has_add_triangle();
    _impl_.log_.add_triangle_ = add_triangle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_triangle)
}
inline ::protos::AddTriangle* Log::_internal_mutable_add_triangle() {
  if (log_case() != kAddTriangle) {
    clear_log();
    set_has_add_triangle();
    _impl_.log_.add_triangle_ = CreateMaybeMessage< ::protos::AddTriangle >(GetArenaForAllocation());
  }
  return _impl_.log_.add_triangle_;
}
inline ::protos::AddTriangle* Log::mutable_add_triangle() {
  ::protos::AddTriangle* _msg = _internal_mutable_add_triangle();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_triangle)
  return _msg;
}

// .protos.AddRectangle add_rectangle = 7;
inline bool Log::has_add_rectangle() const {
  return log_case() == kAddRectangle;
}
inline bool Log::_internal_has_add_rectangle() const {
  return log_case() == kAddRectangle;
}
inline void Log::set_has_add_rectangle() {
  _impl_._oneof_case_[0] = kAddRectangle;
}
inline void Log::clear_add_rectangle() {
  if (log_case() == kAddRectangle) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.log_.add_rectangle_;
    }
    clear_has_log();
  }
}
inline ::protos::AddRectangle* Log::release_add_rectangle() {
  // @@protoc_insertion_point(field_release:protos.Log.add_rectangle)
  if (log_case() == kAddRectangle) {
    clear_has_log();
    ::protos::AddRectangle* temp = _impl_.log_.add_rectangle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_rectangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddRectangle& Log::_internal_add_rectangle() const {
  return log_case() == kAddRectangle
      ? *_impl_.log_.add_rectangle_
      : reinterpret_cast<::protos::AddRectangle&>(::protos::_AddRectangle_default_instance_);
}
inline const ::protos::AddRectangle& Log::add_rectangle() const {
  // @@protoc_insertion_point(field_get:protos.Log.add_rectangle)
  return _internal_add_rectangle();
}
inline ::protos::AddRectangle* Log::unsafe_arena_release_add_rectangle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_rectangle)
  if (log_case() == kAddRectangle) {
    clear_has_log();
    ::protos::AddRectangle* temp = _impl_.log_.add_rectangle_;
    _impl_.log_.add_rectangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_rectangle(::protos::AddRectangle* add_rectangle) {
  clear_log();
  if (add_rectangle) {
    set_has_add_rectangle();
    _impl_.log_.add_rectangle_ = add_rectangle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_rectangle)
}
inline ::protos::AddRectangle* Log::_internal_mutable_add_rectangle() {
  if (log_case() != kAddRectangle) {
    clear_log();
    set_has_add_rectangle();
    _impl_.log_.add_rectangle_ = CreateMaybeMessage< ::protos::AddRectangle >(GetArenaForAllocation());
  }
  return _impl_.log_.add_rectangle_;
}
inline ::protos::AddRectangle* Log::mutable_add_rectangle() {
  ::protos::AddRectangle* _msg = _internal_mutable_add_rectangle();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_rectangle)
  return _msg;
}

// .protos.AddSector add_sector = 8;
inline bool Log::has_add_sector() const {
  return log_case() == kAddSector;
}
inline bool Log::_internal_has_add_sector() const {
  return log_case() == kAddSector;
}
inline void Log::set_has_add_sector() {
  _impl_._oneof_case_[0] = kAddSector;
}
inline void Log::clear_add_sector() {
  if (log_case() == kAddSector) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.log_.add_sector_;
    }
    clear_has_log();
  }
}
inline ::protos::AddSector* Log::release_add_sector() {
  // @@protoc_insertion_point(field_release:protos.Log.add_sector)
  if (log_case() == kAddSector) {
    clear_has_log();
    ::protos::AddSector* temp = _impl_.log_.add_sector_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_sector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddSector& Log::_internal_add_sector() const {
  return log_case() == kAddSector
      ? *_impl_.log_.add_sector_
      : reinterpret_cast<::protos::AddSector&>(::protos::_AddSector_default_instance_);
}
inline const ::protos::AddSector& Log::add_sector() const {
  // @@protoc_insertion_point(field_get:protos.Log.add_sector)
  return _internal_add_sector();
}
inline ::protos::AddSector* Log::unsafe_arena_release_add_sector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_sector)
  if (log_case() == kAddSector) {
    clear_has_log();
    ::protos::AddSector* temp = _impl_.log_.add_sector_;
    _impl_.log_.add_sector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_sector(::protos::AddSector* add_sector) {
  clear_log();
  if (add_sector) {
    set_has_add_sector();
    _impl_.log_.add_sector_ = add_sector;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_sector)
}
inline ::protos::AddSector* Log::_internal_mutable_add_sector() {
  if (log_case() != kAddSector) {
    clear_log();
    set_has_add_sector();
    _impl_.log_.add_sector_ = CreateMaybeMessage< ::protos::AddSector >(GetArenaForAllocation());
  }
  return _impl_.log_.add_sector_;
}
inline ::protos::AddSector* Log::mutable_add_sector() {
  ::protos::AddSector* _msg = _internal_mutable_add_sector();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_sector)
  return _msg;
}

// .protos.AddMessage add_message = 9;
inline bool Log::has_add_message() const {
  return log_case() == kAddMessage;
}
inline bool Log::_internal_has_add_message() const {
  return log_case() == kAddMessage;
}
inline void Log::set_has_add_message() {
  _impl_._oneof_case_[0] = kAddMessage;
}
inline void Log::clear_add_message() {
  if (log_case() == kAddMessage) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.log_.add_message_;
    }
    clear_has_log();
  }
}
inline ::protos::AddMessage* Log::release_add_message() {
  // @@protoc_insertion_point(field_release:protos.Log.add_message)
  if (log_case() == kAddMessage) {
    clear_has_log();
    ::protos::AddMessage* temp = _impl_.log_.add_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddMessage& Log::_internal_add_message() const {
  return log_case() == kAddMessage
      ? *_impl_.log_.add_message_
      : reinterpret_cast<::protos::AddMessage&>(::protos::_AddMessage_default_instance_);
}
inline const ::protos::AddMessage& Log::add_message() const {
  // @@protoc_insertion_point(field_get:protos.Log.add_message)
  return _internal_add_message();
}
inline ::protos::AddMessage* Log::unsafe_arena_release_add_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_message)
  if (log_case() == kAddMessage) {
    clear_has_log();
    ::protos::AddMessage* temp = _impl_.log_.add_message_;
    _impl_.log_.add_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_message(::protos::AddMessage* add_message) {
  clear_log();
  if (add_message) {
    set_has_add_message();
    _impl_.log_.add_message_ = add_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_message)
}
inline ::protos::AddMessage* Log::_internal_mutable_add_message() {
  if (log_case() != kAddMessage) {
    clear_log();
    set_has_add_message();
    _impl_.log_.add_message_ = CreateMaybeMessage< ::protos::AddMessage >(GetArenaForAllocation());
  }
  return _impl_.log_.add_message_;
}
inline ::protos::AddMessage* Log::mutable_add_message() {
  ::protos::AddMessage* _msg = _internal_mutable_add_message();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_message)
  return _msg;
}

inline bool Log::has_log() const {
  return log_case() != LOG_NOT_SET;
}
inline void Log::clear_has_log() {
  _impl_._oneof_case_[0] = LOG_NOT_SET;
}
inline Log::LogCase Log::log_case() const {
  return Log::LogCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DebugClient

// string message = 1;
inline void DebugClient::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& DebugClient::message() const {
  // @@protoc_insertion_point(field_get:protos.DebugClient.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DebugClient::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protos.DebugClient.message)
}
inline std::string* DebugClient::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:protos.DebugClient.message)
  return _s;
}
inline const std::string& DebugClient::_internal_message() const {
  return _impl_.message_.Get();
}
inline void DebugClient::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* DebugClient::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* DebugClient::release_message() {
  // @@protoc_insertion_point(field_release:protos.DebugClient.message)
  return _impl_.message_.Release();
}
inline void DebugClient::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.DebugClient.message)
}

// -------------------------------------------------------------------

// Body_GoToPoint

// .protos.Vector2D target_point = 1;
inline bool Body_GoToPoint::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Body_GoToPoint::clear_target_point() {
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_GoToPoint::_internal_target_point() const {
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_GoToPoint::target_point() const {
  // @@protoc_insertion_point(field_get:protos.Body_GoToPoint.target_point)
  return _internal_target_point();
}
inline void Body_GoToPoint::unsafe_arena_set_allocated_target_point(
    ::protos::Vector2D* target_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = target_point;
  if (target_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_GoToPoint.target_point)
}
inline ::protos::Vector2D* Body_GoToPoint::release_target_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Body_GoToPoint::unsafe_arena_release_target_point() {
  // @@protoc_insertion_point(field_release:protos.Body_GoToPoint.target_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_GoToPoint::_internal_mutable_target_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.target_point_ = p;
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Body_GoToPoint::mutable_target_point() {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_GoToPoint.target_point)
  return _msg;
}
inline void Body_GoToPoint::set_allocated_target_point(::protos::Vector2D* target_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_point_;
  }
  if (target_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_point);
    if (message_arena != submessage_arena) {
      target_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_point_ = target_point;
  // @@protoc_insertion_point(field_set_allocated:protos.Body_GoToPoint.target_point)
}

// float distance_threshold = 2;
inline void Body_GoToPoint::clear_distance_threshold() {
  _impl_.distance_threshold_ = 0;
}
inline float Body_GoToPoint::distance_threshold() const {
  // @@protoc_insertion_point(field_get:protos.Body_GoToPoint.distance_threshold)
  return _internal_distance_threshold();
}
inline void Body_GoToPoint::set_distance_threshold(float value) {
  _internal_set_distance_threshold(value);
  // @@protoc_insertion_point(field_set:protos.Body_GoToPoint.distance_threshold)
}
inline float Body_GoToPoint::_internal_distance_threshold() const {
  return _impl_.distance_threshold_;
}
inline void Body_GoToPoint::_internal_set_distance_threshold(float value) {
  ;
  _impl_.distance_threshold_ = value;
}

// float max_dash_power = 3;
inline void Body_GoToPoint::clear_max_dash_power() {
  _impl_.max_dash_power_ = 0;
}
inline float Body_GoToPoint::max_dash_power() const {
  // @@protoc_insertion_point(field_get:protos.Body_GoToPoint.max_dash_power)
  return _internal_max_dash_power();
}
inline void Body_GoToPoint::set_max_dash_power(float value) {
  _internal_set_max_dash_power(value);
  // @@protoc_insertion_point(field_set:protos.Body_GoToPoint.max_dash_power)
}
inline float Body_GoToPoint::_internal_max_dash_power() const {
  return _impl_.max_dash_power_;
}
inline void Body_GoToPoint::_internal_set_max_dash_power(float value) {
  ;
  _impl_.max_dash_power_ = value;
}

// -------------------------------------------------------------------

// Body_SmartKick

// .protos.Vector2D target_point = 1;
inline bool Body_SmartKick::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Body_SmartKick::clear_target_point() {
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_SmartKick::_internal_target_point() const {
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_SmartKick::target_point() const {
  // @@protoc_insertion_point(field_get:protos.Body_SmartKick.target_point)
  return _internal_target_point();
}
inline void Body_SmartKick::unsafe_arena_set_allocated_target_point(
    ::protos::Vector2D* target_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = target_point;
  if (target_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_SmartKick.target_point)
}
inline ::protos::Vector2D* Body_SmartKick::release_target_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Body_SmartKick::unsafe_arena_release_target_point() {
  // @@protoc_insertion_point(field_release:protos.Body_SmartKick.target_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_SmartKick::_internal_mutable_target_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.target_point_ = p;
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Body_SmartKick::mutable_target_point() {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_SmartKick.target_point)
  return _msg;
}
inline void Body_SmartKick::set_allocated_target_point(::protos::Vector2D* target_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_point_;
  }
  if (target_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_point);
    if (message_arena != submessage_arena) {
      target_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_point_ = target_point;
  // @@protoc_insertion_point(field_set_allocated:protos.Body_SmartKick.target_point)
}

// float first_speed = 2;
inline void Body_SmartKick::clear_first_speed() {
  _impl_.first_speed_ = 0;
}
inline float Body_SmartKick::first_speed() const {
  // @@protoc_insertion_point(field_get:protos.Body_SmartKick.first_speed)
  return _internal_first_speed();
}
inline void Body_SmartKick::set_first_speed(float value) {
  _internal_set_first_speed(value);
  // @@protoc_insertion_point(field_set:protos.Body_SmartKick.first_speed)
}
inline float Body_SmartKick::_internal_first_speed() const {
  return _impl_.first_speed_;
}
inline void Body_SmartKick::_internal_set_first_speed(float value) {
  ;
  _impl_.first_speed_ = value;
}

// float first_speed_threshold = 3;
inline void Body_SmartKick::clear_first_speed_threshold() {
  _impl_.first_speed_threshold_ = 0;
}
inline float Body_SmartKick::first_speed_threshold() const {
  // @@protoc_insertion_point(field_get:protos.Body_SmartKick.first_speed_threshold)
  return _internal_first_speed_threshold();
}
inline void Body_SmartKick::set_first_speed_threshold(float value) {
  _internal_set_first_speed_threshold(value);
  // @@protoc_insertion_point(field_set:protos.Body_SmartKick.first_speed_threshold)
}
inline float Body_SmartKick::_internal_first_speed_threshold() const {
  return _impl_.first_speed_threshold_;
}
inline void Body_SmartKick::_internal_set_first_speed_threshold(float value) {
  ;
  _impl_.first_speed_threshold_ = value;
}

// int32 max_steps = 4;
inline void Body_SmartKick::clear_max_steps() {
  _impl_.max_steps_ = 0;
}
inline ::int32_t Body_SmartKick::max_steps() const {
  // @@protoc_insertion_point(field_get:protos.Body_SmartKick.max_steps)
  return _internal_max_steps();
}
inline void Body_SmartKick::set_max_steps(::int32_t value) {
  _internal_set_max_steps(value);
  // @@protoc_insertion_point(field_set:protos.Body_SmartKick.max_steps)
}
inline ::int32_t Body_SmartKick::_internal_max_steps() const {
  return _impl_.max_steps_;
}
inline void Body_SmartKick::_internal_set_max_steps(::int32_t value) {
  ;
  _impl_.max_steps_ = value;
}

// -------------------------------------------------------------------

// Bhv_BeforeKickOff

// .protos.Vector2D point = 1;
inline bool Bhv_BeforeKickOff::has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline void Bhv_BeforeKickOff::clear_point() {
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Bhv_BeforeKickOff::_internal_point() const {
  const ::protos::Vector2D* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Bhv_BeforeKickOff::point() const {
  // @@protoc_insertion_point(field_get:protos.Bhv_BeforeKickOff.point)
  return _internal_point();
}
inline void Bhv_BeforeKickOff::unsafe_arena_set_allocated_point(
    ::protos::Vector2D* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Bhv_BeforeKickOff.point)
}
inline ::protos::Vector2D* Bhv_BeforeKickOff::release_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Bhv_BeforeKickOff::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:protos.Bhv_BeforeKickOff.point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Bhv_BeforeKickOff::_internal_mutable_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::protos::Vector2D* Bhv_BeforeKickOff::mutable_point() {
  ::protos::Vector2D* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:protos.Bhv_BeforeKickOff.point)
  return _msg;
}
inline void Bhv_BeforeKickOff::set_allocated_point(::protos::Vector2D* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:protos.Bhv_BeforeKickOff.point)
}

// -------------------------------------------------------------------

// Bhv_BodyNeckToBall

// -------------------------------------------------------------------

// Bhv_BodyNeckToPoint

// .protos.Vector2D point = 1;
inline bool Bhv_BodyNeckToPoint::has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline void Bhv_BodyNeckToPoint::clear_point() {
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Bhv_BodyNeckToPoint::_internal_point() const {
  const ::protos::Vector2D* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Bhv_BodyNeckToPoint::point() const {
  // @@protoc_insertion_point(field_get:protos.Bhv_BodyNeckToPoint.point)
  return _internal_point();
}
inline void Bhv_BodyNeckToPoint::unsafe_arena_set_allocated_point(
    ::protos::Vector2D* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Bhv_BodyNeckToPoint.point)
}
inline ::protos::Vector2D* Bhv_BodyNeckToPoint::release_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Bhv_BodyNeckToPoint::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:protos.Bhv_BodyNeckToPoint.point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Bhv_BodyNeckToPoint::_internal_mutable_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::protos::Vector2D* Bhv_BodyNeckToPoint::mutable_point() {
  ::protos::Vector2D* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:protos.Bhv_BodyNeckToPoint.point)
  return _msg;
}
inline void Bhv_BodyNeckToPoint::set_allocated_point(::protos::Vector2D* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:protos.Bhv_BodyNeckToPoint.point)
}

// -------------------------------------------------------------------

// Bhv_Emergency

// -------------------------------------------------------------------

// Bhv_GoToPointLookBall

// .protos.Vector2D target_point = 1;
inline bool Bhv_GoToPointLookBall::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Bhv_GoToPointLookBall::clear_target_point() {
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Bhv_GoToPointLookBall::_internal_target_point() const {
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Bhv_GoToPointLookBall::target_point() const {
  // @@protoc_insertion_point(field_get:protos.Bhv_GoToPointLookBall.target_point)
  return _internal_target_point();
}
inline void Bhv_GoToPointLookBall::unsafe_arena_set_allocated_target_point(
    ::protos::Vector2D* target_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = target_point;
  if (target_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Bhv_GoToPointLookBall.target_point)
}
inline ::protos::Vector2D* Bhv_GoToPointLookBall::release_target_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Bhv_GoToPointLookBall::unsafe_arena_release_target_point() {
  // @@protoc_insertion_point(field_release:protos.Bhv_GoToPointLookBall.target_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Bhv_GoToPointLookBall::_internal_mutable_target_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.target_point_ = p;
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Bhv_GoToPointLookBall::mutable_target_point() {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Bhv_GoToPointLookBall.target_point)
  return _msg;
}
inline void Bhv_GoToPointLookBall::set_allocated_target_point(::protos::Vector2D* target_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_point_;
  }
  if (target_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_point);
    if (message_arena != submessage_arena) {
      target_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_point_ = target_point;
  // @@protoc_insertion_point(field_set_allocated:protos.Bhv_GoToPointLookBall.target_point)
}

// float distance_threshold = 2;
inline void Bhv_GoToPointLookBall::clear_distance_threshold() {
  _impl_.distance_threshold_ = 0;
}
inline float Bhv_GoToPointLookBall::distance_threshold() const {
  // @@protoc_insertion_point(field_get:protos.Bhv_GoToPointLookBall.distance_threshold)
  return _internal_distance_threshold();
}
inline void Bhv_GoToPointLookBall::set_distance_threshold(float value) {
  _internal_set_distance_threshold(value);
  // @@protoc_insertion_point(field_set:protos.Bhv_GoToPointLookBall.distance_threshold)
}
inline float Bhv_GoToPointLookBall::_internal_distance_threshold() const {
  return _impl_.distance_threshold_;
}
inline void Bhv_GoToPointLookBall::_internal_set_distance_threshold(float value) {
  ;
  _impl_.distance_threshold_ = value;
}

// float max_dash_power = 3;
inline void Bhv_GoToPointLookBall::clear_max_dash_power() {
  _impl_.max_dash_power_ = 0;
}
inline float Bhv_GoToPointLookBall::max_dash_power() const {
  // @@protoc_insertion_point(field_get:protos.Bhv_GoToPointLookBall.max_dash_power)
  return _internal_max_dash_power();
}
inline void Bhv_GoToPointLookBall::set_max_dash_power(float value) {
  _internal_set_max_dash_power(value);
  // @@protoc_insertion_point(field_set:protos.Bhv_GoToPointLookBall.max_dash_power)
}
inline float Bhv_GoToPointLookBall::_internal_max_dash_power() const {
  return _impl_.max_dash_power_;
}
inline void Bhv_GoToPointLookBall::_internal_set_max_dash_power(float value) {
  ;
  _impl_.max_dash_power_ = value;
}

// -------------------------------------------------------------------

// Bhv_NeckBodyToBall

// float angle_buf = 1;
inline void Bhv_NeckBodyToBall::clear_angle_buf() {
  _impl_.angle_buf_ = 0;
}
inline float Bhv_NeckBodyToBall::angle_buf() const {
  // @@protoc_insertion_point(field_get:protos.Bhv_NeckBodyToBall.angle_buf)
  return _internal_angle_buf();
}
inline void Bhv_NeckBodyToBall::set_angle_buf(float value) {
  _internal_set_angle_buf(value);
  // @@protoc_insertion_point(field_set:protos.Bhv_NeckBodyToBall.angle_buf)
}
inline float Bhv_NeckBodyToBall::_internal_angle_buf() const {
  return _impl_.angle_buf_;
}
inline void Bhv_NeckBodyToBall::_internal_set_angle_buf(float value) {
  ;
  _impl_.angle_buf_ = value;
}

// -------------------------------------------------------------------

// Bhv_NeckBodyToPoint

// .protos.Vector2D point = 1;
inline bool Bhv_NeckBodyToPoint::has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline void Bhv_NeckBodyToPoint::clear_point() {
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Bhv_NeckBodyToPoint::_internal_point() const {
  const ::protos::Vector2D* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Bhv_NeckBodyToPoint::point() const {
  // @@protoc_insertion_point(field_get:protos.Bhv_NeckBodyToPoint.point)
  return _internal_point();
}
inline void Bhv_NeckBodyToPoint::unsafe_arena_set_allocated_point(
    ::protos::Vector2D* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Bhv_NeckBodyToPoint.point)
}
inline ::protos::Vector2D* Bhv_NeckBodyToPoint::release_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Bhv_NeckBodyToPoint::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:protos.Bhv_NeckBodyToPoint.point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Bhv_NeckBodyToPoint::_internal_mutable_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::protos::Vector2D* Bhv_NeckBodyToPoint::mutable_point() {
  ::protos::Vector2D* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:protos.Bhv_NeckBodyToPoint.point)
  return _msg;
}
inline void Bhv_NeckBodyToPoint::set_allocated_point(::protos::Vector2D* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:protos.Bhv_NeckBodyToPoint.point)
}

// float angle_buf = 2;
inline void Bhv_NeckBodyToPoint::clear_angle_buf() {
  _impl_.angle_buf_ = 0;
}
inline float Bhv_NeckBodyToPoint::angle_buf() const {
  // @@protoc_insertion_point(field_get:protos.Bhv_NeckBodyToPoint.angle_buf)
  return _internal_angle_buf();
}
inline void Bhv_NeckBodyToPoint::set_angle_buf(float value) {
  _internal_set_angle_buf(value);
  // @@protoc_insertion_point(field_set:protos.Bhv_NeckBodyToPoint.angle_buf)
}
inline float Bhv_NeckBodyToPoint::_internal_angle_buf() const {
  return _impl_.angle_buf_;
}
inline void Bhv_NeckBodyToPoint::_internal_set_angle_buf(float value) {
  ;
  _impl_.angle_buf_ = value;
}

// -------------------------------------------------------------------

// Bhv_ScanField

// -------------------------------------------------------------------

// Body_AdvanceBall

// -------------------------------------------------------------------

// Body_ClearBall

// -------------------------------------------------------------------

// Body_Dribble

// .protos.Vector2D target_point = 1;
inline bool Body_Dribble::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Body_Dribble::clear_target_point() {
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_Dribble::_internal_target_point() const {
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_Dribble::target_point() const {
  // @@protoc_insertion_point(field_get:protos.Body_Dribble.target_point)
  return _internal_target_point();
}
inline void Body_Dribble::unsafe_arena_set_allocated_target_point(
    ::protos::Vector2D* target_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = target_point;
  if (target_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_Dribble.target_point)
}
inline ::protos::Vector2D* Body_Dribble::release_target_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Body_Dribble::unsafe_arena_release_target_point() {
  // @@protoc_insertion_point(field_release:protos.Body_Dribble.target_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_Dribble::_internal_mutable_target_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.target_point_ = p;
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Body_Dribble::mutable_target_point() {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_Dribble.target_point)
  return _msg;
}
inline void Body_Dribble::set_allocated_target_point(::protos::Vector2D* target_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_point_;
  }
  if (target_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_point);
    if (message_arena != submessage_arena) {
      target_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_point_ = target_point;
  // @@protoc_insertion_point(field_set_allocated:protos.Body_Dribble.target_point)
}

// float distance_threshold = 2;
inline void Body_Dribble::clear_distance_threshold() {
  _impl_.distance_threshold_ = 0;
}
inline float Body_Dribble::distance_threshold() const {
  // @@protoc_insertion_point(field_get:protos.Body_Dribble.distance_threshold)
  return _internal_distance_threshold();
}
inline void Body_Dribble::set_distance_threshold(float value) {
  _internal_set_distance_threshold(value);
  // @@protoc_insertion_point(field_set:protos.Body_Dribble.distance_threshold)
}
inline float Body_Dribble::_internal_distance_threshold() const {
  return _impl_.distance_threshold_;
}
inline void Body_Dribble::_internal_set_distance_threshold(float value) {
  ;
  _impl_.distance_threshold_ = value;
}

// float dash_power = 3;
inline void Body_Dribble::clear_dash_power() {
  _impl_.dash_power_ = 0;
}
inline float Body_Dribble::dash_power() const {
  // @@protoc_insertion_point(field_get:protos.Body_Dribble.dash_power)
  return _internal_dash_power();
}
inline void Body_Dribble::set_dash_power(float value) {
  _internal_set_dash_power(value);
  // @@protoc_insertion_point(field_set:protos.Body_Dribble.dash_power)
}
inline float Body_Dribble::_internal_dash_power() const {
  return _impl_.dash_power_;
}
inline void Body_Dribble::_internal_set_dash_power(float value) {
  ;
  _impl_.dash_power_ = value;
}

// int32 dash_count = 4;
inline void Body_Dribble::clear_dash_count() {
  _impl_.dash_count_ = 0;
}
inline ::int32_t Body_Dribble::dash_count() const {
  // @@protoc_insertion_point(field_get:protos.Body_Dribble.dash_count)
  return _internal_dash_count();
}
inline void Body_Dribble::set_dash_count(::int32_t value) {
  _internal_set_dash_count(value);
  // @@protoc_insertion_point(field_set:protos.Body_Dribble.dash_count)
}
inline ::int32_t Body_Dribble::_internal_dash_count() const {
  return _impl_.dash_count_;
}
inline void Body_Dribble::_internal_set_dash_count(::int32_t value) {
  ;
  _impl_.dash_count_ = value;
}

// bool dodge = 5;
inline void Body_Dribble::clear_dodge() {
  _impl_.dodge_ = false;
}
inline bool Body_Dribble::dodge() const {
  // @@protoc_insertion_point(field_get:protos.Body_Dribble.dodge)
  return _internal_dodge();
}
inline void Body_Dribble::set_dodge(bool value) {
  _internal_set_dodge(value);
  // @@protoc_insertion_point(field_set:protos.Body_Dribble.dodge)
}
inline bool Body_Dribble::_internal_dodge() const {
  return _impl_.dodge_;
}
inline void Body_Dribble::_internal_set_dodge(bool value) {
  ;
  _impl_.dodge_ = value;
}

// -------------------------------------------------------------------

// Body_GoToPointDodge

// .protos.Vector2D target_point = 1;
inline bool Body_GoToPointDodge::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Body_GoToPointDodge::clear_target_point() {
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_GoToPointDodge::_internal_target_point() const {
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_GoToPointDodge::target_point() const {
  // @@protoc_insertion_point(field_get:protos.Body_GoToPointDodge.target_point)
  return _internal_target_point();
}
inline void Body_GoToPointDodge::unsafe_arena_set_allocated_target_point(
    ::protos::Vector2D* target_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = target_point;
  if (target_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_GoToPointDodge.target_point)
}
inline ::protos::Vector2D* Body_GoToPointDodge::release_target_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Body_GoToPointDodge::unsafe_arena_release_target_point() {
  // @@protoc_insertion_point(field_release:protos.Body_GoToPointDodge.target_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_GoToPointDodge::_internal_mutable_target_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.target_point_ = p;
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Body_GoToPointDodge::mutable_target_point() {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_GoToPointDodge.target_point)
  return _msg;
}
inline void Body_GoToPointDodge::set_allocated_target_point(::protos::Vector2D* target_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_point_;
  }
  if (target_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_point);
    if (message_arena != submessage_arena) {
      target_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_point_ = target_point;
  // @@protoc_insertion_point(field_set_allocated:protos.Body_GoToPointDodge.target_point)
}

// float dash_power = 2;
inline void Body_GoToPointDodge::clear_dash_power() {
  _impl_.dash_power_ = 0;
}
inline float Body_GoToPointDodge::dash_power() const {
  // @@protoc_insertion_point(field_get:protos.Body_GoToPointDodge.dash_power)
  return _internal_dash_power();
}
inline void Body_GoToPointDodge::set_dash_power(float value) {
  _internal_set_dash_power(value);
  // @@protoc_insertion_point(field_set:protos.Body_GoToPointDodge.dash_power)
}
inline float Body_GoToPointDodge::_internal_dash_power() const {
  return _impl_.dash_power_;
}
inline void Body_GoToPointDodge::_internal_set_dash_power(float value) {
  ;
  _impl_.dash_power_ = value;
}

// -------------------------------------------------------------------

// Body_HoldBall

// bool do_turn = 1;
inline void Body_HoldBall::clear_do_turn() {
  _impl_.do_turn_ = false;
}
inline bool Body_HoldBall::do_turn() const {
  // @@protoc_insertion_point(field_get:protos.Body_HoldBall.do_turn)
  return _internal_do_turn();
}
inline void Body_HoldBall::set_do_turn(bool value) {
  _internal_set_do_turn(value);
  // @@protoc_insertion_point(field_set:protos.Body_HoldBall.do_turn)
}
inline bool Body_HoldBall::_internal_do_turn() const {
  return _impl_.do_turn_;
}
inline void Body_HoldBall::_internal_set_do_turn(bool value) {
  ;
  _impl_.do_turn_ = value;
}

// .protos.Vector2D turn_target_point = 2;
inline bool Body_HoldBall::has_turn_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.turn_target_point_ != nullptr);
  return value;
}
inline void Body_HoldBall::clear_turn_target_point() {
  if (_impl_.turn_target_point_ != nullptr) _impl_.turn_target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_HoldBall::_internal_turn_target_point() const {
  const ::protos::Vector2D* p = _impl_.turn_target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_HoldBall::turn_target_point() const {
  // @@protoc_insertion_point(field_get:protos.Body_HoldBall.turn_target_point)
  return _internal_turn_target_point();
}
inline void Body_HoldBall::unsafe_arena_set_allocated_turn_target_point(
    ::protos::Vector2D* turn_target_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.turn_target_point_);
  }
  _impl_.turn_target_point_ = turn_target_point;
  if (turn_target_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_HoldBall.turn_target_point)
}
inline ::protos::Vector2D* Body_HoldBall::release_turn_target_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.turn_target_point_;
  _impl_.turn_target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Body_HoldBall::unsafe_arena_release_turn_target_point() {
  // @@protoc_insertion_point(field_release:protos.Body_HoldBall.turn_target_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.turn_target_point_;
  _impl_.turn_target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_HoldBall::_internal_mutable_turn_target_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.turn_target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.turn_target_point_ = p;
  }
  return _impl_.turn_target_point_;
}
inline ::protos::Vector2D* Body_HoldBall::mutable_turn_target_point() {
  ::protos::Vector2D* _msg = _internal_mutable_turn_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_HoldBall.turn_target_point)
  return _msg;
}
inline void Body_HoldBall::set_allocated_turn_target_point(::protos::Vector2D* turn_target_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.turn_target_point_;
  }
  if (turn_target_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(turn_target_point);
    if (message_arena != submessage_arena) {
      turn_target_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, turn_target_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.turn_target_point_ = turn_target_point;
  // @@protoc_insertion_point(field_set_allocated:protos.Body_HoldBall.turn_target_point)
}

// .protos.Vector2D kick_target_point = 3;
inline bool Body_HoldBall::has_kick_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kick_target_point_ != nullptr);
  return value;
}
inline void Body_HoldBall::clear_kick_target_point() {
  if (_impl_.kick_target_point_ != nullptr) _impl_.kick_target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& Body_HoldBall::_internal_kick_target_point() const {
  const ::protos::Vector2D* p = _impl_.kick_target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_HoldBall::kick_target_point() const {
  // @@protoc_insertion_point(field_get:protos.Body_HoldBall.kick_target_point)
  return _internal_kick_target_point();
}
inline void Body_HoldBall::unsafe_arena_set_allocated_kick_target_point(
    ::protos::Vector2D* kick_target_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.kick_target_point_);
  }
  _impl_.kick_target_point_ = kick_target_point;
  if (kick_target_point) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_HoldBall.kick_target_point)
}
inline ::protos::Vector2D* Body_HoldBall::release_kick_target_point() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.kick_target_point_;
  _impl_.kick_target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Body_HoldBall::unsafe_arena_release_kick_target_point() {
  // @@protoc_insertion_point(field_release:protos.Body_HoldBall.kick_target_point)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.kick_target_point_;
  _impl_.kick_target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_HoldBall::_internal_mutable_kick_target_point() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.kick_target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.kick_target_point_ = p;
  }
  return _impl_.kick_target_point_;
}
inline ::protos::Vector2D* Body_HoldBall::mutable_kick_target_point() {
  ::protos::Vector2D* _msg = _internal_mutable_kick_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_HoldBall.kick_target_point)
  return _msg;
}
inline void Body_HoldBall::set_allocated_kick_target_point(::protos::Vector2D* kick_target_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.kick_target_point_;
  }
  if (kick_target_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(kick_target_point);
    if (message_arena != submessage_arena) {
      kick_target_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kick_target_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.kick_target_point_ = kick_target_point;
  // @@protoc_insertion_point(field_set_allocated:protos.Body_HoldBall.kick_target_point)
}

// -------------------------------------------------------------------

// Body_Intercept

// bool save_recovery = 1;
inline void Body_Intercept::clear_save_recovery() {
  _impl_.save_recovery_ = false;
}
inline bool Body_Intercept::save_recovery() const {
  // @@protoc_insertion_point(field_get:protos.Body_Intercept.save_recovery)
  return _internal_save_recovery();
}
inline void Body_Intercept::set_save_recovery(bool value) {
  _internal_set_save_recovery(value);
  // @@protoc_insertion_point(field_set:protos.Body_Intercept.save_recovery)
}
inline bool Body_Intercept::_internal_save_recovery() const {
  return _impl_.save_recovery_;
}
inline void Body_Intercept::_internal_set_save_recovery(bool value) {
  ;
  _impl_.save_recovery_ = value;
}

// .protos.Vector2D face_point = 2;
inline bool Body_Intercept::has_face_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.face_point_ != nullptr);
  return value;
}
inline void Body_Intercept::clear_face_point() {
  if (_impl_.face_point_ != nullptr) _impl_.face_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_Intercept::_internal_face_point() const {
  const ::protos::Vector2D* p = _impl_.face_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_Intercept::face_point() const {
  // @@protoc_insertion_point(field_get:protos.Body_Intercept.face_point)
  return _internal_face_point();
}
inline void Body_Intercept::unsafe_arena_set_allocated_face_point(
    ::protos::Vector2D* face_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.face_point_);
  }
  _impl_.face_point_ = face_point;
  if (face_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_Intercept.face_point)
}
inline ::protos::Vector2D* Body_Intercept::release_face_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.face_point_;
  _impl_.face_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Body_Intercept::unsafe_arena_release_face_point() {
  // @@protoc_insertion_point(field_release:protos.Body_Intercept.face_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.face_point_;
  _impl_.face_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_Intercept::_internal_mutable_face_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.face_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.face_point_ = p;
  }
  return _impl_.face_point_;
}
inline ::protos::Vector2D* Body_Intercept::mutable_face_point() {
  ::protos::Vector2D* _msg = _internal_mutable_face_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_Intercept.face_point)
  return _msg;
}
inline void Body_Intercept::set_allocated_face_point(::protos::Vector2D* face_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.face_point_;
  }
  if (face_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(face_point);
    if (message_arena != submessage_arena) {
      face_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, face_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.face_point_ = face_point;
  // @@protoc_insertion_point(field_set_allocated:protos.Body_Intercept.face_point)
}

// -------------------------------------------------------------------

// Body_KickOneStep

// .protos.Vector2D target_point = 1;
inline bool Body_KickOneStep::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Body_KickOneStep::clear_target_point() {
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_KickOneStep::_internal_target_point() const {
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_KickOneStep::target_point() const {
  // @@protoc_insertion_point(field_get:protos.Body_KickOneStep.target_point)
  return _internal_target_point();
}
inline void Body_KickOneStep::unsafe_arena_set_allocated_target_point(
    ::protos::Vector2D* target_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = target_point;
  if (target_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_KickOneStep.target_point)
}
inline ::protos::Vector2D* Body_KickOneStep::release_target_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Body_KickOneStep::unsafe_arena_release_target_point() {
  // @@protoc_insertion_point(field_release:protos.Body_KickOneStep.target_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_KickOneStep::_internal_mutable_target_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.target_point_ = p;
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Body_KickOneStep::mutable_target_point() {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_KickOneStep.target_point)
  return _msg;
}
inline void Body_KickOneStep::set_allocated_target_point(::protos::Vector2D* target_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_point_;
  }
  if (target_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_point);
    if (message_arena != submessage_arena) {
      target_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_point_ = target_point;
  // @@protoc_insertion_point(field_set_allocated:protos.Body_KickOneStep.target_point)
}

// float first_speed = 2;
inline void Body_KickOneStep::clear_first_speed() {
  _impl_.first_speed_ = 0;
}
inline float Body_KickOneStep::first_speed() const {
  // @@protoc_insertion_point(field_get:protos.Body_KickOneStep.first_speed)
  return _internal_first_speed();
}
inline void Body_KickOneStep::set_first_speed(float value) {
  _internal_set_first_speed(value);
  // @@protoc_insertion_point(field_set:protos.Body_KickOneStep.first_speed)
}
inline float Body_KickOneStep::_internal_first_speed() const {
  return _impl_.first_speed_;
}
inline void Body_KickOneStep::_internal_set_first_speed(float value) {
  ;
  _impl_.first_speed_ = value;
}

// bool force_mode = 3;
inline void Body_KickOneStep::clear_force_mode() {
  _impl_.force_mode_ = false;
}
inline bool Body_KickOneStep::force_mode() const {
  // @@protoc_insertion_point(field_get:protos.Body_KickOneStep.force_mode)
  return _internal_force_mode();
}
inline void Body_KickOneStep::set_force_mode(bool value) {
  _internal_set_force_mode(value);
  // @@protoc_insertion_point(field_set:protos.Body_KickOneStep.force_mode)
}
inline bool Body_KickOneStep::_internal_force_mode() const {
  return _impl_.force_mode_;
}
inline void Body_KickOneStep::_internal_set_force_mode(bool value) {
  ;
  _impl_.force_mode_ = value;
}

// -------------------------------------------------------------------

// Body_StopBall

// -------------------------------------------------------------------

// Body_StopDash

// bool save_recovery = 1;
inline void Body_StopDash::clear_save_recovery() {
  _impl_.save_recovery_ = false;
}
inline bool Body_StopDash::save_recovery() const {
  // @@protoc_insertion_point(field_get:protos.Body_StopDash.save_recovery)
  return _internal_save_recovery();
}
inline void Body_StopDash::set_save_recovery(bool value) {
  _internal_set_save_recovery(value);
  // @@protoc_insertion_point(field_set:protos.Body_StopDash.save_recovery)
}
inline bool Body_StopDash::_internal_save_recovery() const {
  return _impl_.save_recovery_;
}
inline void Body_StopDash::_internal_set_save_recovery(bool value) {
  ;
  _impl_.save_recovery_ = value;
}

// -------------------------------------------------------------------

// Body_TackleToPoint

// .protos.Vector2D target_point = 1;
inline bool Body_TackleToPoint::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Body_TackleToPoint::clear_target_point() {
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_TackleToPoint::_internal_target_point() const {
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_TackleToPoint::target_point() const {
  // @@protoc_insertion_point(field_get:protos.Body_TackleToPoint.target_point)
  return _internal_target_point();
}
inline void Body_TackleToPoint::unsafe_arena_set_allocated_target_point(
    ::protos::Vector2D* target_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = target_point;
  if (target_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_TackleToPoint.target_point)
}
inline ::protos::Vector2D* Body_TackleToPoint::release_target_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Body_TackleToPoint::unsafe_arena_release_target_point() {
  // @@protoc_insertion_point(field_release:protos.Body_TackleToPoint.target_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_TackleToPoint::_internal_mutable_target_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.target_point_ = p;
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Body_TackleToPoint::mutable_target_point() {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_TackleToPoint.target_point)
  return _msg;
}
inline void Body_TackleToPoint::set_allocated_target_point(::protos::Vector2D* target_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_point_;
  }
  if (target_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_point);
    if (message_arena != submessage_arena) {
      target_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_point_ = target_point;
  // @@protoc_insertion_point(field_set_allocated:protos.Body_TackleToPoint.target_point)
}

// float min_probability = 2;
inline void Body_TackleToPoint::clear_min_probability() {
  _impl_.min_probability_ = 0;
}
inline float Body_TackleToPoint::min_probability() const {
  // @@protoc_insertion_point(field_get:protos.Body_TackleToPoint.min_probability)
  return _internal_min_probability();
}
inline void Body_TackleToPoint::set_min_probability(float value) {
  _internal_set_min_probability(value);
  // @@protoc_insertion_point(field_set:protos.Body_TackleToPoint.min_probability)
}
inline float Body_TackleToPoint::_internal_min_probability() const {
  return _impl_.min_probability_;
}
inline void Body_TackleToPoint::_internal_set_min_probability(float value) {
  ;
  _impl_.min_probability_ = value;
}

// float min_speed = 3;
inline void Body_TackleToPoint::clear_min_speed() {
  _impl_.min_speed_ = 0;
}
inline float Body_TackleToPoint::min_speed() const {
  // @@protoc_insertion_point(field_get:protos.Body_TackleToPoint.min_speed)
  return _internal_min_speed();
}
inline void Body_TackleToPoint::set_min_speed(float value) {
  _internal_set_min_speed(value);
  // @@protoc_insertion_point(field_set:protos.Body_TackleToPoint.min_speed)
}
inline float Body_TackleToPoint::_internal_min_speed() const {
  return _impl_.min_speed_;
}
inline void Body_TackleToPoint::_internal_set_min_speed(float value) {
  ;
  _impl_.min_speed_ = value;
}

// -------------------------------------------------------------------

// Body_TurnToAngle

// float angle = 1;
inline void Body_TurnToAngle::clear_angle() {
  _impl_.angle_ = 0;
}
inline float Body_TurnToAngle::angle() const {
  // @@protoc_insertion_point(field_get:protos.Body_TurnToAngle.angle)
  return _internal_angle();
}
inline void Body_TurnToAngle::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:protos.Body_TurnToAngle.angle)
}
inline float Body_TurnToAngle::_internal_angle() const {
  return _impl_.angle_;
}
inline void Body_TurnToAngle::_internal_set_angle(float value) {
  ;
  _impl_.angle_ = value;
}

// -------------------------------------------------------------------

// Body_TurnToBall

// int32 cycle = 1;
inline void Body_TurnToBall::clear_cycle() {
  _impl_.cycle_ = 0;
}
inline ::int32_t Body_TurnToBall::cycle() const {
  // @@protoc_insertion_point(field_get:protos.Body_TurnToBall.cycle)
  return _internal_cycle();
}
inline void Body_TurnToBall::set_cycle(::int32_t value) {
  _internal_set_cycle(value);
  // @@protoc_insertion_point(field_set:protos.Body_TurnToBall.cycle)
}
inline ::int32_t Body_TurnToBall::_internal_cycle() const {
  return _impl_.cycle_;
}
inline void Body_TurnToBall::_internal_set_cycle(::int32_t value) {
  ;
  _impl_.cycle_ = value;
}

// -------------------------------------------------------------------

// Body_TurnToPoint

// .protos.Vector2D target_point = 1;
inline bool Body_TurnToPoint::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Body_TurnToPoint::clear_target_point() {
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_TurnToPoint::_internal_target_point() const {
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_TurnToPoint::target_point() const {
  // @@protoc_insertion_point(field_get:protos.Body_TurnToPoint.target_point)
  return _internal_target_point();
}
inline void Body_TurnToPoint::unsafe_arena_set_allocated_target_point(
    ::protos::Vector2D* target_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = target_point;
  if (target_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_TurnToPoint.target_point)
}
inline ::protos::Vector2D* Body_TurnToPoint::release_target_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Body_TurnToPoint::unsafe_arena_release_target_point() {
  // @@protoc_insertion_point(field_release:protos.Body_TurnToPoint.target_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_TurnToPoint::_internal_mutable_target_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.target_point_ = p;
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Body_TurnToPoint::mutable_target_point() {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_TurnToPoint.target_point)
  return _msg;
}
inline void Body_TurnToPoint::set_allocated_target_point(::protos::Vector2D* target_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_point_;
  }
  if (target_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_point);
    if (message_arena != submessage_arena) {
      target_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_point_ = target_point;
  // @@protoc_insertion_point(field_set_allocated:protos.Body_TurnToPoint.target_point)
}

// int32 cycle = 2;
inline void Body_TurnToPoint::clear_cycle() {
  _impl_.cycle_ = 0;
}
inline ::int32_t Body_TurnToPoint::cycle() const {
  // @@protoc_insertion_point(field_get:protos.Body_TurnToPoint.cycle)
  return _internal_cycle();
}
inline void Body_TurnToPoint::set_cycle(::int32_t value) {
  _internal_set_cycle(value);
  // @@protoc_insertion_point(field_set:protos.Body_TurnToPoint.cycle)
}
inline ::int32_t Body_TurnToPoint::_internal_cycle() const {
  return _impl_.cycle_;
}
inline void Body_TurnToPoint::_internal_set_cycle(::int32_t value) {
  ;
  _impl_.cycle_ = value;
}

// -------------------------------------------------------------------

// Focus_MoveToPoint

// .protos.Vector2D target_point = 1;
inline bool Focus_MoveToPoint::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Focus_MoveToPoint::clear_target_point() {
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Focus_MoveToPoint::_internal_target_point() const {
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Focus_MoveToPoint::target_point() const {
  // @@protoc_insertion_point(field_get:protos.Focus_MoveToPoint.target_point)
  return _internal_target_point();
}
inline void Focus_MoveToPoint::unsafe_arena_set_allocated_target_point(
    ::protos::Vector2D* target_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = target_point;
  if (target_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Focus_MoveToPoint.target_point)
}
inline ::protos::Vector2D* Focus_MoveToPoint::release_target_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Focus_MoveToPoint::unsafe_arena_release_target_point() {
  // @@protoc_insertion_point(field_release:protos.Focus_MoveToPoint.target_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Focus_MoveToPoint::_internal_mutable_target_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.target_point_ = p;
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Focus_MoveToPoint::mutable_target_point() {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Focus_MoveToPoint.target_point)
  return _msg;
}
inline void Focus_MoveToPoint::set_allocated_target_point(::protos::Vector2D* target_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_point_;
  }
  if (target_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_point);
    if (message_arena != submessage_arena) {
      target_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_point_ = target_point;
  // @@protoc_insertion_point(field_set_allocated:protos.Focus_MoveToPoint.target_point)
}

// -------------------------------------------------------------------

// Focus_Reset

// -------------------------------------------------------------------

// Neck_ScanField

// -------------------------------------------------------------------

// Neck_ScanPlayers

// -------------------------------------------------------------------

// Neck_TurnToBallAndPlayer

// .protos.Side side = 1;
inline void Neck_TurnToBallAndPlayer::clear_side() {
  _impl_.side_ = 0;
}
inline ::protos::Side Neck_TurnToBallAndPlayer::side() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToBallAndPlayer.side)
  return _internal_side();
}
inline void Neck_TurnToBallAndPlayer::set_side(::protos::Side value) {
   _internal_set_side(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToBallAndPlayer.side)
}
inline ::protos::Side Neck_TurnToBallAndPlayer::_internal_side() const {
  return static_cast<::protos::Side>(_impl_.side_);
}
inline void Neck_TurnToBallAndPlayer::_internal_set_side(::protos::Side value) {
  ;
  _impl_.side_ = value;
}

// int32 uniform_number = 2;
inline void Neck_TurnToBallAndPlayer::clear_uniform_number() {
  _impl_.uniform_number_ = 0;
}
inline ::int32_t Neck_TurnToBallAndPlayer::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToBallAndPlayer.uniform_number)
  return _internal_uniform_number();
}
inline void Neck_TurnToBallAndPlayer::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToBallAndPlayer.uniform_number)
}
inline ::int32_t Neck_TurnToBallAndPlayer::_internal_uniform_number() const {
  return _impl_.uniform_number_;
}
inline void Neck_TurnToBallAndPlayer::_internal_set_uniform_number(::int32_t value) {
  ;
  _impl_.uniform_number_ = value;
}

// int32 count_threshold = 3;
inline void Neck_TurnToBallAndPlayer::clear_count_threshold() {
  _impl_.count_threshold_ = 0;
}
inline ::int32_t Neck_TurnToBallAndPlayer::count_threshold() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToBallAndPlayer.count_threshold)
  return _internal_count_threshold();
}
inline void Neck_TurnToBallAndPlayer::set_count_threshold(::int32_t value) {
  _internal_set_count_threshold(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToBallAndPlayer.count_threshold)
}
inline ::int32_t Neck_TurnToBallAndPlayer::_internal_count_threshold() const {
  return _impl_.count_threshold_;
}
inline void Neck_TurnToBallAndPlayer::_internal_set_count_threshold(::int32_t value) {
  ;
  _impl_.count_threshold_ = value;
}

// -------------------------------------------------------------------

// Neck_TurnToBallOrScan

// int32 count_threshold = 1;
inline void Neck_TurnToBallOrScan::clear_count_threshold() {
  _impl_.count_threshold_ = 0;
}
inline ::int32_t Neck_TurnToBallOrScan::count_threshold() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToBallOrScan.count_threshold)
  return _internal_count_threshold();
}
inline void Neck_TurnToBallOrScan::set_count_threshold(::int32_t value) {
  _internal_set_count_threshold(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToBallOrScan.count_threshold)
}
inline ::int32_t Neck_TurnToBallOrScan::_internal_count_threshold() const {
  return _impl_.count_threshold_;
}
inline void Neck_TurnToBallOrScan::_internal_set_count_threshold(::int32_t value) {
  ;
  _impl_.count_threshold_ = value;
}

// -------------------------------------------------------------------

// Neck_TurnToBall

// -------------------------------------------------------------------

// Neck_TurnToGoalieOrScan

// int32 count_threshold = 1;
inline void Neck_TurnToGoalieOrScan::clear_count_threshold() {
  _impl_.count_threshold_ = 0;
}
inline ::int32_t Neck_TurnToGoalieOrScan::count_threshold() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToGoalieOrScan.count_threshold)
  return _internal_count_threshold();
}
inline void Neck_TurnToGoalieOrScan::set_count_threshold(::int32_t value) {
  _internal_set_count_threshold(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToGoalieOrScan.count_threshold)
}
inline ::int32_t Neck_TurnToGoalieOrScan::_internal_count_threshold() const {
  return _impl_.count_threshold_;
}
inline void Neck_TurnToGoalieOrScan::_internal_set_count_threshold(::int32_t value) {
  ;
  _impl_.count_threshold_ = value;
}

// -------------------------------------------------------------------

// Neck_TurnToLowConfTeammate

// -------------------------------------------------------------------

// Neck_TurnToPlayerOrScan

// .protos.Side side = 1;
inline void Neck_TurnToPlayerOrScan::clear_side() {
  _impl_.side_ = 0;
}
inline ::protos::Side Neck_TurnToPlayerOrScan::side() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToPlayerOrScan.side)
  return _internal_side();
}
inline void Neck_TurnToPlayerOrScan::set_side(::protos::Side value) {
   _internal_set_side(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToPlayerOrScan.side)
}
inline ::protos::Side Neck_TurnToPlayerOrScan::_internal_side() const {
  return static_cast<::protos::Side>(_impl_.side_);
}
inline void Neck_TurnToPlayerOrScan::_internal_set_side(::protos::Side value) {
  ;
  _impl_.side_ = value;
}

// int32 uniform_number = 2;
inline void Neck_TurnToPlayerOrScan::clear_uniform_number() {
  _impl_.uniform_number_ = 0;
}
inline ::int32_t Neck_TurnToPlayerOrScan::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToPlayerOrScan.uniform_number)
  return _internal_uniform_number();
}
inline void Neck_TurnToPlayerOrScan::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToPlayerOrScan.uniform_number)
}
inline ::int32_t Neck_TurnToPlayerOrScan::_internal_uniform_number() const {
  return _impl_.uniform_number_;
}
inline void Neck_TurnToPlayerOrScan::_internal_set_uniform_number(::int32_t value) {
  ;
  _impl_.uniform_number_ = value;
}

// int32 count_threshold = 3;
inline void Neck_TurnToPlayerOrScan::clear_count_threshold() {
  _impl_.count_threshold_ = 0;
}
inline ::int32_t Neck_TurnToPlayerOrScan::count_threshold() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToPlayerOrScan.count_threshold)
  return _internal_count_threshold();
}
inline void Neck_TurnToPlayerOrScan::set_count_threshold(::int32_t value) {
  _internal_set_count_threshold(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToPlayerOrScan.count_threshold)
}
inline ::int32_t Neck_TurnToPlayerOrScan::_internal_count_threshold() const {
  return _impl_.count_threshold_;
}
inline void Neck_TurnToPlayerOrScan::_internal_set_count_threshold(::int32_t value) {
  ;
  _impl_.count_threshold_ = value;
}

// -------------------------------------------------------------------

// Neck_TurnToPoint

// .protos.Vector2D target_point = 1;
inline bool Neck_TurnToPoint::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Neck_TurnToPoint::clear_target_point() {
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Neck_TurnToPoint::_internal_target_point() const {
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(
      ::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Neck_TurnToPoint::target_point() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToPoint.target_point)
  return _internal_target_point();
}
inline void Neck_TurnToPoint::unsafe_arena_set_allocated_target_point(
    ::protos::Vector2D* target_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = target_point;
  if (target_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Neck_TurnToPoint.target_point)
}
inline ::protos::Vector2D* Neck_TurnToPoint::release_target_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protos::Vector2D* Neck_TurnToPoint::unsafe_arena_release_target_point() {
  // @@protoc_insertion_point(field_release:protos.Neck_TurnToPoint.target_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Neck_TurnToPoint::_internal_mutable_target_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArenaForAllocation());
    _impl_.target_point_ = p;
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Neck_TurnToPoint::mutable_target_point() {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Neck_TurnToPoint.target_point)
  return _msg;
}
inline void Neck_TurnToPoint::set_allocated_target_point(::protos::Vector2D* target_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_point_;
  }
  if (target_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_point);
    if (message_arena != submessage_arena) {
      target_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_point_ = target_point;
  // @@protoc_insertion_point(field_set_allocated:protos.Neck_TurnToPoint.target_point)
}

// -------------------------------------------------------------------

// Neck_TurnToRelative

// float angle = 1;
inline void Neck_TurnToRelative::clear_angle() {
  _impl_.angle_ = 0;
}
inline float Neck_TurnToRelative::angle() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToRelative.angle)
  return _internal_angle();
}
inline void Neck_TurnToRelative::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToRelative.angle)
}
inline float Neck_TurnToRelative::_internal_angle() const {
  return _impl_.angle_;
}
inline void Neck_TurnToRelative::_internal_set_angle(float value) {
  ;
  _impl_.angle_ = value;
}

// -------------------------------------------------------------------

// View_ChangeWidth

// .protos.ViewWidth view_width = 1;
inline void View_ChangeWidth::clear_view_width() {
  _impl_.view_width_ = 0;
}
inline ::protos::ViewWidth View_ChangeWidth::view_width() const {
  // @@protoc_insertion_point(field_get:protos.View_ChangeWidth.view_width)
  return _internal_view_width();
}
inline void View_ChangeWidth::set_view_width(::protos::ViewWidth value) {
   _internal_set_view_width(value);
  // @@protoc_insertion_point(field_set:protos.View_ChangeWidth.view_width)
}
inline ::protos::ViewWidth View_ChangeWidth::_internal_view_width() const {
  return static_cast<::protos::ViewWidth>(_impl_.view_width_);
}
inline void View_ChangeWidth::_internal_set_view_width(::protos::ViewWidth value) {
  ;
  _impl_.view_width_ = value;
}

// -------------------------------------------------------------------

// View_Normal

// -------------------------------------------------------------------

// View_Synch

// -------------------------------------------------------------------

// View_Wide

// -------------------------------------------------------------------

// Action

// .protos.Dash dash = 1;
inline bool Action::has_dash() const {
  return action_case() == kDash;
}
inline bool Action::_internal_has_dash() const {
  return action_case() == kDash;
}
inline void Action::set_has_dash() {
  _impl_._oneof_case_[0] = kDash;
}
inline void Action::clear_dash() {
  if (action_case() == kDash) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.dash_;
    }
    clear_has_action();
  }
}
inline ::protos::Dash* Action::release_dash() {
  // @@protoc_insertion_point(field_release:protos.Action.dash)
  if (action_case() == kDash) {
    clear_has_action();
    ::protos::Dash* temp = _impl_.action_.dash_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.dash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Dash& Action::_internal_dash() const {
  return action_case() == kDash
      ? *_impl_.action_.dash_
      : reinterpret_cast<::protos::Dash&>(::protos::_Dash_default_instance_);
}
inline const ::protos::Dash& Action::dash() const {
  // @@protoc_insertion_point(field_get:protos.Action.dash)
  return _internal_dash();
}
inline ::protos::Dash* Action::unsafe_arena_release_dash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.dash)
  if (action_case() == kDash) {
    clear_has_action();
    ::protos::Dash* temp = _impl_.action_.dash_;
    _impl_.action_.dash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_dash(::protos::Dash* dash) {
  clear_action();
  if (dash) {
    set_has_dash();
    _impl_.action_.dash_ = dash;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.dash)
}
inline ::protos::Dash* Action::_internal_mutable_dash() {
  if (action_case() != kDash) {
    clear_action();
    set_has_dash();
    _impl_.action_.dash_ = CreateMaybeMessage< ::protos::Dash >(GetArenaForAllocation());
  }
  return _impl_.action_.dash_;
}
inline ::protos::Dash* Action::mutable_dash() {
  ::protos::Dash* _msg = _internal_mutable_dash();
  // @@protoc_insertion_point(field_mutable:protos.Action.dash)
  return _msg;
}

// .protos.Turn turn = 2;
inline bool Action::has_turn() const {
  return action_case() == kTurn;
}
inline bool Action::_internal_has_turn() const {
  return action_case() == kTurn;
}
inline void Action::set_has_turn() {
  _impl_._oneof_case_[0] = kTurn;
}
inline void Action::clear_turn() {
  if (action_case() == kTurn) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.turn_;
    }
    clear_has_action();
  }
}
inline ::protos::Turn* Action::release_turn() {
  // @@protoc_insertion_point(field_release:protos.Action.turn)
  if (action_case() == kTurn) {
    clear_has_action();
    ::protos::Turn* temp = _impl_.action_.turn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.turn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Turn& Action::_internal_turn() const {
  return action_case() == kTurn
      ? *_impl_.action_.turn_
      : reinterpret_cast<::protos::Turn&>(::protos::_Turn_default_instance_);
}
inline const ::protos::Turn& Action::turn() const {
  // @@protoc_insertion_point(field_get:protos.Action.turn)
  return _internal_turn();
}
inline ::protos::Turn* Action::unsafe_arena_release_turn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.turn)
  if (action_case() == kTurn) {
    clear_has_action();
    ::protos::Turn* temp = _impl_.action_.turn_;
    _impl_.action_.turn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_turn(::protos::Turn* turn) {
  clear_action();
  if (turn) {
    set_has_turn();
    _impl_.action_.turn_ = turn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.turn)
}
inline ::protos::Turn* Action::_internal_mutable_turn() {
  if (action_case() != kTurn) {
    clear_action();
    set_has_turn();
    _impl_.action_.turn_ = CreateMaybeMessage< ::protos::Turn >(GetArenaForAllocation());
  }
  return _impl_.action_.turn_;
}
inline ::protos::Turn* Action::mutable_turn() {
  ::protos::Turn* _msg = _internal_mutable_turn();
  // @@protoc_insertion_point(field_mutable:protos.Action.turn)
  return _msg;
}

// .protos.Kick kick = 3;
inline bool Action::has_kick() const {
  return action_case() == kKick;
}
inline bool Action::_internal_has_kick() const {
  return action_case() == kKick;
}
inline void Action::set_has_kick() {
  _impl_._oneof_case_[0] = kKick;
}
inline void Action::clear_kick() {
  if (action_case() == kKick) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.kick_;
    }
    clear_has_action();
  }
}
inline ::protos::Kick* Action::release_kick() {
  // @@protoc_insertion_point(field_release:protos.Action.kick)
  if (action_case() == kKick) {
    clear_has_action();
    ::protos::Kick* temp = _impl_.action_.kick_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.kick_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Kick& Action::_internal_kick() const {
  return action_case() == kKick
      ? *_impl_.action_.kick_
      : reinterpret_cast<::protos::Kick&>(::protos::_Kick_default_instance_);
}
inline const ::protos::Kick& Action::kick() const {
  // @@protoc_insertion_point(field_get:protos.Action.kick)
  return _internal_kick();
}
inline ::protos::Kick* Action::unsafe_arena_release_kick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.kick)
  if (action_case() == kKick) {
    clear_has_action();
    ::protos::Kick* temp = _impl_.action_.kick_;
    _impl_.action_.kick_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_kick(::protos::Kick* kick) {
  clear_action();
  if (kick) {
    set_has_kick();
    _impl_.action_.kick_ = kick;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.kick)
}
inline ::protos::Kick* Action::_internal_mutable_kick() {
  if (action_case() != kKick) {
    clear_action();
    set_has_kick();
    _impl_.action_.kick_ = CreateMaybeMessage< ::protos::Kick >(GetArenaForAllocation());
  }
  return _impl_.action_.kick_;
}
inline ::protos::Kick* Action::mutable_kick() {
  ::protos::Kick* _msg = _internal_mutable_kick();
  // @@protoc_insertion_point(field_mutable:protos.Action.kick)
  return _msg;
}

// .protos.Tackle tackle = 4;
inline bool Action::has_tackle() const {
  return action_case() == kTackle;
}
inline bool Action::_internal_has_tackle() const {
  return action_case() == kTackle;
}
inline void Action::set_has_tackle() {
  _impl_._oneof_case_[0] = kTackle;
}
inline void Action::clear_tackle() {
  if (action_case() == kTackle) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.tackle_;
    }
    clear_has_action();
  }
}
inline ::protos::Tackle* Action::release_tackle() {
  // @@protoc_insertion_point(field_release:protos.Action.tackle)
  if (action_case() == kTackle) {
    clear_has_action();
    ::protos::Tackle* temp = _impl_.action_.tackle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.tackle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Tackle& Action::_internal_tackle() const {
  return action_case() == kTackle
      ? *_impl_.action_.tackle_
      : reinterpret_cast<::protos::Tackle&>(::protos::_Tackle_default_instance_);
}
inline const ::protos::Tackle& Action::tackle() const {
  // @@protoc_insertion_point(field_get:protos.Action.tackle)
  return _internal_tackle();
}
inline ::protos::Tackle* Action::unsafe_arena_release_tackle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.tackle)
  if (action_case() == kTackle) {
    clear_has_action();
    ::protos::Tackle* temp = _impl_.action_.tackle_;
    _impl_.action_.tackle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_tackle(::protos::Tackle* tackle) {
  clear_action();
  if (tackle) {
    set_has_tackle();
    _impl_.action_.tackle_ = tackle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.tackle)
}
inline ::protos::Tackle* Action::_internal_mutable_tackle() {
  if (action_case() != kTackle) {
    clear_action();
    set_has_tackle();
    _impl_.action_.tackle_ = CreateMaybeMessage< ::protos::Tackle >(GetArenaForAllocation());
  }
  return _impl_.action_.tackle_;
}
inline ::protos::Tackle* Action::mutable_tackle() {
  ::protos::Tackle* _msg = _internal_mutable_tackle();
  // @@protoc_insertion_point(field_mutable:protos.Action.tackle)
  return _msg;
}

// .protos.Catch catch = 5;
inline bool Action::has_catch_() const {
  return action_case() == kCatch;
}
inline bool Action::_internal_has_catch_() const {
  return action_case() == kCatch;
}
inline void Action::set_has_catch_() {
  _impl_._oneof_case_[0] = kCatch;
}
inline void Action::clear_catch_() {
  if (action_case() == kCatch) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.catch__;
    }
    clear_has_action();
  }
}
inline ::protos::Catch* Action::release_catch_() {
  // @@protoc_insertion_point(field_release:protos.Action.catch)
  if (action_case() == kCatch) {
    clear_has_action();
    ::protos::Catch* temp = _impl_.action_.catch__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.catch__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Catch& Action::_internal_catch_() const {
  return action_case() == kCatch
      ? *_impl_.action_.catch__
      : reinterpret_cast<::protos::Catch&>(::protos::_Catch_default_instance_);
}
inline const ::protos::Catch& Action::catch_() const {
  // @@protoc_insertion_point(field_get:protos.Action.catch)
  return _internal_catch_();
}
inline ::protos::Catch* Action::unsafe_arena_release_catch_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.catch)
  if (action_case() == kCatch) {
    clear_has_action();
    ::protos::Catch* temp = _impl_.action_.catch__;
    _impl_.action_.catch__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_catch_(::protos::Catch* catch_) {
  clear_action();
  if (catch_) {
    set_has_catch_();
    _impl_.action_.catch__ = catch_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.catch)
}
inline ::protos::Catch* Action::_internal_mutable_catch_() {
  if (action_case() != kCatch) {
    clear_action();
    set_has_catch_();
    _impl_.action_.catch__ = CreateMaybeMessage< ::protos::Catch >(GetArenaForAllocation());
  }
  return _impl_.action_.catch__;
}
inline ::protos::Catch* Action::mutable_catch_() {
  ::protos::Catch* _msg = _internal_mutable_catch_();
  // @@protoc_insertion_point(field_mutable:protos.Action.catch)
  return _msg;
}

// .protos.Move move = 6;
inline bool Action::has_move() const {
  return action_case() == kMove;
}
inline bool Action::_internal_has_move() const {
  return action_case() == kMove;
}
inline void Action::set_has_move() {
  _impl_._oneof_case_[0] = kMove;
}
inline void Action::clear_move() {
  if (action_case() == kMove) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.move_;
    }
    clear_has_action();
  }
}
inline ::protos::Move* Action::release_move() {
  // @@protoc_insertion_point(field_release:protos.Action.move)
  if (action_case() == kMove) {
    clear_has_action();
    ::protos::Move* temp = _impl_.action_.move_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Move& Action::_internal_move() const {
  return action_case() == kMove
      ? *_impl_.action_.move_
      : reinterpret_cast<::protos::Move&>(::protos::_Move_default_instance_);
}
inline const ::protos::Move& Action::move() const {
  // @@protoc_insertion_point(field_get:protos.Action.move)
  return _internal_move();
}
inline ::protos::Move* Action::unsafe_arena_release_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.move)
  if (action_case() == kMove) {
    clear_has_action();
    ::protos::Move* temp = _impl_.action_.move_;
    _impl_.action_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_move(::protos::Move* move) {
  clear_action();
  if (move) {
    set_has_move();
    _impl_.action_.move_ = move;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.move)
}
inline ::protos::Move* Action::_internal_mutable_move() {
  if (action_case() != kMove) {
    clear_action();
    set_has_move();
    _impl_.action_.move_ = CreateMaybeMessage< ::protos::Move >(GetArenaForAllocation());
  }
  return _impl_.action_.move_;
}
inline ::protos::Move* Action::mutable_move() {
  ::protos::Move* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:protos.Action.move)
  return _msg;
}

// .protos.TurnNeck turn_neck = 7;
inline bool Action::has_turn_neck() const {
  return action_case() == kTurnNeck;
}
inline bool Action::_internal_has_turn_neck() const {
  return action_case() == kTurnNeck;
}
inline void Action::set_has_turn_neck() {
  _impl_._oneof_case_[0] = kTurnNeck;
}
inline void Action::clear_turn_neck() {
  if (action_case() == kTurnNeck) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.turn_neck_;
    }
    clear_has_action();
  }
}
inline ::protos::TurnNeck* Action::release_turn_neck() {
  // @@protoc_insertion_point(field_release:protos.Action.turn_neck)
  if (action_case() == kTurnNeck) {
    clear_has_action();
    ::protos::TurnNeck* temp = _impl_.action_.turn_neck_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.turn_neck_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::TurnNeck& Action::_internal_turn_neck() const {
  return action_case() == kTurnNeck
      ? *_impl_.action_.turn_neck_
      : reinterpret_cast<::protos::TurnNeck&>(::protos::_TurnNeck_default_instance_);
}
inline const ::protos::TurnNeck& Action::turn_neck() const {
  // @@protoc_insertion_point(field_get:protos.Action.turn_neck)
  return _internal_turn_neck();
}
inline ::protos::TurnNeck* Action::unsafe_arena_release_turn_neck() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.turn_neck)
  if (action_case() == kTurnNeck) {
    clear_has_action();
    ::protos::TurnNeck* temp = _impl_.action_.turn_neck_;
    _impl_.action_.turn_neck_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_turn_neck(::protos::TurnNeck* turn_neck) {
  clear_action();
  if (turn_neck) {
    set_has_turn_neck();
    _impl_.action_.turn_neck_ = turn_neck;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.turn_neck)
}
inline ::protos::TurnNeck* Action::_internal_mutable_turn_neck() {
  if (action_case() != kTurnNeck) {
    clear_action();
    set_has_turn_neck();
    _impl_.action_.turn_neck_ = CreateMaybeMessage< ::protos::TurnNeck >(GetArenaForAllocation());
  }
  return _impl_.action_.turn_neck_;
}
inline ::protos::TurnNeck* Action::mutable_turn_neck() {
  ::protos::TurnNeck* _msg = _internal_mutable_turn_neck();
  // @@protoc_insertion_point(field_mutable:protos.Action.turn_neck)
  return _msg;
}

// .protos.ChangeView change_view = 8;
inline bool Action::has_change_view() const {
  return action_case() == kChangeView;
}
inline bool Action::_internal_has_change_view() const {
  return action_case() == kChangeView;
}
inline void Action::set_has_change_view() {
  _impl_._oneof_case_[0] = kChangeView;
}
inline void Action::clear_change_view() {
  if (action_case() == kChangeView) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.change_view_;
    }
    clear_has_action();
  }
}
inline ::protos::ChangeView* Action::release_change_view() {
  // @@protoc_insertion_point(field_release:protos.Action.change_view)
  if (action_case() == kChangeView) {
    clear_has_action();
    ::protos::ChangeView* temp = _impl_.action_.change_view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.change_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::ChangeView& Action::_internal_change_view() const {
  return action_case() == kChangeView
      ? *_impl_.action_.change_view_
      : reinterpret_cast<::protos::ChangeView&>(::protos::_ChangeView_default_instance_);
}
inline const ::protos::ChangeView& Action::change_view() const {
  // @@protoc_insertion_point(field_get:protos.Action.change_view)
  return _internal_change_view();
}
inline ::protos::ChangeView* Action::unsafe_arena_release_change_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.change_view)
  if (action_case() == kChangeView) {
    clear_has_action();
    ::protos::ChangeView* temp = _impl_.action_.change_view_;
    _impl_.action_.change_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_change_view(::protos::ChangeView* change_view) {
  clear_action();
  if (change_view) {
    set_has_change_view();
    _impl_.action_.change_view_ = change_view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.change_view)
}
inline ::protos::ChangeView* Action::_internal_mutable_change_view() {
  if (action_case() != kChangeView) {
    clear_action();
    set_has_change_view();
    _impl_.action_.change_view_ = CreateMaybeMessage< ::protos::ChangeView >(GetArenaForAllocation());
  }
  return _impl_.action_.change_view_;
}
inline ::protos::ChangeView* Action::mutable_change_view() {
  ::protos::ChangeView* _msg = _internal_mutable_change_view();
  // @@protoc_insertion_point(field_mutable:protos.Action.change_view)
  return _msg;
}

// .protos.Say say = 9;
inline bool Action::has_say() const {
  return action_case() == kSay;
}
inline bool Action::_internal_has_say() const {
  return action_case() == kSay;
}
inline void Action::set_has_say() {
  _impl_._oneof_case_[0] = kSay;
}
inline void Action::clear_say() {
  if (action_case() == kSay) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.say_;
    }
    clear_has_action();
  }
}
inline ::protos::Say* Action::release_say() {
  // @@protoc_insertion_point(field_release:protos.Action.say)
  if (action_case() == kSay) {
    clear_has_action();
    ::protos::Say* temp = _impl_.action_.say_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.say_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Say& Action::_internal_say() const {
  return action_case() == kSay
      ? *_impl_.action_.say_
      : reinterpret_cast<::protos::Say&>(::protos::_Say_default_instance_);
}
inline const ::protos::Say& Action::say() const {
  // @@protoc_insertion_point(field_get:protos.Action.say)
  return _internal_say();
}
inline ::protos::Say* Action::unsafe_arena_release_say() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.say)
  if (action_case() == kSay) {
    clear_has_action();
    ::protos::Say* temp = _impl_.action_.say_;
    _impl_.action_.say_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_say(::protos::Say* say) {
  clear_action();
  if (say) {
    set_has_say();
    _impl_.action_.say_ = say;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.say)
}
inline ::protos::Say* Action::_internal_mutable_say() {
  if (action_case() != kSay) {
    clear_action();
    set_has_say();
    _impl_.action_.say_ = CreateMaybeMessage< ::protos::Say >(GetArenaForAllocation());
  }
  return _impl_.action_.say_;
}
inline ::protos::Say* Action::mutable_say() {
  ::protos::Say* _msg = _internal_mutable_say();
  // @@protoc_insertion_point(field_mutable:protos.Action.say)
  return _msg;
}

// .protos.PointTo point_to = 10;
inline bool Action::has_point_to() const {
  return action_case() == kPointTo;
}
inline bool Action::_internal_has_point_to() const {
  return action_case() == kPointTo;
}
inline void Action::set_has_point_to() {
  _impl_._oneof_case_[0] = kPointTo;
}
inline void Action::clear_point_to() {
  if (action_case() == kPointTo) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.point_to_;
    }
    clear_has_action();
  }
}
inline ::protos::PointTo* Action::release_point_to() {
  // @@protoc_insertion_point(field_release:protos.Action.point_to)
  if (action_case() == kPointTo) {
    clear_has_action();
    ::protos::PointTo* temp = _impl_.action_.point_to_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.point_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::PointTo& Action::_internal_point_to() const {
  return action_case() == kPointTo
      ? *_impl_.action_.point_to_
      : reinterpret_cast<::protos::PointTo&>(::protos::_PointTo_default_instance_);
}
inline const ::protos::PointTo& Action::point_to() const {
  // @@protoc_insertion_point(field_get:protos.Action.point_to)
  return _internal_point_to();
}
inline ::protos::PointTo* Action::unsafe_arena_release_point_to() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.point_to)
  if (action_case() == kPointTo) {
    clear_has_action();
    ::protos::PointTo* temp = _impl_.action_.point_to_;
    _impl_.action_.point_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_point_to(::protos::PointTo* point_to) {
  clear_action();
  if (point_to) {
    set_has_point_to();
    _impl_.action_.point_to_ = point_to;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.point_to)
}
inline ::protos::PointTo* Action::_internal_mutable_point_to() {
  if (action_case() != kPointTo) {
    clear_action();
    set_has_point_to();
    _impl_.action_.point_to_ = CreateMaybeMessage< ::protos::PointTo >(GetArenaForAllocation());
  }
  return _impl_.action_.point_to_;
}
inline ::protos::PointTo* Action::mutable_point_to() {
  ::protos::PointTo* _msg = _internal_mutable_point_to();
  // @@protoc_insertion_point(field_mutable:protos.Action.point_to)
  return _msg;
}

// .protos.PointToOf point_to_of = 11;
inline bool Action::has_point_to_of() const {
  return action_case() == kPointToOf;
}
inline bool Action::_internal_has_point_to_of() const {
  return action_case() == kPointToOf;
}
inline void Action::set_has_point_to_of() {
  _impl_._oneof_case_[0] = kPointToOf;
}
inline void Action::clear_point_to_of() {
  if (action_case() == kPointToOf) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.point_to_of_;
    }
    clear_has_action();
  }
}
inline ::protos::PointToOf* Action::release_point_to_of() {
  // @@protoc_insertion_point(field_release:protos.Action.point_to_of)
  if (action_case() == kPointToOf) {
    clear_has_action();
    ::protos::PointToOf* temp = _impl_.action_.point_to_of_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.point_to_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::PointToOf& Action::_internal_point_to_of() const {
  return action_case() == kPointToOf
      ? *_impl_.action_.point_to_of_
      : reinterpret_cast<::protos::PointToOf&>(::protos::_PointToOf_default_instance_);
}
inline const ::protos::PointToOf& Action::point_to_of() const {
  // @@protoc_insertion_point(field_get:protos.Action.point_to_of)
  return _internal_point_to_of();
}
inline ::protos::PointToOf* Action::unsafe_arena_release_point_to_of() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.point_to_of)
  if (action_case() == kPointToOf) {
    clear_has_action();
    ::protos::PointToOf* temp = _impl_.action_.point_to_of_;
    _impl_.action_.point_to_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_point_to_of(::protos::PointToOf* point_to_of) {
  clear_action();
  if (point_to_of) {
    set_has_point_to_of();
    _impl_.action_.point_to_of_ = point_to_of;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.point_to_of)
}
inline ::protos::PointToOf* Action::_internal_mutable_point_to_of() {
  if (action_case() != kPointToOf) {
    clear_action();
    set_has_point_to_of();
    _impl_.action_.point_to_of_ = CreateMaybeMessage< ::protos::PointToOf >(GetArenaForAllocation());
  }
  return _impl_.action_.point_to_of_;
}
inline ::protos::PointToOf* Action::mutable_point_to_of() {
  ::protos::PointToOf* _msg = _internal_mutable_point_to_of();
  // @@protoc_insertion_point(field_mutable:protos.Action.point_to_of)
  return _msg;
}

// .protos.AttentionTo attention_to = 12;
inline bool Action::has_attention_to() const {
  return action_case() == kAttentionTo;
}
inline bool Action::_internal_has_attention_to() const {
  return action_case() == kAttentionTo;
}
inline void Action::set_has_attention_to() {
  _impl_._oneof_case_[0] = kAttentionTo;
}
inline void Action::clear_attention_to() {
  if (action_case() == kAttentionTo) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.attention_to_;
    }
    clear_has_action();
  }
}
inline ::protos::AttentionTo* Action::release_attention_to() {
  // @@protoc_insertion_point(field_release:protos.Action.attention_to)
  if (action_case() == kAttentionTo) {
    clear_has_action();
    ::protos::AttentionTo* temp = _impl_.action_.attention_to_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.attention_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AttentionTo& Action::_internal_attention_to() const {
  return action_case() == kAttentionTo
      ? *_impl_.action_.attention_to_
      : reinterpret_cast<::protos::AttentionTo&>(::protos::_AttentionTo_default_instance_);
}
inline const ::protos::AttentionTo& Action::attention_to() const {
  // @@protoc_insertion_point(field_get:protos.Action.attention_to)
  return _internal_attention_to();
}
inline ::protos::AttentionTo* Action::unsafe_arena_release_attention_to() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.attention_to)
  if (action_case() == kAttentionTo) {
    clear_has_action();
    ::protos::AttentionTo* temp = _impl_.action_.attention_to_;
    _impl_.action_.attention_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_attention_to(::protos::AttentionTo* attention_to) {
  clear_action();
  if (attention_to) {
    set_has_attention_to();
    _impl_.action_.attention_to_ = attention_to;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.attention_to)
}
inline ::protos::AttentionTo* Action::_internal_mutable_attention_to() {
  if (action_case() != kAttentionTo) {
    clear_action();
    set_has_attention_to();
    _impl_.action_.attention_to_ = CreateMaybeMessage< ::protos::AttentionTo >(GetArenaForAllocation());
  }
  return _impl_.action_.attention_to_;
}
inline ::protos::AttentionTo* Action::mutable_attention_to() {
  ::protos::AttentionTo* _msg = _internal_mutable_attention_to();
  // @@protoc_insertion_point(field_mutable:protos.Action.attention_to)
  return _msg;
}

// .protos.AttentionToOf attention_to_of = 13;
inline bool Action::has_attention_to_of() const {
  return action_case() == kAttentionToOf;
}
inline bool Action::_internal_has_attention_to_of() const {
  return action_case() == kAttentionToOf;
}
inline void Action::set_has_attention_to_of() {
  _impl_._oneof_case_[0] = kAttentionToOf;
}
inline void Action::clear_attention_to_of() {
  if (action_case() == kAttentionToOf) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.attention_to_of_;
    }
    clear_has_action();
  }
}
inline ::protos::AttentionToOf* Action::release_attention_to_of() {
  // @@protoc_insertion_point(field_release:protos.Action.attention_to_of)
  if (action_case() == kAttentionToOf) {
    clear_has_action();
    ::protos::AttentionToOf* temp = _impl_.action_.attention_to_of_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.attention_to_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AttentionToOf& Action::_internal_attention_to_of() const {
  return action_case() == kAttentionToOf
      ? *_impl_.action_.attention_to_of_
      : reinterpret_cast<::protos::AttentionToOf&>(::protos::_AttentionToOf_default_instance_);
}
inline const ::protos::AttentionToOf& Action::attention_to_of() const {
  // @@protoc_insertion_point(field_get:protos.Action.attention_to_of)
  return _internal_attention_to_of();
}
inline ::protos::AttentionToOf* Action::unsafe_arena_release_attention_to_of() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.attention_to_of)
  if (action_case() == kAttentionToOf) {
    clear_has_action();
    ::protos::AttentionToOf* temp = _impl_.action_.attention_to_of_;
    _impl_.action_.attention_to_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_attention_to_of(::protos::AttentionToOf* attention_to_of) {
  clear_action();
  if (attention_to_of) {
    set_has_attention_to_of();
    _impl_.action_.attention_to_of_ = attention_to_of;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.attention_to_of)
}
inline ::protos::AttentionToOf* Action::_internal_mutable_attention_to_of() {
  if (action_case() != kAttentionToOf) {
    clear_action();
    set_has_attention_to_of();
    _impl_.action_.attention_to_of_ = CreateMaybeMessage< ::protos::AttentionToOf >(GetArenaForAllocation());
  }
  return _impl_.action_.attention_to_of_;
}
inline ::protos::AttentionToOf* Action::mutable_attention_to_of() {
  ::protos::AttentionToOf* _msg = _internal_mutable_attention_to_of();
  // @@protoc_insertion_point(field_mutable:protos.Action.attention_to_of)
  return _msg;
}

// .protos.Log log = 14;
inline bool Action::has_log() const {
  return action_case() == kLog;
}
inline bool Action::_internal_has_log() const {
  return action_case() == kLog;
}
inline void Action::set_has_log() {
  _impl_._oneof_case_[0] = kLog;
}
inline void Action::clear_log() {
  if (action_case() == kLog) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.log_;
    }
    clear_has_action();
  }
}
inline ::protos::Log* Action::release_log() {
  // @@protoc_insertion_point(field_release:protos.Action.log)
  if (action_case() == kLog) {
    clear_has_action();
    ::protos::Log* temp = _impl_.action_.log_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Log& Action::_internal_log() const {
  return action_case() == kLog
      ? *_impl_.action_.log_
      : reinterpret_cast<::protos::Log&>(::protos::_Log_default_instance_);
}
inline const ::protos::Log& Action::log() const {
  // @@protoc_insertion_point(field_get:protos.Action.log)
  return _internal_log();
}
inline ::protos::Log* Action::unsafe_arena_release_log() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.log)
  if (action_case() == kLog) {
    clear_has_action();
    ::protos::Log* temp = _impl_.action_.log_;
    _impl_.action_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_log(::protos::Log* log) {
  clear_action();
  if (log) {
    set_has_log();
    _impl_.action_.log_ = log;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.log)
}
inline ::protos::Log* Action::_internal_mutable_log() {
  if (action_case() != kLog) {
    clear_action();
    set_has_log();
    _impl_.action_.log_ = CreateMaybeMessage< ::protos::Log >(GetArenaForAllocation());
  }
  return _impl_.action_.log_;
}
inline ::protos::Log* Action::mutable_log() {
  ::protos::Log* _msg = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:protos.Action.log)
  return _msg;
}

// .protos.DebugClient debug_client = 15;
inline bool Action::has_debug_client() const {
  return action_case() == kDebugClient;
}
inline bool Action::_internal_has_debug_client() const {
  return action_case() == kDebugClient;
}
inline void Action::set_has_debug_client() {
  _impl_._oneof_case_[0] = kDebugClient;
}
inline void Action::clear_debug_client() {
  if (action_case() == kDebugClient) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.debug_client_;
    }
    clear_has_action();
  }
}
inline ::protos::DebugClient* Action::release_debug_client() {
  // @@protoc_insertion_point(field_release:protos.Action.debug_client)
  if (action_case() == kDebugClient) {
    clear_has_action();
    ::protos::DebugClient* temp = _impl_.action_.debug_client_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.debug_client_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::DebugClient& Action::_internal_debug_client() const {
  return action_case() == kDebugClient
      ? *_impl_.action_.debug_client_
      : reinterpret_cast<::protos::DebugClient&>(::protos::_DebugClient_default_instance_);
}
inline const ::protos::DebugClient& Action::debug_client() const {
  // @@protoc_insertion_point(field_get:protos.Action.debug_client)
  return _internal_debug_client();
}
inline ::protos::DebugClient* Action::unsafe_arena_release_debug_client() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.debug_client)
  if (action_case() == kDebugClient) {
    clear_has_action();
    ::protos::DebugClient* temp = _impl_.action_.debug_client_;
    _impl_.action_.debug_client_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_debug_client(::protos::DebugClient* debug_client) {
  clear_action();
  if (debug_client) {
    set_has_debug_client();
    _impl_.action_.debug_client_ = debug_client;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.debug_client)
}
inline ::protos::DebugClient* Action::_internal_mutable_debug_client() {
  if (action_case() != kDebugClient) {
    clear_action();
    set_has_debug_client();
    _impl_.action_.debug_client_ = CreateMaybeMessage< ::protos::DebugClient >(GetArenaForAllocation());
  }
  return _impl_.action_.debug_client_;
}
inline ::protos::DebugClient* Action::mutable_debug_client() {
  ::protos::DebugClient* _msg = _internal_mutable_debug_client();
  // @@protoc_insertion_point(field_mutable:protos.Action.debug_client)
  return _msg;
}

// .protos.Body_GoToPoint body_go_to_point = 16;
inline bool Action::has_body_go_to_point() const {
  return action_case() == kBodyGoToPoint;
}
inline bool Action::_internal_has_body_go_to_point() const {
  return action_case() == kBodyGoToPoint;
}
inline void Action::set_has_body_go_to_point() {
  _impl_._oneof_case_[0] = kBodyGoToPoint;
}
inline void Action::clear_body_go_to_point() {
  if (action_case() == kBodyGoToPoint) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.body_go_to_point_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_GoToPoint* Action::release_body_go_to_point() {
  // @@protoc_insertion_point(field_release:protos.Action.body_go_to_point)
  if (action_case() == kBodyGoToPoint) {
    clear_has_action();
    ::protos::Body_GoToPoint* temp = _impl_.action_.body_go_to_point_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_go_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_GoToPoint& Action::_internal_body_go_to_point() const {
  return action_case() == kBodyGoToPoint
      ? *_impl_.action_.body_go_to_point_
      : reinterpret_cast<::protos::Body_GoToPoint&>(::protos::_Body_GoToPoint_default_instance_);
}
inline const ::protos::Body_GoToPoint& Action::body_go_to_point() const {
  // @@protoc_insertion_point(field_get:protos.Action.body_go_to_point)
  return _internal_body_go_to_point();
}
inline ::protos::Body_GoToPoint* Action::unsafe_arena_release_body_go_to_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.body_go_to_point)
  if (action_case() == kBodyGoToPoint) {
    clear_has_action();
    ::protos::Body_GoToPoint* temp = _impl_.action_.body_go_to_point_;
    _impl_.action_.body_go_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_body_go_to_point(::protos::Body_GoToPoint* body_go_to_point) {
  clear_action();
  if (body_go_to_point) {
    set_has_body_go_to_point();
    _impl_.action_.body_go_to_point_ = body_go_to_point;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.body_go_to_point)
}
inline ::protos::Body_GoToPoint* Action::_internal_mutable_body_go_to_point() {
  if (action_case() != kBodyGoToPoint) {
    clear_action();
    set_has_body_go_to_point();
    _impl_.action_.body_go_to_point_ = CreateMaybeMessage< ::protos::Body_GoToPoint >(GetArenaForAllocation());
  }
  return _impl_.action_.body_go_to_point_;
}
inline ::protos::Body_GoToPoint* Action::mutable_body_go_to_point() {
  ::protos::Body_GoToPoint* _msg = _internal_mutable_body_go_to_point();
  // @@protoc_insertion_point(field_mutable:protos.Action.body_go_to_point)
  return _msg;
}

// .protos.Body_SmartKick body_smart_kick = 17;
inline bool Action::has_body_smart_kick() const {
  return action_case() == kBodySmartKick;
}
inline bool Action::_internal_has_body_smart_kick() const {
  return action_case() == kBodySmartKick;
}
inline void Action::set_has_body_smart_kick() {
  _impl_._oneof_case_[0] = kBodySmartKick;
}
inline void Action::clear_body_smart_kick() {
  if (action_case() == kBodySmartKick) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.body_smart_kick_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_SmartKick* Action::release_body_smart_kick() {
  // @@protoc_insertion_point(field_release:protos.Action.body_smart_kick)
  if (action_case() == kBodySmartKick) {
    clear_has_action();
    ::protos::Body_SmartKick* temp = _impl_.action_.body_smart_kick_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_smart_kick_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_SmartKick& Action::_internal_body_smart_kick() const {
  return action_case() == kBodySmartKick
      ? *_impl_.action_.body_smart_kick_
      : reinterpret_cast<::protos::Body_SmartKick&>(::protos::_Body_SmartKick_default_instance_);
}
inline const ::protos::Body_SmartKick& Action::body_smart_kick() const {
  // @@protoc_insertion_point(field_get:protos.Action.body_smart_kick)
  return _internal_body_smart_kick();
}
inline ::protos::Body_SmartKick* Action::unsafe_arena_release_body_smart_kick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.body_smart_kick)
  if (action_case() == kBodySmartKick) {
    clear_has_action();
    ::protos::Body_SmartKick* temp = _impl_.action_.body_smart_kick_;
    _impl_.action_.body_smart_kick_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_body_smart_kick(::protos::Body_SmartKick* body_smart_kick) {
  clear_action();
  if (body_smart_kick) {
    set_has_body_smart_kick();
    _impl_.action_.body_smart_kick_ = body_smart_kick;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.body_smart_kick)
}
inline ::protos::Body_SmartKick* Action::_internal_mutable_body_smart_kick() {
  if (action_case() != kBodySmartKick) {
    clear_action();
    set_has_body_smart_kick();
    _impl_.action_.body_smart_kick_ = CreateMaybeMessage< ::protos::Body_SmartKick >(GetArenaForAllocation());
  }
  return _impl_.action_.body_smart_kick_;
}
inline ::protos::Body_SmartKick* Action::mutable_body_smart_kick() {
  ::protos::Body_SmartKick* _msg = _internal_mutable_body_smart_kick();
  // @@protoc_insertion_point(field_mutable:protos.Action.body_smart_kick)
  return _msg;
}

// .protos.Bhv_BeforeKickOff bhv_before_kick_off = 18;
inline bool Action::has_bhv_before_kick_off() const {
  return action_case() == kBhvBeforeKickOff;
}
inline bool Action::_internal_has_bhv_before_kick_off() const {
  return action_case() == kBhvBeforeKickOff;
}
inline void Action::set_has_bhv_before_kick_off() {
  _impl_._oneof_case_[0] = kBhvBeforeKickOff;
}
inline void Action::clear_bhv_before_kick_off() {
  if (action_case() == kBhvBeforeKickOff) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.bhv_before_kick_off_;
    }
    clear_has_action();
  }
}
inline ::protos::Bhv_BeforeKickOff* Action::release_bhv_before_kick_off() {
  // @@protoc_insertion_point(field_release:protos.Action.bhv_before_kick_off)
  if (action_case() == kBhvBeforeKickOff) {
    clear_has_action();
    ::protos::Bhv_BeforeKickOff* temp = _impl_.action_.bhv_before_kick_off_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.bhv_before_kick_off_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Bhv_BeforeKickOff& Action::_internal_bhv_before_kick_off() const {
  return action_case() == kBhvBeforeKickOff
      ? *_impl_.action_.bhv_before_kick_off_
      : reinterpret_cast<::protos::Bhv_BeforeKickOff&>(::protos::_Bhv_BeforeKickOff_default_instance_);
}
inline const ::protos::Bhv_BeforeKickOff& Action::bhv_before_kick_off() const {
  // @@protoc_insertion_point(field_get:protos.Action.bhv_before_kick_off)
  return _internal_bhv_before_kick_off();
}
inline ::protos::Bhv_BeforeKickOff* Action::unsafe_arena_release_bhv_before_kick_off() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.bhv_before_kick_off)
  if (action_case() == kBhvBeforeKickOff) {
    clear_has_action();
    ::protos::Bhv_BeforeKickOff* temp = _impl_.action_.bhv_before_kick_off_;
    _impl_.action_.bhv_before_kick_off_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_bhv_before_kick_off(::protos::Bhv_BeforeKickOff* bhv_before_kick_off) {
  clear_action();
  if (bhv_before_kick_off) {
    set_has_bhv_before_kick_off();
    _impl_.action_.bhv_before_kick_off_ = bhv_before_kick_off;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.bhv_before_kick_off)
}
inline ::protos::Bhv_BeforeKickOff* Action::_internal_mutable_bhv_before_kick_off() {
  if (action_case() != kBhvBeforeKickOff) {
    clear_action();
    set_has_bhv_before_kick_off();
    _impl_.action_.bhv_before_kick_off_ = CreateMaybeMessage< ::protos::Bhv_BeforeKickOff >(GetArenaForAllocation());
  }
  return _impl_.action_.bhv_before_kick_off_;
}
inline ::protos::Bhv_BeforeKickOff* Action::mutable_bhv_before_kick_off() {
  ::protos::Bhv_BeforeKickOff* _msg = _internal_mutable_bhv_before_kick_off();
  // @@protoc_insertion_point(field_mutable:protos.Action.bhv_before_kick_off)
  return _msg;
}

// .protos.Bhv_BodyNeckToBall bhv_body_neck_to_ball = 19;
inline bool Action::has_bhv_body_neck_to_ball() const {
  return action_case() == kBhvBodyNeckToBall;
}
inline bool Action::_internal_has_bhv_body_neck_to_ball() const {
  return action_case() == kBhvBodyNeckToBall;
}
inline void Action::set_has_bhv_body_neck_to_ball() {
  _impl_._oneof_case_[0] = kBhvBodyNeckToBall;
}
inline void Action::clear_bhv_body_neck_to_ball() {
  if (action_case() == kBhvBodyNeckToBall) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.bhv_body_neck_to_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Bhv_BodyNeckToBall* Action::release_bhv_body_neck_to_ball() {
  // @@protoc_insertion_point(field_release:protos.Action.bhv_body_neck_to_ball)
  if (action_case() == kBhvBodyNeckToBall) {
    clear_has_action();
    ::protos::Bhv_BodyNeckToBall* temp = _impl_.action_.bhv_body_neck_to_ball_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.bhv_body_neck_to_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Bhv_BodyNeckToBall& Action::_internal_bhv_body_neck_to_ball() const {
  return action_case() == kBhvBodyNeckToBall
      ? *_impl_.action_.bhv_body_neck_to_ball_
      : reinterpret_cast<::protos::Bhv_BodyNeckToBall&>(::protos::_Bhv_BodyNeckToBall_default_instance_);
}
inline const ::protos::Bhv_BodyNeckToBall& Action::bhv_body_neck_to_ball() const {
  // @@protoc_insertion_point(field_get:protos.Action.bhv_body_neck_to_ball)
  return _internal_bhv_body_neck_to_ball();
}
inline ::protos::Bhv_BodyNeckToBall* Action::unsafe_arena_release_bhv_body_neck_to_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.bhv_body_neck_to_ball)
  if (action_case() == kBhvBodyNeckToBall) {
    clear_has_action();
    ::protos::Bhv_BodyNeckToBall* temp = _impl_.action_.bhv_body_neck_to_ball_;
    _impl_.action_.bhv_body_neck_to_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_bhv_body_neck_to_ball(::protos::Bhv_BodyNeckToBall* bhv_body_neck_to_ball) {
  clear_action();
  if (bhv_body_neck_to_ball) {
    set_has_bhv_body_neck_to_ball();
    _impl_.action_.bhv_body_neck_to_ball_ = bhv_body_neck_to_ball;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.bhv_body_neck_to_ball)
}
inline ::protos::Bhv_BodyNeckToBall* Action::_internal_mutable_bhv_body_neck_to_ball() {
  if (action_case() != kBhvBodyNeckToBall) {
    clear_action();
    set_has_bhv_body_neck_to_ball();
    _impl_.action_.bhv_body_neck_to_ball_ = CreateMaybeMessage< ::protos::Bhv_BodyNeckToBall >(GetArenaForAllocation());
  }
  return _impl_.action_.bhv_body_neck_to_ball_;
}
inline ::protos::Bhv_BodyNeckToBall* Action::mutable_bhv_body_neck_to_ball() {
  ::protos::Bhv_BodyNeckToBall* _msg = _internal_mutable_bhv_body_neck_to_ball();
  // @@protoc_insertion_point(field_mutable:protos.Action.bhv_body_neck_to_ball)
  return _msg;
}

// .protos.Bhv_BodyNeckToPoint bhv_body_neck_to_point = 20;
inline bool Action::has_bhv_body_neck_to_point() const {
  return action_case() == kBhvBodyNeckToPoint;
}
inline bool Action::_internal_has_bhv_body_neck_to_point() const {
  return action_case() == kBhvBodyNeckToPoint;
}
inline void Action::set_has_bhv_body_neck_to_point() {
  _impl_._oneof_case_[0] = kBhvBodyNeckToPoint;
}
inline void Action::clear_bhv_body_neck_to_point() {
  if (action_case() == kBhvBodyNeckToPoint) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.bhv_body_neck_to_point_;
    }
    clear_has_action();
  }
}
inline ::protos::Bhv_BodyNeckToPoint* Action::release_bhv_body_neck_to_point() {
  // @@protoc_insertion_point(field_release:protos.Action.bhv_body_neck_to_point)
  if (action_case() == kBhvBodyNeckToPoint) {
    clear_has_action();
    ::protos::Bhv_BodyNeckToPoint* temp = _impl_.action_.bhv_body_neck_to_point_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.bhv_body_neck_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Bhv_BodyNeckToPoint& Action::_internal_bhv_body_neck_to_point() const {
  return action_case() == kBhvBodyNeckToPoint
      ? *_impl_.action_.bhv_body_neck_to_point_
      : reinterpret_cast<::protos::Bhv_BodyNeckToPoint&>(::protos::_Bhv_BodyNeckToPoint_default_instance_);
}
inline const ::protos::Bhv_BodyNeckToPoint& Action::bhv_body_neck_to_point() const {
  // @@protoc_insertion_point(field_get:protos.Action.bhv_body_neck_to_point)
  return _internal_bhv_body_neck_to_point();
}
inline ::protos::Bhv_BodyNeckToPoint* Action::unsafe_arena_release_bhv_body_neck_to_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.bhv_body_neck_to_point)
  if (action_case() == kBhvBodyNeckToPoint) {
    clear_has_action();
    ::protos::Bhv_BodyNeckToPoint* temp = _impl_.action_.bhv_body_neck_to_point_;
    _impl_.action_.bhv_body_neck_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_bhv_body_neck_to_point(::protos::Bhv_BodyNeckToPoint* bhv_body_neck_to_point) {
  clear_action();
  if (bhv_body_neck_to_point) {
    set_has_bhv_body_neck_to_point();
    _impl_.action_.bhv_body_neck_to_point_ = bhv_body_neck_to_point;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.bhv_body_neck_to_point)
}
inline ::protos::Bhv_BodyNeckToPoint* Action::_internal_mutable_bhv_body_neck_to_point() {
  if (action_case() != kBhvBodyNeckToPoint) {
    clear_action();
    set_has_bhv_body_neck_to_point();
    _impl_.action_.bhv_body_neck_to_point_ = CreateMaybeMessage< ::protos::Bhv_BodyNeckToPoint >(GetArenaForAllocation());
  }
  return _impl_.action_.bhv_body_neck_to_point_;
}
inline ::protos::Bhv_BodyNeckToPoint* Action::mutable_bhv_body_neck_to_point() {
  ::protos::Bhv_BodyNeckToPoint* _msg = _internal_mutable_bhv_body_neck_to_point();
  // @@protoc_insertion_point(field_mutable:protos.Action.bhv_body_neck_to_point)
  return _msg;
}

// .protos.Bhv_Emergency bhv_emergency = 21;
inline bool Action::has_bhv_emergency() const {
  return action_case() == kBhvEmergency;
}
inline bool Action::_internal_has_bhv_emergency() const {
  return action_case() == kBhvEmergency;
}
inline void Action::set_has_bhv_emergency() {
  _impl_._oneof_case_[0] = kBhvEmergency;
}
inline void Action::clear_bhv_emergency() {
  if (action_case() == kBhvEmergency) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.bhv_emergency_;
    }
    clear_has_action();
  }
}
inline ::protos::Bhv_Emergency* Action::release_bhv_emergency() {
  // @@protoc_insertion_point(field_release:protos.Action.bhv_emergency)
  if (action_case() == kBhvEmergency) {
    clear_has_action();
    ::protos::Bhv_Emergency* temp = _impl_.action_.bhv_emergency_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.bhv_emergency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Bhv_Emergency& Action::_internal_bhv_emergency() const {
  return action_case() == kBhvEmergency
      ? *_impl_.action_.bhv_emergency_
      : reinterpret_cast<::protos::Bhv_Emergency&>(::protos::_Bhv_Emergency_default_instance_);
}
inline const ::protos::Bhv_Emergency& Action::bhv_emergency() const {
  // @@protoc_insertion_point(field_get:protos.Action.bhv_emergency)
  return _internal_bhv_emergency();
}
inline ::protos::Bhv_Emergency* Action::unsafe_arena_release_bhv_emergency() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.bhv_emergency)
  if (action_case() == kBhvEmergency) {
    clear_has_action();
    ::protos::Bhv_Emergency* temp = _impl_.action_.bhv_emergency_;
    _impl_.action_.bhv_emergency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_bhv_emergency(::protos::Bhv_Emergency* bhv_emergency) {
  clear_action();
  if (bhv_emergency) {
    set_has_bhv_emergency();
    _impl_.action_.bhv_emergency_ = bhv_emergency;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.bhv_emergency)
}
inline ::protos::Bhv_Emergency* Action::_internal_mutable_bhv_emergency() {
  if (action_case() != kBhvEmergency) {
    clear_action();
    set_has_bhv_emergency();
    _impl_.action_.bhv_emergency_ = CreateMaybeMessage< ::protos::Bhv_Emergency >(GetArenaForAllocation());
  }
  return _impl_.action_.bhv_emergency_;
}
inline ::protos::Bhv_Emergency* Action::mutable_bhv_emergency() {
  ::protos::Bhv_Emergency* _msg = _internal_mutable_bhv_emergency();
  // @@protoc_insertion_point(field_mutable:protos.Action.bhv_emergency)
  return _msg;
}

// .protos.Bhv_GoToPointLookBall bhv_go_to_point_look_ball = 22;
inline bool Action::has_bhv_go_to_point_look_ball() const {
  return action_case() == kBhvGoToPointLookBall;
}
inline bool Action::_internal_has_bhv_go_to_point_look_ball() const {
  return action_case() == kBhvGoToPointLookBall;
}
inline void Action::set_has_bhv_go_to_point_look_ball() {
  _impl_._oneof_case_[0] = kBhvGoToPointLookBall;
}
inline void Action::clear_bhv_go_to_point_look_ball() {
  if (action_case() == kBhvGoToPointLookBall) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.bhv_go_to_point_look_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Bhv_GoToPointLookBall* Action::release_bhv_go_to_point_look_ball() {
  // @@protoc_insertion_point(field_release:protos.Action.bhv_go_to_point_look_ball)
  if (action_case() == kBhvGoToPointLookBall) {
    clear_has_action();
    ::protos::Bhv_GoToPointLookBall* temp = _impl_.action_.bhv_go_to_point_look_ball_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.bhv_go_to_point_look_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Bhv_GoToPointLookBall& Action::_internal_bhv_go_to_point_look_ball() const {
  return action_case() == kBhvGoToPointLookBall
      ? *_impl_.action_.bhv_go_to_point_look_ball_
      : reinterpret_cast<::protos::Bhv_GoToPointLookBall&>(::protos::_Bhv_GoToPointLookBall_default_instance_);
}
inline const ::protos::Bhv_GoToPointLookBall& Action::bhv_go_to_point_look_ball() const {
  // @@protoc_insertion_point(field_get:protos.Action.bhv_go_to_point_look_ball)
  return _internal_bhv_go_to_point_look_ball();
}
inline ::protos::Bhv_GoToPointLookBall* Action::unsafe_arena_release_bhv_go_to_point_look_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.bhv_go_to_point_look_ball)
  if (action_case() == kBhvGoToPointLookBall) {
    clear_has_action();
    ::protos::Bhv_GoToPointLookBall* temp = _impl_.action_.bhv_go_to_point_look_ball_;
    _impl_.action_.bhv_go_to_point_look_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_bhv_go_to_point_look_ball(::protos::Bhv_GoToPointLookBall* bhv_go_to_point_look_ball) {
  clear_action();
  if (bhv_go_to_point_look_ball) {
    set_has_bhv_go_to_point_look_ball();
    _impl_.action_.bhv_go_to_point_look_ball_ = bhv_go_to_point_look_ball;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.bhv_go_to_point_look_ball)
}
inline ::protos::Bhv_GoToPointLookBall* Action::_internal_mutable_bhv_go_to_point_look_ball() {
  if (action_case() != kBhvGoToPointLookBall) {
    clear_action();
    set_has_bhv_go_to_point_look_ball();
    _impl_.action_.bhv_go_to_point_look_ball_ = CreateMaybeMessage< ::protos::Bhv_GoToPointLookBall >(GetArenaForAllocation());
  }
  return _impl_.action_.bhv_go_to_point_look_ball_;
}
inline ::protos::Bhv_GoToPointLookBall* Action::mutable_bhv_go_to_point_look_ball() {
  ::protos::Bhv_GoToPointLookBall* _msg = _internal_mutable_bhv_go_to_point_look_ball();
  // @@protoc_insertion_point(field_mutable:protos.Action.bhv_go_to_point_look_ball)
  return _msg;
}

// .protos.Bhv_NeckBodyToBall bhv_neck_body_to_ball = 23;
inline bool Action::has_bhv_neck_body_to_ball() const {
  return action_case() == kBhvNeckBodyToBall;
}
inline bool Action::_internal_has_bhv_neck_body_to_ball() const {
  return action_case() == kBhvNeckBodyToBall;
}
inline void Action::set_has_bhv_neck_body_to_ball() {
  _impl_._oneof_case_[0] = kBhvNeckBodyToBall;
}
inline void Action::clear_bhv_neck_body_to_ball() {
  if (action_case() == kBhvNeckBodyToBall) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.bhv_neck_body_to_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Bhv_NeckBodyToBall* Action::release_bhv_neck_body_to_ball() {
  // @@protoc_insertion_point(field_release:protos.Action.bhv_neck_body_to_ball)
  if (action_case() == kBhvNeckBodyToBall) {
    clear_has_action();
    ::protos::Bhv_NeckBodyToBall* temp = _impl_.action_.bhv_neck_body_to_ball_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.bhv_neck_body_to_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Bhv_NeckBodyToBall& Action::_internal_bhv_neck_body_to_ball() const {
  return action_case() == kBhvNeckBodyToBall
      ? *_impl_.action_.bhv_neck_body_to_ball_
      : reinterpret_cast<::protos::Bhv_NeckBodyToBall&>(::protos::_Bhv_NeckBodyToBall_default_instance_);
}
inline const ::protos::Bhv_NeckBodyToBall& Action::bhv_neck_body_to_ball() const {
  // @@protoc_insertion_point(field_get:protos.Action.bhv_neck_body_to_ball)
  return _internal_bhv_neck_body_to_ball();
}
inline ::protos::Bhv_NeckBodyToBall* Action::unsafe_arena_release_bhv_neck_body_to_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.bhv_neck_body_to_ball)
  if (action_case() == kBhvNeckBodyToBall) {
    clear_has_action();
    ::protos::Bhv_NeckBodyToBall* temp = _impl_.action_.bhv_neck_body_to_ball_;
    _impl_.action_.bhv_neck_body_to_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_bhv_neck_body_to_ball(::protos::Bhv_NeckBodyToBall* bhv_neck_body_to_ball) {
  clear_action();
  if (bhv_neck_body_to_ball) {
    set_has_bhv_neck_body_to_ball();
    _impl_.action_.bhv_neck_body_to_ball_ = bhv_neck_body_to_ball;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.bhv_neck_body_to_ball)
}
inline ::protos::Bhv_NeckBodyToBall* Action::_internal_mutable_bhv_neck_body_to_ball() {
  if (action_case() != kBhvNeckBodyToBall) {
    clear_action();
    set_has_bhv_neck_body_to_ball();
    _impl_.action_.bhv_neck_body_to_ball_ = CreateMaybeMessage< ::protos::Bhv_NeckBodyToBall >(GetArenaForAllocation());
  }
  return _impl_.action_.bhv_neck_body_to_ball_;
}
inline ::protos::Bhv_NeckBodyToBall* Action::mutable_bhv_neck_body_to_ball() {
  ::protos::Bhv_NeckBodyToBall* _msg = _internal_mutable_bhv_neck_body_to_ball();
  // @@protoc_insertion_point(field_mutable:protos.Action.bhv_neck_body_to_ball)
  return _msg;
}

// .protos.Bhv_NeckBodyToPoint bhv_neck_body_to_point = 24;
inline bool Action::has_bhv_neck_body_to_point() const {
  return action_case() == kBhvNeckBodyToPoint;
}
inline bool Action::_internal_has_bhv_neck_body_to_point() const {
  return action_case() == kBhvNeckBodyToPoint;
}
inline void Action::set_has_bhv_neck_body_to_point() {
  _impl_._oneof_case_[0] = kBhvNeckBodyToPoint;
}
inline void Action::clear_bhv_neck_body_to_point() {
  if (action_case() == kBhvNeckBodyToPoint) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.bhv_neck_body_to_point_;
    }
    clear_has_action();
  }
}
inline ::protos::Bhv_NeckBodyToPoint* Action::release_bhv_neck_body_to_point() {
  // @@protoc_insertion_point(field_release:protos.Action.bhv_neck_body_to_point)
  if (action_case() == kBhvNeckBodyToPoint) {
    clear_has_action();
    ::protos::Bhv_NeckBodyToPoint* temp = _impl_.action_.bhv_neck_body_to_point_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.bhv_neck_body_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Bhv_NeckBodyToPoint& Action::_internal_bhv_neck_body_to_point() const {
  return action_case() == kBhvNeckBodyToPoint
      ? *_impl_.action_.bhv_neck_body_to_point_
      : reinterpret_cast<::protos::Bhv_NeckBodyToPoint&>(::protos::_Bhv_NeckBodyToPoint_default_instance_);
}
inline const ::protos::Bhv_NeckBodyToPoint& Action::bhv_neck_body_to_point() const {
  // @@protoc_insertion_point(field_get:protos.Action.bhv_neck_body_to_point)
  return _internal_bhv_neck_body_to_point();
}
inline ::protos::Bhv_NeckBodyToPoint* Action::unsafe_arena_release_bhv_neck_body_to_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.bhv_neck_body_to_point)
  if (action_case() == kBhvNeckBodyToPoint) {
    clear_has_action();
    ::protos::Bhv_NeckBodyToPoint* temp = _impl_.action_.bhv_neck_body_to_point_;
    _impl_.action_.bhv_neck_body_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_bhv_neck_body_to_point(::protos::Bhv_NeckBodyToPoint* bhv_neck_body_to_point) {
  clear_action();
  if (bhv_neck_body_to_point) {
    set_has_bhv_neck_body_to_point();
    _impl_.action_.bhv_neck_body_to_point_ = bhv_neck_body_to_point;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.bhv_neck_body_to_point)
}
inline ::protos::Bhv_NeckBodyToPoint* Action::_internal_mutable_bhv_neck_body_to_point() {
  if (action_case() != kBhvNeckBodyToPoint) {
    clear_action();
    set_has_bhv_neck_body_to_point();
    _impl_.action_.bhv_neck_body_to_point_ = CreateMaybeMessage< ::protos::Bhv_NeckBodyToPoint >(GetArenaForAllocation());
  }
  return _impl_.action_.bhv_neck_body_to_point_;
}
inline ::protos::Bhv_NeckBodyToPoint* Action::mutable_bhv_neck_body_to_point() {
  ::protos::Bhv_NeckBodyToPoint* _msg = _internal_mutable_bhv_neck_body_to_point();
  // @@protoc_insertion_point(field_mutable:protos.Action.bhv_neck_body_to_point)
  return _msg;
}

// .protos.Bhv_ScanField bhv_scan_field = 25;
inline bool Action::has_bhv_scan_field() const {
  return action_case() == kBhvScanField;
}
inline bool Action::_internal_has_bhv_scan_field() const {
  return action_case() == kBhvScanField;
}
inline void Action::set_has_bhv_scan_field() {
  _impl_._oneof_case_[0] = kBhvScanField;
}
inline void Action::clear_bhv_scan_field() {
  if (action_case() == kBhvScanField) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.bhv_scan_field_;
    }
    clear_has_action();
  }
}
inline ::protos::Bhv_ScanField* Action::release_bhv_scan_field() {
  // @@protoc_insertion_point(field_release:protos.Action.bhv_scan_field)
  if (action_case() == kBhvScanField) {
    clear_has_action();
    ::protos::Bhv_ScanField* temp = _impl_.action_.bhv_scan_field_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.bhv_scan_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Bhv_ScanField& Action::_internal_bhv_scan_field() const {
  return action_case() == kBhvScanField
      ? *_impl_.action_.bhv_scan_field_
      : reinterpret_cast<::protos::Bhv_ScanField&>(::protos::_Bhv_ScanField_default_instance_);
}
inline const ::protos::Bhv_ScanField& Action::bhv_scan_field() const {
  // @@protoc_insertion_point(field_get:protos.Action.bhv_scan_field)
  return _internal_bhv_scan_field();
}
inline ::protos::Bhv_ScanField* Action::unsafe_arena_release_bhv_scan_field() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.bhv_scan_field)
  if (action_case() == kBhvScanField) {
    clear_has_action();
    ::protos::Bhv_ScanField* temp = _impl_.action_.bhv_scan_field_;
    _impl_.action_.bhv_scan_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_bhv_scan_field(::protos::Bhv_ScanField* bhv_scan_field) {
  clear_action();
  if (bhv_scan_field) {
    set_has_bhv_scan_field();
    _impl_.action_.bhv_scan_field_ = bhv_scan_field;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.bhv_scan_field)
}
inline ::protos::Bhv_ScanField* Action::_internal_mutable_bhv_scan_field() {
  if (action_case() != kBhvScanField) {
    clear_action();
    set_has_bhv_scan_field();
    _impl_.action_.bhv_scan_field_ = CreateMaybeMessage< ::protos::Bhv_ScanField >(GetArenaForAllocation());
  }
  return _impl_.action_.bhv_scan_field_;
}
inline ::protos::Bhv_ScanField* Action::mutable_bhv_scan_field() {
  ::protos::Bhv_ScanField* _msg = _internal_mutable_bhv_scan_field();
  // @@protoc_insertion_point(field_mutable:protos.Action.bhv_scan_field)
  return _msg;
}

// .protos.Body_AdvanceBall body_advance_ball = 26;
inline bool Action::has_body_advance_ball() const {
  return action_case() == kBodyAdvanceBall;
}
inline bool Action::_internal_has_body_advance_ball() const {
  return action_case() == kBodyAdvanceBall;
}
inline void Action::set_has_body_advance_ball() {
  _impl_._oneof_case_[0] = kBodyAdvanceBall;
}
inline void Action::clear_body_advance_ball() {
  if (action_case() == kBodyAdvanceBall) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.body_advance_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_AdvanceBall* Action::release_body_advance_ball() {
  // @@protoc_insertion_point(field_release:protos.Action.body_advance_ball)
  if (action_case() == kBodyAdvanceBall) {
    clear_has_action();
    ::protos::Body_AdvanceBall* temp = _impl_.action_.body_advance_ball_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_advance_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_AdvanceBall& Action::_internal_body_advance_ball() const {
  return action_case() == kBodyAdvanceBall
      ? *_impl_.action_.body_advance_ball_
      : reinterpret_cast<::protos::Body_AdvanceBall&>(::protos::_Body_AdvanceBall_default_instance_);
}
inline const ::protos::Body_AdvanceBall& Action::body_advance_ball() const {
  // @@protoc_insertion_point(field_get:protos.Action.body_advance_ball)
  return _internal_body_advance_ball();
}
inline ::protos::Body_AdvanceBall* Action::unsafe_arena_release_body_advance_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.body_advance_ball)
  if (action_case() == kBodyAdvanceBall) {
    clear_has_action();
    ::protos::Body_AdvanceBall* temp = _impl_.action_.body_advance_ball_;
    _impl_.action_.body_advance_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_body_advance_ball(::protos::Body_AdvanceBall* body_advance_ball) {
  clear_action();
  if (body_advance_ball) {
    set_has_body_advance_ball();
    _impl_.action_.body_advance_ball_ = body_advance_ball;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.body_advance_ball)
}
inline ::protos::Body_AdvanceBall* Action::_internal_mutable_body_advance_ball() {
  if (action_case() != kBodyAdvanceBall) {
    clear_action();
    set_has_body_advance_ball();
    _impl_.action_.body_advance_ball_ = CreateMaybeMessage< ::protos::Body_AdvanceBall >(GetArenaForAllocation());
  }
  return _impl_.action_.body_advance_ball_;
}
inline ::protos::Body_AdvanceBall* Action::mutable_body_advance_ball() {
  ::protos::Body_AdvanceBall* _msg = _internal_mutable_body_advance_ball();
  // @@protoc_insertion_point(field_mutable:protos.Action.body_advance_ball)
  return _msg;
}

// .protos.Body_ClearBall body_clear_ball = 27;
inline bool Action::has_body_clear_ball() const {
  return action_case() == kBodyClearBall;
}
inline bool Action::_internal_has_body_clear_ball() const {
  return action_case() == kBodyClearBall;
}
inline void Action::set_has_body_clear_ball() {
  _impl_._oneof_case_[0] = kBodyClearBall;
}
inline void Action::clear_body_clear_ball() {
  if (action_case() == kBodyClearBall) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.body_clear_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_ClearBall* Action::release_body_clear_ball() {
  // @@protoc_insertion_point(field_release:protos.Action.body_clear_ball)
  if (action_case() == kBodyClearBall) {
    clear_has_action();
    ::protos::Body_ClearBall* temp = _impl_.action_.body_clear_ball_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_clear_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_ClearBall& Action::_internal_body_clear_ball() const {
  return action_case() == kBodyClearBall
      ? *_impl_.action_.body_clear_ball_
      : reinterpret_cast<::protos::Body_ClearBall&>(::protos::_Body_ClearBall_default_instance_);
}
inline const ::protos::Body_ClearBall& Action::body_clear_ball() const {
  // @@protoc_insertion_point(field_get:protos.Action.body_clear_ball)
  return _internal_body_clear_ball();
}
inline ::protos::Body_ClearBall* Action::unsafe_arena_release_body_clear_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.body_clear_ball)
  if (action_case() == kBodyClearBall) {
    clear_has_action();
    ::protos::Body_ClearBall* temp = _impl_.action_.body_clear_ball_;
    _impl_.action_.body_clear_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_body_clear_ball(::protos::Body_ClearBall* body_clear_ball) {
  clear_action();
  if (body_clear_ball) {
    set_has_body_clear_ball();
    _impl_.action_.body_clear_ball_ = body_clear_ball;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.body_clear_ball)
}
inline ::protos::Body_ClearBall* Action::_internal_mutable_body_clear_ball() {
  if (action_case() != kBodyClearBall) {
    clear_action();
    set_has_body_clear_ball();
    _impl_.action_.body_clear_ball_ = CreateMaybeMessage< ::protos::Body_ClearBall >(GetArenaForAllocation());
  }
  return _impl_.action_.body_clear_ball_;
}
inline ::protos::Body_ClearBall* Action::mutable_body_clear_ball() {
  ::protos::Body_ClearBall* _msg = _internal_mutable_body_clear_ball();
  // @@protoc_insertion_point(field_mutable:protos.Action.body_clear_ball)
  return _msg;
}

// .protos.Body_Dribble body_dribble = 28;
inline bool Action::has_body_dribble() const {
  return action_case() == kBodyDribble;
}
inline bool Action::_internal_has_body_dribble() const {
  return action_case() == kBodyDribble;
}
inline void Action::set_has_body_dribble() {
  _impl_._oneof_case_[0] = kBodyDribble;
}
inline void Action::clear_body_dribble() {
  if (action_case() == kBodyDribble) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.body_dribble_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_Dribble* Action::release_body_dribble() {
  // @@protoc_insertion_point(field_release:protos.Action.body_dribble)
  if (action_case() == kBodyDribble) {
    clear_has_action();
    ::protos::Body_Dribble* temp = _impl_.action_.body_dribble_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_dribble_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_Dribble& Action::_internal_body_dribble() const {
  return action_case() == kBodyDribble
      ? *_impl_.action_.body_dribble_
      : reinterpret_cast<::protos::Body_Dribble&>(::protos::_Body_Dribble_default_instance_);
}
inline const ::protos::Body_Dribble& Action::body_dribble() const {
  // @@protoc_insertion_point(field_get:protos.Action.body_dribble)
  return _internal_body_dribble();
}
inline ::protos::Body_Dribble* Action::unsafe_arena_release_body_dribble() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.body_dribble)
  if (action_case() == kBodyDribble) {
    clear_has_action();
    ::protos::Body_Dribble* temp = _impl_.action_.body_dribble_;
    _impl_.action_.body_dribble_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_body_dribble(::protos::Body_Dribble* body_dribble) {
  clear_action();
  if (body_dribble) {
    set_has_body_dribble();
    _impl_.action_.body_dribble_ = body_dribble;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.body_dribble)
}
inline ::protos::Body_Dribble* Action::_internal_mutable_body_dribble() {
  if (action_case() != kBodyDribble) {
    clear_action();
    set_has_body_dribble();
    _impl_.action_.body_dribble_ = CreateMaybeMessage< ::protos::Body_Dribble >(GetArenaForAllocation());
  }
  return _impl_.action_.body_dribble_;
}
inline ::protos::Body_Dribble* Action::mutable_body_dribble() {
  ::protos::Body_Dribble* _msg = _internal_mutable_body_dribble();
  // @@protoc_insertion_point(field_mutable:protos.Action.body_dribble)
  return _msg;
}

// .protos.Body_GoToPointDodge body_go_to_point_dodge = 29;
inline bool Action::has_body_go_to_point_dodge() const {
  return action_case() == kBodyGoToPointDodge;
}
inline bool Action::_internal_has_body_go_to_point_dodge() const {
  return action_case() == kBodyGoToPointDodge;
}
inline void Action::set_has_body_go_to_point_dodge() {
  _impl_._oneof_case_[0] = kBodyGoToPointDodge;
}
inline void Action::clear_body_go_to_point_dodge() {
  if (action_case() == kBodyGoToPointDodge) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.body_go_to_point_dodge_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_GoToPointDodge* Action::release_body_go_to_point_dodge() {
  // @@protoc_insertion_point(field_release:protos.Action.body_go_to_point_dodge)
  if (action_case() == kBodyGoToPointDodge) {
    clear_has_action();
    ::protos::Body_GoToPointDodge* temp = _impl_.action_.body_go_to_point_dodge_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_go_to_point_dodge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_GoToPointDodge& Action::_internal_body_go_to_point_dodge() const {
  return action_case() == kBodyGoToPointDodge
      ? *_impl_.action_.body_go_to_point_dodge_
      : reinterpret_cast<::protos::Body_GoToPointDodge&>(::protos::_Body_GoToPointDodge_default_instance_);
}
inline const ::protos::Body_GoToPointDodge& Action::body_go_to_point_dodge() const {
  // @@protoc_insertion_point(field_get:protos.Action.body_go_to_point_dodge)
  return _internal_body_go_to_point_dodge();
}
inline ::protos::Body_GoToPointDodge* Action::unsafe_arena_release_body_go_to_point_dodge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.body_go_to_point_dodge)
  if (action_case() == kBodyGoToPointDodge) {
    clear_has_action();
    ::protos::Body_GoToPointDodge* temp = _impl_.action_.body_go_to_point_dodge_;
    _impl_.action_.body_go_to_point_dodge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_body_go_to_point_dodge(::protos::Body_GoToPointDodge* body_go_to_point_dodge) {
  clear_action();
  if (body_go_to_point_dodge) {
    set_has_body_go_to_point_dodge();
    _impl_.action_.body_go_to_point_dodge_ = body_go_to_point_dodge;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.body_go_to_point_dodge)
}
inline ::protos::Body_GoToPointDodge* Action::_internal_mutable_body_go_to_point_dodge() {
  if (action_case() != kBodyGoToPointDodge) {
    clear_action();
    set_has_body_go_to_point_dodge();
    _impl_.action_.body_go_to_point_dodge_ = CreateMaybeMessage< ::protos::Body_GoToPointDodge >(GetArenaForAllocation());
  }
  return _impl_.action_.body_go_to_point_dodge_;
}
inline ::protos::Body_GoToPointDodge* Action::mutable_body_go_to_point_dodge() {
  ::protos::Body_GoToPointDodge* _msg = _internal_mutable_body_go_to_point_dodge();
  // @@protoc_insertion_point(field_mutable:protos.Action.body_go_to_point_dodge)
  return _msg;
}

// .protos.Body_HoldBall body_hold_ball = 30;
inline bool Action::has_body_hold_ball() const {
  return action_case() == kBodyHoldBall;
}
inline bool Action::_internal_has_body_hold_ball() const {
  return action_case() == kBodyHoldBall;
}
inline void Action::set_has_body_hold_ball() {
  _impl_._oneof_case_[0] = kBodyHoldBall;
}
inline void Action::clear_body_hold_ball() {
  if (action_case() == kBodyHoldBall) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.body_hold_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_HoldBall* Action::release_body_hold_ball() {
  // @@protoc_insertion_point(field_release:protos.Action.body_hold_ball)
  if (action_case() == kBodyHoldBall) {
    clear_has_action();
    ::protos::Body_HoldBall* temp = _impl_.action_.body_hold_ball_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_hold_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_HoldBall& Action::_internal_body_hold_ball() const {
  return action_case() == kBodyHoldBall
      ? *_impl_.action_.body_hold_ball_
      : reinterpret_cast<::protos::Body_HoldBall&>(::protos::_Body_HoldBall_default_instance_);
}
inline const ::protos::Body_HoldBall& Action::body_hold_ball() const {
  // @@protoc_insertion_point(field_get:protos.Action.body_hold_ball)
  return _internal_body_hold_ball();
}
inline ::protos::Body_HoldBall* Action::unsafe_arena_release_body_hold_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.body_hold_ball)
  if (action_case() == kBodyHoldBall) {
    clear_has_action();
    ::protos::Body_HoldBall* temp = _impl_.action_.body_hold_ball_;
    _impl_.action_.body_hold_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_body_hold_ball(::protos::Body_HoldBall* body_hold_ball) {
  clear_action();
  if (body_hold_ball) {
    set_has_body_hold_ball();
    _impl_.action_.body_hold_ball_ = body_hold_ball;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.body_hold_ball)
}
inline ::protos::Body_HoldBall* Action::_internal_mutable_body_hold_ball() {
  if (action_case() != kBodyHoldBall) {
    clear_action();
    set_has_body_hold_ball();
    _impl_.action_.body_hold_ball_ = CreateMaybeMessage< ::protos::Body_HoldBall >(GetArenaForAllocation());
  }
  return _impl_.action_.body_hold_ball_;
}
inline ::protos::Body_HoldBall* Action::mutable_body_hold_ball() {
  ::protos::Body_HoldBall* _msg = _internal_mutable_body_hold_ball();
  // @@protoc_insertion_point(field_mutable:protos.Action.body_hold_ball)
  return _msg;
}

// .protos.Body_Intercept body_intercept = 31;
inline bool Action::has_body_intercept() const {
  return action_case() == kBodyIntercept;
}
inline bool Action::_internal_has_body_intercept() const {
  return action_case() == kBodyIntercept;
}
inline void Action::set_has_body_intercept() {
  _impl_._oneof_case_[0] = kBodyIntercept;
}
inline void Action::clear_body_intercept() {
  if (action_case() == kBodyIntercept) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.body_intercept_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_Intercept* Action::release_body_intercept() {
  // @@protoc_insertion_point(field_release:protos.Action.body_intercept)
  if (action_case() == kBodyIntercept) {
    clear_has_action();
    ::protos::Body_Intercept* temp = _impl_.action_.body_intercept_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_intercept_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_Intercept& Action::_internal_body_intercept() const {
  return action_case() == kBodyIntercept
      ? *_impl_.action_.body_intercept_
      : reinterpret_cast<::protos::Body_Intercept&>(::protos::_Body_Intercept_default_instance_);
}
inline const ::protos::Body_Intercept& Action::body_intercept() const {
  // @@protoc_insertion_point(field_get:protos.Action.body_intercept)
  return _internal_body_intercept();
}
inline ::protos::Body_Intercept* Action::unsafe_arena_release_body_intercept() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.body_intercept)
  if (action_case() == kBodyIntercept) {
    clear_has_action();
    ::protos::Body_Intercept* temp = _impl_.action_.body_intercept_;
    _impl_.action_.body_intercept_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_body_intercept(::protos::Body_Intercept* body_intercept) {
  clear_action();
  if (body_intercept) {
    set_has_body_intercept();
    _impl_.action_.body_intercept_ = body_intercept;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.body_intercept)
}
inline ::protos::Body_Intercept* Action::_internal_mutable_body_intercept() {
  if (action_case() != kBodyIntercept) {
    clear_action();
    set_has_body_intercept();
    _impl_.action_.body_intercept_ = CreateMaybeMessage< ::protos::Body_Intercept >(GetArenaForAllocation());
  }
  return _impl_.action_.body_intercept_;
}
inline ::protos::Body_Intercept* Action::mutable_body_intercept() {
  ::protos::Body_Intercept* _msg = _internal_mutable_body_intercept();
  // @@protoc_insertion_point(field_mutable:protos.Action.body_intercept)
  return _msg;
}

// .protos.Body_KickOneStep body_kick_one_step = 32;
inline bool Action::has_body_kick_one_step() const {
  return action_case() == kBodyKickOneStep;
}
inline bool Action::_internal_has_body_kick_one_step() const {
  return action_case() == kBodyKickOneStep;
}
inline void Action::set_has_body_kick_one_step() {
  _impl_._oneof_case_[0] = kBodyKickOneStep;
}
inline void Action::clear_body_kick_one_step() {
  if (action_case() == kBodyKickOneStep) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.body_kick_one_step_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_KickOneStep* Action::release_body_kick_one_step() {
  // @@protoc_insertion_point(field_release:protos.Action.body_kick_one_step)
  if (action_case() == kBodyKickOneStep) {
    clear_has_action();
    ::protos::Body_KickOneStep* temp = _impl_.action_.body_kick_one_step_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_kick_one_step_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_KickOneStep& Action::_internal_body_kick_one_step() const {
  return action_case() == kBodyKickOneStep
      ? *_impl_.action_.body_kick_one_step_
      : reinterpret_cast<::protos::Body_KickOneStep&>(::protos::_Body_KickOneStep_default_instance_);
}
inline const ::protos::Body_KickOneStep& Action::body_kick_one_step() const {
  // @@protoc_insertion_point(field_get:protos.Action.body_kick_one_step)
  return _internal_body_kick_one_step();
}
inline ::protos::Body_KickOneStep* Action::unsafe_arena_release_body_kick_one_step() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.body_kick_one_step)
  if (action_case() == kBodyKickOneStep) {
    clear_has_action();
    ::protos::Body_KickOneStep* temp = _impl_.action_.body_kick_one_step_;
    _impl_.action_.body_kick_one_step_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_body_kick_one_step(::protos::Body_KickOneStep* body_kick_one_step) {
  clear_action();
  if (body_kick_one_step) {
    set_has_body_kick_one_step();
    _impl_.action_.body_kick_one_step_ = body_kick_one_step;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.body_kick_one_step)
}
inline ::protos::Body_KickOneStep* Action::_internal_mutable_body_kick_one_step() {
  if (action_case() != kBodyKickOneStep) {
    clear_action();
    set_has_body_kick_one_step();
    _impl_.action_.body_kick_one_step_ = CreateMaybeMessage< ::protos::Body_KickOneStep >(GetArenaForAllocation());
  }
  return _impl_.action_.body_kick_one_step_;
}
inline ::protos::Body_KickOneStep* Action::mutable_body_kick_one_step() {
  ::protos::Body_KickOneStep* _msg = _internal_mutable_body_kick_one_step();
  // @@protoc_insertion_point(field_mutable:protos.Action.body_kick_one_step)
  return _msg;
}

// .protos.Body_StopBall body_stop_ball = 33;
inline bool Action::has_body_stop_ball() const {
  return action_case() == kBodyStopBall;
}
inline bool Action::_internal_has_body_stop_ball() const {
  return action_case() == kBodyStopBall;
}
inline void Action::set_has_body_stop_ball() {
  _impl_._oneof_case_[0] = kBodyStopBall;
}
inline void Action::clear_body_stop_ball() {
  if (action_case() == kBodyStopBall) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.body_stop_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_StopBall* Action::release_body_stop_ball() {
  // @@protoc_insertion_point(field_release:protos.Action.body_stop_ball)
  if (action_case() == kBodyStopBall) {
    clear_has_action();
    ::protos::Body_StopBall* temp = _impl_.action_.body_stop_ball_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_stop_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_StopBall& Action::_internal_body_stop_ball() const {
  return action_case() == kBodyStopBall
      ? *_impl_.action_.body_stop_ball_
      : reinterpret_cast<::protos::Body_StopBall&>(::protos::_Body_StopBall_default_instance_);
}
inline const ::protos::Body_StopBall& Action::body_stop_ball() const {
  // @@protoc_insertion_point(field_get:protos.Action.body_stop_ball)
  return _internal_body_stop_ball();
}
inline ::protos::Body_StopBall* Action::unsafe_arena_release_body_stop_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.body_stop_ball)
  if (action_case() == kBodyStopBall) {
    clear_has_action();
    ::protos::Body_StopBall* temp = _impl_.action_.body_stop_ball_;
    _impl_.action_.body_stop_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_body_stop_ball(::protos::Body_StopBall* body_stop_ball) {
  clear_action();
  if (body_stop_ball) {
    set_has_body_stop_ball();
    _impl_.action_.body_stop_ball_ = body_stop_ball;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.body_stop_ball)
}
inline ::protos::Body_StopBall* Action::_internal_mutable_body_stop_ball() {
  if (action_case() != kBodyStopBall) {
    clear_action();
    set_has_body_stop_ball();
    _impl_.action_.body_stop_ball_ = CreateMaybeMessage< ::protos::Body_StopBall >(GetArenaForAllocation());
  }
  return _impl_.action_.body_stop_ball_;
}
inline ::protos::Body_StopBall* Action::mutable_body_stop_ball() {
  ::protos::Body_StopBall* _msg = _internal_mutable_body_stop_ball();
  // @@protoc_insertion_point(field_mutable:protos.Action.body_stop_ball)
  return _msg;
}

// .protos.Body_StopDash body_stop_dash = 34;
inline bool Action::has_body_stop_dash() const {
  return action_case() == kBodyStopDash;
}
inline bool Action::_internal_has_body_stop_dash() const {
  return action_case() == kBodyStopDash;
}
inline void Action::set_has_body_stop_dash() {
  _impl_._oneof_case_[0] = kBodyStopDash;
}
inline void Action::clear_body_stop_dash() {
  if (action_case() == kBodyStopDash) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.body_stop_dash_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_StopDash* Action::release_body_stop_dash() {
  // @@protoc_insertion_point(field_release:protos.Action.body_stop_dash)
  if (action_case() == kBodyStopDash) {
    clear_has_action();
    ::protos::Body_StopDash* temp = _impl_.action_.body_stop_dash_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_stop_dash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_StopDash& Action::_internal_body_stop_dash() const {
  return action_case() == kBodyStopDash
      ? *_impl_.action_.body_stop_dash_
      : reinterpret_cast<::protos::Body_StopDash&>(::protos::_Body_StopDash_default_instance_);
}
inline const ::protos::Body_StopDash& Action::body_stop_dash() const {
  // @@protoc_insertion_point(field_get:protos.Action.body_stop_dash)
  return _internal_body_stop_dash();
}
inline ::protos::Body_StopDash* Action::unsafe_arena_release_body_stop_dash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.body_stop_dash)
  if (action_case() == kBodyStopDash) {
    clear_has_action();
    ::protos::Body_StopDash* temp = _impl_.action_.body_stop_dash_;
    _impl_.action_.body_stop_dash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_body_stop_dash(::protos::Body_StopDash* body_stop_dash) {
  clear_action();
  if (body_stop_dash) {
    set_has_body_stop_dash();
    _impl_.action_.body_stop_dash_ = body_stop_dash;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.body_stop_dash)
}
inline ::protos::Body_StopDash* Action::_internal_mutable_body_stop_dash() {
  if (action_case() != kBodyStopDash) {
    clear_action();
    set_has_body_stop_dash();
    _impl_.action_.body_stop_dash_ = CreateMaybeMessage< ::protos::Body_StopDash >(GetArenaForAllocation());
  }
  return _impl_.action_.body_stop_dash_;
}
inline ::protos::Body_StopDash* Action::mutable_body_stop_dash() {
  ::protos::Body_StopDash* _msg = _internal_mutable_body_stop_dash();
  // @@protoc_insertion_point(field_mutable:protos.Action.body_stop_dash)
  return _msg;
}

// .protos.Body_TackleToPoint body_tackle_to_point = 35;
inline bool Action::has_body_tackle_to_point() const {
  return action_case() == kBodyTackleToPoint;
}
inline bool Action::_internal_has_body_tackle_to_point() const {
  return action_case() == kBodyTackleToPoint;
}
inline void Action::set_has_body_tackle_to_point() {
  _impl_._oneof_case_[0] = kBodyTackleToPoint;
}
inline void Action::clear_body_tackle_to_point() {
  if (action_case() == kBodyTackleToPoint) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.body_tackle_to_point_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_TackleToPoint* Action::release_body_tackle_to_point() {
  // @@protoc_insertion_point(field_release:protos.Action.body_tackle_to_point)
  if (action_case() == kBodyTackleToPoint) {
    clear_has_action();
    ::protos::Body_TackleToPoint* temp = _impl_.action_.body_tackle_to_point_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_tackle_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_TackleToPoint& Action::_internal_body_tackle_to_point() const {
  return action_case() == kBodyTackleToPoint
      ? *_impl_.action_.body_tackle_to_point_
      : reinterpret_cast<::protos::Body_TackleToPoint&>(::protos::_Body_TackleToPoint_default_instance_);
}
inline const ::protos::Body_TackleToPoint& Action::body_tackle_to_point() const {
  // @@protoc_insertion_point(field_get:protos.Action.body_tackle_to_point)
  return _internal_body_tackle_to_point();
}
inline ::protos::Body_TackleToPoint* Action::unsafe_arena_release_body_tackle_to_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.body_tackle_to_point)
  if (action_case() == kBodyTackleToPoint) {
    clear_has_action();
    ::protos::Body_TackleToPoint* temp = _impl_.action_.body_tackle_to_point_;
    _impl_.action_.body_tackle_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_body_tackle_to_point(::protos::Body_TackleToPoint* body_tackle_to_point) {
  clear_action();
  if (body_tackle_to_point) {
    set_has_body_tackle_to_point();
    _impl_.action_.body_tackle_to_point_ = body_tackle_to_point;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.body_tackle_to_point)
}
inline ::protos::Body_TackleToPoint* Action::_internal_mutable_body_tackle_to_point() {
  if (action_case() != kBodyTackleToPoint) {
    clear_action();
    set_has_body_tackle_to_point();
    _impl_.action_.body_tackle_to_point_ = CreateMaybeMessage< ::protos::Body_TackleToPoint >(GetArenaForAllocation());
  }
  return _impl_.action_.body_tackle_to_point_;
}
inline ::protos::Body_TackleToPoint* Action::mutable_body_tackle_to_point() {
  ::protos::Body_TackleToPoint* _msg = _internal_mutable_body_tackle_to_point();
  // @@protoc_insertion_point(field_mutable:protos.Action.body_tackle_to_point)
  return _msg;
}

// .protos.Body_TurnToAngle body_turn_to_angle = 36;
inline bool Action::has_body_turn_to_angle() const {
  return action_case() == kBodyTurnToAngle;
}
inline bool Action::_internal_has_body_turn_to_angle() const {
  return action_case() == kBodyTurnToAngle;
}
inline void Action::set_has_body_turn_to_angle() {
  _impl_._oneof_case_[0] = kBodyTurnToAngle;
}
inline void Action::clear_body_turn_to_angle() {
  if (action_case() == kBodyTurnToAngle) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.body_turn_to_angle_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_TurnToAngle* Action::release_body_turn_to_angle() {
  // @@protoc_insertion_point(field_release:protos.Action.body_turn_to_angle)
  if (action_case() == kBodyTurnToAngle) {
    clear_has_action();
    ::protos::Body_TurnToAngle* temp = _impl_.action_.body_turn_to_angle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_turn_to_angle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_TurnToAngle& Action::_internal_body_turn_to_angle() const {
  return action_case() == kBodyTurnToAngle
      ? *_impl_.action_.body_turn_to_angle_
      : reinterpret_cast<::protos::Body_TurnToAngle&>(::protos::_Body_TurnToAngle_default_instance_);
}
inline const ::protos::Body_TurnToAngle& Action::body_turn_to_angle() const {
  // @@protoc_insertion_point(field_get:protos.Action.body_turn_to_angle)
  return _internal_body_turn_to_angle();
}
inline ::protos::Body_TurnToAngle* Action::unsafe_arena_release_body_turn_to_angle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.body_turn_to_angle)
  if (action_case() == kBodyTurnToAngle) {
    clear_has_action();
    ::protos::Body_TurnToAngle* temp = _impl_.action_.body_turn_to_angle_;
    _impl_.action_.body_turn_to_angle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_body_turn_to_angle(::protos::Body_TurnToAngle* body_turn_to_angle) {
  clear_action();
  if (body_turn_to_angle) {
    set_has_body_turn_to_angle();
    _impl_.action_.body_turn_to_angle_ = body_turn_to_angle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.body_turn_to_angle)
}
inline ::protos::Body_TurnToAngle* Action::_internal_mutable_body_turn_to_angle() {
  if (action_case() != kBodyTurnToAngle) {
    clear_action();
    set_has_body_turn_to_angle();
    _impl_.action_.body_turn_to_angle_ = CreateMaybeMessage< ::protos::Body_TurnToAngle >(GetArenaForAllocation());
  }
  return _impl_.action_.body_turn_to_angle_;
}
inline ::protos::Body_TurnToAngle* Action::mutable_body_turn_to_angle() {
  ::protos::Body_TurnToAngle* _msg = _internal_mutable_body_turn_to_angle();
  // @@protoc_insertion_point(field_mutable:protos.Action.body_turn_to_angle)
  return _msg;
}

// .protos.Body_TurnToBall body_turn_to_ball = 37;
inline bool Action::has_body_turn_to_ball() const {
  return action_case() == kBodyTurnToBall;
}
inline bool Action::_internal_has_body_turn_to_ball() const {
  return action_case() == kBodyTurnToBall;
}
inline void Action::set_has_body_turn_to_ball() {
  _impl_._oneof_case_[0] = kBodyTurnToBall;
}
inline void Action::clear_body_turn_to_ball() {
  if (action_case() == kBodyTurnToBall) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.body_turn_to_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_TurnToBall* Action::release_body_turn_to_ball() {
  // @@protoc_insertion_point(field_release:protos.Action.body_turn_to_ball)
  if (action_case() == kBodyTurnToBall) {
    clear_has_action();
    ::protos::Body_TurnToBall* temp = _impl_.action_.body_turn_to_ball_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_turn_to_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_TurnToBall& Action::_internal_body_turn_to_ball() const {
  return action_case() == kBodyTurnToBall
      ? *_impl_.action_.body_turn_to_ball_
      : reinterpret_cast<::protos::Body_TurnToBall&>(::protos::_Body_TurnToBall_default_instance_);
}
inline const ::protos::Body_TurnToBall& Action::body_turn_to_ball() const {
  // @@protoc_insertion_point(field_get:protos.Action.body_turn_to_ball)
  return _internal_body_turn_to_ball();
}
inline ::protos::Body_TurnToBall* Action::unsafe_arena_release_body_turn_to_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.body_turn_to_ball)
  if (action_case() == kBodyTurnToBall) {
    clear_has_action();
    ::protos::Body_TurnToBall* temp = _impl_.action_.body_turn_to_ball_;
    _impl_.action_.body_turn_to_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_body_turn_to_ball(::protos::Body_TurnToBall* body_turn_to_ball) {
  clear_action();
  if (body_turn_to_ball) {
    set_has_body_turn_to_ball();
    _impl_.action_.body_turn_to_ball_ = body_turn_to_ball;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.body_turn_to_ball)
}
inline ::protos::Body_TurnToBall* Action::_internal_mutable_body_turn_to_ball() {
  if (action_case() != kBodyTurnToBall) {
    clear_action();
    set_has_body_turn_to_ball();
    _impl_.action_.body_turn_to_ball_ = CreateMaybeMessage< ::protos::Body_TurnToBall >(GetArenaForAllocation());
  }
  return _impl_.action_.body_turn_to_ball_;
}
inline ::protos::Body_TurnToBall* Action::mutable_body_turn_to_ball() {
  ::protos::Body_TurnToBall* _msg = _internal_mutable_body_turn_to_ball();
  // @@protoc_insertion_point(field_mutable:protos.Action.body_turn_to_ball)
  return _msg;
}

// .protos.Body_TurnToPoint body_turn_to_point = 38;
inline bool Action::has_body_turn_to_point() const {
  return action_case() == kBodyTurnToPoint;
}
inline bool Action::_internal_has_body_turn_to_point() const {
  return action_case() == kBodyTurnToPoint;
}
inline void Action::set_has_body_turn_to_point() {
  _impl_._oneof_case_[0] = kBodyTurnToPoint;
}
inline void Action::clear_body_turn_to_point() {
  if (action_case() == kBodyTurnToPoint) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.body_turn_to_point_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_TurnToPoint* Action::release_body_turn_to_point() {
  // @@protoc_insertion_point(field_release:protos.Action.body_turn_to_point)
  if (action_case() == kBodyTurnToPoint) {
    clear_has_action();
    ::protos::Body_TurnToPoint* temp = _impl_.action_.body_turn_to_point_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_turn_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_TurnToPoint& Action::_internal_body_turn_to_point() const {
  return action_case() == kBodyTurnToPoint
      ? *_impl_.action_.body_turn_to_point_
      : reinterpret_cast<::protos::Body_TurnToPoint&>(::protos::_Body_TurnToPoint_default_instance_);
}
inline const ::protos::Body_TurnToPoint& Action::body_turn_to_point() const {
  // @@protoc_insertion_point(field_get:protos.Action.body_turn_to_point)
  return _internal_body_turn_to_point();
}
inline ::protos::Body_TurnToPoint* Action::unsafe_arena_release_body_turn_to_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.body_turn_to_point)
  if (action_case() == kBodyTurnToPoint) {
    clear_has_action();
    ::protos::Body_TurnToPoint* temp = _impl_.action_.body_turn_to_point_;
    _impl_.action_.body_turn_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_body_turn_to_point(::protos::Body_TurnToPoint* body_turn_to_point) {
  clear_action();
  if (body_turn_to_point) {
    set_has_body_turn_to_point();
    _impl_.action_.body_turn_to_point_ = body_turn_to_point;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.body_turn_to_point)
}
inline ::protos::Body_TurnToPoint* Action::_internal_mutable_body_turn_to_point() {
  if (action_case() != kBodyTurnToPoint) {
    clear_action();
    set_has_body_turn_to_point();
    _impl_.action_.body_turn_to_point_ = CreateMaybeMessage< ::protos::Body_TurnToPoint >(GetArenaForAllocation());
  }
  return _impl_.action_.body_turn_to_point_;
}
inline ::protos::Body_TurnToPoint* Action::mutable_body_turn_to_point() {
  ::protos::Body_TurnToPoint* _msg = _internal_mutable_body_turn_to_point();
  // @@protoc_insertion_point(field_mutable:protos.Action.body_turn_to_point)
  return _msg;
}

// .protos.Focus_MoveToPoint focus_move_to_point = 39;
inline bool Action::has_focus_move_to_point() const {
  return action_case() == kFocusMoveToPoint;
}
inline bool Action::_internal_has_focus_move_to_point() const {
  return action_case() == kFocusMoveToPoint;
}
inline void Action::set_has_focus_move_to_point() {
  _impl_._oneof_case_[0] = kFocusMoveToPoint;
}
inline void Action::clear_focus_move_to_point() {
  if (action_case() == kFocusMoveToPoint) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.focus_move_to_point_;
    }
    clear_has_action();
  }
}
inline ::protos::Focus_MoveToPoint* Action::release_focus_move_to_point() {
  // @@protoc_insertion_point(field_release:protos.Action.focus_move_to_point)
  if (action_case() == kFocusMoveToPoint) {
    clear_has_action();
    ::protos::Focus_MoveToPoint* temp = _impl_.action_.focus_move_to_point_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.focus_move_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Focus_MoveToPoint& Action::_internal_focus_move_to_point() const {
  return action_case() == kFocusMoveToPoint
      ? *_impl_.action_.focus_move_to_point_
      : reinterpret_cast<::protos::Focus_MoveToPoint&>(::protos::_Focus_MoveToPoint_default_instance_);
}
inline const ::protos::Focus_MoveToPoint& Action::focus_move_to_point() const {
  // @@protoc_insertion_point(field_get:protos.Action.focus_move_to_point)
  return _internal_focus_move_to_point();
}
inline ::protos::Focus_MoveToPoint* Action::unsafe_arena_release_focus_move_to_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.focus_move_to_point)
  if (action_case() == kFocusMoveToPoint) {
    clear_has_action();
    ::protos::Focus_MoveToPoint* temp = _impl_.action_.focus_move_to_point_;
    _impl_.action_.focus_move_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_focus_move_to_point(::protos::Focus_MoveToPoint* focus_move_to_point) {
  clear_action();
  if (focus_move_to_point) {
    set_has_focus_move_to_point();
    _impl_.action_.focus_move_to_point_ = focus_move_to_point;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.focus_move_to_point)
}
inline ::protos::Focus_MoveToPoint* Action::_internal_mutable_focus_move_to_point() {
  if (action_case() != kFocusMoveToPoint) {
    clear_action();
    set_has_focus_move_to_point();
    _impl_.action_.focus_move_to_point_ = CreateMaybeMessage< ::protos::Focus_MoveToPoint >(GetArenaForAllocation());
  }
  return _impl_.action_.focus_move_to_point_;
}
inline ::protos::Focus_MoveToPoint* Action::mutable_focus_move_to_point() {
  ::protos::Focus_MoveToPoint* _msg = _internal_mutable_focus_move_to_point();
  // @@protoc_insertion_point(field_mutable:protos.Action.focus_move_to_point)
  return _msg;
}

// .protos.Focus_Reset focus_reset = 40;
inline bool Action::has_focus_reset() const {
  return action_case() == kFocusReset;
}
inline bool Action::_internal_has_focus_reset() const {
  return action_case() == kFocusReset;
}
inline void Action::set_has_focus_reset() {
  _impl_._oneof_case_[0] = kFocusReset;
}
inline void Action::clear_focus_reset() {
  if (action_case() == kFocusReset) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.focus_reset_;
    }
    clear_has_action();
  }
}
inline ::protos::Focus_Reset* Action::release_focus_reset() {
  // @@protoc_insertion_point(field_release:protos.Action.focus_reset)
  if (action_case() == kFocusReset) {
    clear_has_action();
    ::protos::Focus_Reset* temp = _impl_.action_.focus_reset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.focus_reset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Focus_Reset& Action::_internal_focus_reset() const {
  return action_case() == kFocusReset
      ? *_impl_.action_.focus_reset_
      : reinterpret_cast<::protos::Focus_Reset&>(::protos::_Focus_Reset_default_instance_);
}
inline const ::protos::Focus_Reset& Action::focus_reset() const {
  // @@protoc_insertion_point(field_get:protos.Action.focus_reset)
  return _internal_focus_reset();
}
inline ::protos::Focus_Reset* Action::unsafe_arena_release_focus_reset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.focus_reset)
  if (action_case() == kFocusReset) {
    clear_has_action();
    ::protos::Focus_Reset* temp = _impl_.action_.focus_reset_;
    _impl_.action_.focus_reset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_focus_reset(::protos::Focus_Reset* focus_reset) {
  clear_action();
  if (focus_reset) {
    set_has_focus_reset();
    _impl_.action_.focus_reset_ = focus_reset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.focus_reset)
}
inline ::protos::Focus_Reset* Action::_internal_mutable_focus_reset() {
  if (action_case() != kFocusReset) {
    clear_action();
    set_has_focus_reset();
    _impl_.action_.focus_reset_ = CreateMaybeMessage< ::protos::Focus_Reset >(GetArenaForAllocation());
  }
  return _impl_.action_.focus_reset_;
}
inline ::protos::Focus_Reset* Action::mutable_focus_reset() {
  ::protos::Focus_Reset* _msg = _internal_mutable_focus_reset();
  // @@protoc_insertion_point(field_mutable:protos.Action.focus_reset)
  return _msg;
}

// .protos.Neck_ScanField neck_scan_field = 41;
inline bool Action::has_neck_scan_field() const {
  return action_case() == kNeckScanField;
}
inline bool Action::_internal_has_neck_scan_field() const {
  return action_case() == kNeckScanField;
}
inline void Action::set_has_neck_scan_field() {
  _impl_._oneof_case_[0] = kNeckScanField;
}
inline void Action::clear_neck_scan_field() {
  if (action_case() == kNeckScanField) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.neck_scan_field_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_ScanField* Action::release_neck_scan_field() {
  // @@protoc_insertion_point(field_release:protos.Action.neck_scan_field)
  if (action_case() == kNeckScanField) {
    clear_has_action();
    ::protos::Neck_ScanField* temp = _impl_.action_.neck_scan_field_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_scan_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_ScanField& Action::_internal_neck_scan_field() const {
  return action_case() == kNeckScanField
      ? *_impl_.action_.neck_scan_field_
      : reinterpret_cast<::protos::Neck_ScanField&>(::protos::_Neck_ScanField_default_instance_);
}
inline const ::protos::Neck_ScanField& Action::neck_scan_field() const {
  // @@protoc_insertion_point(field_get:protos.Action.neck_scan_field)
  return _internal_neck_scan_field();
}
inline ::protos::Neck_ScanField* Action::unsafe_arena_release_neck_scan_field() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.neck_scan_field)
  if (action_case() == kNeckScanField) {
    clear_has_action();
    ::protos::Neck_ScanField* temp = _impl_.action_.neck_scan_field_;
    _impl_.action_.neck_scan_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_neck_scan_field(::protos::Neck_ScanField* neck_scan_field) {
  clear_action();
  if (neck_scan_field) {
    set_has_neck_scan_field();
    _impl_.action_.neck_scan_field_ = neck_scan_field;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.neck_scan_field)
}
inline ::protos::Neck_ScanField* Action::_internal_mutable_neck_scan_field() {
  if (action_case() != kNeckScanField) {
    clear_action();
    set_has_neck_scan_field();
    _impl_.action_.neck_scan_field_ = CreateMaybeMessage< ::protos::Neck_ScanField >(GetArenaForAllocation());
  }
  return _impl_.action_.neck_scan_field_;
}
inline ::protos::Neck_ScanField* Action::mutable_neck_scan_field() {
  ::protos::Neck_ScanField* _msg = _internal_mutable_neck_scan_field();
  // @@protoc_insertion_point(field_mutable:protos.Action.neck_scan_field)
  return _msg;
}

// .protos.Neck_ScanPlayers neck_scan_players = 42;
inline bool Action::has_neck_scan_players() const {
  return action_case() == kNeckScanPlayers;
}
inline bool Action::_internal_has_neck_scan_players() const {
  return action_case() == kNeckScanPlayers;
}
inline void Action::set_has_neck_scan_players() {
  _impl_._oneof_case_[0] = kNeckScanPlayers;
}
inline void Action::clear_neck_scan_players() {
  if (action_case() == kNeckScanPlayers) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.neck_scan_players_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_ScanPlayers* Action::release_neck_scan_players() {
  // @@protoc_insertion_point(field_release:protos.Action.neck_scan_players)
  if (action_case() == kNeckScanPlayers) {
    clear_has_action();
    ::protos::Neck_ScanPlayers* temp = _impl_.action_.neck_scan_players_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_scan_players_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_ScanPlayers& Action::_internal_neck_scan_players() const {
  return action_case() == kNeckScanPlayers
      ? *_impl_.action_.neck_scan_players_
      : reinterpret_cast<::protos::Neck_ScanPlayers&>(::protos::_Neck_ScanPlayers_default_instance_);
}
inline const ::protos::Neck_ScanPlayers& Action::neck_scan_players() const {
  // @@protoc_insertion_point(field_get:protos.Action.neck_scan_players)
  return _internal_neck_scan_players();
}
inline ::protos::Neck_ScanPlayers* Action::unsafe_arena_release_neck_scan_players() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.neck_scan_players)
  if (action_case() == kNeckScanPlayers) {
    clear_has_action();
    ::protos::Neck_ScanPlayers* temp = _impl_.action_.neck_scan_players_;
    _impl_.action_.neck_scan_players_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_neck_scan_players(::protos::Neck_ScanPlayers* neck_scan_players) {
  clear_action();
  if (neck_scan_players) {
    set_has_neck_scan_players();
    _impl_.action_.neck_scan_players_ = neck_scan_players;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.neck_scan_players)
}
inline ::protos::Neck_ScanPlayers* Action::_internal_mutable_neck_scan_players() {
  if (action_case() != kNeckScanPlayers) {
    clear_action();
    set_has_neck_scan_players();
    _impl_.action_.neck_scan_players_ = CreateMaybeMessage< ::protos::Neck_ScanPlayers >(GetArenaForAllocation());
  }
  return _impl_.action_.neck_scan_players_;
}
inline ::protos::Neck_ScanPlayers* Action::mutable_neck_scan_players() {
  ::protos::Neck_ScanPlayers* _msg = _internal_mutable_neck_scan_players();
  // @@protoc_insertion_point(field_mutable:protos.Action.neck_scan_players)
  return _msg;
}

// .protos.Neck_TurnToBallAndPlayer neck_turn_to_ball_and_player = 43;
inline bool Action::has_neck_turn_to_ball_and_player() const {
  return action_case() == kNeckTurnToBallAndPlayer;
}
inline bool Action::_internal_has_neck_turn_to_ball_and_player() const {
  return action_case() == kNeckTurnToBallAndPlayer;
}
inline void Action::set_has_neck_turn_to_ball_and_player() {
  _impl_._oneof_case_[0] = kNeckTurnToBallAndPlayer;
}
inline void Action::clear_neck_turn_to_ball_and_player() {
  if (action_case() == kNeckTurnToBallAndPlayer) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.neck_turn_to_ball_and_player_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_TurnToBallAndPlayer* Action::release_neck_turn_to_ball_and_player() {
  // @@protoc_insertion_point(field_release:protos.Action.neck_turn_to_ball_and_player)
  if (action_case() == kNeckTurnToBallAndPlayer) {
    clear_has_action();
    ::protos::Neck_TurnToBallAndPlayer* temp = _impl_.action_.neck_turn_to_ball_and_player_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_turn_to_ball_and_player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_TurnToBallAndPlayer& Action::_internal_neck_turn_to_ball_and_player() const {
  return action_case() == kNeckTurnToBallAndPlayer
      ? *_impl_.action_.neck_turn_to_ball_and_player_
      : reinterpret_cast<::protos::Neck_TurnToBallAndPlayer&>(::protos::_Neck_TurnToBallAndPlayer_default_instance_);
}
inline const ::protos::Neck_TurnToBallAndPlayer& Action::neck_turn_to_ball_and_player() const {
  // @@protoc_insertion_point(field_get:protos.Action.neck_turn_to_ball_and_player)
  return _internal_neck_turn_to_ball_and_player();
}
inline ::protos::Neck_TurnToBallAndPlayer* Action::unsafe_arena_release_neck_turn_to_ball_and_player() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.neck_turn_to_ball_and_player)
  if (action_case() == kNeckTurnToBallAndPlayer) {
    clear_has_action();
    ::protos::Neck_TurnToBallAndPlayer* temp = _impl_.action_.neck_turn_to_ball_and_player_;
    _impl_.action_.neck_turn_to_ball_and_player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_neck_turn_to_ball_and_player(::protos::Neck_TurnToBallAndPlayer* neck_turn_to_ball_and_player) {
  clear_action();
  if (neck_turn_to_ball_and_player) {
    set_has_neck_turn_to_ball_and_player();
    _impl_.action_.neck_turn_to_ball_and_player_ = neck_turn_to_ball_and_player;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.neck_turn_to_ball_and_player)
}
inline ::protos::Neck_TurnToBallAndPlayer* Action::_internal_mutable_neck_turn_to_ball_and_player() {
  if (action_case() != kNeckTurnToBallAndPlayer) {
    clear_action();
    set_has_neck_turn_to_ball_and_player();
    _impl_.action_.neck_turn_to_ball_and_player_ = CreateMaybeMessage< ::protos::Neck_TurnToBallAndPlayer >(GetArenaForAllocation());
  }
  return _impl_.action_.neck_turn_to_ball_and_player_;
}
inline ::protos::Neck_TurnToBallAndPlayer* Action::mutable_neck_turn_to_ball_and_player() {
  ::protos::Neck_TurnToBallAndPlayer* _msg = _internal_mutable_neck_turn_to_ball_and_player();
  // @@protoc_insertion_point(field_mutable:protos.Action.neck_turn_to_ball_and_player)
  return _msg;
}

// .protos.Neck_TurnToBallOrScan neck_turn_to_ball_or_scan = 44;
inline bool Action::has_neck_turn_to_ball_or_scan() const {
  return action_case() == kNeckTurnToBallOrScan;
}
inline bool Action::_internal_has_neck_turn_to_ball_or_scan() const {
  return action_case() == kNeckTurnToBallOrScan;
}
inline void Action::set_has_neck_turn_to_ball_or_scan() {
  _impl_._oneof_case_[0] = kNeckTurnToBallOrScan;
}
inline void Action::clear_neck_turn_to_ball_or_scan() {
  if (action_case() == kNeckTurnToBallOrScan) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.neck_turn_to_ball_or_scan_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_TurnToBallOrScan* Action::release_neck_turn_to_ball_or_scan() {
  // @@protoc_insertion_point(field_release:protos.Action.neck_turn_to_ball_or_scan)
  if (action_case() == kNeckTurnToBallOrScan) {
    clear_has_action();
    ::protos::Neck_TurnToBallOrScan* temp = _impl_.action_.neck_turn_to_ball_or_scan_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_turn_to_ball_or_scan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_TurnToBallOrScan& Action::_internal_neck_turn_to_ball_or_scan() const {
  return action_case() == kNeckTurnToBallOrScan
      ? *_impl_.action_.neck_turn_to_ball_or_scan_
      : reinterpret_cast<::protos::Neck_TurnToBallOrScan&>(::protos::_Neck_TurnToBallOrScan_default_instance_);
}
inline const ::protos::Neck_TurnToBallOrScan& Action::neck_turn_to_ball_or_scan() const {
  // @@protoc_insertion_point(field_get:protos.Action.neck_turn_to_ball_or_scan)
  return _internal_neck_turn_to_ball_or_scan();
}
inline ::protos::Neck_TurnToBallOrScan* Action::unsafe_arena_release_neck_turn_to_ball_or_scan() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.neck_turn_to_ball_or_scan)
  if (action_case() == kNeckTurnToBallOrScan) {
    clear_has_action();
    ::protos::Neck_TurnToBallOrScan* temp = _impl_.action_.neck_turn_to_ball_or_scan_;
    _impl_.action_.neck_turn_to_ball_or_scan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_neck_turn_to_ball_or_scan(::protos::Neck_TurnToBallOrScan* neck_turn_to_ball_or_scan) {
  clear_action();
  if (neck_turn_to_ball_or_scan) {
    set_has_neck_turn_to_ball_or_scan();
    _impl_.action_.neck_turn_to_ball_or_scan_ = neck_turn_to_ball_or_scan;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.neck_turn_to_ball_or_scan)
}
inline ::protos::Neck_TurnToBallOrScan* Action::_internal_mutable_neck_turn_to_ball_or_scan() {
  if (action_case() != kNeckTurnToBallOrScan) {
    clear_action();
    set_has_neck_turn_to_ball_or_scan();
    _impl_.action_.neck_turn_to_ball_or_scan_ = CreateMaybeMessage< ::protos::Neck_TurnToBallOrScan >(GetArenaForAllocation());
  }
  return _impl_.action_.neck_turn_to_ball_or_scan_;
}
inline ::protos::Neck_TurnToBallOrScan* Action::mutable_neck_turn_to_ball_or_scan() {
  ::protos::Neck_TurnToBallOrScan* _msg = _internal_mutable_neck_turn_to_ball_or_scan();
  // @@protoc_insertion_point(field_mutable:protos.Action.neck_turn_to_ball_or_scan)
  return _msg;
}

// .protos.Neck_TurnToBall neck_turn_to_ball = 45;
inline bool Action::has_neck_turn_to_ball() const {
  return action_case() == kNeckTurnToBall;
}
inline bool Action::_internal_has_neck_turn_to_ball() const {
  return action_case() == kNeckTurnToBall;
}
inline void Action::set_has_neck_turn_to_ball() {
  _impl_._oneof_case_[0] = kNeckTurnToBall;
}
inline void Action::clear_neck_turn_to_ball() {
  if (action_case() == kNeckTurnToBall) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.neck_turn_to_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_TurnToBall* Action::release_neck_turn_to_ball() {
  // @@protoc_insertion_point(field_release:protos.Action.neck_turn_to_ball)
  if (action_case() == kNeckTurnToBall) {
    clear_has_action();
    ::protos::Neck_TurnToBall* temp = _impl_.action_.neck_turn_to_ball_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_turn_to_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_TurnToBall& Action::_internal_neck_turn_to_ball() const {
  return action_case() == kNeckTurnToBall
      ? *_impl_.action_.neck_turn_to_ball_
      : reinterpret_cast<::protos::Neck_TurnToBall&>(::protos::_Neck_TurnToBall_default_instance_);
}
inline const ::protos::Neck_TurnToBall& Action::neck_turn_to_ball() const {
  // @@protoc_insertion_point(field_get:protos.Action.neck_turn_to_ball)
  return _internal_neck_turn_to_ball();
}
inline ::protos::Neck_TurnToBall* Action::unsafe_arena_release_neck_turn_to_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.neck_turn_to_ball)
  if (action_case() == kNeckTurnToBall) {
    clear_has_action();
    ::protos::Neck_TurnToBall* temp = _impl_.action_.neck_turn_to_ball_;
    _impl_.action_.neck_turn_to_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_neck_turn_to_ball(::protos::Neck_TurnToBall* neck_turn_to_ball) {
  clear_action();
  if (neck_turn_to_ball) {
    set_has_neck_turn_to_ball();
    _impl_.action_.neck_turn_to_ball_ = neck_turn_to_ball;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.neck_turn_to_ball)
}
inline ::protos::Neck_TurnToBall* Action::_internal_mutable_neck_turn_to_ball() {
  if (action_case() != kNeckTurnToBall) {
    clear_action();
    set_has_neck_turn_to_ball();
    _impl_.action_.neck_turn_to_ball_ = CreateMaybeMessage< ::protos::Neck_TurnToBall >(GetArenaForAllocation());
  }
  return _impl_.action_.neck_turn_to_ball_;
}
inline ::protos::Neck_TurnToBall* Action::mutable_neck_turn_to_ball() {
  ::protos::Neck_TurnToBall* _msg = _internal_mutable_neck_turn_to_ball();
  // @@protoc_insertion_point(field_mutable:protos.Action.neck_turn_to_ball)
  return _msg;
}

// .protos.Neck_TurnToGoalieOrScan neck_turn_to_goalie_or_scan = 46;
inline bool Action::has_neck_turn_to_goalie_or_scan() const {
  return action_case() == kNeckTurnToGoalieOrScan;
}
inline bool Action::_internal_has_neck_turn_to_goalie_or_scan() const {
  return action_case() == kNeckTurnToGoalieOrScan;
}
inline void Action::set_has_neck_turn_to_goalie_or_scan() {
  _impl_._oneof_case_[0] = kNeckTurnToGoalieOrScan;
}
inline void Action::clear_neck_turn_to_goalie_or_scan() {
  if (action_case() == kNeckTurnToGoalieOrScan) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.neck_turn_to_goalie_or_scan_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_TurnToGoalieOrScan* Action::release_neck_turn_to_goalie_or_scan() {
  // @@protoc_insertion_point(field_release:protos.Action.neck_turn_to_goalie_or_scan)
  if (action_case() == kNeckTurnToGoalieOrScan) {
    clear_has_action();
    ::protos::Neck_TurnToGoalieOrScan* temp = _impl_.action_.neck_turn_to_goalie_or_scan_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_turn_to_goalie_or_scan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_TurnToGoalieOrScan& Action::_internal_neck_turn_to_goalie_or_scan() const {
  return action_case() == kNeckTurnToGoalieOrScan
      ? *_impl_.action_.neck_turn_to_goalie_or_scan_
      : reinterpret_cast<::protos::Neck_TurnToGoalieOrScan&>(::protos::_Neck_TurnToGoalieOrScan_default_instance_);
}
inline const ::protos::Neck_TurnToGoalieOrScan& Action::neck_turn_to_goalie_or_scan() const {
  // @@protoc_insertion_point(field_get:protos.Action.neck_turn_to_goalie_or_scan)
  return _internal_neck_turn_to_goalie_or_scan();
}
inline ::protos::Neck_TurnToGoalieOrScan* Action::unsafe_arena_release_neck_turn_to_goalie_or_scan() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.neck_turn_to_goalie_or_scan)
  if (action_case() == kNeckTurnToGoalieOrScan) {
    clear_has_action();
    ::protos::Neck_TurnToGoalieOrScan* temp = _impl_.action_.neck_turn_to_goalie_or_scan_;
    _impl_.action_.neck_turn_to_goalie_or_scan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_neck_turn_to_goalie_or_scan(::protos::Neck_TurnToGoalieOrScan* neck_turn_to_goalie_or_scan) {
  clear_action();
  if (neck_turn_to_goalie_or_scan) {
    set_has_neck_turn_to_goalie_or_scan();
    _impl_.action_.neck_turn_to_goalie_or_scan_ = neck_turn_to_goalie_or_scan;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.neck_turn_to_goalie_or_scan)
}
inline ::protos::Neck_TurnToGoalieOrScan* Action::_internal_mutable_neck_turn_to_goalie_or_scan() {
  if (action_case() != kNeckTurnToGoalieOrScan) {
    clear_action();
    set_has_neck_turn_to_goalie_or_scan();
    _impl_.action_.neck_turn_to_goalie_or_scan_ = CreateMaybeMessage< ::protos::Neck_TurnToGoalieOrScan >(GetArenaForAllocation());
  }
  return _impl_.action_.neck_turn_to_goalie_or_scan_;
}
inline ::protos::Neck_TurnToGoalieOrScan* Action::mutable_neck_turn_to_goalie_or_scan() {
  ::protos::Neck_TurnToGoalieOrScan* _msg = _internal_mutable_neck_turn_to_goalie_or_scan();
  // @@protoc_insertion_point(field_mutable:protos.Action.neck_turn_to_goalie_or_scan)
  return _msg;
}

// .protos.Neck_TurnToLowConfTeammate neck_turn_to_low_conf_teammate = 47;
inline bool Action::has_neck_turn_to_low_conf_teammate() const {
  return action_case() == kNeckTurnToLowConfTeammate;
}
inline bool Action::_internal_has_neck_turn_to_low_conf_teammate() const {
  return action_case() == kNeckTurnToLowConfTeammate;
}
inline void Action::set_has_neck_turn_to_low_conf_teammate() {
  _impl_._oneof_case_[0] = kNeckTurnToLowConfTeammate;
}
inline void Action::clear_neck_turn_to_low_conf_teammate() {
  if (action_case() == kNeckTurnToLowConfTeammate) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.neck_turn_to_low_conf_teammate_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_TurnToLowConfTeammate* Action::release_neck_turn_to_low_conf_teammate() {
  // @@protoc_insertion_point(field_release:protos.Action.neck_turn_to_low_conf_teammate)
  if (action_case() == kNeckTurnToLowConfTeammate) {
    clear_has_action();
    ::protos::Neck_TurnToLowConfTeammate* temp = _impl_.action_.neck_turn_to_low_conf_teammate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_turn_to_low_conf_teammate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_TurnToLowConfTeammate& Action::_internal_neck_turn_to_low_conf_teammate() const {
  return action_case() == kNeckTurnToLowConfTeammate
      ? *_impl_.action_.neck_turn_to_low_conf_teammate_
      : reinterpret_cast<::protos::Neck_TurnToLowConfTeammate&>(::protos::_Neck_TurnToLowConfTeammate_default_instance_);
}
inline const ::protos::Neck_TurnToLowConfTeammate& Action::neck_turn_to_low_conf_teammate() const {
  // @@protoc_insertion_point(field_get:protos.Action.neck_turn_to_low_conf_teammate)
  return _internal_neck_turn_to_low_conf_teammate();
}
inline ::protos::Neck_TurnToLowConfTeammate* Action::unsafe_arena_release_neck_turn_to_low_conf_teammate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.neck_turn_to_low_conf_teammate)
  if (action_case() == kNeckTurnToLowConfTeammate) {
    clear_has_action();
    ::protos::Neck_TurnToLowConfTeammate* temp = _impl_.action_.neck_turn_to_low_conf_teammate_;
    _impl_.action_.neck_turn_to_low_conf_teammate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_neck_turn_to_low_conf_teammate(::protos::Neck_TurnToLowConfTeammate* neck_turn_to_low_conf_teammate) {
  clear_action();
  if (neck_turn_to_low_conf_teammate) {
    set_has_neck_turn_to_low_conf_teammate();
    _impl_.action_.neck_turn_to_low_conf_teammate_ = neck_turn_to_low_conf_teammate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.neck_turn_to_low_conf_teammate)
}
inline ::protos::Neck_TurnToLowConfTeammate* Action::_internal_mutable_neck_turn_to_low_conf_teammate() {
  if (action_case() != kNeckTurnToLowConfTeammate) {
    clear_action();
    set_has_neck_turn_to_low_conf_teammate();
    _impl_.action_.neck_turn_to_low_conf_teammate_ = CreateMaybeMessage< ::protos::Neck_TurnToLowConfTeammate >(GetArenaForAllocation());
  }
  return _impl_.action_.neck_turn_to_low_conf_teammate_;
}
inline ::protos::Neck_TurnToLowConfTeammate* Action::mutable_neck_turn_to_low_conf_teammate() {
  ::protos::Neck_TurnToLowConfTeammate* _msg = _internal_mutable_neck_turn_to_low_conf_teammate();
  // @@protoc_insertion_point(field_mutable:protos.Action.neck_turn_to_low_conf_teammate)
  return _msg;
}

// .protos.Neck_TurnToPlayerOrScan neck_turn_to_player_or_scan = 48;
inline bool Action::has_neck_turn_to_player_or_scan() const {
  return action_case() == kNeckTurnToPlayerOrScan;
}
inline bool Action::_internal_has_neck_turn_to_player_or_scan() const {
  return action_case() == kNeckTurnToPlayerOrScan;
}
inline void Action::set_has_neck_turn_to_player_or_scan() {
  _impl_._oneof_case_[0] = kNeckTurnToPlayerOrScan;
}
inline void Action::clear_neck_turn_to_player_or_scan() {
  if (action_case() == kNeckTurnToPlayerOrScan) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.neck_turn_to_player_or_scan_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_TurnToPlayerOrScan* Action::release_neck_turn_to_player_or_scan() {
  // @@protoc_insertion_point(field_release:protos.Action.neck_turn_to_player_or_scan)
  if (action_case() == kNeckTurnToPlayerOrScan) {
    clear_has_action();
    ::protos::Neck_TurnToPlayerOrScan* temp = _impl_.action_.neck_turn_to_player_or_scan_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_turn_to_player_or_scan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_TurnToPlayerOrScan& Action::_internal_neck_turn_to_player_or_scan() const {
  return action_case() == kNeckTurnToPlayerOrScan
      ? *_impl_.action_.neck_turn_to_player_or_scan_
      : reinterpret_cast<::protos::Neck_TurnToPlayerOrScan&>(::protos::_Neck_TurnToPlayerOrScan_default_instance_);
}
inline const ::protos::Neck_TurnToPlayerOrScan& Action::neck_turn_to_player_or_scan() const {
  // @@protoc_insertion_point(field_get:protos.Action.neck_turn_to_player_or_scan)
  return _internal_neck_turn_to_player_or_scan();
}
inline ::protos::Neck_TurnToPlayerOrScan* Action::unsafe_arena_release_neck_turn_to_player_or_scan() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.neck_turn_to_player_or_scan)
  if (action_case() == kNeckTurnToPlayerOrScan) {
    clear_has_action();
    ::protos::Neck_TurnToPlayerOrScan* temp = _impl_.action_.neck_turn_to_player_or_scan_;
    _impl_.action_.neck_turn_to_player_or_scan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_neck_turn_to_player_or_scan(::protos::Neck_TurnToPlayerOrScan* neck_turn_to_player_or_scan) {
  clear_action();
  if (neck_turn_to_player_or_scan) {
    set_has_neck_turn_to_player_or_scan();
    _impl_.action_.neck_turn_to_player_or_scan_ = neck_turn_to_player_or_scan;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.neck_turn_to_player_or_scan)
}
inline ::protos::Neck_TurnToPlayerOrScan* Action::_internal_mutable_neck_turn_to_player_or_scan() {
  if (action_case() != kNeckTurnToPlayerOrScan) {
    clear_action();
    set_has_neck_turn_to_player_or_scan();
    _impl_.action_.neck_turn_to_player_or_scan_ = CreateMaybeMessage< ::protos::Neck_TurnToPlayerOrScan >(GetArenaForAllocation());
  }
  return _impl_.action_.neck_turn_to_player_or_scan_;
}
inline ::protos::Neck_TurnToPlayerOrScan* Action::mutable_neck_turn_to_player_or_scan() {
  ::protos::Neck_TurnToPlayerOrScan* _msg = _internal_mutable_neck_turn_to_player_or_scan();
  // @@protoc_insertion_point(field_mutable:protos.Action.neck_turn_to_player_or_scan)
  return _msg;
}

// .protos.Neck_TurnToPoint neck_turn_to_point = 49;
inline bool Action::has_neck_turn_to_point() const {
  return action_case() == kNeckTurnToPoint;
}
inline bool Action::_internal_has_neck_turn_to_point() const {
  return action_case() == kNeckTurnToPoint;
}
inline void Action::set_has_neck_turn_to_point() {
  _impl_._oneof_case_[0] = kNeckTurnToPoint;
}
inline void Action::clear_neck_turn_to_point() {
  if (action_case() == kNeckTurnToPoint) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.neck_turn_to_point_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_TurnToPoint* Action::release_neck_turn_to_point() {
  // @@protoc_insertion_point(field_release:protos.Action.neck_turn_to_point)
  if (action_case() == kNeckTurnToPoint) {
    clear_has_action();
    ::protos::Neck_TurnToPoint* temp = _impl_.action_.neck_turn_to_point_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_turn_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_TurnToPoint& Action::_internal_neck_turn_to_point() const {
  return action_case() == kNeckTurnToPoint
      ? *_impl_.action_.neck_turn_to_point_
      : reinterpret_cast<::protos::Neck_TurnToPoint&>(::protos::_Neck_TurnToPoint_default_instance_);
}
inline const ::protos::Neck_TurnToPoint& Action::neck_turn_to_point() const {
  // @@protoc_insertion_point(field_get:protos.Action.neck_turn_to_point)
  return _internal_neck_turn_to_point();
}
inline ::protos::Neck_TurnToPoint* Action::unsafe_arena_release_neck_turn_to_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.neck_turn_to_point)
  if (action_case() == kNeckTurnToPoint) {
    clear_has_action();
    ::protos::Neck_TurnToPoint* temp = _impl_.action_.neck_turn_to_point_;
    _impl_.action_.neck_turn_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_neck_turn_to_point(::protos::Neck_TurnToPoint* neck_turn_to_point) {
  clear_action();
  if (neck_turn_to_point) {
    set_has_neck_turn_to_point();
    _impl_.action_.neck_turn_to_point_ = neck_turn_to_point;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.neck_turn_to_point)
}
inline ::protos::Neck_TurnToPoint* Action::_internal_mutable_neck_turn_to_point() {
  if (action_case() != kNeckTurnToPoint) {
    clear_action();
    set_has_neck_turn_to_point();
    _impl_.action_.neck_turn_to_point_ = CreateMaybeMessage< ::protos::Neck_TurnToPoint >(GetArenaForAllocation());
  }
  return _impl_.action_.neck_turn_to_point_;
}
inline ::protos::Neck_TurnToPoint* Action::mutable_neck_turn_to_point() {
  ::protos::Neck_TurnToPoint* _msg = _internal_mutable_neck_turn_to_point();
  // @@protoc_insertion_point(field_mutable:protos.Action.neck_turn_to_point)
  return _msg;
}

// .protos.Neck_TurnToRelative neck_turn_to_relative = 50;
inline bool Action::has_neck_turn_to_relative() const {
  return action_case() == kNeckTurnToRelative;
}
inline bool Action::_internal_has_neck_turn_to_relative() const {
  return action_case() == kNeckTurnToRelative;
}
inline void Action::set_has_neck_turn_to_relative() {
  _impl_._oneof_case_[0] = kNeckTurnToRelative;
}
inline void Action::clear_neck_turn_to_relative() {
  if (action_case() == kNeckTurnToRelative) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.neck_turn_to_relative_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_TurnToRelative* Action::release_neck_turn_to_relative() {
  // @@protoc_insertion_point(field_release:protos.Action.neck_turn_to_relative)
  if (action_case() == kNeckTurnToRelative) {
    clear_has_action();
    ::protos::Neck_TurnToRelative* temp = _impl_.action_.neck_turn_to_relative_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_turn_to_relative_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_TurnToRelative& Action::_internal_neck_turn_to_relative() const {
  return action_case() == kNeckTurnToRelative
      ? *_impl_.action_.neck_turn_to_relative_
      : reinterpret_cast<::protos::Neck_TurnToRelative&>(::protos::_Neck_TurnToRelative_default_instance_);
}
inline const ::protos::Neck_TurnToRelative& Action::neck_turn_to_relative() const {
  // @@protoc_insertion_point(field_get:protos.Action.neck_turn_to_relative)
  return _internal_neck_turn_to_relative();
}
inline ::protos::Neck_TurnToRelative* Action::unsafe_arena_release_neck_turn_to_relative() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.neck_turn_to_relative)
  if (action_case() == kNeckTurnToRelative) {
    clear_has_action();
    ::protos::Neck_TurnToRelative* temp = _impl_.action_.neck_turn_to_relative_;
    _impl_.action_.neck_turn_to_relative_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_neck_turn_to_relative(::protos::Neck_TurnToRelative* neck_turn_to_relative) {
  clear_action();
  if (neck_turn_to_relative) {
    set_has_neck_turn_to_relative();
    _impl_.action_.neck_turn_to_relative_ = neck_turn_to_relative;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.neck_turn_to_relative)
}
inline ::protos::Neck_TurnToRelative* Action::_internal_mutable_neck_turn_to_relative() {
  if (action_case() != kNeckTurnToRelative) {
    clear_action();
    set_has_neck_turn_to_relative();
    _impl_.action_.neck_turn_to_relative_ = CreateMaybeMessage< ::protos::Neck_TurnToRelative >(GetArenaForAllocation());
  }
  return _impl_.action_.neck_turn_to_relative_;
}
inline ::protos::Neck_TurnToRelative* Action::mutable_neck_turn_to_relative() {
  ::protos::Neck_TurnToRelative* _msg = _internal_mutable_neck_turn_to_relative();
  // @@protoc_insertion_point(field_mutable:protos.Action.neck_turn_to_relative)
  return _msg;
}

// .protos.View_ChangeWidth view_change_width = 51;
inline bool Action::has_view_change_width() const {
  return action_case() == kViewChangeWidth;
}
inline bool Action::_internal_has_view_change_width() const {
  return action_case() == kViewChangeWidth;
}
inline void Action::set_has_view_change_width() {
  _impl_._oneof_case_[0] = kViewChangeWidth;
}
inline void Action::clear_view_change_width() {
  if (action_case() == kViewChangeWidth) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.view_change_width_;
    }
    clear_has_action();
  }
}
inline ::protos::View_ChangeWidth* Action::release_view_change_width() {
  // @@protoc_insertion_point(field_release:protos.Action.view_change_width)
  if (action_case() == kViewChangeWidth) {
    clear_has_action();
    ::protos::View_ChangeWidth* temp = _impl_.action_.view_change_width_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.view_change_width_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::View_ChangeWidth& Action::_internal_view_change_width() const {
  return action_case() == kViewChangeWidth
      ? *_impl_.action_.view_change_width_
      : reinterpret_cast<::protos::View_ChangeWidth&>(::protos::_View_ChangeWidth_default_instance_);
}
inline const ::protos::View_ChangeWidth& Action::view_change_width() const {
  // @@protoc_insertion_point(field_get:protos.Action.view_change_width)
  return _internal_view_change_width();
}
inline ::protos::View_ChangeWidth* Action::unsafe_arena_release_view_change_width() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.view_change_width)
  if (action_case() == kViewChangeWidth) {
    clear_has_action();
    ::protos::View_ChangeWidth* temp = _impl_.action_.view_change_width_;
    _impl_.action_.view_change_width_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_view_change_width(::protos::View_ChangeWidth* view_change_width) {
  clear_action();
  if (view_change_width) {
    set_has_view_change_width();
    _impl_.action_.view_change_width_ = view_change_width;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.view_change_width)
}
inline ::protos::View_ChangeWidth* Action::_internal_mutable_view_change_width() {
  if (action_case() != kViewChangeWidth) {
    clear_action();
    set_has_view_change_width();
    _impl_.action_.view_change_width_ = CreateMaybeMessage< ::protos::View_ChangeWidth >(GetArenaForAllocation());
  }
  return _impl_.action_.view_change_width_;
}
inline ::protos::View_ChangeWidth* Action::mutable_view_change_width() {
  ::protos::View_ChangeWidth* _msg = _internal_mutable_view_change_width();
  // @@protoc_insertion_point(field_mutable:protos.Action.view_change_width)
  return _msg;
}

// .protos.View_Normal view_normal = 52;
inline bool Action::has_view_normal() const {
  return action_case() == kViewNormal;
}
inline bool Action::_internal_has_view_normal() const {
  return action_case() == kViewNormal;
}
inline void Action::set_has_view_normal() {
  _impl_._oneof_case_[0] = kViewNormal;
}
inline void Action::clear_view_normal() {
  if (action_case() == kViewNormal) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.view_normal_;
    }
    clear_has_action();
  }
}
inline ::protos::View_Normal* Action::release_view_normal() {
  // @@protoc_insertion_point(field_release:protos.Action.view_normal)
  if (action_case() == kViewNormal) {
    clear_has_action();
    ::protos::View_Normal* temp = _impl_.action_.view_normal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.view_normal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::View_Normal& Action::_internal_view_normal() const {
  return action_case() == kViewNormal
      ? *_impl_.action_.view_normal_
      : reinterpret_cast<::protos::View_Normal&>(::protos::_View_Normal_default_instance_);
}
inline const ::protos::View_Normal& Action::view_normal() const {
  // @@protoc_insertion_point(field_get:protos.Action.view_normal)
  return _internal_view_normal();
}
inline ::protos::View_Normal* Action::unsafe_arena_release_view_normal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.view_normal)
  if (action_case() == kViewNormal) {
    clear_has_action();
    ::protos::View_Normal* temp = _impl_.action_.view_normal_;
    _impl_.action_.view_normal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_view_normal(::protos::View_Normal* view_normal) {
  clear_action();
  if (view_normal) {
    set_has_view_normal();
    _impl_.action_.view_normal_ = view_normal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.view_normal)
}
inline ::protos::View_Normal* Action::_internal_mutable_view_normal() {
  if (action_case() != kViewNormal) {
    clear_action();
    set_has_view_normal();
    _impl_.action_.view_normal_ = CreateMaybeMessage< ::protos::View_Normal >(GetArenaForAllocation());
  }
  return _impl_.action_.view_normal_;
}
inline ::protos::View_Normal* Action::mutable_view_normal() {
  ::protos::View_Normal* _msg = _internal_mutable_view_normal();
  // @@protoc_insertion_point(field_mutable:protos.Action.view_normal)
  return _msg;
}

// .protos.View_Synch view_synch = 53;
inline bool Action::has_view_synch() const {
  return action_case() == kViewSynch;
}
inline bool Action::_internal_has_view_synch() const {
  return action_case() == kViewSynch;
}
inline void Action::set_has_view_synch() {
  _impl_._oneof_case_[0] = kViewSynch;
}
inline void Action::clear_view_synch() {
  if (action_case() == kViewSynch) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.view_synch_;
    }
    clear_has_action();
  }
}
inline ::protos::View_Synch* Action::release_view_synch() {
  // @@protoc_insertion_point(field_release:protos.Action.view_synch)
  if (action_case() == kViewSynch) {
    clear_has_action();
    ::protos::View_Synch* temp = _impl_.action_.view_synch_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.view_synch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::View_Synch& Action::_internal_view_synch() const {
  return action_case() == kViewSynch
      ? *_impl_.action_.view_synch_
      : reinterpret_cast<::protos::View_Synch&>(::protos::_View_Synch_default_instance_);
}
inline const ::protos::View_Synch& Action::view_synch() const {
  // @@protoc_insertion_point(field_get:protos.Action.view_synch)
  return _internal_view_synch();
}
inline ::protos::View_Synch* Action::unsafe_arena_release_view_synch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.view_synch)
  if (action_case() == kViewSynch) {
    clear_has_action();
    ::protos::View_Synch* temp = _impl_.action_.view_synch_;
    _impl_.action_.view_synch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_view_synch(::protos::View_Synch* view_synch) {
  clear_action();
  if (view_synch) {
    set_has_view_synch();
    _impl_.action_.view_synch_ = view_synch;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.view_synch)
}
inline ::protos::View_Synch* Action::_internal_mutable_view_synch() {
  if (action_case() != kViewSynch) {
    clear_action();
    set_has_view_synch();
    _impl_.action_.view_synch_ = CreateMaybeMessage< ::protos::View_Synch >(GetArenaForAllocation());
  }
  return _impl_.action_.view_synch_;
}
inline ::protos::View_Synch* Action::mutable_view_synch() {
  ::protos::View_Synch* _msg = _internal_mutable_view_synch();
  // @@protoc_insertion_point(field_mutable:protos.Action.view_synch)
  return _msg;
}

// .protos.View_Wide view_wide = 54;
inline bool Action::has_view_wide() const {
  return action_case() == kViewWide;
}
inline bool Action::_internal_has_view_wide() const {
  return action_case() == kViewWide;
}
inline void Action::set_has_view_wide() {
  _impl_._oneof_case_[0] = kViewWide;
}
inline void Action::clear_view_wide() {
  if (action_case() == kViewWide) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.view_wide_;
    }
    clear_has_action();
  }
}
inline ::protos::View_Wide* Action::release_view_wide() {
  // @@protoc_insertion_point(field_release:protos.Action.view_wide)
  if (action_case() == kViewWide) {
    clear_has_action();
    ::protos::View_Wide* temp = _impl_.action_.view_wide_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.view_wide_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::View_Wide& Action::_internal_view_wide() const {
  return action_case() == kViewWide
      ? *_impl_.action_.view_wide_
      : reinterpret_cast<::protos::View_Wide&>(::protos::_View_Wide_default_instance_);
}
inline const ::protos::View_Wide& Action::view_wide() const {
  // @@protoc_insertion_point(field_get:protos.Action.view_wide)
  return _internal_view_wide();
}
inline ::protos::View_Wide* Action::unsafe_arena_release_view_wide() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Action.view_wide)
  if (action_case() == kViewWide) {
    clear_has_action();
    ::protos::View_Wide* temp = _impl_.action_.view_wide_;
    _impl_.action_.view_wide_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_view_wide(::protos::View_Wide* view_wide) {
  clear_action();
  if (view_wide) {
    set_has_view_wide();
    _impl_.action_.view_wide_ = view_wide;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Action.view_wide)
}
inline ::protos::View_Wide* Action::_internal_mutable_view_wide() {
  if (action_case() != kViewWide) {
    clear_action();
    set_has_view_wide();
    _impl_.action_.view_wide_ = CreateMaybeMessage< ::protos::View_Wide >(GetArenaForAllocation());
  }
  return _impl_.action_.view_wide_;
}
inline ::protos::View_Wide* Action::mutable_view_wide() {
  ::protos::View_Wide* _msg = _internal_mutable_view_wide();
  // @@protoc_insertion_point(field_mutable:protos.Action.view_wide)
  return _msg;
}

inline bool Action::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void Action::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline Action::ActionCase Action::action_case() const {
  return Action::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Actions

// repeated .protos.Action actions = 1;
inline int Actions::_internal_actions_size() const {
  return _impl_.actions_.size();
}
inline int Actions::actions_size() const {
  return _internal_actions_size();
}
inline void Actions::clear_actions() {
  _internal_mutable_actions()->Clear();
}
inline ::protos::Action* Actions::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:protos.Actions.actions)
  return _internal_mutable_actions()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Action >*
Actions::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:protos.Actions.actions)
  return _internal_mutable_actions();
}
inline const ::protos::Action& Actions::_internal_actions(int index) const {
  return _internal_actions().Get(index);
}
inline const ::protos::Action& Actions::actions(int index) const {
  // @@protoc_insertion_point(field_get:protos.Actions.actions)
  return _internal_actions(index);
}
inline ::protos::Action* Actions::_internal_add_actions() {
  return _internal_mutable_actions()->Add();
}
inline ::protos::Action* Actions::add_actions() {
  ::protos::Action* _add = _internal_add_actions();
  // @@protoc_insertion_point(field_add:protos.Actions.actions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protos::Action >&
Actions::actions() const {
  // @@protoc_insertion_point(field_list:protos.Actions.actions)
  return _internal_actions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Action>&
Actions::_internal_actions() const {
  return _impl_.actions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::protos::Action>*
Actions::_internal_mutable_actions() {
  return &_impl_.actions_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace protos


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::protos::ViewWidth> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::protos::ViewWidth>() {
  return ::protos::ViewWidth_descriptor();
}
template <>
struct is_proto_enum<::protos::Side> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::protos::Side>() {
  return ::protos::Side_descriptor();
}
template <>
struct is_proto_enum<::protos::LoggerLevel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::protos::LoggerLevel>() {
  return ::protos::LoggerLevel_descriptor();
}
template <>
struct is_proto_enum<::protos::InterceptActionType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::protos::InterceptActionType>() {
  return ::protos::InterceptActionType_descriptor();
}
template <>
struct is_proto_enum<::protos::GameModeType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::protos::GameModeType>() {
  return ::protos::GameModeType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_service_2eproto_2epb_2eh
